(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b2)) {
        if (__propIsEnum.call(b2, prop))
          __defNormalProp(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all3) => {
    for (var name in all3)
      __defProp(target, name, { get: all3[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // (disabled):node_modules/@tensorflow/tfjs/node_modules/node-fetch/browser.js
  var require_browser = __commonJS({
    "(disabled):node_modules/@tensorflow/tfjs/node_modules/node-fetch/browser.js"() {
    }
  });

  // (disabled):../../node_modules/util/util.js
  var require_util = __commonJS({
    "(disabled):../../node_modules/util/util.js"() {
    }
  });

  // (disabled):../../node_modules/string_decoder/index.js
  var require_string_decoder = __commonJS({
    "(disabled):../../node_modules/string_decoder/index.js"() {
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // node_modules/long/src/long.js
  var require_long = __commonJS({
    "node_modules/long/src/long.js"(exports, module) {
      module.exports = Long2;
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          13,
          2,
          96,
          0,
          1,
          127,
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          3,
          7,
          6,
          0,
          1,
          1,
          1,
          1,
          1,
          6,
          6,
          1,
          127,
          1,
          65,
          0,
          11,
          7,
          50,
          6,
          3,
          109,
          117,
          108,
          0,
          1,
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          10,
          191,
          1,
          6,
          4,
          0,
          35,
          0,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11
        ])), {}).exports;
      } catch (e2) {
      }
      function Long2(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long2.prototype.__isLong__;
      Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      Long2.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long2.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value))
          return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value < 0)
            return UZERO;
          if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
        }
        if (value < 0)
          return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long2.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long2(lowBits, highBits, unsigned);
      }
      Long2.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("empty string");
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return ZERO;
        if (typeof unsigned === "number") {
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p2;
        if ((p2 = str.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p2 === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i2 = 0; i2 < str.length; i2 += 8) {
          var size = Math.min(8, str.length - i2), value = parseInt(str.substring(i2, i2 + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long2.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number")
          return fromNumber(val, unsigned);
        if (typeof val === "string")
          return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long2.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long2.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long2.UZERO = UZERO;
      var ONE = fromInt(1);
      Long2.ONE = ONE;
      var UONE = fromInt(1, true);
      Long2.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long2.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long2.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long2.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div2 = this.div(radixLong), rem1 = div2.mul(radixLong).sub(this);
            return div2.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven2() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add4(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply3(multiplier) {
        if (this.isZero())
          return ZERO;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm.mul(
            this.low,
            this.high,
            multiplier.low,
            multiplier.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (multiplier.isZero())
          return ZERO;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or2(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
          else
            return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le2) {
        return le2 ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi2 = this.high, lo2 = this.low;
        return [
          lo2 & 255,
          lo2 >>> 8 & 255,
          lo2 >>> 16 & 255,
          lo2 >>> 24,
          hi2 & 255,
          hi2 >>> 8 & 255,
          hi2 >>> 16 & 255,
          hi2 >>> 24
        ];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi2 = this.high, lo2 = this.low;
        return [
          hi2 >>> 24,
          hi2 >>> 16 & 255,
          hi2 >>> 8 & 255,
          hi2 & 255,
          lo2 >>> 24,
          lo2 >>> 16 & 255,
          lo2 >>> 8 & 255,
          lo2 & 255
        ];
      };
      Long2.fromBytes = function fromBytes(bytes, unsigned, le2) {
        return le2 ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
      };
      Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long2(
          bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
          bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
          unsigned
        );
      };
      Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long2(
          bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
          bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
          unsigned
        );
      };
    }
  });

  // (disabled):node_modules/node-fetch/browser.js
  var require_browser2 = __commonJS({
    "(disabled):node_modules/node-fetch/browser.js"() {
    }
  });

  // node_modules/seedrandom/lib/alea.js
  var require_alea = __commonJS({
    "node_modules/seedrandom/lib/alea.js"(exports, module) {
      (function(global2, module2, define2) {
        function Alea(seed) {
          var me2 = this, mash = Mash();
          me2.next = function() {
            var t3 = 2091639 * me2.s0 + me2.c * 23283064365386963e-26;
            me2.s0 = me2.s1;
            me2.s1 = me2.s2;
            return me2.s2 = t3 - (me2.c = t3 | 0);
          };
          me2.c = 1;
          me2.s0 = mash(" ");
          me2.s1 = mash(" ");
          me2.s2 = mash(" ");
          me2.s0 -= mash(seed);
          if (me2.s0 < 0) {
            me2.s0 += 1;
          }
          me2.s1 -= mash(seed);
          if (me2.s1 < 0) {
            me2.s1 += 1;
          }
          me2.s2 -= mash(seed);
          if (me2.s2 < 0) {
            me2.s2 += 1;
          }
          mash = null;
        }
        function copy(f2, t3) {
          t3.c = f2.c;
          t3.s0 = f2.s0;
          t3.s1 = f2.s1;
          t3.s2 = f2.s2;
          return t3;
        }
        function impl(seed, opts) {
          var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
          prng.int32 = function() {
            return xg.next() * 4294967296 | 0;
          };
          prng.double = function() {
            return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
          };
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        function Mash() {
          var n2 = 4022871197;
          var mash = function(data) {
            data = String(data);
            for (var i2 = 0; i2 < data.length; i2++) {
              n2 += data.charCodeAt(i2);
              var h = 0.02519603282416938 * n2;
              n2 = h >>> 0;
              h -= n2;
              h *= n2;
              n2 = h >>> 0;
              h -= n2;
              n2 += h * 4294967296;
            }
            return (n2 >>> 0) * 23283064365386963e-26;
          };
          return mash;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.alea = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xor128.js
  var require_xor128 = __commonJS({
    "node_modules/seedrandom/lib/xor128.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me2 = this, strseed = "";
          me2.x = 0;
          me2.y = 0;
          me2.z = 0;
          me2.w = 0;
          me2.next = function() {
            var t3 = me2.x ^ me2.x << 11;
            me2.x = me2.y;
            me2.y = me2.z;
            me2.z = me2.w;
            return me2.w ^= me2.w >>> 19 ^ t3 ^ t3 >>> 8;
          };
          if (seed === (seed | 0)) {
            me2.x = seed;
          } else {
            strseed += seed;
          }
          for (var k4 = 0; k4 < strseed.length + 64; k4++) {
            me2.x ^= strseed.charCodeAt(k4) | 0;
            me2.next();
          }
        }
        function copy(f2, t3) {
          t3.x = f2.x;
          t3.y = f2.y;
          t3.z = f2.z;
          t3.w = f2.w;
          return t3;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor128 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xorwow.js
  var require_xorwow = __commonJS({
    "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me2 = this, strseed = "";
          me2.next = function() {
            var t3 = me2.x ^ me2.x >>> 2;
            me2.x = me2.y;
            me2.y = me2.z;
            me2.z = me2.w;
            me2.w = me2.v;
            return (me2.d = me2.d + 362437 | 0) + (me2.v = me2.v ^ me2.v << 4 ^ (t3 ^ t3 << 1)) | 0;
          };
          me2.x = 0;
          me2.y = 0;
          me2.z = 0;
          me2.w = 0;
          me2.v = 0;
          if (seed === (seed | 0)) {
            me2.x = seed;
          } else {
            strseed += seed;
          }
          for (var k4 = 0; k4 < strseed.length + 64; k4++) {
            me2.x ^= strseed.charCodeAt(k4) | 0;
            if (k4 == strseed.length) {
              me2.d = me2.x << 10 ^ me2.x >>> 4;
            }
            me2.next();
          }
        }
        function copy(f2, t3) {
          t3.x = f2.x;
          t3.y = f2.y;
          t3.z = f2.z;
          t3.w = f2.w;
          t3.v = f2.v;
          t3.d = f2.d;
          return t3;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorwow = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xorshift7.js
  var require_xorshift7 = __commonJS({
    "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me2 = this;
          me2.next = function() {
            var X3 = me2.x, i2 = me2.i, t3, v2, w2;
            t3 = X3[i2];
            t3 ^= t3 >>> 7;
            v2 = t3 ^ t3 << 24;
            t3 = X3[i2 + 1 & 7];
            v2 ^= t3 ^ t3 >>> 10;
            t3 = X3[i2 + 3 & 7];
            v2 ^= t3 ^ t3 >>> 3;
            t3 = X3[i2 + 4 & 7];
            v2 ^= t3 ^ t3 << 7;
            t3 = X3[i2 + 7 & 7];
            t3 = t3 ^ t3 << 13;
            v2 ^= t3 ^ t3 << 9;
            X3[i2] = v2;
            me2.i = i2 + 1 & 7;
            return v2;
          };
          function init(me3, seed2) {
            var j3, w2, X3 = [];
            if (seed2 === (seed2 | 0)) {
              w2 = X3[0] = seed2;
            } else {
              seed2 = "" + seed2;
              for (j3 = 0; j3 < seed2.length; ++j3) {
                X3[j3 & 7] = X3[j3 & 7] << 15 ^ seed2.charCodeAt(j3) + X3[j3 + 1 & 7] << 13;
              }
            }
            while (X3.length < 8)
              X3.push(0);
            for (j3 = 0; j3 < 8 && X3[j3] === 0; ++j3)
              ;
            if (j3 == 8)
              w2 = X3[7] = -1;
            else
              w2 = X3[j3];
            me3.x = X3;
            me3.i = 0;
            for (j3 = 256; j3 > 0; --j3) {
              me3.next();
            }
          }
          init(me2, seed);
        }
        function copy(f2, t3) {
          t3.x = f2.x.slice();
          t3.i = f2.i;
          return t3;
        }
        function impl(seed, opts) {
          if (seed == null)
            seed = +/* @__PURE__ */ new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.x)
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorshift7 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xor4096.js
  var require_xor4096 = __commonJS({
    "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me2 = this;
          me2.next = function() {
            var w2 = me2.w, X3 = me2.X, i2 = me2.i, t3, v2;
            me2.w = w2 = w2 + 1640531527 | 0;
            v2 = X3[i2 + 34 & 127];
            t3 = X3[i2 = i2 + 1 & 127];
            v2 ^= v2 << 13;
            t3 ^= t3 << 17;
            v2 ^= v2 >>> 15;
            t3 ^= t3 >>> 12;
            v2 = X3[i2] = v2 ^ t3;
            me2.i = i2;
            return v2 + (w2 ^ w2 >>> 16) | 0;
          };
          function init(me3, seed2) {
            var t3, v2, i2, j3, w2, X3 = [], limit = 128;
            if (seed2 === (seed2 | 0)) {
              v2 = seed2;
              seed2 = null;
            } else {
              seed2 = seed2 + "\0";
              v2 = 0;
              limit = Math.max(limit, seed2.length);
            }
            for (i2 = 0, j3 = -32; j3 < limit; ++j3) {
              if (seed2)
                v2 ^= seed2.charCodeAt((j3 + 32) % seed2.length);
              if (j3 === 0)
                w2 = v2;
              v2 ^= v2 << 10;
              v2 ^= v2 >>> 15;
              v2 ^= v2 << 4;
              v2 ^= v2 >>> 13;
              if (j3 >= 0) {
                w2 = w2 + 1640531527 | 0;
                t3 = X3[j3 & 127] ^= v2 + w2;
                i2 = 0 == t3 ? i2 + 1 : 0;
              }
            }
            if (i2 >= 128) {
              X3[(seed2 && seed2.length || 0) & 127] = -1;
            }
            i2 = 127;
            for (j3 = 4 * 128; j3 > 0; --j3) {
              v2 = X3[i2 + 34 & 127];
              t3 = X3[i2 = i2 + 1 & 127];
              v2 ^= v2 << 13;
              t3 ^= t3 << 17;
              v2 ^= v2 >>> 15;
              t3 ^= t3 >>> 12;
              X3[i2] = v2 ^ t3;
            }
            me3.w = w2;
            me3.X = X3;
            me3.i = i2;
          }
          init(me2, seed);
        }
        function copy(f2, t3) {
          t3.i = f2.i;
          t3.w = f2.w;
          t3.X = f2.X.slice();
          return t3;
        }
        ;
        function impl(seed, opts) {
          if (seed == null)
            seed = +/* @__PURE__ */ new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.X)
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor4096 = impl;
        }
      })(
        exports,
        // window object or global
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/tychei.js
  var require_tychei = __commonJS({
    "node_modules/seedrandom/lib/tychei.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me2 = this, strseed = "";
          me2.next = function() {
            var b2 = me2.b, c2 = me2.c, d2 = me2.d, a2 = me2.a;
            b2 = b2 << 25 ^ b2 >>> 7 ^ c2;
            c2 = c2 - d2 | 0;
            d2 = d2 << 24 ^ d2 >>> 8 ^ a2;
            a2 = a2 - b2 | 0;
            me2.b = b2 = b2 << 20 ^ b2 >>> 12 ^ c2;
            me2.c = c2 = c2 - d2 | 0;
            me2.d = d2 << 16 ^ c2 >>> 16 ^ a2;
            return me2.a = a2 - b2 | 0;
          };
          me2.a = 0;
          me2.b = 0;
          me2.c = 2654435769 | 0;
          me2.d = 1367130551;
          if (seed === Math.floor(seed)) {
            me2.a = seed / 4294967296 | 0;
            me2.b = seed | 0;
          } else {
            strseed += seed;
          }
          for (var k4 = 0; k4 < strseed.length + 20; k4++) {
            me2.b ^= strseed.charCodeAt(k4) | 0;
            me2.next();
          }
        }
        function copy(f2, t3) {
          t3.a = f2.a;
          t3.b = f2.b;
          t3.c = f2.c;
          t3.d = f2.d;
          return t3;
        }
        ;
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.tychei = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/seedrandom.js
  var require_seedrandom = __commonJS({
    "node_modules/seedrandom/seedrandom.js"(exports, module) {
      (function(global2, pool2, math) {
        var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom3(seed, options, callback) {
          var key = [];
          options = options == true ? { entropy: true } : options || {};
          var shortseed = mixkey(flatten3(
            options.entropy ? [seed, tostring(pool2)] : seed == null ? autoseed() : seed,
            3
          ), key);
          var arc4 = new ARC4(key);
          var prng = function() {
            var n2 = arc4.g(chunks), d2 = startdenom, x2 = 0;
            while (n2 < significance) {
              n2 = (n2 + x2) * width;
              d2 *= width;
              x2 = arc4.g(1);
            }
            while (n2 >= overflow) {
              n2 /= 2;
              d2 /= 2;
              x2 >>>= 1;
            }
            return (n2 + x2) / d2;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng.double = prng;
          mixkey(tostring(arc4.S), pool2);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy(state, arc4);
              }
              prng2.state = function() {
                return copy(arc4, {});
              };
            }
            if (is_math_call) {
              math[rngname] = prng2;
              return seed2;
            } else
              return prng2;
          })(
            prng,
            shortseed,
            "global" in options ? options.global : this == math,
            options.state
          );
        }
        function ARC4(key) {
          var t3, keylen = key.length, me2 = this, i2 = 0, j3 = me2.i = me2.j = 0, s2 = me2.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i2 < width) {
            s2[i2] = i2++;
          }
          for (i2 = 0; i2 < width; i2++) {
            s2[i2] = s2[j3 = mask & j3 + key[i2 % keylen] + (t3 = s2[i2])];
            s2[j3] = t3;
          }
          (me2.g = function(count2) {
            var t4, r2 = 0, i3 = me2.i, j4 = me2.j, s3 = me2.S;
            while (count2--) {
              t4 = s3[i3 = mask & i3 + 1];
              r2 = r2 * width + s3[mask & (s3[i3] = s3[j4 = mask & j4 + t4]) + (s3[j4] = t4)];
            }
            me2.i = i3;
            me2.j = j4;
            return r2;
          })(width);
        }
        function copy(f2, t3) {
          t3.i = f2.i;
          t3.j = f2.j;
          t3.S = f2.S.slice();
          return t3;
        }
        ;
        function flatten3(obj, depth) {
          var result = [], typ = typeof obj, prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten3(obj[prop], depth - 1));
              } catch (e2) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key) {
          var stringseed = seed + "", smear, j3 = 0;
          while (j3 < stringseed.length) {
            key[mask & j3] = mask & (smear ^= key[mask & j3] * 19) + stringseed.charCodeAt(j3++);
          }
          return tostring(key);
        }
        function autoseed() {
          try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
              out = out(width);
            } else {
              out = new Uint8Array(width);
              (global2.crypto || global2.msCrypto).getRandomValues(out);
            }
            return tostring(out);
          } catch (e2) {
            var browser = global2.navigator, plugins = browser && browser.plugins;
            return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool2)];
          }
        }
        function tostring(a2) {
          return String.fromCharCode.apply(0, a2);
        }
        mixkey(math.random(), pool2);
        if (typeof module == "object" && module.exports) {
          module.exports = seedrandom3;
          try {
            nodecrypto = require_crypto();
          } catch (ex) {
          }
        } else if (typeof define == "function" && define.amd) {
          define(function() {
            return seedrandom3;
          });
        } else {
          math["seed" + rngname] = seedrandom3;
        }
      })(
        // global: `self` in browsers (including strict mode and web workers),
        // otherwise `this` in Node and other environments
        typeof self !== "undefined" ? self : exports,
        [],
        // pool: entropy pool starts empty
        Math
        // math: package containing random, pow, and seedrandom
      );
    }
  });

  // node_modules/seedrandom/index.js
  var require_seedrandom2 = __commonJS({
    "node_modules/seedrandom/index.js"(exports, module) {
      var alea3 = require_alea();
      var xor1282 = require_xor128();
      var xorwow2 = require_xorwow();
      var xorshift72 = require_xorshift7();
      var xor40962 = require_xor4096();
      var tychei2 = require_tychei();
      var sr2 = require_seedrandom();
      sr2.alea = alea3;
      sr2.xor128 = xor1282;
      sr2.xorwow = xorwow2;
      sr2.xorshift7 = xorshift72;
      sr2.xor4096 = xor40962;
      sr2.tychei = tychei2;
      module.exports = sr2;
    }
  });

  // node_modules/@mediapipe/face_mesh/face_mesh.js
  var require_face_mesh = __commonJS({
    "node_modules/@mediapipe/face_mesh/face_mesh.js"(exports) {
      (function() {
        "use strict";
        var v2;
        function aa2(a2) {
          var b2 = 0;
          return function() {
            return b2 < a2.length ? { done: false, value: a2[b2++] } : { done: true };
          };
        }
        var ba2 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a2, b2, c2) {
          if (a2 == Array.prototype || a2 == Object.prototype)
            return a2;
          a2[b2] = c2.value;
          return a2;
        };
        function ca2(a2) {
          a2 = ["object" == typeof globalThis && globalThis, a2, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
          for (var b2 = 0; b2 < a2.length; ++b2) {
            var c2 = a2[b2];
            if (c2 && c2.Math == Math)
              return c2;
          }
          throw Error("Cannot find global object");
        }
        var G3 = ca2(this);
        function J3(a2, b2) {
          if (b2)
            a: {
              var c2 = G3;
              a2 = a2.split(".");
              for (var d2 = 0; d2 < a2.length - 1; d2++) {
                var e2 = a2[d2];
                if (!(e2 in c2))
                  break a;
                c2 = c2[e2];
              }
              a2 = a2[a2.length - 1];
              d2 = c2[a2];
              b2 = b2(d2);
              b2 != d2 && null != b2 && ba2(c2, a2, { configurable: true, writable: true, value: b2 });
            }
        }
        J3("Symbol", function(a2) {
          function b2(g2) {
            if (this instanceof b2)
              throw new TypeError("Symbol is not a constructor");
            return new c2(d2 + (g2 || "") + "_" + e2++, g2);
          }
          function c2(g2, f2) {
            this.g = g2;
            ba2(this, "description", { configurable: true, writable: true, value: f2 });
          }
          if (a2)
            return a2;
          c2.prototype.toString = function() {
            return this.g;
          };
          var d2 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", e2 = 0;
          return b2;
        });
        J3("Symbol.iterator", function(a2) {
          if (a2)
            return a2;
          a2 = Symbol("Symbol.iterator");
          for (var b2 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), c2 = 0; c2 < b2.length; c2++) {
            var d2 = G3[b2[c2]];
            "function" === typeof d2 && "function" != typeof d2.prototype[a2] && ba2(d2.prototype, a2, { configurable: true, writable: true, value: function() {
              return da2(aa2(this));
            } });
          }
          return a2;
        });
        function da2(a2) {
          a2 = { next: a2 };
          a2[Symbol.iterator] = function() {
            return this;
          };
          return a2;
        }
        function K3(a2) {
          var b2 = "undefined" != typeof Symbol && Symbol.iterator && a2[Symbol.iterator];
          return b2 ? b2.call(a2) : { next: aa2(a2) };
        }
        function L3(a2) {
          if (!(a2 instanceof Array)) {
            a2 = K3(a2);
            for (var b2, c2 = []; !(b2 = a2.next()).done; )
              c2.push(b2.value);
            a2 = c2;
          }
          return a2;
        }
        var ea2 = "function" == typeof Object.create ? Object.create : function(a2) {
          function b2() {
          }
          b2.prototype = a2;
          return new b2();
        }, fa2;
        if ("function" == typeof Object.setPrototypeOf)
          fa2 = Object.setPrototypeOf;
        else {
          var ha2;
          a: {
            var ia2 = { a: true }, ja2 = {};
            try {
              ja2.__proto__ = ia2;
              ha2 = ja2.a;
              break a;
            } catch (a2) {
            }
            ha2 = false;
          }
          fa2 = ha2 ? function(a2, b2) {
            a2.__proto__ = b2;
            if (a2.__proto__ !== b2)
              throw new TypeError(a2 + " is not extensible");
            return a2;
          } : null;
        }
        var ka2 = fa2;
        function M2(a2, b2) {
          a2.prototype = ea2(b2.prototype);
          a2.prototype.constructor = a2;
          if (ka2)
            ka2(a2, b2);
          else
            for (var c2 in b2)
              if ("prototype" != c2)
                if (Object.defineProperties) {
                  var d2 = Object.getOwnPropertyDescriptor(b2, c2);
                  d2 && Object.defineProperty(a2, c2, d2);
                } else
                  a2[c2] = b2[c2];
          a2.ea = b2.prototype;
        }
        function ma2() {
          this.l = false;
          this.i = null;
          this.h = void 0;
          this.g = 1;
          this.s = this.m = 0;
          this.j = null;
        }
        function na2(a2) {
          if (a2.l)
            throw new TypeError("Generator is already running");
          a2.l = true;
        }
        ma2.prototype.o = function(a2) {
          this.h = a2;
        };
        function oa2(a2, b2) {
          a2.j = { U: b2, V: true };
          a2.g = a2.m || a2.s;
        }
        ma2.prototype.return = function(a2) {
          this.j = { return: a2 };
          this.g = this.s;
        };
        function N3(a2, b2, c2) {
          a2.g = c2;
          return { value: b2 };
        }
        function pa2(a2) {
          this.g = new ma2();
          this.h = a2;
        }
        function qa2(a2, b2) {
          na2(a2.g);
          var c2 = a2.g.i;
          if (c2)
            return ra2(a2, "return" in c2 ? c2["return"] : function(d2) {
              return { value: d2, done: true };
            }, b2, a2.g.return);
          a2.g.return(b2);
          return sa2(a2);
        }
        function ra2(a2, b2, c2, d2) {
          try {
            var e2 = b2.call(a2.g.i, c2);
            if (!(e2 instanceof Object))
              throw new TypeError("Iterator result " + e2 + " is not an object");
            if (!e2.done)
              return a2.g.l = false, e2;
            var g2 = e2.value;
          } catch (f2) {
            return a2.g.i = null, oa2(a2.g, f2), sa2(a2);
          }
          a2.g.i = null;
          d2.call(a2.g, g2);
          return sa2(a2);
        }
        function sa2(a2) {
          for (; a2.g.g; )
            try {
              var b2 = a2.h(a2.g);
              if (b2)
                return a2.g.l = false, { value: b2.value, done: false };
            } catch (c2) {
              a2.g.h = void 0, oa2(a2.g, c2);
            }
          a2.g.l = false;
          if (a2.g.j) {
            b2 = a2.g.j;
            a2.g.j = null;
            if (b2.V)
              throw b2.U;
            return { value: b2.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function ta2(a2) {
          this.next = function(b2) {
            na2(a2.g);
            a2.g.i ? b2 = ra2(a2, a2.g.i.next, b2, a2.g.o) : (a2.g.o(b2), b2 = sa2(a2));
            return b2;
          };
          this.throw = function(b2) {
            na2(a2.g);
            a2.g.i ? b2 = ra2(a2, a2.g.i["throw"], b2, a2.g.o) : (oa2(a2.g, b2), b2 = sa2(a2));
            return b2;
          };
          this.return = function(b2) {
            return qa2(a2, b2);
          };
          this[Symbol.iterator] = function() {
            return this;
          };
        }
        function O3(a2, b2) {
          b2 = new ta2(new pa2(b2));
          ka2 && a2.prototype && ka2(b2, a2.prototype);
          return b2;
        }
        function ua2(a2, b2) {
          a2 instanceof String && (a2 += "");
          var c2 = 0, d2 = false, e2 = { next: function() {
            if (!d2 && c2 < a2.length) {
              var g2 = c2++;
              return { value: b2(g2, a2[g2]), done: false };
            }
            d2 = true;
            return { done: true, value: void 0 };
          } };
          e2[Symbol.iterator] = function() {
            return e2;
          };
          return e2;
        }
        var va2 = "function" == typeof Object.assign ? Object.assign : function(a2, b2) {
          for (var c2 = 1; c2 < arguments.length; c2++) {
            var d2 = arguments[c2];
            if (d2)
              for (var e2 in d2)
                Object.prototype.hasOwnProperty.call(d2, e2) && (a2[e2] = d2[e2]);
          }
          return a2;
        };
        J3("Object.assign", function(a2) {
          return a2 || va2;
        });
        J3("Promise", function(a2) {
          function b2(f2) {
            this.h = 0;
            this.i = void 0;
            this.g = [];
            this.o = false;
            var h = this.j();
            try {
              f2(h.resolve, h.reject);
            } catch (k4) {
              h.reject(k4);
            }
          }
          function c2() {
            this.g = null;
          }
          function d2(f2) {
            return f2 instanceof b2 ? f2 : new b2(function(h) {
              h(f2);
            });
          }
          if (a2)
            return a2;
          c2.prototype.h = function(f2) {
            if (null == this.g) {
              this.g = [];
              var h = this;
              this.i(function() {
                h.l();
              });
            }
            this.g.push(f2);
          };
          var e2 = G3.setTimeout;
          c2.prototype.i = function(f2) {
            e2(f2, 0);
          };
          c2.prototype.l = function() {
            for (; this.g && this.g.length; ) {
              var f2 = this.g;
              this.g = [];
              for (var h = 0; h < f2.length; ++h) {
                var k4 = f2[h];
                f2[h] = null;
                try {
                  k4();
                } catch (l3) {
                  this.j(l3);
                }
              }
            }
            this.g = null;
          };
          c2.prototype.j = function(f2) {
            this.i(function() {
              throw f2;
            });
          };
          b2.prototype.j = function() {
            function f2(l3) {
              return function(n2) {
                k4 || (k4 = true, l3.call(h, n2));
              };
            }
            var h = this, k4 = false;
            return { resolve: f2(this.C), reject: f2(this.l) };
          };
          b2.prototype.C = function(f2) {
            if (f2 === this)
              this.l(new TypeError("A Promise cannot resolve to itself"));
            else if (f2 instanceof b2)
              this.F(f2);
            else {
              a:
                switch (typeof f2) {
                  case "object":
                    var h = null != f2;
                    break a;
                  case "function":
                    h = true;
                    break a;
                  default:
                    h = false;
                }
              h ? this.u(f2) : this.m(f2);
            }
          };
          b2.prototype.u = function(f2) {
            var h = void 0;
            try {
              h = f2.then;
            } catch (k4) {
              this.l(k4);
              return;
            }
            "function" == typeof h ? this.G(h, f2) : this.m(f2);
          };
          b2.prototype.l = function(f2) {
            this.s(2, f2);
          };
          b2.prototype.m = function(f2) {
            this.s(1, f2);
          };
          b2.prototype.s = function(f2, h) {
            if (0 != this.h)
              throw Error("Cannot settle(" + f2 + ", " + h + "): Promise already settled in state" + this.h);
            this.h = f2;
            this.i = h;
            2 === this.h && this.D();
            this.A();
          };
          b2.prototype.D = function() {
            var f2 = this;
            e2(function() {
              if (f2.B()) {
                var h = G3.console;
                "undefined" !== typeof h && h.error(f2.i);
              }
            }, 1);
          };
          b2.prototype.B = function() {
            if (this.o)
              return false;
            var f2 = G3.CustomEvent, h = G3.Event, k4 = G3.dispatchEvent;
            if ("undefined" === typeof k4)
              return true;
            "function" === typeof f2 ? f2 = new f2("unhandledrejection", { cancelable: true }) : "function" === typeof h ? f2 = new h("unhandledrejection", { cancelable: true }) : (f2 = G3.document.createEvent("CustomEvent"), f2.initCustomEvent("unhandledrejection", false, true, f2));
            f2.promise = this;
            f2.reason = this.i;
            return k4(f2);
          };
          b2.prototype.A = function() {
            if (null != this.g) {
              for (var f2 = 0; f2 < this.g.length; ++f2)
                g2.h(this.g[f2]);
              this.g = null;
            }
          };
          var g2 = new c2();
          b2.prototype.F = function(f2) {
            var h = this.j();
            f2.J(h.resolve, h.reject);
          };
          b2.prototype.G = function(f2, h) {
            var k4 = this.j();
            try {
              f2.call(h, k4.resolve, k4.reject);
            } catch (l3) {
              k4.reject(l3);
            }
          };
          b2.prototype.then = function(f2, h) {
            function k4(w2, r2) {
              return "function" == typeof w2 ? function(y2) {
                try {
                  l3(w2(y2));
                } catch (m2) {
                  n2(m2);
                }
              } : r2;
            }
            var l3, n2, u2 = new b2(function(w2, r2) {
              l3 = w2;
              n2 = r2;
            });
            this.J(k4(f2, l3), k4(h, n2));
            return u2;
          };
          b2.prototype.catch = function(f2) {
            return this.then(void 0, f2);
          };
          b2.prototype.J = function(f2, h) {
            function k4() {
              switch (l3.h) {
                case 1:
                  f2(l3.i);
                  break;
                case 2:
                  h(l3.i);
                  break;
                default:
                  throw Error("Unexpected state: " + l3.h);
              }
            }
            var l3 = this;
            null == this.g ? g2.h(k4) : this.g.push(k4);
            this.o = true;
          };
          b2.resolve = d2;
          b2.reject = function(f2) {
            return new b2(function(h, k4) {
              k4(f2);
            });
          };
          b2.race = function(f2) {
            return new b2(function(h, k4) {
              for (var l3 = K3(f2), n2 = l3.next(); !n2.done; n2 = l3.next())
                d2(n2.value).J(h, k4);
            });
          };
          b2.all = function(f2) {
            var h = K3(f2), k4 = h.next();
            return k4.done ? d2([]) : new b2(function(l3, n2) {
              function u2(y2) {
                return function(m2) {
                  w2[y2] = m2;
                  r2--;
                  0 == r2 && l3(w2);
                };
              }
              var w2 = [], r2 = 0;
              do
                w2.push(void 0), r2++, d2(k4.value).J(u2(w2.length - 1), n2), k4 = h.next();
              while (!k4.done);
            });
          };
          return b2;
        });
        J3("Object.is", function(a2) {
          return a2 ? a2 : function(b2, c2) {
            return b2 === c2 ? 0 !== b2 || 1 / b2 === 1 / c2 : b2 !== b2 && c2 !== c2;
          };
        });
        J3("Array.prototype.includes", function(a2) {
          return a2 ? a2 : function(b2, c2) {
            var d2 = this;
            d2 instanceof String && (d2 = String(d2));
            var e2 = d2.length;
            c2 = c2 || 0;
            for (0 > c2 && (c2 = Math.max(c2 + e2, 0)); c2 < e2; c2++) {
              var g2 = d2[c2];
              if (g2 === b2 || Object.is(g2, b2))
                return true;
            }
            return false;
          };
        });
        J3("String.prototype.includes", function(a2) {
          return a2 ? a2 : function(b2, c2) {
            if (null == this)
              throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");
            if (b2 instanceof RegExp)
              throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
            return -1 !== this.indexOf(b2, c2 || 0);
          };
        });
        J3("Array.prototype.keys", function(a2) {
          return a2 ? a2 : function() {
            return ua2(this, function(b2) {
              return b2;
            });
          };
        });
        var wa2 = this || self;
        function P3(a2, b2) {
          a2 = a2.split(".");
          var c2 = wa2;
          a2[0] in c2 || "undefined" == typeof c2.execScript || c2.execScript("var " + a2[0]);
          for (var d2; a2.length && (d2 = a2.shift()); )
            a2.length || void 0 === b2 ? c2[d2] && c2[d2] !== Object.prototype[d2] ? c2 = c2[d2] : c2 = c2[d2] = {} : c2[d2] = b2;
        }
        ;
        function xa2(a2, b2) {
          b2 = String.fromCharCode.apply(null, b2);
          return null == a2 ? b2 : a2 + b2;
        }
        var ya2, za2 = "undefined" !== typeof TextDecoder, Aa2, Ba2 = "undefined" !== typeof TextEncoder;
        function Ca2(a2) {
          if (Ba2)
            a2 = (Aa2 || (Aa2 = new TextEncoder())).encode(a2);
          else {
            var b2 = void 0;
            b2 = void 0 === b2 ? false : b2;
            for (var c2 = 0, d2 = new Uint8Array(3 * a2.length), e2 = 0; e2 < a2.length; e2++) {
              var g2 = a2.charCodeAt(e2);
              if (128 > g2)
                d2[c2++] = g2;
              else {
                if (2048 > g2)
                  d2[c2++] = g2 >> 6 | 192;
                else {
                  if (55296 <= g2 && 57343 >= g2) {
                    if (56319 >= g2 && e2 < a2.length) {
                      var f2 = a2.charCodeAt(++e2);
                      if (56320 <= f2 && 57343 >= f2) {
                        g2 = 1024 * (g2 - 55296) + f2 - 56320 + 65536;
                        d2[c2++] = g2 >> 18 | 240;
                        d2[c2++] = g2 >> 12 & 63 | 128;
                        d2[c2++] = g2 >> 6 & 63 | 128;
                        d2[c2++] = g2 & 63 | 128;
                        continue;
                      } else
                        e2--;
                    }
                    if (b2)
                      throw Error("Found an unpaired surrogate");
                    g2 = 65533;
                  }
                  d2[c2++] = g2 >> 12 | 224;
                  d2[c2++] = g2 >> 6 & 63 | 128;
                }
                d2[c2++] = g2 & 63 | 128;
              }
            }
            a2 = d2.subarray(0, c2);
          }
          return a2;
        }
        ;
        var Da2 = {}, Ea2 = null;
        function Fa2(a2, b2) {
          void 0 === b2 && (b2 = 0);
          Ga2();
          b2 = Da2[b2];
          for (var c2 = Array(Math.floor(a2.length / 3)), d2 = b2[64] || "", e2 = 0, g2 = 0; e2 < a2.length - 2; e2 += 3) {
            var f2 = a2[e2], h = a2[e2 + 1], k4 = a2[e2 + 2], l3 = b2[f2 >> 2];
            f2 = b2[(f2 & 3) << 4 | h >> 4];
            h = b2[(h & 15) << 2 | k4 >> 6];
            k4 = b2[k4 & 63];
            c2[g2++] = l3 + f2 + h + k4;
          }
          l3 = 0;
          k4 = d2;
          switch (a2.length - e2) {
            case 2:
              l3 = a2[e2 + 1], k4 = b2[(l3 & 15) << 2] || d2;
            case 1:
              a2 = a2[e2], c2[g2] = b2[a2 >> 2] + b2[(a2 & 3) << 4 | l3 >> 4] + k4 + d2;
          }
          return c2.join("");
        }
        function Ha2(a2) {
          var b2 = a2.length, c2 = 3 * b2 / 4;
          c2 % 3 ? c2 = Math.floor(c2) : -1 != "=.".indexOf(a2[b2 - 1]) && (c2 = -1 != "=.".indexOf(a2[b2 - 2]) ? c2 - 2 : c2 - 1);
          var d2 = new Uint8Array(c2), e2 = 0;
          Ia2(a2, function(g2) {
            d2[e2++] = g2;
          });
          return d2.subarray(0, e2);
        }
        function Ia2(a2, b2) {
          function c2(k4) {
            for (; d2 < a2.length; ) {
              var l3 = a2.charAt(d2++), n2 = Ea2[l3];
              if (null != n2)
                return n2;
              if (!/^[\s\xa0]*$/.test(l3))
                throw Error("Unknown base64 encoding at char: " + l3);
            }
            return k4;
          }
          Ga2();
          for (var d2 = 0; ; ) {
            var e2 = c2(-1), g2 = c2(0), f2 = c2(64), h = c2(64);
            if (64 === h && -1 === e2)
              break;
            b2(e2 << 2 | g2 >> 4);
            64 != f2 && (b2(g2 << 4 & 240 | f2 >> 2), 64 != h && b2(f2 << 6 & 192 | h));
          }
        }
        function Ga2() {
          if (!Ea2) {
            Ea2 = {};
            for (var a2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b2 = ["+/=", "+/", "-_=", "-_.", "-_"], c2 = 0; 5 > c2; c2++) {
              var d2 = a2.concat(b2[c2].split(""));
              Da2[c2] = d2;
              for (var e2 = 0; e2 < d2.length; e2++) {
                var g2 = d2[e2];
                void 0 === Ea2[g2] && (Ea2[g2] = e2);
              }
            }
          }
        }
        ;
        var Ja2 = "function" === typeof Uint8Array.prototype.slice, Ka2;
        function La2(a2, b2, c2) {
          return b2 === c2 ? Ka2 || (Ka2 = new Uint8Array(0)) : Ja2 ? a2.slice(b2, c2) : new Uint8Array(a2.subarray(b2, c2));
        }
        var Q3 = 0, R3 = 0;
        function Ma2(a2, b2) {
          b2 = void 0 === b2 ? {} : b2;
          b2 = void 0 === b2.v ? false : b2.v;
          this.h = null;
          this.g = this.j = this.l = 0;
          this.m = false;
          this.v = b2;
          a2 && Na2(this, a2);
        }
        function Na2(a2, b2) {
          b2 = b2.constructor === Uint8Array ? b2 : b2.constructor === ArrayBuffer ? new Uint8Array(b2) : b2.constructor === Array ? new Uint8Array(b2) : b2.constructor === String ? Ha2(b2) : b2 instanceof Uint8Array ? new Uint8Array(b2.buffer, b2.byteOffset, b2.byteLength) : new Uint8Array(0);
          a2.h = b2;
          a2.l = 0;
          a2.j = a2.h.length;
          a2.g = a2.l;
        }
        Ma2.prototype.reset = function() {
          this.g = this.l;
        };
        function Oa2(a2) {
          for (var b2 = 128, c2 = 0, d2 = 0, e2 = 0; 4 > e2 && 128 <= b2; e2++)
            b2 = a2.h[a2.g++], c2 |= (b2 & 127) << 7 * e2;
          128 <= b2 && (b2 = a2.h[a2.g++], c2 |= (b2 & 127) << 28, d2 |= (b2 & 127) >> 4);
          if (128 <= b2)
            for (e2 = 0; 5 > e2 && 128 <= b2; e2++)
              b2 = a2.h[a2.g++], d2 |= (b2 & 127) << 7 * e2 + 3;
          if (128 > b2) {
            a2 = c2 >>> 0;
            b2 = d2 >>> 0;
            if (d2 = b2 & 2147483648)
              a2 = ~a2 + 1 >>> 0, b2 = ~b2 >>> 0, 0 == a2 && (b2 = b2 + 1 >>> 0);
            a2 = 4294967296 * b2 + (a2 >>> 0);
            return d2 ? -a2 : a2;
          }
          a2.m = true;
        }
        Ma2.prototype.i = function() {
          var a2 = this.h, b2 = a2[this.g], c2 = b2 & 127;
          if (128 > b2)
            return this.g += 1, c2;
          b2 = a2[this.g + 1];
          c2 |= (b2 & 127) << 7;
          if (128 > b2)
            return this.g += 2, c2;
          b2 = a2[this.g + 2];
          c2 |= (b2 & 127) << 14;
          if (128 > b2)
            return this.g += 3, c2;
          b2 = a2[this.g + 3];
          c2 |= (b2 & 127) << 21;
          if (128 > b2)
            return this.g += 4, c2;
          b2 = a2[this.g + 4];
          c2 |= (b2 & 15) << 28;
          if (128 > b2)
            return this.g += 5, c2 >>> 0;
          this.g += 5;
          128 <= a2[this.g++] && 128 <= a2[this.g++] && 128 <= a2[this.g++] && 128 <= a2[this.g++] && this.g++;
          return c2;
        };
        Ma2.prototype.o = function() {
          var a2 = this.h[this.g], b2 = this.h[this.g + 1];
          var c2 = this.h[this.g + 2];
          var d2 = this.h[this.g + 3];
          this.g += 4;
          c2 = (a2 << 0 | b2 << 8 | c2 << 16 | d2 << 24) >>> 0;
          a2 = 2 * (c2 >> 31) + 1;
          b2 = c2 >>> 23 & 255;
          c2 &= 8388607;
          return 255 == b2 ? c2 ? NaN : Infinity * a2 : 0 == b2 ? a2 * Math.pow(2, -149) * c2 : a2 * Math.pow(2, b2 - 150) * (c2 + Math.pow(2, 23));
        };
        var Pa2 = [];
        function Qa2() {
          this.g = new Uint8Array(64);
          this.h = 0;
        }
        Qa2.prototype.push = function(a2) {
          if (!(this.h + 1 < this.g.length)) {
            var b2 = this.g;
            this.g = new Uint8Array(Math.ceil(1 + 2 * this.g.length));
            this.g.set(b2);
          }
          this.g[this.h++] = a2;
        };
        Qa2.prototype.length = function() {
          return this.h;
        };
        Qa2.prototype.end = function() {
          var a2 = this.g, b2 = this.h;
          this.h = 0;
          return La2(a2, 0, b2);
        };
        function Ra2(a2, b2) {
          for (; 127 < b2; )
            a2.push(b2 & 127 | 128), b2 >>>= 7;
          a2.push(b2);
        }
        ;
        function Sa2(a2) {
          var b2 = {}, c2 = void 0 === b2.N ? false : b2.N;
          this.o = { v: void 0 === b2.v ? false : b2.v };
          this.N = c2;
          b2 = this.o;
          Pa2.length ? (c2 = Pa2.pop(), b2 && (c2.v = b2.v), a2 && Na2(c2, a2), a2 = c2) : a2 = new Ma2(a2, b2);
          this.g = a2;
          this.m = this.g.g;
          this.h = this.i = this.l = -1;
          this.j = false;
        }
        Sa2.prototype.reset = function() {
          this.g.reset();
          this.h = this.l = -1;
        };
        function S3(a2) {
          var b2 = a2.g;
          (b2 = b2.g == b2.j) || (b2 = a2.j) || (b2 = a2.g, b2 = b2.m || 0 > b2.g || b2.g > b2.j);
          if (b2)
            return false;
          a2.m = a2.g.g;
          b2 = a2.g.i();
          var c2 = b2 & 7;
          if (0 != c2 && 5 != c2 && 1 != c2 && 2 != c2 && 3 != c2 && 4 != c2)
            return a2.j = true, false;
          a2.i = b2;
          a2.l = b2 >>> 3;
          a2.h = c2;
          return true;
        }
        function Ta2(a2) {
          switch (a2.h) {
            case 0:
              if (0 != a2.h)
                Ta2(a2);
              else {
                for (a2 = a2.g; a2.h[a2.g] & 128; )
                  a2.g++;
                a2.g++;
              }
              break;
            case 1:
              1 != a2.h ? Ta2(a2) : (a2 = a2.g, a2.g += 8);
              break;
            case 2:
              if (2 != a2.h)
                Ta2(a2);
              else {
                var b2 = a2.g.i();
                a2 = a2.g;
                a2.g += b2;
              }
              break;
            case 5:
              5 != a2.h ? Ta2(a2) : (a2 = a2.g, a2.g += 4);
              break;
            case 3:
              b2 = a2.l;
              do {
                if (!S3(a2)) {
                  a2.j = true;
                  break;
                }
                if (4 == a2.h) {
                  a2.l != b2 && (a2.j = true);
                  break;
                }
                Ta2(a2);
              } while (1);
              break;
            default:
              a2.j = true;
          }
        }
        function Ua2(a2, b2, c2) {
          var d2 = a2.g.j, e2 = a2.g.i(), g2 = a2.g.g + e2;
          a2.g.j = g2;
          c2(b2, a2);
          c2 = g2 - a2.g.g;
          if (0 !== c2)
            throw Error("Message parsing ended unexpectedly. Expected to read " + e2 + " bytes, instead read " + (e2 - c2) + " bytes, either the data ended unexpectedly or the message misreported its own length");
          a2.g.g = g2;
          a2.g.j = d2;
          return b2;
        }
        function T2(a2) {
          return a2.g.o();
        }
        function Va2(a2) {
          var b2 = a2.g.i();
          a2 = a2.g;
          var c2 = a2.g;
          a2.g += b2;
          a2 = a2.h;
          var d2;
          if (za2)
            (d2 = ya2) || (d2 = ya2 = new TextDecoder("utf-8", { fatal: false })), d2 = d2.decode(a2.subarray(c2, c2 + b2));
          else {
            b2 = c2 + b2;
            for (var e2 = [], g2 = null, f2, h, k4; c2 < b2; )
              f2 = a2[c2++], 128 > f2 ? e2.push(f2) : 224 > f2 ? c2 >= b2 ? e2.push(65533) : (h = a2[c2++], 194 > f2 || 128 !== (h & 192) ? (c2--, e2.push(65533)) : e2.push((f2 & 31) << 6 | h & 63)) : 240 > f2 ? c2 >= b2 - 1 ? e2.push(65533) : (h = a2[c2++], 128 !== (h & 192) || 224 === f2 && 160 > h || 237 === f2 && 160 <= h || 128 !== ((d2 = a2[c2++]) & 192) ? (c2--, e2.push(65533)) : e2.push((f2 & 15) << 12 | (h & 63) << 6 | d2 & 63)) : 244 >= f2 ? c2 >= b2 - 2 ? e2.push(65533) : (h = a2[c2++], 128 !== (h & 192) || 0 !== (f2 << 28) + (h - 144) >> 30 || 128 !== ((d2 = a2[c2++]) & 192) || 128 !== ((k4 = a2[c2++]) & 192) ? (c2--, e2.push(65533)) : (f2 = (f2 & 7) << 18 | (h & 63) << 12 | (d2 & 63) << 6 | k4 & 63, f2 -= 65536, e2.push((f2 >> 10 & 1023) + 55296, (f2 & 1023) + 56320))) : e2.push(65533), 8192 <= e2.length && (g2 = xa2(g2, e2), e2.length = 0);
            d2 = xa2(g2, e2);
          }
          return d2;
        }
        function Wa2(a2, b2, c2) {
          var d2 = a2.g.i();
          for (d2 = a2.g.g + d2; a2.g.g < d2; )
            c2.push(b2.call(a2.g));
        }
        function Xa2(a2, b2) {
          2 == a2.h ? Wa2(a2, Ma2.prototype.o, b2) : b2.push(T2(a2));
        }
        ;
        function Ya2() {
          this.h = [];
          this.i = 0;
          this.g = new Qa2();
        }
        function Za2(a2, b2) {
          0 !== b2.length && (a2.h.push(b2), a2.i += b2.length);
        }
        function $a2(a2) {
          var b2 = a2.i + a2.g.length();
          if (0 === b2)
            return new Uint8Array(0);
          b2 = new Uint8Array(b2);
          for (var c2 = a2.h, d2 = c2.length, e2 = 0, g2 = 0; g2 < d2; g2++) {
            var f2 = c2[g2];
            0 !== f2.length && (b2.set(f2, e2), e2 += f2.length);
          }
          c2 = a2.g;
          d2 = c2.h;
          0 !== d2 && (b2.set(c2.g.subarray(0, d2), e2), c2.h = 0);
          a2.h = [b2];
          return b2;
        }
        function U3(a2, b2, c2) {
          if (null != c2) {
            Ra2(a2.g, 8 * b2 + 5);
            a2 = a2.g;
            var d2 = c2;
            d2 = (c2 = 0 > d2 ? 1 : 0) ? -d2 : d2;
            0 === d2 ? 0 < 1 / d2 ? Q3 = R3 = 0 : (R3 = 0, Q3 = 2147483648) : isNaN(d2) ? (R3 = 0, Q3 = 2147483647) : 34028234663852886e22 < d2 ? (R3 = 0, Q3 = (c2 << 31 | 2139095040) >>> 0) : 11754943508222875e-54 > d2 ? (d2 = Math.round(d2 / Math.pow(2, -149)), R3 = 0, Q3 = (c2 << 31 | d2) >>> 0) : (b2 = Math.floor(Math.log(d2) / Math.LN2), d2 *= Math.pow(2, -b2), d2 = Math.round(8388608 * d2), 16777216 <= d2 && ++b2, R3 = 0, Q3 = (c2 << 31 | b2 + 127 << 23 | d2 & 8388607) >>> 0);
            c2 = Q3;
            a2.push(c2 >>> 0 & 255);
            a2.push(c2 >>> 8 & 255);
            a2.push(c2 >>> 16 & 255);
            a2.push(c2 >>> 24 & 255);
          }
        }
        ;
        var ab = "function" === typeof Uint8Array;
        function bb(a2, b2, c2) {
          if (null != a2)
            return "object" === typeof a2 ? ab && a2 instanceof Uint8Array ? c2(a2) : cb(a2, b2, c2) : b2(a2);
        }
        function cb(a2, b2, c2) {
          if (Array.isArray(a2)) {
            for (var d2 = Array(a2.length), e2 = 0; e2 < a2.length; e2++)
              d2[e2] = bb(a2[e2], b2, c2);
            Array.isArray(a2) && a2.W && db(d2);
            return d2;
          }
          d2 = {};
          for (e2 in a2)
            d2[e2] = bb(a2[e2], b2, c2);
          return d2;
        }
        function eb(a2) {
          return "number" === typeof a2 ? isFinite(a2) ? a2 : String(a2) : a2;
        }
        var fb = { W: { value: true, configurable: true } };
        function db(a2) {
          Array.isArray(a2) && !Object.isFrozen(a2) && Object.defineProperties(a2, fb);
          return a2;
        }
        ;
        var gb;
        function V3(a2, b2, c2) {
          var d2 = gb;
          gb = null;
          a2 || (a2 = d2);
          d2 = this.constructor.ca;
          a2 || (a2 = d2 ? [d2] : []);
          this.j = d2 ? 0 : -1;
          this.m = this.g = null;
          this.h = a2;
          a: {
            d2 = this.h.length;
            a2 = d2 - 1;
            if (d2 && (d2 = this.h[a2], !(null === d2 || "object" != typeof d2 || Array.isArray(d2) || ab && d2 instanceof Uint8Array))) {
              this.l = a2 - this.j;
              this.i = d2;
              break a;
            }
            void 0 !== b2 && -1 < b2 ? (this.l = Math.max(b2, a2 + 1 - this.j), this.i = null) : this.l = Number.MAX_VALUE;
          }
          if (c2)
            for (b2 = 0; b2 < c2.length; b2++)
              a2 = c2[b2], a2 < this.l ? (a2 += this.j, (d2 = this.h[a2]) ? db(d2) : this.h[a2] = hb) : (ib(this), (d2 = this.i[a2]) ? db(d2) : this.i[a2] = hb);
        }
        var hb = Object.freeze(db([]));
        function ib(a2) {
          var b2 = a2.l + a2.j;
          a2.h[b2] || (a2.i = a2.h[b2] = {});
        }
        function W3(a2, b2, c2) {
          return -1 === b2 ? null : (void 0 === c2 ? 0 : c2) || b2 >= a2.l ? a2.i ? a2.i[b2] : void 0 : a2.h[b2 + a2.j];
        }
        function jb(a2, b2) {
          var c2 = void 0 === c2 ? false : c2;
          var d2 = W3(a2, b2, c2);
          null == d2 && (d2 = hb);
          d2 === hb && (d2 = db([]), X3(a2, b2, d2, c2));
          return d2;
        }
        function kb(a2) {
          var b2 = jb(a2, 3);
          a2.m || (a2.m = {});
          if (!a2.m[3]) {
            for (var c2 = 0; c2 < b2.length; c2++)
              b2[c2] = +b2[c2];
            a2.m[3] = true;
          }
          return b2;
        }
        function lb(a2, b2, c2) {
          a2 = W3(a2, b2);
          return null == a2 ? c2 : a2;
        }
        function Y3(a2, b2, c2) {
          a2 = W3(a2, b2);
          a2 = null == a2 ? a2 : +a2;
          return null == a2 ? void 0 === c2 ? 0 : c2 : a2;
        }
        function X3(a2, b2, c2, d2) {
          (void 0 === d2 ? 0 : d2) || b2 >= a2.l ? (ib(a2), a2.i[b2] = c2) : a2.h[b2 + a2.j] = c2;
        }
        function mb(a2, b2, c2) {
          if (-1 === c2)
            return null;
          a2.g || (a2.g = {});
          if (!a2.g[c2]) {
            var d2 = W3(a2, c2, false);
            d2 && (a2.g[c2] = new b2(d2));
          }
          return a2.g[c2];
        }
        function nb(a2, b2) {
          a2.g || (a2.g = {});
          var c2 = a2.g[1];
          if (!c2) {
            var d2 = jb(a2, 1);
            c2 = [];
            for (var e2 = 0; e2 < d2.length; e2++)
              c2[e2] = new b2(d2[e2]);
            a2.g[1] = c2;
          }
          return c2;
        }
        function ob(a2, b2, c2) {
          var d2 = void 0 === d2 ? false : d2;
          a2.g || (a2.g = {});
          var e2 = c2 ? pb(c2, false) : c2;
          a2.g[b2] = c2;
          X3(a2, b2, e2, d2);
        }
        function qb(a2, b2, c2, d2) {
          var e2 = nb(a2, c2);
          b2 = b2 ? b2 : new c2();
          a2 = jb(a2, 1);
          void 0 != d2 ? (e2.splice(d2, 0, b2), a2.splice(d2, 0, pb(b2, false))) : (e2.push(b2), a2.push(pb(b2, false)));
        }
        V3.prototype.toJSON = function() {
          var a2 = pb(this, false);
          return cb(a2, eb, Fa2);
        };
        function pb(a2, b2) {
          if (a2.g)
            for (var c2 in a2.g) {
              var d2 = a2.g[c2];
              if (Array.isArray(d2))
                for (var e2 = 0; e2 < d2.length; e2++)
                  d2[e2] && pb(d2[e2], b2);
              else
                d2 && pb(d2, b2);
            }
          return a2.h;
        }
        V3.prototype.toString = function() {
          return pb(this, false).toString();
        };
        function rb(a2, b2) {
          if (a2 = a2.o) {
            Za2(b2, b2.g.end());
            for (var c2 = 0; c2 < a2.length; c2++)
              Za2(b2, a2[c2]);
          }
        }
        function sb(a2, b2) {
          if (4 == b2.h)
            return false;
          var c2 = b2.m;
          Ta2(b2);
          b2.N || (b2 = La2(b2.g.h, c2, b2.g.g), (c2 = a2.o) ? c2.push(b2) : a2.o = [b2]);
          return true;
        }
        ;
        function tb(a2) {
          V3.call(this, a2, -1, ub);
        }
        M2(tb, V3);
        tb.prototype.getRows = function() {
          return W3(this, 1);
        };
        tb.prototype.getCols = function() {
          return W3(this, 2);
        };
        tb.prototype.getPackedDataList = function() {
          return kb(this);
        };
        tb.prototype.getLayout = function() {
          return lb(this, 4, 0);
        };
        function vb(a2, b2) {
          for (; S3(b2); )
            switch (b2.i) {
              case 8:
                var c2 = b2.g.i();
                X3(a2, 1, c2);
                break;
              case 16:
                c2 = b2.g.i();
                X3(a2, 2, c2);
                break;
              case 29:
              case 26:
                Xa2(b2, a2.getPackedDataList());
                break;
              case 32:
                c2 = Oa2(b2.g);
                X3(a2, 4, c2);
                break;
              default:
                if (!sb(a2, b2))
                  return a2;
            }
          return a2;
        }
        var ub = [3];
        function Z3(a2, b2) {
          var c2 = void 0;
          return new (c2 || (c2 = Promise))(function(d2, e2) {
            function g2(k4) {
              try {
                h(b2.next(k4));
              } catch (l3) {
                e2(l3);
              }
            }
            function f2(k4) {
              try {
                h(b2["throw"](k4));
              } catch (l3) {
                e2(l3);
              }
            }
            function h(k4) {
              k4.done ? d2(k4.value) : new c2(function(l3) {
                l3(k4.value);
              }).then(g2, f2);
            }
            h((b2 = b2.apply(a2, void 0)).next());
          });
        }
        ;
        function wb(a2) {
          V3.call(this, a2);
        }
        M2(wb, V3);
        function xb(a2, b2) {
          for (; S3(b2); )
            switch (b2.i) {
              case 8:
                var c2 = b2.g.i();
                X3(a2, 1, c2);
                break;
              case 21:
                c2 = T2(b2);
                X3(a2, 2, c2);
                break;
              case 26:
                c2 = Va2(b2);
                X3(a2, 3, c2);
                break;
              case 34:
                c2 = Va2(b2);
                X3(a2, 4, c2);
                break;
              default:
                if (!sb(a2, b2))
                  return a2;
            }
          return a2;
        }
        ;
        function yb(a2) {
          V3.call(this, a2, -1, zb);
        }
        M2(yb, V3);
        yb.prototype.addClassification = function(a2, b2) {
          qb(this, a2, wb, b2);
          return this;
        };
        var zb = [1];
        function Ab(a2) {
          V3.call(this, a2);
        }
        M2(Ab, V3);
        function Bb(a2, b2) {
          for (; S3(b2); )
            switch (b2.i) {
              case 13:
                var c2 = T2(b2);
                X3(a2, 1, c2);
                break;
              case 21:
                c2 = T2(b2);
                X3(a2, 2, c2);
                break;
              case 29:
                c2 = T2(b2);
                X3(a2, 3, c2);
                break;
              case 37:
                c2 = T2(b2);
                X3(a2, 4, c2);
                break;
              case 45:
                c2 = T2(b2);
                X3(a2, 5, c2);
                break;
              default:
                if (!sb(a2, b2))
                  return a2;
            }
          return a2;
        }
        ;
        function Cb(a2) {
          V3.call(this, a2, -1, Db);
        }
        M2(Cb, V3);
        function Eb(a2) {
          a: {
            var b2 = new Cb();
            for (a2 = new Sa2(a2); S3(a2); )
              switch (a2.i) {
                case 10:
                  var c2 = Ua2(a2, new Ab(), Bb);
                  qb(b2, c2, Ab, void 0);
                  break;
                default:
                  if (!sb(b2, a2))
                    break a;
              }
          }
          return b2;
        }
        var Db = [1];
        function Fb(a2) {
          V3.call(this, a2);
        }
        M2(Fb, V3);
        function Gb(a2) {
          V3.call(this, a2, -1, Hb);
        }
        M2(Gb, V3);
        Gb.prototype.getVertexType = function() {
          return lb(this, 1, 0);
        };
        Gb.prototype.getPrimitiveType = function() {
          return lb(this, 2, 0);
        };
        Gb.prototype.getVertexBufferList = function() {
          return kb(this);
        };
        Gb.prototype.getIndexBufferList = function() {
          return jb(this, 4);
        };
        function Ib(a2, b2) {
          for (; S3(b2); )
            switch (b2.i) {
              case 8:
                var c2 = Oa2(b2.g);
                X3(a2, 1, c2);
                break;
              case 16:
                c2 = Oa2(b2.g);
                X3(a2, 2, c2);
                break;
              case 29:
              case 26:
                Xa2(b2, a2.getVertexBufferList());
                break;
              case 32:
              case 34:
                c2 = b2;
                var d2 = a2.getIndexBufferList();
                2 == c2.h ? Wa2(c2, Ma2.prototype.i, d2) : d2.push(c2.g.i());
                break;
              default:
                if (!sb(a2, b2))
                  return a2;
            }
          return a2;
        }
        var Hb = [3, 4];
        function Jb(a2) {
          V3.call(this, a2);
        }
        M2(Jb, V3);
        Jb.prototype.getMesh = function() {
          return mb(this, Gb, 1);
        };
        Jb.prototype.getPoseTransformMatrix = function() {
          return mb(this, tb, 2);
        };
        function Kb(a2) {
          a: {
            var b2 = new Jb();
            for (a2 = new Sa2(a2); S3(a2); )
              switch (a2.i) {
                case 10:
                  var c2 = Ua2(a2, new Gb(), Ib);
                  ob(b2, 1, c2);
                  break;
                case 18:
                  c2 = Ua2(a2, new tb(), vb);
                  ob(b2, 2, c2);
                  break;
                default:
                  if (!sb(b2, a2))
                    break a;
              }
          }
          return b2;
        }
        ;
        function Lb(a2, b2, c2) {
          c2 = a2.createShader(0 === c2 ? a2.VERTEX_SHADER : a2.FRAGMENT_SHADER);
          a2.shaderSource(c2, b2);
          a2.compileShader(c2);
          if (!a2.getShaderParameter(c2, a2.COMPILE_STATUS))
            throw Error("Could not compile WebGL shader.\n\n" + a2.getShaderInfoLog(c2));
          return c2;
        }
        ;
        function Mb(a2) {
          return nb(a2, wb).map(function(b2) {
            return { index: lb(b2, 1, 0), Y: Y3(b2, 2), label: null != W3(b2, 3) ? lb(b2, 3, "") : void 0, displayName: null != W3(b2, 4) ? lb(b2, 4, "") : void 0 };
          });
        }
        ;
        function Nb(a2) {
          return { x: Y3(a2, 1), y: Y3(a2, 2), z: Y3(a2, 3), visibility: null != W3(a2, 4) ? Y3(a2, 4) : void 0 };
        }
        ;
        function Ob(a2, b2) {
          this.h = a2;
          this.g = b2;
          this.l = 0;
        }
        function Pb(a2, b2, c2) {
          Qb(a2, b2);
          if ("function" === typeof a2.g.canvas.transferToImageBitmap)
            return Promise.resolve(a2.g.canvas.transferToImageBitmap());
          if (c2)
            return Promise.resolve(a2.g.canvas);
          if ("function" === typeof createImageBitmap)
            return createImageBitmap(a2.g.canvas);
          void 0 === a2.i && (a2.i = document.createElement("canvas"));
          return new Promise(function(d2) {
            a2.i.height = a2.g.canvas.height;
            a2.i.width = a2.g.canvas.width;
            a2.i.getContext("2d", {}).drawImage(a2.g.canvas, 0, 0, a2.g.canvas.width, a2.g.canvas.height);
            d2(a2.i);
          });
        }
        function Qb(a2, b2) {
          var c2 = a2.g;
          if (void 0 === a2.m) {
            var d2 = Lb(c2, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", 0), e2 = Lb(c2, "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }", 1), g2 = c2.createProgram();
            c2.attachShader(g2, d2);
            c2.attachShader(g2, e2);
            c2.linkProgram(g2);
            if (!c2.getProgramParameter(g2, c2.LINK_STATUS))
              throw Error("Could not compile WebGL program.\n\n" + c2.getProgramInfoLog(g2));
            d2 = a2.m = g2;
            c2.useProgram(d2);
            e2 = c2.getUniformLocation(d2, "sampler0");
            a2.j = { I: c2.getAttribLocation(d2, "aVertex"), H: c2.getAttribLocation(d2, "aTex"), da: e2 };
            a2.s = c2.createBuffer();
            c2.bindBuffer(c2.ARRAY_BUFFER, a2.s);
            c2.enableVertexAttribArray(a2.j.I);
            c2.vertexAttribPointer(a2.j.I, 2, c2.FLOAT, false, 0, 0);
            c2.bufferData(c2.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), c2.STATIC_DRAW);
            c2.bindBuffer(c2.ARRAY_BUFFER, null);
            a2.o = c2.createBuffer();
            c2.bindBuffer(c2.ARRAY_BUFFER, a2.o);
            c2.enableVertexAttribArray(a2.j.H);
            c2.vertexAttribPointer(
              a2.j.H,
              2,
              c2.FLOAT,
              false,
              0,
              0
            );
            c2.bufferData(c2.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), c2.STATIC_DRAW);
            c2.bindBuffer(c2.ARRAY_BUFFER, null);
            c2.uniform1i(e2, 0);
          }
          d2 = a2.j;
          c2.useProgram(a2.m);
          c2.canvas.width = b2.width;
          c2.canvas.height = b2.height;
          c2.viewport(0, 0, b2.width, b2.height);
          c2.activeTexture(c2.TEXTURE0);
          a2.h.bindTexture2d(b2.glName);
          c2.enableVertexAttribArray(d2.I);
          c2.bindBuffer(c2.ARRAY_BUFFER, a2.s);
          c2.vertexAttribPointer(d2.I, 2, c2.FLOAT, false, 0, 0);
          c2.enableVertexAttribArray(d2.H);
          c2.bindBuffer(c2.ARRAY_BUFFER, a2.o);
          c2.vertexAttribPointer(
            d2.H,
            2,
            c2.FLOAT,
            false,
            0,
            0
          );
          c2.bindFramebuffer(c2.DRAW_FRAMEBUFFER ? c2.DRAW_FRAMEBUFFER : c2.FRAMEBUFFER, null);
          c2.clearColor(0, 0, 0, 0);
          c2.clear(c2.COLOR_BUFFER_BIT);
          c2.colorMask(true, true, true, true);
          c2.drawArrays(c2.TRIANGLE_FAN, 0, 4);
          c2.disableVertexAttribArray(d2.I);
          c2.disableVertexAttribArray(d2.H);
          c2.bindBuffer(c2.ARRAY_BUFFER, null);
          a2.h.bindTexture2d(0);
        }
        function Rb(a2) {
          this.g = a2;
        }
        ;
        var Sb = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]);
        function Tb(a2, b2) {
          return b2 + a2;
        }
        function Ub(a2, b2) {
          window[a2] = b2;
        }
        function Vb(a2) {
          var b2 = document.createElement("script");
          b2.setAttribute("src", a2);
          b2.setAttribute("crossorigin", "anonymous");
          return new Promise(function(c2) {
            b2.addEventListener("load", function() {
              c2();
            }, false);
            b2.addEventListener("error", function() {
              c2();
            }, false);
            document.body.appendChild(b2);
          });
        }
        function Wb() {
          return Z3(this, function b2() {
            return O3(b2, function(c2) {
              switch (c2.g) {
                case 1:
                  return c2.m = 2, N3(c2, WebAssembly.instantiate(Sb), 4);
                case 4:
                  c2.g = 3;
                  c2.m = 0;
                  break;
                case 2:
                  return c2.m = 0, c2.j = null, c2.return(false);
                case 3:
                  return c2.return(true);
              }
            });
          });
        }
        function Xb(a2) {
          this.g = a2;
          this.listeners = {};
          this.j = {};
          this.F = {};
          this.m = {};
          this.s = {};
          this.G = this.o = this.R = true;
          this.C = Promise.resolve();
          this.P = "";
          this.B = {};
          this.locateFile = a2 && a2.locateFile || Tb;
          if ("object" === typeof window)
            var b2 = window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/";
          else if ("undefined" !== typeof location)
            b2 = location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/";
          else
            throw Error("solutions can only be loaded on a web page or in a web worker");
          this.S = b2;
          if (a2.options) {
            b2 = K3(Object.keys(a2.options));
            for (var c2 = b2.next(); !c2.done; c2 = b2.next()) {
              c2 = c2.value;
              var d2 = a2.options[c2].default;
              void 0 !== d2 && (this.j[c2] = "function" === typeof d2 ? d2() : d2);
            }
          }
        }
        v2 = Xb.prototype;
        v2.close = function() {
          this.i && this.i.delete();
          return Promise.resolve();
        };
        function Yb(a2, b2) {
          return void 0 === a2.g.files ? [] : "function" === typeof a2.g.files ? a2.g.files(b2) : a2.g.files;
        }
        function Zb(a2) {
          return Z3(a2, function c2() {
            var d2 = this, e2, g2, f2, h, k4, l3, n2, u2, w2, r2, y2;
            return O3(c2, function(m2) {
              switch (m2.g) {
                case 1:
                  e2 = d2;
                  if (!d2.R)
                    return m2.return();
                  g2 = Yb(d2, d2.j);
                  return N3(m2, Wb(), 2);
                case 2:
                  f2 = m2.h;
                  if ("object" === typeof window)
                    return Ub("createMediapipeSolutionsWasm", { locateFile: d2.locateFile }), Ub("createMediapipeSolutionsPackedAssets", { locateFile: d2.locateFile }), l3 = g2.filter(function(t3) {
                      return void 0 !== t3.data;
                    }), n2 = g2.filter(function(t3) {
                      return void 0 === t3.data;
                    }), u2 = Promise.all(l3.map(function(t3) {
                      var x2 = $b(e2, t3.url);
                      if (void 0 !== t3.path) {
                        var z3 = t3.path;
                        x2 = x2.then(function(E3) {
                          e2.overrideFile(z3, E3);
                          return Promise.resolve(E3);
                        });
                      }
                      return x2;
                    })), w2 = Promise.all(n2.map(function(t3) {
                      return void 0 === t3.simd || t3.simd && f2 || !t3.simd && !f2 ? Vb(e2.locateFile(t3.url, e2.S)) : Promise.resolve();
                    })).then(function() {
                      return Z3(e2, function x2() {
                        var z3, E3, F3 = this;
                        return O3(x2, function(I3) {
                          if (1 == I3.g)
                            return z3 = window.createMediapipeSolutionsWasm, E3 = window.createMediapipeSolutionsPackedAssets, N3(I3, z3(E3), 2);
                          F3.h = I3.h;
                          I3.g = 0;
                        });
                      });
                    }), r2 = function() {
                      return Z3(e2, function x2() {
                        var z3 = this;
                        return O3(x2, function(E3) {
                          z3.g.graph && z3.g.graph.url ? E3 = N3(E3, $b(z3, z3.g.graph.url), 0) : (E3.g = 0, E3 = void 0);
                          return E3;
                        });
                      });
                    }(), N3(m2, Promise.all([w2, u2, r2]), 7);
                  if ("function" !== typeof importScripts)
                    throw Error("solutions can only be loaded on a web page or in a web worker");
                  h = g2.filter(function(t3) {
                    return void 0 === t3.simd || t3.simd && f2 || !t3.simd && !f2;
                  }).map(function(t3) {
                    return e2.locateFile(t3.url, e2.S);
                  });
                  importScripts.apply(null, L3(h));
                  return N3(m2, createMediapipeSolutionsWasm(Module), 6);
                case 6:
                  d2.h = m2.h;
                  d2.l = new OffscreenCanvas(1, 1);
                  d2.h.canvas = d2.l;
                  k4 = d2.h.GL.createContext(
                    d2.l,
                    { antialias: false, alpha: false, ba: "undefined" !== typeof WebGL2RenderingContext ? 2 : 1 }
                  );
                  d2.h.GL.makeContextCurrent(k4);
                  m2.g = 4;
                  break;
                case 7:
                  d2.l = document.createElement("canvas");
                  y2 = d2.l.getContext("webgl2", {});
                  if (!y2 && (y2 = d2.l.getContext("webgl", {}), !y2))
                    return alert("Failed to create WebGL canvas context when passing video frame."), m2.return();
                  d2.D = y2;
                  d2.h.canvas = d2.l;
                  d2.h.createContext(d2.l, true, true, {});
                case 4:
                  d2.i = new d2.h.SolutionWasm(), d2.R = false, m2.g = 0;
              }
            });
          });
        }
        function ac2(a2) {
          return Z3(a2, function c2() {
            var d2 = this, e2, g2, f2, h, k4, l3, n2, u2;
            return O3(c2, function(w2) {
              if (1 == w2.g) {
                if (d2.g.graph && d2.g.graph.url && d2.P === d2.g.graph.url)
                  return w2.return();
                d2.o = true;
                if (!d2.g.graph || !d2.g.graph.url) {
                  w2.g = 2;
                  return;
                }
                d2.P = d2.g.graph.url;
                return N3(w2, $b(d2, d2.g.graph.url), 3);
              }
              2 != w2.g && (e2 = w2.h, d2.i.loadGraph(e2));
              g2 = K3(Object.keys(d2.B));
              for (f2 = g2.next(); !f2.done; f2 = g2.next())
                h = f2.value, d2.i.overrideFile(h, d2.B[h]);
              d2.B = {};
              if (d2.g.listeners)
                for (k4 = K3(d2.g.listeners), l3 = k4.next(); !l3.done; l3 = k4.next())
                  n2 = l3.value, bc2(d2, n2);
              u2 = d2.j;
              d2.j = {};
              d2.setOptions(u2);
              w2.g = 0;
            });
          });
        }
        v2.reset = function() {
          return Z3(this, function b2() {
            var c2 = this;
            return O3(b2, function(d2) {
              c2.i && (c2.i.reset(), c2.m = {}, c2.s = {});
              d2.g = 0;
            });
          });
        };
        v2.setOptions = function(a2, b2) {
          var c2 = this;
          if (b2 = b2 || this.g.options) {
            for (var d2 = [], e2 = [], g2 = {}, f2 = K3(Object.keys(a2)), h = f2.next(); !h.done; g2 = { K: g2.K, L: g2.L }, h = f2.next()) {
              var k4 = h.value;
              k4 in this.j && this.j[k4] === a2[k4] || (this.j[k4] = a2[k4], h = b2[k4], void 0 !== h && (h.onChange && (g2.K = h.onChange, g2.L = a2[k4], d2.push(function(l3) {
                return function() {
                  return Z3(c2, function u2() {
                    var w2, r2 = this;
                    return O3(u2, function(y2) {
                      if (1 == y2.g)
                        return N3(y2, l3.K(l3.L), 2);
                      w2 = y2.h;
                      true === w2 && (r2.o = true);
                      y2.g = 0;
                    });
                  });
                };
              }(g2))), h.graphOptionXref && (k4 = { valueNumber: 1 === h.type ? a2[k4] : 0, valueBoolean: 0 === h.type ? a2[k4] : false, valueString: 2 === h.type ? a2[k4] : "" }, h = Object.assign(Object.assign(Object.assign({}, { calculatorName: "", calculatorIndex: 0 }), h.graphOptionXref), k4), e2.push(h))));
            }
            if (0 !== d2.length || 0 !== e2.length)
              this.o = true, this.A = (void 0 === this.A ? [] : this.A).concat(e2), this.u = (void 0 === this.u ? [] : this.u).concat(d2);
          }
        };
        function cc2(a2) {
          return Z3(a2, function c2() {
            var d2 = this, e2, g2, f2, h, k4, l3, n2;
            return O3(c2, function(u2) {
              switch (u2.g) {
                case 1:
                  if (!d2.o)
                    return u2.return();
                  if (!d2.u) {
                    u2.g = 2;
                    break;
                  }
                  e2 = K3(d2.u);
                  g2 = e2.next();
                case 3:
                  if (g2.done) {
                    u2.g = 5;
                    break;
                  }
                  f2 = g2.value;
                  return N3(u2, f2(), 4);
                case 4:
                  g2 = e2.next();
                  u2.g = 3;
                  break;
                case 5:
                  d2.u = void 0;
                case 2:
                  if (d2.A) {
                    h = new d2.h.GraphOptionChangeRequestList();
                    k4 = K3(d2.A);
                    for (l3 = k4.next(); !l3.done; l3 = k4.next())
                      n2 = l3.value, h.push_back(n2);
                    d2.i.changeOptions(h);
                    h.delete();
                    d2.A = void 0;
                  }
                  d2.o = false;
                  u2.g = 0;
              }
            });
          });
        }
        v2.initialize = function() {
          return Z3(this, function b2() {
            var c2 = this;
            return O3(b2, function(d2) {
              return 1 == d2.g ? N3(d2, Zb(c2), 2) : 3 != d2.g ? N3(d2, ac2(c2), 3) : N3(d2, cc2(c2), 0);
            });
          });
        };
        function $b(a2, b2) {
          return Z3(a2, function d2() {
            var e2 = this, g2, f2;
            return O3(d2, function(h) {
              if (b2 in e2.F)
                return h.return(e2.F[b2]);
              g2 = e2.locateFile(b2, "");
              f2 = fetch(g2).then(function(k4) {
                return k4.arrayBuffer();
              });
              e2.F[b2] = f2;
              return h.return(f2);
            });
          });
        }
        v2.overrideFile = function(a2, b2) {
          this.i ? this.i.overrideFile(a2, b2) : this.B[a2] = b2;
        };
        v2.clearOverriddenFiles = function() {
          this.B = {};
          this.i && this.i.clearOverriddenFiles();
        };
        v2.send = function(a2, b2) {
          return Z3(this, function d2() {
            var e2 = this, g2, f2, h, k4, l3, n2, u2, w2, r2;
            return O3(d2, function(y2) {
              switch (y2.g) {
                case 1:
                  if (!e2.g.inputs)
                    return y2.return();
                  g2 = 1e3 * (void 0 === b2 || null === b2 ? performance.now() : b2);
                  return N3(y2, e2.C, 2);
                case 2:
                  return N3(y2, e2.initialize(), 3);
                case 3:
                  f2 = new e2.h.PacketDataList();
                  h = K3(Object.keys(a2));
                  for (k4 = h.next(); !k4.done; k4 = h.next())
                    if (l3 = k4.value, n2 = e2.g.inputs[l3]) {
                      a: {
                        var m2 = e2;
                        var t3 = a2[l3];
                        switch (n2.type) {
                          case "video":
                            var x2 = m2.m[n2.stream];
                            x2 || (x2 = new Ob(m2.h, m2.D), m2.m[n2.stream] = x2);
                            m2 = x2;
                            0 === m2.l && (m2.l = m2.h.createTexture());
                            if ("undefined" !== typeof HTMLVideoElement && t3 instanceof HTMLVideoElement) {
                              var z3 = t3.videoWidth;
                              x2 = t3.videoHeight;
                            } else
                              "undefined" !== typeof HTMLImageElement && t3 instanceof HTMLImageElement ? (z3 = t3.naturalWidth, x2 = t3.naturalHeight) : (z3 = t3.width, x2 = t3.height);
                            x2 = { glName: m2.l, width: z3, height: x2 };
                            z3 = m2.g;
                            z3.canvas.width = x2.width;
                            z3.canvas.height = x2.height;
                            z3.activeTexture(z3.TEXTURE0);
                            m2.h.bindTexture2d(m2.l);
                            z3.texImage2D(z3.TEXTURE_2D, 0, z3.RGBA, z3.RGBA, z3.UNSIGNED_BYTE, t3);
                            m2.h.bindTexture2d(0);
                            m2 = x2;
                            break a;
                          case "detections":
                            x2 = m2.m[n2.stream];
                            x2 || (x2 = new Rb(m2.h), m2.m[n2.stream] = x2);
                            m2 = x2;
                            m2.data || (m2.data = new m2.g.DetectionListData());
                            m2.data.reset(t3.length);
                            for (x2 = 0; x2 < t3.length; ++x2) {
                              z3 = t3[x2];
                              var E3 = m2.data, F3 = E3.setBoundingBox, I3 = x2;
                              var H3 = z3.T;
                              var p2 = new Fb();
                              X3(p2, 1, H3.Z);
                              X3(p2, 2, H3.$);
                              X3(p2, 3, H3.height);
                              X3(p2, 4, H3.width);
                              X3(p2, 5, H3.rotation);
                              X3(p2, 6, H3.X);
                              var A2 = H3 = new Ya2();
                              U3(A2, 1, W3(p2, 1));
                              U3(A2, 2, W3(p2, 2));
                              U3(A2, 3, W3(p2, 3));
                              U3(A2, 4, W3(p2, 4));
                              U3(A2, 5, W3(p2, 5));
                              var C3 = W3(p2, 6);
                              if (null != C3 && null != C3) {
                                Ra2(A2.g, 48);
                                var q3 = A2.g, B3 = C3;
                                C3 = 0 > B3;
                                B3 = Math.abs(B3);
                                var D3 = B3 >>> 0;
                                B3 = Math.floor((B3 - D3) / 4294967296);
                                B3 >>>= 0;
                                C3 && (B3 = ~B3 >>> 0, D3 = (~D3 >>> 0) + 1, 4294967295 < D3 && (D3 = 0, B3++, 4294967295 < B3 && (B3 = 0)));
                                Q3 = D3;
                                R3 = B3;
                                C3 = Q3;
                                for (D3 = R3; 0 < D3 || 127 < C3; )
                                  q3.push(C3 & 127 | 128), C3 = (C3 >>> 7 | D3 << 25) >>> 0, D3 >>>= 7;
                                q3.push(C3);
                              }
                              rb(p2, A2);
                              H3 = $a2(H3);
                              F3.call(E3, I3, H3);
                              if (z3.O)
                                for (E3 = 0; E3 < z3.O.length; ++E3)
                                  p2 = z3.O[E3], A2 = p2.visibility ? true : false, F3 = m2.data, I3 = F3.addNormalizedLandmark, H3 = x2, p2 = Object.assign(Object.assign({}, p2), { visibility: A2 ? p2.visibility : 0 }), A2 = new Ab(), X3(A2, 1, p2.x), X3(A2, 2, p2.y), X3(A2, 3, p2.z), p2.visibility && X3(A2, 4, p2.visibility), q3 = p2 = new Ya2(), U3(q3, 1, W3(A2, 1)), U3(q3, 2, W3(A2, 2)), U3(q3, 3, W3(A2, 3)), U3(q3, 4, W3(A2, 4)), U3(q3, 5, W3(A2, 5)), rb(A2, q3), p2 = $a2(p2), I3.call(F3, H3, p2);
                              if (z3.M)
                                for (E3 = 0; E3 < z3.M.length; ++E3) {
                                  F3 = m2.data;
                                  I3 = F3.addClassification;
                                  H3 = x2;
                                  p2 = z3.M[E3];
                                  A2 = new wb();
                                  X3(A2, 2, p2.Y);
                                  p2.index && X3(A2, 1, p2.index);
                                  p2.label && X3(A2, 3, p2.label);
                                  p2.displayName && X3(A2, 4, p2.displayName);
                                  q3 = p2 = new Ya2();
                                  D3 = W3(A2, 1);
                                  if (null != D3 && null != D3)
                                    if (Ra2(q3.g, 8), C3 = q3.g, 0 <= D3)
                                      Ra2(C3, D3);
                                    else {
                                      for (B3 = 0; 9 > B3; B3++)
                                        C3.push(D3 & 127 | 128), D3 >>= 7;
                                      C3.push(1);
                                    }
                                  U3(q3, 2, W3(A2, 2));
                                  C3 = W3(A2, 3);
                                  null != C3 && (C3 = Ca2(C3), Ra2(q3.g, 26), Ra2(q3.g, C3.length), Za2(q3, q3.g.end()), Za2(q3, C3));
                                  C3 = W3(A2, 4);
                                  null != C3 && (C3 = Ca2(C3), Ra2(q3.g, 34), Ra2(q3.g, C3.length), Za2(q3, q3.g.end()), Za2(q3, C3));
                                  rb(A2, q3);
                                  p2 = $a2(p2);
                                  I3.call(F3, H3, p2);
                                }
                            }
                            m2 = m2.data;
                            break a;
                          default:
                            m2 = {};
                        }
                      }
                      u2 = m2;
                      w2 = n2.stream;
                      switch (n2.type) {
                        case "video":
                          f2.pushTexture2d(Object.assign(Object.assign({}, u2), { stream: w2, timestamp: g2 }));
                          break;
                        case "detections":
                          r2 = u2;
                          r2.stream = w2;
                          r2.timestamp = g2;
                          f2.pushDetectionList(r2);
                          break;
                        default:
                          throw Error("Unknown input config type: '" + n2.type + "'");
                      }
                    }
                  e2.i.send(f2);
                  return N3(y2, e2.C, 4);
                case 4:
                  f2.delete(), y2.g = 0;
              }
            });
          });
        };
        function dc2(a2, b2, c2) {
          return Z3(a2, function e2() {
            var g2, f2, h, k4, l3, n2, u2 = this, w2, r2, y2, m2, t3, x2, z3, E3;
            return O3(e2, function(F3) {
              switch (F3.g) {
                case 1:
                  if (!c2)
                    return F3.return(b2);
                  g2 = {};
                  f2 = 0;
                  h = K3(Object.keys(c2));
                  for (k4 = h.next(); !k4.done; k4 = h.next())
                    l3 = k4.value, n2 = c2[l3], "string" !== typeof n2 && "texture" === n2.type && void 0 !== b2[n2.stream] && ++f2;
                  1 < f2 && (u2.G = false);
                  w2 = K3(Object.keys(c2));
                  k4 = w2.next();
                case 2:
                  if (k4.done) {
                    F3.g = 4;
                    break;
                  }
                  r2 = k4.value;
                  y2 = c2[r2];
                  if ("string" === typeof y2)
                    return z3 = g2, E3 = r2, N3(F3, ec2(u2, r2, b2[y2]), 14);
                  m2 = b2[y2.stream];
                  if ("detection_list" === y2.type) {
                    if (m2) {
                      var I3 = m2.getRectList();
                      for (var H3 = m2.getLandmarksList(), p2 = m2.getClassificationsList(), A2 = [], C3 = 0; C3 < I3.size(); ++C3) {
                        var q3 = I3.get(C3);
                        a: {
                          var B3 = new Fb();
                          for (q3 = new Sa2(q3); S3(q3); )
                            switch (q3.i) {
                              case 13:
                                var D3 = T2(q3);
                                X3(B3, 1, D3);
                                break;
                              case 21:
                                D3 = T2(q3);
                                X3(B3, 2, D3);
                                break;
                              case 29:
                                D3 = T2(q3);
                                X3(B3, 3, D3);
                                break;
                              case 37:
                                D3 = T2(q3);
                                X3(B3, 4, D3);
                                break;
                              case 45:
                                D3 = T2(q3);
                                X3(B3, 5, D3);
                                break;
                              case 48:
                                D3 = Oa2(q3.g);
                                X3(B3, 6, D3);
                                break;
                              default:
                                if (!sb(B3, q3))
                                  break a;
                            }
                        }
                        B3 = { Z: Y3(B3, 1), $: Y3(B3, 2), height: Y3(B3, 3), width: Y3(B3, 4), rotation: Y3(B3, 5, 0), X: lb(B3, 6, 0) };
                        q3 = nb(Eb(H3.get(C3)), Ab).map(Nb);
                        var la2 = p2.get(C3);
                        a:
                          for (D3 = new yb(), la2 = new Sa2(la2); S3(la2); )
                            switch (la2.i) {
                              case 10:
                                D3.addClassification(Ua2(la2, new wb(), xb));
                                break;
                              default:
                                if (!sb(D3, la2))
                                  break a;
                            }
                        B3 = { T: B3, O: q3, M: Mb(D3) };
                        A2.push(B3);
                      }
                      I3 = A2;
                    } else
                      I3 = [];
                    g2[r2] = I3;
                    F3.g = 7;
                    break;
                  }
                  if ("proto_list" === y2.type) {
                    if (m2) {
                      I3 = Array(m2.size());
                      for (H3 = 0; H3 < m2.size(); H3++)
                        I3[H3] = m2.get(H3);
                      m2.delete();
                    } else
                      I3 = [];
                    g2[r2] = I3;
                    F3.g = 7;
                    break;
                  }
                  if (void 0 === m2) {
                    F3.g = 3;
                    break;
                  }
                  if ("float_list" === y2.type) {
                    g2[r2] = m2;
                    F3.g = 7;
                    break;
                  }
                  if ("proto" === y2.type) {
                    g2[r2] = m2;
                    F3.g = 7;
                    break;
                  }
                  if ("texture" !== y2.type)
                    throw Error("Unknown output config type: '" + y2.type + "'");
                  t3 = u2.s[r2];
                  t3 || (t3 = new Ob(u2.h, u2.D), u2.s[r2] = t3);
                  return N3(F3, Pb(t3, m2, u2.G), 13);
                case 13:
                  x2 = F3.h, g2[r2] = x2;
                case 7:
                  y2.transform && g2[r2] && (g2[r2] = y2.transform(g2[r2]));
                  F3.g = 3;
                  break;
                case 14:
                  z3[E3] = F3.h;
                case 3:
                  k4 = w2.next();
                  F3.g = 2;
                  break;
                case 4:
                  return F3.return(g2);
              }
            });
          });
        }
        function ec2(a2, b2, c2) {
          return Z3(a2, function e2() {
            var g2 = this, f2;
            return O3(e2, function(h) {
              return "number" === typeof c2 || c2 instanceof Uint8Array || c2 instanceof g2.h.Uint8BlobList ? h.return(c2) : c2 instanceof g2.h.Texture2dDataOut ? (f2 = g2.s[b2], f2 || (f2 = new Ob(g2.h, g2.D), g2.s[b2] = f2), h.return(Pb(f2, c2, g2.G))) : h.return(void 0);
            });
          });
        }
        function bc2(a2, b2) {
          for (var c2 = b2.name || "$", d2 = [].concat(L3(b2.wants)), e2 = new a2.h.StringList(), g2 = K3(b2.wants), f2 = g2.next(); !f2.done; f2 = g2.next())
            e2.push_back(f2.value);
          g2 = a2.h.PacketListener.implement({ onResults: function(h) {
            for (var k4 = {}, l3 = 0; l3 < b2.wants.length; ++l3)
              k4[d2[l3]] = h.get(l3);
            var n2 = a2.listeners[c2];
            n2 && (a2.C = dc2(a2, k4, b2.outs).then(function(u2) {
              u2 = n2(u2);
              for (var w2 = 0; w2 < b2.wants.length; ++w2) {
                var r2 = k4[d2[w2]];
                "object" === typeof r2 && r2.hasOwnProperty && r2.hasOwnProperty("delete") && r2.delete();
              }
              u2 && (a2.C = u2);
            }));
          } });
          a2.i.attachMultiListener(e2, g2);
          e2.delete();
        }
        v2.onResults = function(a2, b2) {
          this.listeners[b2 || "$"] = a2;
        };
        P3("Solution", Xb);
        P3("OptionType", { BOOL: 0, NUMBER: 1, aa: 2, 0: "BOOL", 1: "NUMBER", 2: "STRING" });
        function fc2(a2) {
          a2 = Kb(a2);
          var b2 = a2.getMesh();
          if (!b2)
            return a2;
          var c2 = new Float32Array(b2.getVertexBufferList());
          b2.getVertexBufferList = function() {
            return c2;
          };
          var d2 = new Uint32Array(b2.getIndexBufferList());
          b2.getIndexBufferList = function() {
            return d2;
          };
          return a2;
        }
        ;
        var gc2 = { files: [{ url: "face_mesh_solution_packed_assets_loader.js" }, { simd: true, url: "face_mesh_solution_simd_wasm_bin.js" }, { simd: false, url: "face_mesh_solution_wasm_bin.js" }], graph: { url: "face_mesh.binarypb" }, listeners: [{ wants: ["multi_face_geometry", "image_transformed", "multi_face_landmarks"], outs: { image: "image_transformed", multiFaceGeometry: { type: "proto_list", stream: "multi_face_geometry", transform: function(a2) {
          return a2.map(fc2);
        } }, multiFaceLandmarks: { type: "proto_list", stream: "multi_face_landmarks", transform: function(a2) {
          return a2.map(function(b2) {
            return nb(
              Eb(b2),
              Ab
            ).map(Nb);
          });
        } } } }], inputs: { image: { type: "video", stream: "input_frames_gpu" } }, options: { useCpuInference: { type: 0, graphOptionXref: { calculatorType: "InferenceCalculator", fieldName: "use_cpu_inference" }, default: "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document }, enableFaceGeometry: { type: 0, graphOptionXref: {
          calculatorName: "EnableFaceGeometryConstant",
          calculatorType: "ConstantSidePacketCalculator",
          fieldName: "bool_value"
        } }, selfieMode: { type: 0, graphOptionXref: { calculatorType: "GlScalerCalculator", calculatorIndex: 1, fieldName: "flip_horizontal" } }, maxNumFaces: { type: 1, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorNumFaces", fieldName: "int_value" } }, refineLandmarks: { type: 0, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorRefineLandmarks", fieldName: "bool_value" } }, minDetectionConfidence: {
          type: 1,
          graphOptionXref: { calculatorType: "TensorsToDetectionsCalculator", calculatorName: "facelandmarkfrontgpu__facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator", fieldName: "min_score_thresh" }
        }, minTrackingConfidence: { type: 1, graphOptionXref: { calculatorType: "ThresholdingCalculator", calculatorName: "facelandmarkfrontgpu__facelandmarkgpu__ThresholdingCalculator", fieldName: "threshold" } }, cameraNear: { type: 1, graphOptionXref: {
          calculatorType: "FaceGeometryEnvGeneratorCalculator",
          fieldName: "near"
        } }, cameraFar: { type: 1, graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "far" } }, cameraVerticalFovDegrees: { type: 1, graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "vertical_fov_degrees" } } } };
        var hc2 = [[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]], ic2 = [[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [
          386,
          385
        ], [385, 384], [384, 398], [398, 362]], jc2 = [[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]], kc2 = [[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]], lc2 = [[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]], mc2 = [
          [10, 338],
          [338, 297],
          [297, 332],
          [332, 284],
          [284, 251],
          [251, 389],
          [389, 356],
          [356, 454],
          [454, 323],
          [323, 361],
          [361, 288],
          [288, 397],
          [397, 365],
          [365, 379],
          [379, 378],
          [378, 400],
          [400, 377],
          [377, 152],
          [152, 148],
          [148, 176],
          [176, 149],
          [149, 150],
          [150, 136],
          [136, 172],
          [172, 58],
          [58, 132],
          [132, 93],
          [93, 234],
          [234, 127],
          [127, 162],
          [162, 21],
          [21, 54],
          [54, 103],
          [103, 67],
          [67, 109],
          [109, 10]
        ], nc2 = [].concat(L3(hc2), L3(ic2), L3(jc2), L3(kc2), L3(lc2), L3(mc2));
        function oc2(a2) {
          a2 = a2 || {};
          a2 = Object.assign(Object.assign({}, gc2), a2);
          this.g = new Xb(a2);
        }
        v2 = oc2.prototype;
        v2.close = function() {
          this.g.close();
          return Promise.resolve();
        };
        v2.onResults = function(a2) {
          this.g.onResults(a2);
        };
        v2.initialize = function() {
          return Z3(this, function b2() {
            var c2 = this;
            return O3(b2, function(d2) {
              return N3(d2, c2.g.initialize(), 0);
            });
          });
        };
        v2.reset = function() {
          this.g.reset();
        };
        v2.send = function(a2) {
          return Z3(this, function c2() {
            var d2 = this;
            return O3(c2, function(e2) {
              return N3(e2, d2.g.send(a2), 0);
            });
          });
        };
        v2.setOptions = function(a2) {
          this.g.setOptions(a2);
        };
        P3("FACE_GEOMETRY", { Layout: { COLUMN_MAJOR: 0, ROW_MAJOR: 1, 0: "COLUMN_MAJOR", 1: "ROW_MAJOR" }, PrimitiveType: { TRIANGLE: 0, 0: "TRIANGLE" }, VertexType: { VERTEX_PT: 0, 0: "VERTEX_PT" }, DEFAULT_CAMERA_PARAMS: { verticalFovDegrees: 63, near: 1, far: 1e4 } });
        P3("FaceMesh", oc2);
        P3("FACEMESH_LIPS", hc2);
        P3("FACEMESH_LEFT_EYE", ic2);
        P3("FACEMESH_LEFT_EYEBROW", jc2);
        P3("FACEMESH_LEFT_IRIS", [[474, 475], [475, 476], [476, 477], [477, 474]]);
        P3("FACEMESH_RIGHT_EYE", kc2);
        P3("FACEMESH_RIGHT_EYEBROW", lc2);
        P3("FACEMESH_RIGHT_IRIS", [[469, 470], [470, 471], [471, 472], [472, 469]]);
        P3("FACEMESH_FACE_OVAL", mc2);
        P3("FACEMESH_CONTOURS", nc2);
        P3("FACEMESH_TESSELATION", [
          [127, 34],
          [34, 139],
          [139, 127],
          [11, 0],
          [0, 37],
          [37, 11],
          [232, 231],
          [231, 120],
          [120, 232],
          [72, 37],
          [37, 39],
          [39, 72],
          [128, 121],
          [121, 47],
          [47, 128],
          [232, 121],
          [121, 128],
          [128, 232],
          [104, 69],
          [69, 67],
          [67, 104],
          [175, 171],
          [171, 148],
          [148, 175],
          [118, 50],
          [50, 101],
          [101, 118],
          [73, 39],
          [39, 40],
          [40, 73],
          [9, 151],
          [151, 108],
          [108, 9],
          [48, 115],
          [115, 131],
          [131, 48],
          [194, 204],
          [204, 211],
          [211, 194],
          [74, 40],
          [40, 185],
          [185, 74],
          [80, 42],
          [42, 183],
          [183, 80],
          [40, 92],
          [92, 186],
          [186, 40],
          [230, 229],
          [229, 118],
          [118, 230],
          [202, 212],
          [
            212,
            214
          ],
          [214, 202],
          [83, 18],
          [18, 17],
          [17, 83],
          [76, 61],
          [61, 146],
          [146, 76],
          [160, 29],
          [29, 30],
          [30, 160],
          [56, 157],
          [157, 173],
          [173, 56],
          [106, 204],
          [204, 194],
          [194, 106],
          [135, 214],
          [214, 192],
          [192, 135],
          [203, 165],
          [165, 98],
          [98, 203],
          [21, 71],
          [71, 68],
          [68, 21],
          [51, 45],
          [45, 4],
          [4, 51],
          [144, 24],
          [24, 23],
          [23, 144],
          [77, 146],
          [146, 91],
          [91, 77],
          [205, 50],
          [50, 187],
          [187, 205],
          [201, 200],
          [200, 18],
          [18, 201],
          [91, 106],
          [106, 182],
          [182, 91],
          [90, 91],
          [91, 181],
          [181, 90],
          [85, 84],
          [84, 17],
          [17, 85],
          [206, 203],
          [203, 36],
          [36, 206],
          [148, 171],
          [171, 140],
          [140, 148],
          [
            92,
            40
          ],
          [40, 39],
          [39, 92],
          [193, 189],
          [189, 244],
          [244, 193],
          [159, 158],
          [158, 28],
          [28, 159],
          [247, 246],
          [246, 161],
          [161, 247],
          [236, 3],
          [3, 196],
          [196, 236],
          [54, 68],
          [68, 104],
          [104, 54],
          [193, 168],
          [168, 8],
          [8, 193],
          [117, 228],
          [228, 31],
          [31, 117],
          [189, 193],
          [193, 55],
          [55, 189],
          [98, 97],
          [97, 99],
          [99, 98],
          [126, 47],
          [47, 100],
          [100, 126],
          [166, 79],
          [79, 218],
          [218, 166],
          [155, 154],
          [154, 26],
          [26, 155],
          [209, 49],
          [49, 131],
          [131, 209],
          [135, 136],
          [136, 150],
          [150, 135],
          [47, 126],
          [126, 217],
          [217, 47],
          [223, 52],
          [52, 53],
          [53, 223],
          [45, 51],
          [51, 134],
          [134, 45],
          [211, 170],
          [
            170,
            140
          ],
          [140, 211],
          [67, 69],
          [69, 108],
          [108, 67],
          [43, 106],
          [106, 91],
          [91, 43],
          [230, 119],
          [119, 120],
          [120, 230],
          [226, 130],
          [130, 247],
          [247, 226],
          [63, 53],
          [53, 52],
          [52, 63],
          [238, 20],
          [20, 242],
          [242, 238],
          [46, 70],
          [70, 156],
          [156, 46],
          [78, 62],
          [62, 96],
          [96, 78],
          [46, 53],
          [53, 63],
          [63, 46],
          [143, 34],
          [34, 227],
          [227, 143],
          [123, 117],
          [117, 111],
          [111, 123],
          [44, 125],
          [125, 19],
          [19, 44],
          [236, 134],
          [134, 51],
          [51, 236],
          [216, 206],
          [206, 205],
          [205, 216],
          [154, 153],
          [153, 22],
          [22, 154],
          [39, 37],
          [37, 167],
          [167, 39],
          [200, 201],
          [201, 208],
          [208, 200],
          [36, 142],
          [142, 100],
          [
            100,
            36
          ],
          [57, 212],
          [212, 202],
          [202, 57],
          [20, 60],
          [60, 99],
          [99, 20],
          [28, 158],
          [158, 157],
          [157, 28],
          [35, 226],
          [226, 113],
          [113, 35],
          [160, 159],
          [159, 27],
          [27, 160],
          [204, 202],
          [202, 210],
          [210, 204],
          [113, 225],
          [225, 46],
          [46, 113],
          [43, 202],
          [202, 204],
          [204, 43],
          [62, 76],
          [76, 77],
          [77, 62],
          [137, 123],
          [123, 116],
          [116, 137],
          [41, 38],
          [38, 72],
          [72, 41],
          [203, 129],
          [129, 142],
          [142, 203],
          [64, 98],
          [98, 240],
          [240, 64],
          [49, 102],
          [102, 64],
          [64, 49],
          [41, 73],
          [73, 74],
          [74, 41],
          [212, 216],
          [216, 207],
          [207, 212],
          [42, 74],
          [74, 184],
          [184, 42],
          [169, 170],
          [170, 211],
          [211, 169],
          [
            170,
            149
          ],
          [149, 176],
          [176, 170],
          [105, 66],
          [66, 69],
          [69, 105],
          [122, 6],
          [6, 168],
          [168, 122],
          [123, 147],
          [147, 187],
          [187, 123],
          [96, 77],
          [77, 90],
          [90, 96],
          [65, 55],
          [55, 107],
          [107, 65],
          [89, 90],
          [90, 180],
          [180, 89],
          [101, 100],
          [100, 120],
          [120, 101],
          [63, 105],
          [105, 104],
          [104, 63],
          [93, 137],
          [137, 227],
          [227, 93],
          [15, 86],
          [86, 85],
          [85, 15],
          [129, 102],
          [102, 49],
          [49, 129],
          [14, 87],
          [87, 86],
          [86, 14],
          [55, 8],
          [8, 9],
          [9, 55],
          [100, 47],
          [47, 121],
          [121, 100],
          [145, 23],
          [23, 22],
          [22, 145],
          [88, 89],
          [89, 179],
          [179, 88],
          [6, 122],
          [122, 196],
          [196, 6],
          [88, 95],
          [95, 96],
          [96, 88],
          [138, 172],
          [172, 136],
          [136, 138],
          [215, 58],
          [58, 172],
          [172, 215],
          [115, 48],
          [48, 219],
          [219, 115],
          [42, 80],
          [80, 81],
          [81, 42],
          [195, 3],
          [3, 51],
          [51, 195],
          [43, 146],
          [146, 61],
          [61, 43],
          [171, 175],
          [175, 199],
          [199, 171],
          [81, 82],
          [82, 38],
          [38, 81],
          [53, 46],
          [46, 225],
          [225, 53],
          [144, 163],
          [163, 110],
          [110, 144],
          [52, 65],
          [65, 66],
          [66, 52],
          [229, 228],
          [228, 117],
          [117, 229],
          [34, 127],
          [127, 234],
          [234, 34],
          [107, 108],
          [108, 69],
          [69, 107],
          [109, 108],
          [108, 151],
          [151, 109],
          [48, 64],
          [64, 235],
          [235, 48],
          [62, 78],
          [78, 191],
          [191, 62],
          [129, 209],
          [209, 126],
          [126, 129],
          [111, 35],
          [35, 143],
          [
            143,
            111
          ],
          [117, 123],
          [123, 50],
          [50, 117],
          [222, 65],
          [65, 52],
          [52, 222],
          [19, 125],
          [125, 141],
          [141, 19],
          [221, 55],
          [55, 65],
          [65, 221],
          [3, 195],
          [195, 197],
          [197, 3],
          [25, 7],
          [7, 33],
          [33, 25],
          [220, 237],
          [237, 44],
          [44, 220],
          [70, 71],
          [71, 139],
          [139, 70],
          [122, 193],
          [193, 245],
          [245, 122],
          [247, 130],
          [130, 33],
          [33, 247],
          [71, 21],
          [21, 162],
          [162, 71],
          [170, 169],
          [169, 150],
          [150, 170],
          [188, 174],
          [174, 196],
          [196, 188],
          [216, 186],
          [186, 92],
          [92, 216],
          [2, 97],
          [97, 167],
          [167, 2],
          [141, 125],
          [125, 241],
          [241, 141],
          [164, 167],
          [167, 37],
          [37, 164],
          [72, 38],
          [38, 12],
          [12, 72],
          [38, 82],
          [82, 13],
          [13, 38],
          [63, 68],
          [68, 71],
          [71, 63],
          [226, 35],
          [35, 111],
          [111, 226],
          [101, 50],
          [50, 205],
          [205, 101],
          [206, 92],
          [92, 165],
          [165, 206],
          [209, 198],
          [198, 217],
          [217, 209],
          [165, 167],
          [167, 97],
          [97, 165],
          [220, 115],
          [115, 218],
          [218, 220],
          [133, 112],
          [112, 243],
          [243, 133],
          [239, 238],
          [238, 241],
          [241, 239],
          [214, 135],
          [135, 169],
          [169, 214],
          [190, 173],
          [173, 133],
          [133, 190],
          [171, 208],
          [208, 32],
          [32, 171],
          [125, 44],
          [44, 237],
          [237, 125],
          [86, 87],
          [87, 178],
          [178, 86],
          [85, 86],
          [86, 179],
          [179, 85],
          [84, 85],
          [85, 180],
          [180, 84],
          [83, 84],
          [84, 181],
          [181, 83],
          [201, 83],
          [83, 182],
          [182, 201],
          [137, 93],
          [93, 132],
          [132, 137],
          [76, 62],
          [62, 183],
          [183, 76],
          [61, 76],
          [76, 184],
          [184, 61],
          [57, 61],
          [61, 185],
          [185, 57],
          [212, 57],
          [57, 186],
          [186, 212],
          [214, 207],
          [207, 187],
          [187, 214],
          [34, 143],
          [143, 156],
          [156, 34],
          [79, 239],
          [239, 237],
          [237, 79],
          [123, 137],
          [137, 177],
          [177, 123],
          [44, 1],
          [1, 4],
          [4, 44],
          [201, 194],
          [194, 32],
          [32, 201],
          [64, 102],
          [102, 129],
          [129, 64],
          [213, 215],
          [215, 138],
          [138, 213],
          [59, 166],
          [166, 219],
          [219, 59],
          [242, 99],
          [99, 97],
          [97, 242],
          [2, 94],
          [94, 141],
          [141, 2],
          [75, 59],
          [59, 235],
          [235, 75],
          [24, 110],
          [110, 228],
          [
            228,
            24
          ],
          [25, 130],
          [130, 226],
          [226, 25],
          [23, 24],
          [24, 229],
          [229, 23],
          [22, 23],
          [23, 230],
          [230, 22],
          [26, 22],
          [22, 231],
          [231, 26],
          [112, 26],
          [26, 232],
          [232, 112],
          [189, 190],
          [190, 243],
          [243, 189],
          [221, 56],
          [56, 190],
          [190, 221],
          [28, 56],
          [56, 221],
          [221, 28],
          [27, 28],
          [28, 222],
          [222, 27],
          [29, 27],
          [27, 223],
          [223, 29],
          [30, 29],
          [29, 224],
          [224, 30],
          [247, 30],
          [30, 225],
          [225, 247],
          [238, 79],
          [79, 20],
          [20, 238],
          [166, 59],
          [59, 75],
          [75, 166],
          [60, 75],
          [75, 240],
          [240, 60],
          [147, 177],
          [177, 215],
          [215, 147],
          [20, 79],
          [79, 166],
          [166, 20],
          [187, 147],
          [147, 213],
          [213, 187],
          [112, 233],
          [233, 244],
          [244, 112],
          [233, 128],
          [128, 245],
          [245, 233],
          [128, 114],
          [114, 188],
          [188, 128],
          [114, 217],
          [217, 174],
          [174, 114],
          [131, 115],
          [115, 220],
          [220, 131],
          [217, 198],
          [198, 236],
          [236, 217],
          [198, 131],
          [131, 134],
          [134, 198],
          [177, 132],
          [132, 58],
          [58, 177],
          [143, 35],
          [35, 124],
          [124, 143],
          [110, 163],
          [163, 7],
          [7, 110],
          [228, 110],
          [110, 25],
          [25, 228],
          [356, 389],
          [389, 368],
          [368, 356],
          [11, 302],
          [302, 267],
          [267, 11],
          [452, 350],
          [350, 349],
          [349, 452],
          [302, 303],
          [303, 269],
          [269, 302],
          [357, 343],
          [343, 277],
          [277, 357],
          [452, 453],
          [453, 357],
          [357, 452],
          [333, 332],
          [
            332,
            297
          ],
          [297, 333],
          [175, 152],
          [152, 377],
          [377, 175],
          [347, 348],
          [348, 330],
          [330, 347],
          [303, 304],
          [304, 270],
          [270, 303],
          [9, 336],
          [336, 337],
          [337, 9],
          [278, 279],
          [279, 360],
          [360, 278],
          [418, 262],
          [262, 431],
          [431, 418],
          [304, 408],
          [408, 409],
          [409, 304],
          [310, 415],
          [415, 407],
          [407, 310],
          [270, 409],
          [409, 410],
          [410, 270],
          [450, 348],
          [348, 347],
          [347, 450],
          [422, 430],
          [430, 434],
          [434, 422],
          [313, 314],
          [314, 17],
          [17, 313],
          [306, 307],
          [307, 375],
          [375, 306],
          [387, 388],
          [388, 260],
          [260, 387],
          [286, 414],
          [414, 398],
          [398, 286],
          [335, 406],
          [406, 418],
          [418, 335],
          [364, 367],
          [
            367,
            416
          ],
          [416, 364],
          [423, 358],
          [358, 327],
          [327, 423],
          [251, 284],
          [284, 298],
          [298, 251],
          [281, 5],
          [5, 4],
          [4, 281],
          [373, 374],
          [374, 253],
          [253, 373],
          [307, 320],
          [320, 321],
          [321, 307],
          [425, 427],
          [427, 411],
          [411, 425],
          [421, 313],
          [313, 18],
          [18, 421],
          [321, 405],
          [405, 406],
          [406, 321],
          [320, 404],
          [404, 405],
          [405, 320],
          [315, 16],
          [16, 17],
          [17, 315],
          [426, 425],
          [425, 266],
          [266, 426],
          [377, 400],
          [400, 369],
          [369, 377],
          [322, 391],
          [391, 269],
          [269, 322],
          [417, 465],
          [465, 464],
          [464, 417],
          [386, 257],
          [257, 258],
          [258, 386],
          [466, 260],
          [260, 388],
          [388, 466],
          [456, 399],
          [399, 419],
          [419, 456],
          [284, 332],
          [332, 333],
          [333, 284],
          [417, 285],
          [285, 8],
          [8, 417],
          [346, 340],
          [340, 261],
          [261, 346],
          [413, 441],
          [441, 285],
          [285, 413],
          [327, 460],
          [460, 328],
          [328, 327],
          [355, 371],
          [371, 329],
          [329, 355],
          [392, 439],
          [439, 438],
          [438, 392],
          [382, 341],
          [341, 256],
          [256, 382],
          [429, 420],
          [420, 360],
          [360, 429],
          [364, 394],
          [394, 379],
          [379, 364],
          [277, 343],
          [343, 437],
          [437, 277],
          [443, 444],
          [444, 283],
          [283, 443],
          [275, 440],
          [440, 363],
          [363, 275],
          [431, 262],
          [262, 369],
          [369, 431],
          [297, 338],
          [338, 337],
          [337, 297],
          [273, 375],
          [375, 321],
          [321, 273],
          [450, 451],
          [
            451,
            349
          ],
          [349, 450],
          [446, 342],
          [342, 467],
          [467, 446],
          [293, 334],
          [334, 282],
          [282, 293],
          [458, 461],
          [461, 462],
          [462, 458],
          [276, 353],
          [353, 383],
          [383, 276],
          [308, 324],
          [324, 325],
          [325, 308],
          [276, 300],
          [300, 293],
          [293, 276],
          [372, 345],
          [345, 447],
          [447, 372],
          [352, 345],
          [345, 340],
          [340, 352],
          [274, 1],
          [1, 19],
          [19, 274],
          [456, 248],
          [248, 281],
          [281, 456],
          [436, 427],
          [427, 425],
          [425, 436],
          [381, 256],
          [256, 252],
          [252, 381],
          [269, 391],
          [391, 393],
          [393, 269],
          [200, 199],
          [199, 428],
          [428, 200],
          [266, 330],
          [330, 329],
          [329, 266],
          [287, 273],
          [273, 422],
          [422, 287],
          [250, 462],
          [
            462,
            328
          ],
          [328, 250],
          [258, 286],
          [286, 384],
          [384, 258],
          [265, 353],
          [353, 342],
          [342, 265],
          [387, 259],
          [259, 257],
          [257, 387],
          [424, 431],
          [431, 430],
          [430, 424],
          [342, 353],
          [353, 276],
          [276, 342],
          [273, 335],
          [335, 424],
          [424, 273],
          [292, 325],
          [325, 307],
          [307, 292],
          [366, 447],
          [447, 345],
          [345, 366],
          [271, 303],
          [303, 302],
          [302, 271],
          [423, 266],
          [266, 371],
          [371, 423],
          [294, 455],
          [455, 460],
          [460, 294],
          [279, 278],
          [278, 294],
          [294, 279],
          [271, 272],
          [272, 304],
          [304, 271],
          [432, 434],
          [434, 427],
          [427, 432],
          [272, 407],
          [407, 408],
          [408, 272],
          [394, 430],
          [430, 431],
          [431, 394],
          [395, 369],
          [369, 400],
          [400, 395],
          [334, 333],
          [333, 299],
          [299, 334],
          [351, 417],
          [417, 168],
          [168, 351],
          [352, 280],
          [280, 411],
          [411, 352],
          [325, 319],
          [319, 320],
          [320, 325],
          [295, 296],
          [296, 336],
          [336, 295],
          [319, 403],
          [403, 404],
          [404, 319],
          [330, 348],
          [348, 349],
          [349, 330],
          [293, 298],
          [298, 333],
          [333, 293],
          [323, 454],
          [454, 447],
          [447, 323],
          [15, 16],
          [16, 315],
          [315, 15],
          [358, 429],
          [429, 279],
          [279, 358],
          [14, 15],
          [15, 316],
          [316, 14],
          [285, 336],
          [336, 9],
          [9, 285],
          [329, 349],
          [349, 350],
          [350, 329],
          [374, 380],
          [380, 252],
          [252, 374],
          [318, 402],
          [402, 403],
          [403, 318],
          [6, 197],
          [
            197,
            419
          ],
          [419, 6],
          [318, 319],
          [319, 325],
          [325, 318],
          [367, 364],
          [364, 365],
          [365, 367],
          [435, 367],
          [367, 397],
          [397, 435],
          [344, 438],
          [438, 439],
          [439, 344],
          [272, 271],
          [271, 311],
          [311, 272],
          [195, 5],
          [5, 281],
          [281, 195],
          [273, 287],
          [287, 291],
          [291, 273],
          [396, 428],
          [428, 199],
          [199, 396],
          [311, 271],
          [271, 268],
          [268, 311],
          [283, 444],
          [444, 445],
          [445, 283],
          [373, 254],
          [254, 339],
          [339, 373],
          [282, 334],
          [334, 296],
          [296, 282],
          [449, 347],
          [347, 346],
          [346, 449],
          [264, 447],
          [447, 454],
          [454, 264],
          [336, 296],
          [296, 299],
          [299, 336],
          [338, 10],
          [10, 151],
          [151, 338],
          [278, 439],
          [
            439,
            455
          ],
          [455, 278],
          [292, 407],
          [407, 415],
          [415, 292],
          [358, 371],
          [371, 355],
          [355, 358],
          [340, 345],
          [345, 372],
          [372, 340],
          [346, 347],
          [347, 280],
          [280, 346],
          [442, 443],
          [443, 282],
          [282, 442],
          [19, 94],
          [94, 370],
          [370, 19],
          [441, 442],
          [442, 295],
          [295, 441],
          [248, 419],
          [419, 197],
          [197, 248],
          [263, 255],
          [255, 359],
          [359, 263],
          [440, 275],
          [275, 274],
          [274, 440],
          [300, 383],
          [383, 368],
          [368, 300],
          [351, 412],
          [412, 465],
          [465, 351],
          [263, 467],
          [467, 466],
          [466, 263],
          [301, 368],
          [368, 389],
          [389, 301],
          [395, 378],
          [378, 379],
          [379, 395],
          [412, 351],
          [351, 419],
          [419, 412],
          [436, 426],
          [426, 322],
          [322, 436],
          [2, 164],
          [164, 393],
          [393, 2],
          [370, 462],
          [462, 461],
          [461, 370],
          [164, 0],
          [0, 267],
          [267, 164],
          [302, 11],
          [11, 12],
          [12, 302],
          [268, 12],
          [12, 13],
          [13, 268],
          [293, 300],
          [300, 301],
          [301, 293],
          [446, 261],
          [261, 340],
          [340, 446],
          [330, 266],
          [266, 425],
          [425, 330],
          [426, 423],
          [423, 391],
          [391, 426],
          [429, 355],
          [355, 437],
          [437, 429],
          [391, 327],
          [327, 326],
          [326, 391],
          [440, 457],
          [457, 438],
          [438, 440],
          [341, 382],
          [382, 362],
          [362, 341],
          [459, 457],
          [457, 461],
          [461, 459],
          [434, 430],
          [430, 394],
          [394, 434],
          [414, 463],
          [463, 362],
          [362, 414],
          [396, 369],
          [369, 262],
          [262, 396],
          [354, 461],
          [461, 457],
          [457, 354],
          [316, 403],
          [403, 402],
          [402, 316],
          [315, 404],
          [404, 403],
          [403, 315],
          [314, 405],
          [405, 404],
          [404, 314],
          [313, 406],
          [406, 405],
          [405, 313],
          [421, 418],
          [418, 406],
          [406, 421],
          [366, 401],
          [401, 361],
          [361, 366],
          [306, 408],
          [408, 407],
          [407, 306],
          [291, 409],
          [409, 408],
          [408, 291],
          [287, 410],
          [410, 409],
          [409, 287],
          [432, 436],
          [436, 410],
          [410, 432],
          [434, 416],
          [416, 411],
          [411, 434],
          [264, 368],
          [368, 383],
          [383, 264],
          [309, 438],
          [438, 457],
          [457, 309],
          [352, 376],
          [376, 401],
          [401, 352],
          [274, 275],
          [275, 4],
          [4, 274],
          [421, 428],
          [
            428,
            262
          ],
          [262, 421],
          [294, 327],
          [327, 358],
          [358, 294],
          [433, 416],
          [416, 367],
          [367, 433],
          [289, 455],
          [455, 439],
          [439, 289],
          [462, 370],
          [370, 326],
          [326, 462],
          [2, 326],
          [326, 370],
          [370, 2],
          [305, 460],
          [460, 455],
          [455, 305],
          [254, 449],
          [449, 448],
          [448, 254],
          [255, 261],
          [261, 446],
          [446, 255],
          [253, 450],
          [450, 449],
          [449, 253],
          [252, 451],
          [451, 450],
          [450, 252],
          [256, 452],
          [452, 451],
          [451, 256],
          [341, 453],
          [453, 452],
          [452, 341],
          [413, 464],
          [464, 463],
          [463, 413],
          [441, 413],
          [413, 414],
          [414, 441],
          [258, 442],
          [442, 441],
          [441, 258],
          [257, 443],
          [443, 442],
          [442, 257],
          [259, 444],
          [444, 443],
          [443, 259],
          [260, 445],
          [445, 444],
          [444, 260],
          [467, 342],
          [342, 445],
          [445, 467],
          [459, 458],
          [458, 250],
          [250, 459],
          [289, 392],
          [392, 290],
          [290, 289],
          [290, 328],
          [328, 460],
          [460, 290],
          [376, 433],
          [433, 435],
          [435, 376],
          [250, 290],
          [290, 392],
          [392, 250],
          [411, 416],
          [416, 433],
          [433, 411],
          [341, 463],
          [463, 464],
          [464, 341],
          [453, 464],
          [464, 465],
          [465, 453],
          [357, 465],
          [465, 412],
          [412, 357],
          [343, 412],
          [412, 399],
          [399, 343],
          [360, 363],
          [363, 440],
          [440, 360],
          [437, 399],
          [399, 456],
          [456, 437],
          [420, 456],
          [456, 363],
          [363, 420],
          [401, 435],
          [435, 288],
          [288, 401],
          [
            372,
            383
          ],
          [383, 353],
          [353, 372],
          [339, 255],
          [255, 249],
          [249, 339],
          [448, 261],
          [261, 255],
          [255, 448],
          [133, 243],
          [243, 190],
          [190, 133],
          [133, 155],
          [155, 112],
          [112, 133],
          [33, 246],
          [246, 247],
          [247, 33],
          [33, 130],
          [130, 25],
          [25, 33],
          [398, 384],
          [384, 286],
          [286, 398],
          [362, 398],
          [398, 414],
          [414, 362],
          [362, 463],
          [463, 341],
          [341, 362],
          [263, 359],
          [359, 467],
          [467, 263],
          [263, 249],
          [249, 255],
          [255, 263],
          [466, 467],
          [467, 260],
          [260, 466],
          [75, 60],
          [60, 166],
          [166, 75],
          [238, 239],
          [239, 79],
          [79, 238],
          [162, 127],
          [127, 139],
          [139, 162],
          [72, 11],
          [11, 37],
          [37, 72],
          [121, 232],
          [
            232,
            120
          ],
          [120, 121],
          [73, 72],
          [72, 39],
          [39, 73],
          [114, 128],
          [128, 47],
          [47, 114],
          [233, 232],
          [232, 128],
          [128, 233],
          [103, 104],
          [104, 67],
          [67, 103],
          [152, 175],
          [175, 148],
          [148, 152],
          [119, 118],
          [118, 101],
          [101, 119],
          [74, 73],
          [73, 40],
          [40, 74],
          [107, 9],
          [9, 108],
          [108, 107],
          [49, 48],
          [48, 131],
          [131, 49],
          [32, 194],
          [194, 211],
          [211, 32],
          [184, 74],
          [74, 185],
          [185, 184],
          [191, 80],
          [80, 183],
          [183, 191],
          [185, 40],
          [40, 186],
          [186, 185],
          [119, 230],
          [230, 118],
          [118, 119],
          [210, 202],
          [202, 214],
          [214, 210],
          [84, 83],
          [83, 17],
          [17, 84],
          [77, 76],
          [76, 146],
          [146, 77],
          [161, 160],
          [160, 30],
          [30, 161],
          [190, 56],
          [56, 173],
          [173, 190],
          [182, 106],
          [106, 194],
          [194, 182],
          [138, 135],
          [135, 192],
          [192, 138],
          [129, 203],
          [203, 98],
          [98, 129],
          [54, 21],
          [21, 68],
          [68, 54],
          [5, 51],
          [51, 4],
          [4, 5],
          [145, 144],
          [144, 23],
          [23, 145],
          [90, 77],
          [77, 91],
          [91, 90],
          [207, 205],
          [205, 187],
          [187, 207],
          [83, 201],
          [201, 18],
          [18, 83],
          [181, 91],
          [91, 182],
          [182, 181],
          [180, 90],
          [90, 181],
          [181, 180],
          [16, 85],
          [85, 17],
          [17, 16],
          [205, 206],
          [206, 36],
          [36, 205],
          [176, 148],
          [148, 140],
          [140, 176],
          [165, 92],
          [92, 39],
          [39, 165],
          [245, 193],
          [193, 244],
          [244, 245],
          [27, 159],
          [159, 28],
          [28, 27],
          [
            30,
            247
          ],
          [247, 161],
          [161, 30],
          [174, 236],
          [236, 196],
          [196, 174],
          [103, 54],
          [54, 104],
          [104, 103],
          [55, 193],
          [193, 8],
          [8, 55],
          [111, 117],
          [117, 31],
          [31, 111],
          [221, 189],
          [189, 55],
          [55, 221],
          [240, 98],
          [98, 99],
          [99, 240],
          [142, 126],
          [126, 100],
          [100, 142],
          [219, 166],
          [166, 218],
          [218, 219],
          [112, 155],
          [155, 26],
          [26, 112],
          [198, 209],
          [209, 131],
          [131, 198],
          [169, 135],
          [135, 150],
          [150, 169],
          [114, 47],
          [47, 217],
          [217, 114],
          [224, 223],
          [223, 53],
          [53, 224],
          [220, 45],
          [45, 134],
          [134, 220],
          [32, 211],
          [211, 140],
          [140, 32],
          [109, 67],
          [67, 108],
          [108, 109],
          [146, 43],
          [43, 91],
          [91, 146],
          [231, 230],
          [230, 120],
          [120, 231],
          [113, 226],
          [226, 247],
          [247, 113],
          [105, 63],
          [63, 52],
          [52, 105],
          [241, 238],
          [238, 242],
          [242, 241],
          [124, 46],
          [46, 156],
          [156, 124],
          [95, 78],
          [78, 96],
          [96, 95],
          [70, 46],
          [46, 63],
          [63, 70],
          [116, 143],
          [143, 227],
          [227, 116],
          [116, 123],
          [123, 111],
          [111, 116],
          [1, 44],
          [44, 19],
          [19, 1],
          [3, 236],
          [236, 51],
          [51, 3],
          [207, 216],
          [216, 205],
          [205, 207],
          [26, 154],
          [154, 22],
          [22, 26],
          [165, 39],
          [39, 167],
          [167, 165],
          [199, 200],
          [200, 208],
          [208, 199],
          [101, 36],
          [36, 100],
          [100, 101],
          [43, 57],
          [57, 202],
          [202, 43],
          [242, 20],
          [20, 99],
          [99, 242],
          [56, 28],
          [
            28,
            157
          ],
          [157, 56],
          [124, 35],
          [35, 113],
          [113, 124],
          [29, 160],
          [160, 27],
          [27, 29],
          [211, 204],
          [204, 210],
          [210, 211],
          [124, 113],
          [113, 46],
          [46, 124],
          [106, 43],
          [43, 204],
          [204, 106],
          [96, 62],
          [62, 77],
          [77, 96],
          [227, 137],
          [137, 116],
          [116, 227],
          [73, 41],
          [41, 72],
          [72, 73],
          [36, 203],
          [203, 142],
          [142, 36],
          [235, 64],
          [64, 240],
          [240, 235],
          [48, 49],
          [49, 64],
          [64, 48],
          [42, 41],
          [41, 74],
          [74, 42],
          [214, 212],
          [212, 207],
          [207, 214],
          [183, 42],
          [42, 184],
          [184, 183],
          [210, 169],
          [169, 211],
          [211, 210],
          [140, 170],
          [170, 176],
          [176, 140],
          [104, 105],
          [105, 69],
          [69, 104],
          [193, 122],
          [122, 168],
          [168, 193],
          [50, 123],
          [123, 187],
          [187, 50],
          [89, 96],
          [96, 90],
          [90, 89],
          [66, 65],
          [65, 107],
          [107, 66],
          [179, 89],
          [89, 180],
          [180, 179],
          [119, 101],
          [101, 120],
          [120, 119],
          [68, 63],
          [63, 104],
          [104, 68],
          [234, 93],
          [93, 227],
          [227, 234],
          [16, 15],
          [15, 85],
          [85, 16],
          [209, 129],
          [129, 49],
          [49, 209],
          [15, 14],
          [14, 86],
          [86, 15],
          [107, 55],
          [55, 9],
          [9, 107],
          [120, 100],
          [100, 121],
          [121, 120],
          [153, 145],
          [145, 22],
          [22, 153],
          [178, 88],
          [88, 179],
          [179, 178],
          [197, 6],
          [6, 196],
          [196, 197],
          [89, 88],
          [88, 96],
          [96, 89],
          [135, 138],
          [138, 136],
          [136, 135],
          [138, 215],
          [215, 172],
          [172, 138],
          [
            218,
            115
          ],
          [115, 219],
          [219, 218],
          [41, 42],
          [42, 81],
          [81, 41],
          [5, 195],
          [195, 51],
          [51, 5],
          [57, 43],
          [43, 61],
          [61, 57],
          [208, 171],
          [171, 199],
          [199, 208],
          [41, 81],
          [81, 38],
          [38, 41],
          [224, 53],
          [53, 225],
          [225, 224],
          [24, 144],
          [144, 110],
          [110, 24],
          [105, 52],
          [52, 66],
          [66, 105],
          [118, 229],
          [229, 117],
          [117, 118],
          [227, 34],
          [34, 234],
          [234, 227],
          [66, 107],
          [107, 69],
          [69, 66],
          [10, 109],
          [109, 151],
          [151, 10],
          [219, 48],
          [48, 235],
          [235, 219],
          [183, 62],
          [62, 191],
          [191, 183],
          [142, 129],
          [129, 126],
          [126, 142],
          [116, 111],
          [111, 143],
          [143, 116],
          [118, 117],
          [117, 50],
          [50, 118],
          [223, 222],
          [
            222,
            52
          ],
          [52, 223],
          [94, 19],
          [19, 141],
          [141, 94],
          [222, 221],
          [221, 65],
          [65, 222],
          [196, 3],
          [3, 197],
          [197, 196],
          [45, 220],
          [220, 44],
          [44, 45],
          [156, 70],
          [70, 139],
          [139, 156],
          [188, 122],
          [122, 245],
          [245, 188],
          [139, 71],
          [71, 162],
          [162, 139],
          [149, 170],
          [170, 150],
          [150, 149],
          [122, 188],
          [188, 196],
          [196, 122],
          [206, 216],
          [216, 92],
          [92, 206],
          [164, 2],
          [2, 167],
          [167, 164],
          [242, 141],
          [141, 241],
          [241, 242],
          [0, 164],
          [164, 37],
          [37, 0],
          [11, 72],
          [72, 12],
          [12, 11],
          [12, 38],
          [38, 13],
          [13, 12],
          [70, 63],
          [63, 71],
          [71, 70],
          [31, 226],
          [226, 111],
          [111, 31],
          [36, 101],
          [101, 205],
          [205, 36],
          [203, 206],
          [206, 165],
          [165, 203],
          [126, 209],
          [209, 217],
          [217, 126],
          [98, 165],
          [165, 97],
          [97, 98],
          [237, 220],
          [220, 218],
          [218, 237],
          [237, 239],
          [239, 241],
          [241, 237],
          [210, 214],
          [214, 169],
          [169, 210],
          [140, 171],
          [171, 32],
          [32, 140],
          [241, 125],
          [125, 237],
          [237, 241],
          [179, 86],
          [86, 178],
          [178, 179],
          [180, 85],
          [85, 179],
          [179, 180],
          [181, 84],
          [84, 180],
          [180, 181],
          [182, 83],
          [83, 181],
          [181, 182],
          [194, 201],
          [201, 182],
          [182, 194],
          [177, 137],
          [137, 132],
          [132, 177],
          [184, 76],
          [76, 183],
          [183, 184],
          [185, 61],
          [61, 184],
          [184, 185],
          [186, 57],
          [57, 185],
          [185, 186],
          [216, 212],
          [
            212,
            186
          ],
          [186, 216],
          [192, 214],
          [214, 187],
          [187, 192],
          [139, 34],
          [34, 156],
          [156, 139],
          [218, 79],
          [79, 237],
          [237, 218],
          [147, 123],
          [123, 177],
          [177, 147],
          [45, 44],
          [44, 4],
          [4, 45],
          [208, 201],
          [201, 32],
          [32, 208],
          [98, 64],
          [64, 129],
          [129, 98],
          [192, 213],
          [213, 138],
          [138, 192],
          [235, 59],
          [59, 219],
          [219, 235],
          [141, 242],
          [242, 97],
          [97, 141],
          [97, 2],
          [2, 141],
          [141, 97],
          [240, 75],
          [75, 235],
          [235, 240],
          [229, 24],
          [24, 228],
          [228, 229],
          [31, 25],
          [25, 226],
          [226, 31],
          [230, 23],
          [23, 229],
          [229, 230],
          [231, 22],
          [22, 230],
          [230, 231],
          [232, 26],
          [26, 231],
          [231, 232],
          [233, 112],
          [112, 232],
          [232, 233],
          [244, 189],
          [189, 243],
          [243, 244],
          [189, 221],
          [221, 190],
          [190, 189],
          [222, 28],
          [28, 221],
          [221, 222],
          [223, 27],
          [27, 222],
          [222, 223],
          [224, 29],
          [29, 223],
          [223, 224],
          [225, 30],
          [30, 224],
          [224, 225],
          [113, 247],
          [247, 225],
          [225, 113],
          [99, 60],
          [60, 240],
          [240, 99],
          [213, 147],
          [147, 215],
          [215, 213],
          [60, 20],
          [20, 166],
          [166, 60],
          [192, 187],
          [187, 213],
          [213, 192],
          [243, 112],
          [112, 244],
          [244, 243],
          [244, 233],
          [233, 245],
          [245, 244],
          [245, 128],
          [128, 188],
          [188, 245],
          [188, 114],
          [114, 174],
          [174, 188],
          [134, 131],
          [131, 220],
          [220, 134],
          [174, 217],
          [217, 236],
          [236, 174],
          [236, 198],
          [198, 134],
          [134, 236],
          [215, 177],
          [177, 58],
          [58, 215],
          [156, 143],
          [143, 124],
          [124, 156],
          [25, 110],
          [110, 7],
          [7, 25],
          [31, 228],
          [228, 25],
          [25, 31],
          [264, 356],
          [356, 368],
          [368, 264],
          [0, 11],
          [11, 267],
          [267, 0],
          [451, 452],
          [452, 349],
          [349, 451],
          [267, 302],
          [302, 269],
          [269, 267],
          [350, 357],
          [357, 277],
          [277, 350],
          [350, 452],
          [452, 357],
          [357, 350],
          [299, 333],
          [333, 297],
          [297, 299],
          [396, 175],
          [175, 377],
          [377, 396],
          [280, 347],
          [347, 330],
          [330, 280],
          [269, 303],
          [303, 270],
          [270, 269],
          [151, 9],
          [9, 337],
          [337, 151],
          [344, 278],
          [278, 360],
          [360, 344],
          [424, 418],
          [
            418,
            431
          ],
          [431, 424],
          [270, 304],
          [304, 409],
          [409, 270],
          [272, 310],
          [310, 407],
          [407, 272],
          [322, 270],
          [270, 410],
          [410, 322],
          [449, 450],
          [450, 347],
          [347, 449],
          [432, 422],
          [422, 434],
          [434, 432],
          [18, 313],
          [313, 17],
          [17, 18],
          [291, 306],
          [306, 375],
          [375, 291],
          [259, 387],
          [387, 260],
          [260, 259],
          [424, 335],
          [335, 418],
          [418, 424],
          [434, 364],
          [364, 416],
          [416, 434],
          [391, 423],
          [423, 327],
          [327, 391],
          [301, 251],
          [251, 298],
          [298, 301],
          [275, 281],
          [281, 4],
          [4, 275],
          [254, 373],
          [373, 253],
          [253, 254],
          [375, 307],
          [307, 321],
          [321, 375],
          [280, 425],
          [425, 411],
          [411, 280],
          [200, 421],
          [
            421,
            18
          ],
          [18, 200],
          [335, 321],
          [321, 406],
          [406, 335],
          [321, 320],
          [320, 405],
          [405, 321],
          [314, 315],
          [315, 17],
          [17, 314],
          [423, 426],
          [426, 266],
          [266, 423],
          [396, 377],
          [377, 369],
          [369, 396],
          [270, 322],
          [322, 269],
          [269, 270],
          [413, 417],
          [417, 464],
          [464, 413],
          [385, 386],
          [386, 258],
          [258, 385],
          [248, 456],
          [456, 419],
          [419, 248],
          [298, 284],
          [284, 333],
          [333, 298],
          [168, 417],
          [417, 8],
          [8, 168],
          [448, 346],
          [346, 261],
          [261, 448],
          [417, 413],
          [413, 285],
          [285, 417],
          [326, 327],
          [327, 328],
          [328, 326],
          [277, 355],
          [355, 329],
          [329, 277],
          [309, 392],
          [392, 438],
          [438, 309],
          [381, 382],
          [
            382,
            256
          ],
          [256, 381],
          [279, 429],
          [429, 360],
          [360, 279],
          [365, 364],
          [364, 379],
          [379, 365],
          [355, 277],
          [277, 437],
          [437, 355],
          [282, 443],
          [443, 283],
          [283, 282],
          [281, 275],
          [275, 363],
          [363, 281],
          [395, 431],
          [431, 369],
          [369, 395],
          [299, 297],
          [297, 337],
          [337, 299],
          [335, 273],
          [273, 321],
          [321, 335],
          [348, 450],
          [450, 349],
          [349, 348],
          [359, 446],
          [446, 467],
          [467, 359],
          [283, 293],
          [293, 282],
          [282, 283],
          [250, 458],
          [458, 462],
          [462, 250],
          [300, 276],
          [276, 383],
          [383, 300],
          [292, 308],
          [308, 325],
          [325, 292],
          [283, 276],
          [276, 293],
          [293, 283],
          [264, 372],
          [372, 447],
          [447, 264],
          [346, 352],
          [352, 340],
          [340, 346],
          [354, 274],
          [274, 19],
          [19, 354],
          [363, 456],
          [456, 281],
          [281, 363],
          [426, 436],
          [436, 425],
          [425, 426],
          [380, 381],
          [381, 252],
          [252, 380],
          [267, 269],
          [269, 393],
          [393, 267],
          [421, 200],
          [200, 428],
          [428, 421],
          [371, 266],
          [266, 329],
          [329, 371],
          [432, 287],
          [287, 422],
          [422, 432],
          [290, 250],
          [250, 328],
          [328, 290],
          [385, 258],
          [258, 384],
          [384, 385],
          [446, 265],
          [265, 342],
          [342, 446],
          [386, 387],
          [387, 257],
          [257, 386],
          [422, 424],
          [424, 430],
          [430, 422],
          [445, 342],
          [342, 276],
          [276, 445],
          [422, 273],
          [273, 424],
          [424, 422],
          [306, 292],
          [292, 307],
          [307, 306],
          [
            352,
            366
          ],
          [366, 345],
          [345, 352],
          [268, 271],
          [271, 302],
          [302, 268],
          [358, 423],
          [423, 371],
          [371, 358],
          [327, 294],
          [294, 460],
          [460, 327],
          [331, 279],
          [279, 294],
          [294, 331],
          [303, 271],
          [271, 304],
          [304, 303],
          [436, 432],
          [432, 427],
          [427, 436],
          [304, 272],
          [272, 408],
          [408, 304],
          [395, 394],
          [394, 431],
          [431, 395],
          [378, 395],
          [395, 400],
          [400, 378],
          [296, 334],
          [334, 299],
          [299, 296],
          [6, 351],
          [351, 168],
          [168, 6],
          [376, 352],
          [352, 411],
          [411, 376],
          [307, 325],
          [325, 320],
          [320, 307],
          [285, 295],
          [295, 336],
          [336, 285],
          [320, 319],
          [319, 404],
          [404, 320],
          [329, 330],
          [330, 349],
          [349, 329],
          [334, 293],
          [293, 333],
          [333, 334],
          [366, 323],
          [323, 447],
          [447, 366],
          [316, 15],
          [15, 315],
          [315, 316],
          [331, 358],
          [358, 279],
          [279, 331],
          [317, 14],
          [14, 316],
          [316, 317],
          [8, 285],
          [285, 9],
          [9, 8],
          [277, 329],
          [329, 350],
          [350, 277],
          [253, 374],
          [374, 252],
          [252, 253],
          [319, 318],
          [318, 403],
          [403, 319],
          [351, 6],
          [6, 419],
          [419, 351],
          [324, 318],
          [318, 325],
          [325, 324],
          [397, 367],
          [367, 365],
          [365, 397],
          [288, 435],
          [435, 397],
          [397, 288],
          [278, 344],
          [344, 439],
          [439, 278],
          [310, 272],
          [272, 311],
          [311, 310],
          [248, 195],
          [195, 281],
          [281, 248],
          [375, 273],
          [273, 291],
          [291, 375],
          [175, 396],
          [396, 199],
          [199, 175],
          [312, 311],
          [311, 268],
          [268, 312],
          [276, 283],
          [283, 445],
          [445, 276],
          [390, 373],
          [373, 339],
          [339, 390],
          [295, 282],
          [282, 296],
          [296, 295],
          [448, 449],
          [449, 346],
          [346, 448],
          [356, 264],
          [264, 454],
          [454, 356],
          [337, 336],
          [336, 299],
          [299, 337],
          [337, 338],
          [338, 151],
          [151, 337],
          [294, 278],
          [278, 455],
          [455, 294],
          [308, 292],
          [292, 415],
          [415, 308],
          [429, 358],
          [358, 355],
          [355, 429],
          [265, 340],
          [340, 372],
          [372, 265],
          [352, 346],
          [346, 280],
          [280, 352],
          [295, 442],
          [442, 282],
          [282, 295],
          [354, 19],
          [19, 370],
          [370, 354],
          [285, 441],
          [441, 295],
          [295, 285],
          [
            195,
            248
          ],
          [248, 197],
          [197, 195],
          [457, 440],
          [440, 274],
          [274, 457],
          [301, 300],
          [300, 368],
          [368, 301],
          [417, 351],
          [351, 465],
          [465, 417],
          [251, 301],
          [301, 389],
          [389, 251],
          [394, 395],
          [395, 379],
          [379, 394],
          [399, 412],
          [412, 419],
          [419, 399],
          [410, 436],
          [436, 322],
          [322, 410],
          [326, 2],
          [2, 393],
          [393, 326],
          [354, 370],
          [370, 461],
          [461, 354],
          [393, 164],
          [164, 267],
          [267, 393],
          [268, 302],
          [302, 12],
          [12, 268],
          [312, 268],
          [268, 13],
          [13, 312],
          [298, 293],
          [293, 301],
          [301, 298],
          [265, 446],
          [446, 340],
          [340, 265],
          [280, 330],
          [330, 425],
          [425, 280],
          [322, 426],
          [426, 391],
          [391, 322],
          [
            420,
            429
          ],
          [429, 437],
          [437, 420],
          [393, 391],
          [391, 326],
          [326, 393],
          [344, 440],
          [440, 438],
          [438, 344],
          [458, 459],
          [459, 461],
          [461, 458],
          [364, 434],
          [434, 394],
          [394, 364],
          [428, 396],
          [396, 262],
          [262, 428],
          [274, 354],
          [354, 457],
          [457, 274],
          [317, 316],
          [316, 402],
          [402, 317],
          [316, 315],
          [315, 403],
          [403, 316],
          [315, 314],
          [314, 404],
          [404, 315],
          [314, 313],
          [313, 405],
          [405, 314],
          [313, 421],
          [421, 406],
          [406, 313],
          [323, 366],
          [366, 361],
          [361, 323],
          [292, 306],
          [306, 407],
          [407, 292],
          [306, 291],
          [291, 408],
          [408, 306],
          [291, 287],
          [287, 409],
          [409, 291],
          [287, 432],
          [432, 410],
          [410, 287],
          [427, 434],
          [434, 411],
          [411, 427],
          [372, 264],
          [264, 383],
          [383, 372],
          [459, 309],
          [309, 457],
          [457, 459],
          [366, 352],
          [352, 401],
          [401, 366],
          [1, 274],
          [274, 4],
          [4, 1],
          [418, 421],
          [421, 262],
          [262, 418],
          [331, 294],
          [294, 358],
          [358, 331],
          [435, 433],
          [433, 367],
          [367, 435],
          [392, 289],
          [289, 439],
          [439, 392],
          [328, 462],
          [462, 326],
          [326, 328],
          [94, 2],
          [2, 370],
          [370, 94],
          [289, 305],
          [305, 455],
          [455, 289],
          [339, 254],
          [254, 448],
          [448, 339],
          [359, 255],
          [255, 446],
          [446, 359],
          [254, 253],
          [253, 449],
          [449, 254],
          [253, 252],
          [252, 450],
          [450, 253],
          [252, 256],
          [256, 451],
          [451, 252],
          [
            256,
            341
          ],
          [341, 452],
          [452, 256],
          [414, 413],
          [413, 463],
          [463, 414],
          [286, 441],
          [441, 414],
          [414, 286],
          [286, 258],
          [258, 441],
          [441, 286],
          [258, 257],
          [257, 442],
          [442, 258],
          [257, 259],
          [259, 443],
          [443, 257],
          [259, 260],
          [260, 444],
          [444, 259],
          [260, 467],
          [467, 445],
          [445, 260],
          [309, 459],
          [459, 250],
          [250, 309],
          [305, 289],
          [289, 290],
          [290, 305],
          [305, 290],
          [290, 460],
          [460, 305],
          [401, 376],
          [376, 435],
          [435, 401],
          [309, 250],
          [250, 392],
          [392, 309],
          [376, 411],
          [411, 433],
          [433, 376],
          [453, 341],
          [341, 464],
          [464, 453],
          [357, 453],
          [453, 465],
          [465, 357],
          [343, 357],
          [357, 412],
          [412, 343],
          [437, 343],
          [343, 399],
          [399, 437],
          [344, 360],
          [360, 440],
          [440, 344],
          [420, 437],
          [437, 456],
          [456, 420],
          [360, 420],
          [420, 363],
          [363, 360],
          [361, 401],
          [401, 288],
          [288, 361],
          [265, 372],
          [372, 353],
          [353, 265],
          [390, 339],
          [339, 249],
          [249, 390],
          [339, 448],
          [448, 255],
          [255, 339]
        ]);
        P3("matrixDataToMatrix", function(a2) {
          for (var b2 = a2.getCols(), c2 = a2.getRows(), d2 = a2.getPackedDataList(), e2 = [], g2 = 0; g2 < c2; g2++)
            e2.push(Array(b2));
          for (g2 = 0; g2 < c2; g2++)
            for (var f2 = 0; f2 < b2; f2++) {
              var h = 1 === a2.getLayout() ? g2 * b2 + f2 : f2 * c2 + g2;
              e2[g2][f2] = d2[h];
            }
          return e2;
        });
        P3("VERSION", "0.4.1633559619");
      }).call(exports);
    }
  });

  // node_modules/@tensorflow/tfjs/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js
  var t = function(e2, n2) {
    return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var n3 in e3)
        e3.hasOwnProperty(n3) && (t3[n3] = e3[n3]);
    })(e2, n2);
  };
  function e(e2, n2) {
    function r2() {
      this.constructor = e2;
    }
    t(e2, n2), e2.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
  }
  function n(t3, e2, n2, r2) {
    return new (n2 || (n2 = Promise))(function(o2, a2) {
      function i2(t4) {
        try {
          s2(r2.next(t4));
        } catch (t5) {
          a2(t5);
        }
      }
      function u2(t4) {
        try {
          s2(r2.throw(t4));
        } catch (t5) {
          a2(t5);
        }
      }
      function s2(t4) {
        t4.done ? o2(t4.value) : new n2(function(e3) {
          e3(t4.value);
        }).then(i2, u2);
      }
      s2((r2 = r2.apply(t3, e2 || [])).next());
    });
  }
  function r(t3, e2) {
    var n2, r2, o2, a2, i2 = { label: 0, sent: function() {
      if (1 & o2[0])
        throw o2[1];
      return o2[1];
    }, trys: [], ops: [] };
    return a2 = { next: u2(0), throw: u2(1), return: u2(2) }, "function" == typeof Symbol && (a2[Symbol.iterator] = function() {
      return this;
    }), a2;
    function u2(a3) {
      return function(u3) {
        return function(a4) {
          if (n2)
            throw new TypeError("Generator is already executing.");
          for (; i2; )
            try {
              if (n2 = 1, r2 && (o2 = 2 & a4[0] ? r2.return : a4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, a4[1])).done)
                return o2;
              switch (r2 = 0, o2 && (a4 = [2 & a4[0], o2.value]), a4[0]) {
                case 0:
                case 1:
                  o2 = a4;
                  break;
                case 4:
                  return i2.label++, { value: a4[1], done: false };
                case 5:
                  i2.label++, r2 = a4[1], a4 = [0];
                  continue;
                case 7:
                  a4 = i2.ops.pop(), i2.trys.pop();
                  continue;
                default:
                  if (!(o2 = (o2 = i2.trys).length > 0 && o2[o2.length - 1]) && (6 === a4[0] || 2 === a4[0])) {
                    i2 = 0;
                    continue;
                  }
                  if (3 === a4[0] && (!o2 || a4[1] > o2[0] && a4[1] < o2[3])) {
                    i2.label = a4[1];
                    break;
                  }
                  if (6 === a4[0] && i2.label < o2[1]) {
                    i2.label = o2[1], o2 = a4;
                    break;
                  }
                  if (o2 && i2.label < o2[2]) {
                    i2.label = o2[2], i2.ops.push(a4);
                    break;
                  }
                  o2[2] && i2.ops.pop(), i2.trys.pop();
                  continue;
              }
              a4 = e2.call(t3, i2);
            } catch (t4) {
              a4 = [6, t4], r2 = 0;
            } finally {
              n2 = o2 = 0;
            }
          if (5 & a4[0])
            throw a4[1];
          return { value: a4[0] ? a4[1] : void 0, done: true };
        }([a3, u3]);
      };
    }
  }
  var o = function() {
    function t3(t4) {
      this.global = t4, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();
    }
    return t3.prototype.setPlatform = function(t4, e2) {
      null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e2 + "."), this.platformName = t4, this.platform = e2;
    }, t3.prototype.registerFlag = function(t4, e2, n2) {
      if (this.flagRegistry[t4] = { evaluationFn: e2, setHook: n2 }, null != this.urlFlags[t4]) {
        var r2 = this.urlFlags[t4];
        console.warn("Setting feature override from URL " + t4 + ": " + r2 + "."), this.set(t4, r2);
      }
    }, t3.prototype.get = function(t4) {
      return t4 in this.flags ? this.flags[t4] : (this.flags[t4] = this.evaluateFlag(t4), this.flags[t4]);
    }, t3.prototype.getNumber = function(t4) {
      return this.get(t4);
    }, t3.prototype.getBool = function(t4) {
      return this.get(t4);
    }, t3.prototype.getFlags = function() {
      return this.flags;
    }, Object.defineProperty(t3.prototype, "features", { get: function() {
      return this.flags;
    }, enumerable: true, configurable: true }), t3.prototype.set = function(t4, e2) {
      if (null == this.flagRegistry[t4])
        throw new Error("Cannot set flag " + t4 + " as it has not been registered.");
      this.flags[t4] = e2, null != this.flagRegistry[t4].setHook && this.flagRegistry[t4].setHook(e2);
    }, t3.prototype.evaluateFlag = function(t4) {
      if (null == this.flagRegistry[t4])
        throw new Error("Cannot evaluate flag '" + t4 + "': no evaluation function found.");
      return this.flagRegistry[t4].evaluationFn();
    }, t3.prototype.setFlags = function(t4) {
      this.flags = Object.assign({}, t4);
    }, t3.prototype.reset = function() {
      this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
    }, t3.prototype.populateURLFlags = function() {
      var t4 = this;
      if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
        var e2, n2, r2 = (e2 = this.global.location.search, n2 = {}, e2.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(t5) {
          for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
            e3[r3 - 1] = arguments[r3];
          return function(t6, e4, n3) {
            t6[decodeURIComponent(e4)] = decodeURIComponent(n3 || "");
          }(n2, e3[0], e3[1]), e3.join("=");
        }), n2);
        if ("tfjsflags" in r2)
          r2.tfjsflags.split(",").forEach(function(e3) {
            var n3 = e3.split(":"), r3 = n3[0], o2 = n3[1];
            t4.urlFlags[r3] = function(t5, e4) {
              if ("true" === (e4 = e4.toLowerCase()) || "false" === e4)
                return "true" === e4;
              if ("" + +e4 === e4)
                return +e4;
              throw new Error("Could not parse value flag value " + e4 + " for flag " + t5 + ".");
            }(r3, o2);
          });
      }
    }, t3;
  }();
  function a() {
    return i;
  }
  var i = null;
  var u = /* @__PURE__ */ new Map();
  function s(t3, e2) {
    var n2 = f(t3, e2);
    return u.get(n2);
  }
  function c(t3) {
    for (var e2 = u.entries(), n2 = []; ; ) {
      var r2 = e2.next(), o2 = r2.done, a2 = r2.value;
      if (o2)
        break;
      var i2 = a2[0], s2 = a2[1];
      i2.split("_")[0] === t3 && n2.push(s2);
    }
    return n2;
  }
  function l(t3) {
    var e2 = t3.kernelName, n2 = t3.backendName, r2 = f(e2, n2);
    if (u.has(r2))
      throw new Error("The kernel '" + e2 + "' for backend '" + n2 + "' is already registered");
    u.set(r2, t3);
  }
  function f(t3, e2) {
    return e2 + "_" + t3;
  }
  function p(t3) {
    for (var e2 = t3.length, n2 = 0, r2 = 0; e2 > 0; )
      r2 = Math.random() * e2 | 0, n2 = t3[--e2], t3[e2] = t3[r2], t3[r2] = n2;
  }
  function d(t3, e2, n2) {
    return Math.max(t3, Math.min(e2, n2));
  }
  function v(t3) {
    return t3 % 2 == 0 ? t3 : t3 + 1;
  }
  function m(t3) {
    for (var e2 = 0, n2 = 0; n2 < t3.length; n2++)
      e2 += t3[n2];
    return e2;
  }
  function g(t3, e2) {
    if (!t3)
      throw new Error("string" == typeof e2 ? e2 : e2());
  }
  function y(t3, e2, n2) {
    void 0 === n2 && (n2 = ""), g(C(t3, e2), function() {
      return n2 + " Shapes " + t3 + " and " + e2 + " must match";
    });
  }
  function x(t3) {
    g(null != t3, function() {
      return "The input to the tensor constructor must be a non-null value.";
    });
  }
  function b(t3, e2, n2) {
    if (void 0 === e2 && (e2 = []), void 0 === n2 && (n2 = false), null == e2 && (e2 = []), Array.isArray(t3) || B(t3) && !n2)
      for (var r2 = 0; r2 < t3.length; ++r2)
        b(t3[r2], e2, n2);
    else
      e2.push(t3);
    return e2;
  }
  function w(t3) {
    if (0 === t3.length)
      return 1;
    for (var e2 = t3[0], n2 = 1; n2 < t3.length; n2++)
      e2 *= t3[n2];
    return e2;
  }
  function C(t3, e2) {
    if (t3 === e2)
      return true;
    if (null == t3 || null == e2)
      return false;
    if (t3.length !== e2.length)
      return false;
    for (var n2 = 0; n2 < t3.length; n2++)
      if (t3[n2] !== e2[n2])
        return false;
    return true;
  }
  function E(t3) {
    return t3 % 1 == 0;
  }
  function R(t3) {
    if (null != Math.tanh)
      return Math.tanh(t3);
    if (t3 === 1 / 0)
      return 1;
    if (t3 === -1 / 0)
      return -1;
    var e2 = Math.exp(2 * t3);
    return (e2 - 1) / (e2 + 1);
  }
  function I(t3) {
    var e2 = Math.ceil(Math.sqrt(t3));
    return [e2, Math.ceil(t3 / e2)];
  }
  function k(t3, e2) {
    return e2 <= t3.length ? t3 : t3 + " ".repeat(e2 - t3.length);
  }
  function S(t3, e2, n2) {
    return void 0 === e2 && (e2 = function(t4) {
      return 0;
    }), new Promise(function(r2, o2) {
      var a2 = 0, i2 = function() {
        if (t3())
          r2();
        else {
          var u2 = e2(++a2);
          null != n2 && a2 >= n2 ? o2() : setTimeout(i2, u2);
        }
      };
      i2();
    });
  }
  function A(t3, e2) {
    for (var n2 = 1, r2 = -1, o2 = 0; o2 < t3.length; ++o2)
      if (t3[o2] >= 0)
        n2 *= t3[o2];
      else if (-1 === t3[o2]) {
        if (-1 !== r2)
          throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r2 + " and dim " + o2);
        r2 = o2;
      } else if (t3[o2] < 0)
        throw Error("Shapes can not be < 0. Found " + t3[o2] + " at dim " + o2);
    if (-1 === r2) {
      if (e2 > 0 && e2 !== n2)
        throw Error("Size(" + e2 + ") must match the product of shape " + t3);
      return t3;
    }
    if (0 === n2)
      throw Error("Cannot infer the missing size in [" + t3 + "] when there are 0 elements");
    if (e2 % n2 != 0)
      throw Error("The implicit shape can't be a fractional number. Got " + e2 + " / " + n2);
    var a2 = t3.slice();
    return a2[r2] = e2 / n2, a2;
  }
  function D(t3, e2) {
    var n2 = e2.length;
    return g((t3 = null == t3 ? e2.map(function(t4, e3) {
      return e3;
    }) : [].concat(t3)).every(function(t4) {
      return t4 >= -n2 && t4 < n2;
    }), function() {
      return "All values in axis param must be in range [-" + n2 + ", " + n2 + ") but got axis " + t3;
    }), g(t3.every(function(t4) {
      return E(t4);
    }), function() {
      return "All values in axis param must be integers but got axis " + t3;
    }), t3.map(function(t4) {
      return t4 < 0 ? n2 + t4 : t4;
    });
  }
  function T(t3, e2) {
    for (var n2 = [], r2 = [], o2 = null != e2 && Array.isArray(e2) && 0 === e2.length, a2 = null == e2 || o2 ? null : D(e2, t3).sort(), i2 = 0, u2 = 0; u2 < t3.length; ++u2) {
      if (null != a2) {
        if (a2[i2] === u2 && 1 !== t3[u2])
          throw new Error("Can't squeeze axis " + u2 + " since its dim '" + t3[u2] + "' is not 1");
        (null == a2[i2] || a2[i2] > u2) && 1 === t3[u2] && (n2.push(t3[u2]), r2.push(u2)), a2[i2] <= u2 && i2++;
      }
      1 !== t3[u2] && (n2.push(t3[u2]), r2.push(u2));
    }
    return { newShape: n2, keptDims: r2 };
  }
  function N(t3, e2) {
    var n2 = null;
    if (null == t3 || "float32" === t3)
      n2 = new Float32Array(e2);
    else if ("int32" === t3)
      n2 = new Int32Array(e2);
    else {
      if ("bool" !== t3)
        throw new Error("Unknown data type " + t3);
      n2 = new Uint8Array(e2);
    }
    return n2;
  }
  function F(t3, e2) {
    var n2 = null;
    if (null == t3 || "float32" === t3)
      n2 = new Float32Array(e2);
    else if ("int32" === t3)
      n2 = new Int32Array(e2);
    else if ("bool" === t3)
      n2 = new Uint8Array(e2);
    else {
      if ("string" !== t3)
        throw new Error("Unknown data type " + t3);
      n2 = new Array(e2);
    }
    return n2;
  }
  function O(t3, e2) {
    for (var n2 = 0; n2 < t3.length; n2++) {
      var r2 = t3[n2];
      if (isNaN(r2) || !isFinite(r2))
        throw Error("A tensor of type " + e2 + " being uploaded contains " + r2 + ".");
    }
  }
  function _(t3) {
    return "bool" === t3 || "complex64" === t3 || "float32" === t3 || "int32" === t3 || "string" === t3;
  }
  function M(t3, e2) {
    return "complex64" !== e2 && (("float32" !== e2 || "complex64" === t3) && (("int32" !== e2 || "float32" === t3 || "complex64" === t3) && ("bool" !== e2 || "bool" !== t3)));
  }
  function B(t3) {
    return t3 instanceof Float32Array || t3 instanceof Int32Array || t3 instanceof Uint8Array;
  }
  function P(t3) {
    if ("float32" === t3 || "int32" === t3)
      return 4;
    if ("complex64" === t3)
      return 8;
    if ("bool" === t3)
      return 1;
    throw new Error("Unknown dtype " + t3);
  }
  function L(t3) {
    if (null == t3)
      return 0;
    var e2 = 0;
    return t3.forEach(function(t4) {
      return e2 += t4.length;
    }), e2;
  }
  function W(t3) {
    return "string" == typeof t3 || t3 instanceof String;
  }
  function U(t3) {
    return "boolean" == typeof t3;
  }
  function V(t3) {
    return "number" == typeof t3;
  }
  function z(t3) {
    return Array.isArray(t3) ? z(t3[0]) : t3 instanceof Float32Array ? "float32" : t3 instanceof Int32Array || t3 instanceof Uint8Array ? "int32" : V(t3) ? "float32" : W(t3) ? "string" : U(t3) ? "bool" : "float32";
  }
  function G(t3) {
    return !!(t3 && t3.constructor && t3.call && t3.apply);
  }
  function H(t3, e2) {
    for (var n2 = e2; n2 < t3; ++n2)
      if (t3 % n2 == 0)
        return n2;
    return t3;
  }
  function q(t3) {
    var e2 = t3.length;
    if (e2 < 2)
      return [];
    var n2 = new Array(e2 - 1);
    n2[e2 - 2] = t3[e2 - 1];
    for (var r2 = e2 - 3; r2 >= 0; --r2)
      n2[r2] = n2[r2 + 1] * t3[r2 + 1];
    return n2;
  }
  function K(t3, e2, n2) {
    if ("string" === e2)
      throw new Error("Cannot convert a string[] to a TypedArray");
    if (Array.isArray(t3) && (t3 = b(t3)), n2 && O(t3, e2), function(t4, e3) {
      return t4 instanceof Float32Array && "float32" === e3 || t4 instanceof Int32Array && "int32" === e3 || t4 instanceof Uint8Array && "bool" === e3;
    }(t3, e2))
      return t3;
    if (null == e2 || "float32" === e2 || "complex64" === e2)
      return new Float32Array(t3);
    if ("int32" === e2)
      return new Int32Array(t3);
    if ("bool" === e2) {
      for (var r2 = new Uint8Array(t3.length), o2 = 0; o2 < r2.length; ++o2)
        0 !== Math.round(t3[o2]) && (r2[o2] = 1);
      return r2;
    }
    throw new Error("Unknown data type " + e2);
  }
  function j(t3, e2) {
    if (0 === t3.length)
      return e2[0];
    var n2 = t3.reduce(function(t4, e3) {
      return t4 * e3;
    });
    if (0 === n2)
      return [];
    if (n2 !== e2.length)
      throw new Error("[" + t3 + "] does not match the input size.");
    return function t4(e3, n3, r2) {
      var o2 = new Array();
      if (1 === n3.length)
        for (var a2 = n3[0], i2 = 0; i2 < a2; i2++)
          o2[i2] = r2[e3 + i2];
      else {
        a2 = n3[0];
        var u2 = n3.slice(1), s2 = u2.reduce(function(t5, e4) {
          return t5 * e4;
        });
        for (i2 = 0; i2 < a2; i2++)
          o2[i2] = t4(e3 + i2 * s2, u2, r2);
      }
      return o2;
    }(0, t3, e2);
  }
  function X(t3, e2) {
    for (var n2 = $(t3, e2), r2 = 0; r2 < n2.length; r2++)
      n2[r2] = 1;
    return n2;
  }
  function $(t3, e2) {
    if (null == e2 || "float32" === e2 || "complex64" === e2)
      return new Float32Array(t3);
    if ("int32" === e2)
      return new Int32Array(t3);
    if ("bool" === e2)
      return new Uint8Array(t3);
    throw new Error("Unknown data type " + e2);
  }
  function Y() {
    return a().platform.now();
  }
  function Q(t3) {
    t3.forEach(function(e2) {
      g(Number.isInteger(e2) && e2 >= 0, function() {
        return "Tensor must have a shape comprised of positive integers but got shape [" + t3 + "].";
      });
    });
  }
  function J(t3, e2) {
    return void 0 === e2 && (e2 = "utf-8"), e2 = e2 || "utf-8", a().platform.encode(t3, e2);
  }
  function Z(t3, e2) {
    return void 0 === e2 && (e2 = "utf-8"), e2 = e2 || "utf-8", a().platform.decode(t3, e2);
  }
  var tt = Object.freeze({ shuffle: p, clamp: d, nearestLargerEven: v, sum: m, randUniform: function(t3, e2) {
    var n2 = Math.random();
    return e2 * n2 + (1 - n2) * t3;
  }, distSquared: function(t3, e2) {
    for (var n2 = 0, r2 = 0; r2 < t3.length; r2++) {
      var o2 = Number(t3[r2]) - Number(e2[r2]);
      n2 += o2 * o2;
    }
    return n2;
  }, assert: g, assertShapesMatch: y, assertNonNull: x, flatten: b, sizeFromShape: w, isScalarShape: function(t3) {
    return 0 === t3.length;
  }, arraysEqual: C, isInt: E, tanh: R, sizeToSquarishShape: I, createShuffledIndices: function(t3) {
    for (var e2 = new Uint32Array(t3), n2 = 0; n2 < t3; ++n2)
      e2[n2] = n2;
    return p(e2), e2;
  }, rightPad: k, repeatedTry: S, inferFromImplicitShape: A, parseAxisParam: D, squeezeShape: T, getTypedArrayFromDType: N, getArrayFromDType: F, checkConversionForErrors: O, isValidDtype: _, hasEncodingLoss: M, isTypedArray: B, bytesPerElement: P, bytesFromStringArray: L, isString: W, isBoolean: U, isNumber: V, inferDtype: z, isFunction: G, nearestDivisor: H, computeStrides: q, toTypedArray: K, toNestedArray: j, makeOnesTypedArray: X, makeZerosTypedArray: $, now: Y, assertNonNegativeIntegerDimensions: Q, fetch: function(t3, e2) {
    return a().platform.fetch(t3, e2);
  }, encodeString: J, decodeString: Z });
  var et = function() {
    function t3(t4, e2) {
      this.backendTimer = t4, this.logger = e2, null == e2 && (this.logger = new nt());
    }
    return t3.prototype.profileKernel = function(t4, e2, n2) {
      var r2, o2 = this, a2 = this.backendTimer.time(function() {
        r2 = n2();
      });
      return r2.forEach(function(n3) {
        n3.data().then(function(r3) {
          !function(t5, e3, n4) {
            if ("float32" !== e3)
              return false;
            for (var r4 = 0; r4 < t5.length; r4++) {
              var o3 = t5[r4];
              if (isNaN(o3) || !isFinite(o3))
                return console.warn("Found " + o3 + " in the result of '" + n4 + "'"), true;
            }
          }(r3, n3.dtype, t4), a2.then(function(a3) {
            var i2 = "";
            null != a3.getExtraProfileInfo && (i2 = a3.getExtraProfileInfo()), o2.logger.logKernelProfile(t4, n3, r3, a3.kernelMs, e2, i2);
          });
        });
      }), r2;
    }, t3;
  }();
  var nt = function() {
    function t3() {
    }
    return t3.prototype.logKernelProfile = function(t4, e2, n2, r2, o2, a2) {
      var i2 = k(r2 + "ms", 9), u2 = k(t4, 25), s2 = e2.rank, c2 = e2.size, l3 = k(e2.shape.toString(), 14), h = "";
      for (var f2 in o2) {
        var p2 = o2[f2].shape, d2 = p2.length;
        h += f2 + ": " + d2 + "D " + (d2 > 0 ? p2 : "") + " ";
      }
      console.log("%c" + u2 + "	%c" + i2 + "	%c" + s2 + "D " + l3 + "	%c" + c2 + "	%c" + h + "	%c" + a2, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }, t3;
  }();
  var rt = 20;
  var ot = 3;
  var at = 7;
  function it(t3, e2, n2, r2) {
    var o2 = q(e2), a2 = function(t4, e3, n3, r3) {
      var o3 = w(e3), a3 = r3[r3.length - 1], i3 = new Array(a3).fill(0), u3 = e3.length, s3 = "complex64" === n3 ? ct(t4) : t4;
      if (u3 > 1)
        for (var c2 = 0; c2 < o3 / a3; c2++)
          for (var l3 = c2 * a3, h = 0; h < a3; h++)
            i3[h] = Math.max(i3[h], ut(s3[l3 + h], 0, n3).length);
      return i3;
    }(t3, e2, n2, o2), i2 = e2.length, u2 = function t4(e3, n3, r3, o3, a3, i3) {
      void 0 === i3 && (i3 = true);
      var u3 = "complex64" === r3 ? 2 : 1;
      var s3 = n3[0];
      var c2 = n3.length;
      if (0 === c2) {
        if ("complex64" === r3) {
          var l3 = ct(e3);
          return [ut(l3[0], 0, r3)];
        }
        return "bool" === r3 ? [st(e3[0])] : [e3[0].toString()];
      }
      if (1 === c2) {
        if (s3 > rt) {
          var h = ot * u3, f2 = Array.from(e3.slice(0, h)), p2 = Array.from(e3.slice(s3 - ot * u3, s3));
          return "complex64" === r3 && (f2 = ct(f2), p2 = ct(p2)), ["[" + f2.map(function(t5, e4) {
            return ut(t5, a3[e4], r3);
          }).join(", ") + ", ..., " + p2.map(function(t5, e4) {
            return ut(t5, a3[s3 - ot + e4], r3);
          }).join(", ") + "]"];
        }
        var d2 = "complex64" === r3 ? ct(e3) : Array.from(e3);
        return ["[" + d2.map(function(t5, e4) {
          return ut(t5, a3[e4], r3);
        }).join(", ") + "]"];
      }
      var v2 = n3.slice(1);
      var m2 = o3.slice(1);
      var g2 = o3[0] * u3;
      var y2 = [];
      if (s3 > rt) {
        for (var x2 = 0; x2 < ot; x2++) {
          var b2 = x2 * g2, w2 = b2 + g2;
          y2.push.apply(y2, t4(e3.slice(b2, w2), v2, r3, m2, a3, false));
        }
        y2.push("...");
        for (var x2 = s3 - ot; x2 < s3; x2++) {
          var b2 = x2 * g2, w2 = b2 + g2;
          y2.push.apply(y2, t4(e3.slice(b2, w2), v2, r3, m2, a3, x2 === s3 - 1));
        }
      } else
        for (var x2 = 0; x2 < s3; x2++) {
          var b2 = x2 * g2, w2 = b2 + g2;
          y2.push.apply(y2, t4(e3.slice(b2, w2), v2, r3, m2, a3, x2 === s3 - 1));
        }
      var C3 = 2 === c2 ? "," : "";
      y2[0] = "[" + y2[0] + C3;
      for (var x2 = 1; x2 < y2.length - 1; x2++)
        y2[x2] = " " + y2[x2] + C3;
      var E3 = ",\n";
      for (var x2 = 2; x2 < c2; x2++)
        E3 += "\n";
      y2[y2.length - 1] = " " + y2[y2.length - 1] + "]" + (i3 ? "" : E3);
      return y2;
    }(t3, e2, n2, o2, a2), s2 = ["Tensor"];
    return r2 && (s2.push("  dtype: " + n2), s2.push("  rank: " + i2), s2.push("  shape: [" + e2 + "]"), s2.push("  values:")), s2.push(u2.map(function(t4) {
      return "    " + t4;
    }).join("\n")), s2.join("\n");
  }
  function ut(t3, e2, n2) {
    return k(Array.isArray(t3) ? parseFloat(t3[0].toFixed(at)) + " + " + parseFloat(t3[1].toFixed(at)) + "j" : W(t3) ? "'" + t3 + "'" : "bool" === n2 ? st(t3) : parseFloat(t3.toFixed(at)).toString(), e2);
  }
  function st(t3) {
    return 0 === t3 ? "false" : "true";
  }
  function ct(t3) {
    for (var e2 = [], n2 = 0; n2 < t3.length; n2 += 2)
      e2.push([t3[n2], t3[n2 + 1]]);
    return e2;
  }
  var lt = function() {
    function t3(t4, e2, n2) {
      var r2 = this;
      if (this.dtype = e2, this.shape = t4.slice(), this.size = w(t4), null != n2) {
        var o2 = n2.length;
        g(o2 === this.size, function() {
          return "Length of values '" + o2 + "' does not match the size inferred by the shape '" + r2.size + "'.";
        });
      }
      if ("complex64" === e2)
        throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
      this.values = n2 || F(e2, this.size), this.strides = q(t4);
    }
    return t3.prototype.set = function(t4) {
      for (var e2 = this, n2 = [], r2 = 1; r2 < arguments.length; r2++)
        n2[r2 - 1] = arguments[r2];
      0 === n2.length && (n2 = [0]), g(n2.length === this.rank, function() {
        return "The number of provided coordinates (" + n2.length + ") must match the rank (" + e2.rank + ")";
      });
      var o2 = this.locToIndex(n2);
      this.values[o2] = t4;
    }, t3.prototype.get = function() {
      for (var t4 = [], e2 = 0; e2 < arguments.length; e2++)
        t4[e2] = arguments[e2];
      0 === t4.length && (t4 = [0]);
      for (var n2 = 0, r2 = 0, o2 = t4; r2 < o2.length; r2++) {
        var a2 = o2[r2];
        if (a2 < 0 || a2 >= this.shape[n2]) {
          var i2 = "Requested out of range element at " + t4 + ".   Buffer shape=" + this.shape;
          throw new Error(i2);
        }
        n2++;
      }
      for (var u2 = t4[t4.length - 1], s2 = 0; s2 < t4.length - 1; ++s2)
        u2 += this.strides[s2] * t4[s2];
      return this.values[u2];
    }, t3.prototype.locToIndex = function(t4) {
      if (0 === this.rank)
        return 0;
      if (1 === this.rank)
        return t4[0];
      for (var e2 = t4[t4.length - 1], n2 = 0; n2 < t4.length - 1; ++n2)
        e2 += this.strides[n2] * t4[n2];
      return e2;
    }, t3.prototype.indexToLoc = function(t4) {
      if (0 === this.rank)
        return [];
      if (1 === this.rank)
        return [t4];
      for (var e2 = new Array(this.shape.length), n2 = 0; n2 < e2.length - 1; ++n2)
        e2[n2] = Math.floor(t4 / this.strides[n2]), t4 -= e2[n2] * this.strides[n2];
      return e2[e2.length - 1] = t4, e2;
    }, Object.defineProperty(t3.prototype, "rank", { get: function() {
      return this.shape.length;
    }, enumerable: true, configurable: true }), t3.prototype.toTensor = function() {
      return ht().makeTensor(this.values, this.shape, this.dtype);
    }, t3;
  }();
  var ht = null;
  var ft = null;
  var pt = null;
  var dt = function() {
    function t3(t4, e2, n2, r2) {
      this.kept = false, this.isDisposedInternal = false, this.shape = t4.slice(), this.dtype = e2 || "float32", this.size = w(t4), this.strides = q(t4), this.dataId = n2, this.id = r2, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    return t3.prototype.flatten = function() {
      return this.throwIfDisposed(), this.as1D();
    }, t3.prototype.asScalar = function() {
      return this.throwIfDisposed(), g(1 === this.size, function() {
        return "The array must have only 1 element.";
      }), this.reshape([]);
    }, t3.prototype.as1D = function() {
      return this.throwIfDisposed(), this.reshape([this.size]);
    }, t3.prototype.as2D = function(t4, e2) {
      return this.throwIfDisposed(), this.reshape([t4, e2]);
    }, t3.prototype.as3D = function(t4, e2, n2) {
      return this.throwIfDisposed(), this.reshape([t4, e2, n2]);
    }, t3.prototype.as4D = function(t4, e2, n2, r2) {
      return this.throwIfDisposed(), this.reshape([t4, e2, n2, r2]);
    }, t3.prototype.as5D = function(t4, e2, n2, r2, o2) {
      return this.throwIfDisposed(), this.reshape([t4, e2, n2, r2, o2]);
    }, t3.prototype.asType = function(t4) {
      return this.throwIfDisposed(), ft.cast(this, t4);
    }, Object.defineProperty(t3.prototype, "rank", { get: function() {
      return this.shape.length;
    }, enumerable: true, configurable: true }), t3.prototype.buffer = function() {
      return n(this, void 0, void 0, function() {
        var t4;
        return r(this, function(e2) {
          switch (e2.label) {
            case 0:
              return [4, this.data()];
            case 1:
              return t4 = e2.sent(), [2, ft.buffer(this.shape, this.dtype, t4)];
          }
        });
      });
    }, t3.prototype.bufferSync = function() {
      return ft.buffer(this.shape, this.dtype, this.dataSync());
    }, t3.prototype.array = function() {
      return n(this, void 0, void 0, function() {
        var t4;
        return r(this, function(e2) {
          switch (e2.label) {
            case 0:
              return [4, this.data()];
            case 1:
              return t4 = e2.sent(), [2, j(this.shape, t4)];
          }
        });
      });
    }, t3.prototype.arraySync = function() {
      return j(this.shape, this.dataSync());
    }, t3.prototype.data = function() {
      return n(this, void 0, void 0, function() {
        var t4, e2;
        return r(this, function(n2) {
          switch (n2.label) {
            case 0:
              return this.throwIfDisposed(), t4 = ht().read(this.dataId), "string" !== this.dtype ? [3, 2] : [4, t4];
            case 1:
              e2 = n2.sent();
              try {
                return [2, e2.map(function(t5) {
                  return Z(t5);
                })];
              } catch (t5) {
                throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
              }
              n2.label = 2;
            case 2:
              return [2, t4];
          }
        });
      });
    }, t3.prototype.dataSync = function() {
      this.throwIfDisposed();
      var t4 = ht().readSync(this.dataId);
      if ("string" === this.dtype)
        try {
          return t4.map(function(t5) {
            return Z(t5);
          });
        } catch (t5) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      return t4;
    }, t3.prototype.bytes = function() {
      return n(this, void 0, void 0, function() {
        var t4;
        return r(this, function(e2) {
          switch (e2.label) {
            case 0:
              return this.throwIfDisposed(), [4, ht().read(this.dataId)];
            case 1:
              return t4 = e2.sent(), "string" === this.dtype ? [2, t4] : [2, new Uint8Array(t4.buffer)];
          }
        });
      });
    }, t3.prototype.dispose = function() {
      this.isDisposed || (ht().disposeTensor(this), this.isDisposedInternal = true);
    }, Object.defineProperty(t3.prototype, "isDisposed", { get: function() {
      return this.isDisposedInternal;
    }, enumerable: true, configurable: true }), t3.prototype.throwIfDisposed = function() {
      if (this.isDisposed)
        throw new Error("Tensor is disposed.");
    }, t3.prototype.toFloat = function() {
      return this.asType("float32");
    }, t3.prototype.toInt = function() {
      return this.asType("int32");
    }, t3.prototype.toBool = function() {
      return this.asType("bool");
    }, t3.prototype.print = function(t4) {
      return void 0 === t4 && (t4 = false), ft.print(this, t4);
    }, t3.prototype.reshape = function(t4) {
      return this.throwIfDisposed(), ft.reshape(this, t4);
    }, t3.prototype.reshapeAs = function(t4) {
      return this.throwIfDisposed(), this.reshape(t4.shape);
    }, t3.prototype.expandDims = function(t4) {
      return void 0 === t4 && (t4 = 0), ft.expandDims(this, t4);
    }, t3.prototype.cumsum = function(t4, e2, n2) {
      return void 0 === t4 && (t4 = 0), void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = false), ft.cumsum(this, t4, e2, n2);
    }, t3.prototype.squeeze = function(t4) {
      return this.throwIfDisposed(), ft.squeeze(this, t4);
    }, t3.prototype.clone = function() {
      return this.throwIfDisposed(), ft.clone(this);
    }, t3.prototype.oneHot = function(t4, e2, n2) {
      return this.throwIfDisposed(), ft.oneHot(this, t4, e2, n2);
    }, t3.prototype.toString = function(t4) {
      return void 0 === t4 && (t4 = false), it(this.dataSync(), this.shape, this.dtype, t4);
    }, t3.prototype.tile = function(t4) {
      return this.throwIfDisposed(), ft.tile(this, t4);
    }, t3.prototype.gather = function(t4, e2) {
      return void 0 === e2 && (e2 = 0), this.throwIfDisposed(), ft.gather(this, t4, e2);
    }, t3.prototype.matMul = function(t4, e2, n2) {
      return void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = false), this.throwIfDisposed(), ft.matMul(this, t4, e2, n2);
    }, t3.prototype.dot = function(t4) {
      return this.throwIfDisposed(), ft.dot(this, t4);
    }, t3.prototype.norm = function(t4, e2, n2) {
      return void 0 === t4 && (t4 = "euclidean"), void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false), this.throwIfDisposed(), ft.norm(this, t4, e2, n2);
    }, t3.prototype.slice = function(t4, e2) {
      return this.throwIfDisposed(), ft.slice(this, t4, e2);
    }, t3.prototype.reverse = function(t4) {
      return this.throwIfDisposed(), ft.reverse(this, t4);
    }, t3.prototype.concat = function(e2, n2) {
      return void 0 === n2 && (n2 = 0), this.throwIfDisposed(), e2 instanceof t3 && (e2 = [e2]), ft.concat([this].concat(e2), n2);
    }, t3.prototype.split = function(t4, e2) {
      return void 0 === e2 && (e2 = 0), this.throwIfDisposed(), ft.split(this, t4, e2);
    }, t3.prototype.stack = function(t4, e2) {
      return void 0 === e2 && (e2 = 0), ft.stack([this, t4], e2);
    }, t3.prototype.unstack = function(t4) {
      return void 0 === t4 && (t4 = 0), ft.unstack(this, t4);
    }, t3.prototype.pad = function(t4, e2) {
      return void 0 === e2 && (e2 = 0), ft.pad(this, t4, e2);
    }, t3.prototype.batchNormalization = function(t4, e2, n2, r2, o2) {
      return void 0 === n2 && (n2 = 1e-3), pt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t4, e2, o2, r2, n2);
    }, t3.prototype.batchNorm = function(t4, e2, n2, r2, o2) {
      return void 0 === o2 && (o2 = 1e-3), this.throwIfDisposed(), ft.batchNorm(this, t4, e2, n2, r2, o2);
    }, t3.prototype.all = function(t4, e2) {
      return void 0 === t4 && (t4 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.all(this, t4, e2);
    }, t3.prototype.any = function(t4, e2) {
      return void 0 === t4 && (t4 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.any(this, t4, e2);
    }, t3.prototype.logSumExp = function(t4, e2) {
      return void 0 === t4 && (t4 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.logSumExp(this, t4, e2);
    }, t3.prototype.sum = function(t4, e2) {
      return void 0 === t4 && (t4 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.sum(this, t4, e2);
    }, t3.prototype.prod = function(t4, e2) {
      return void 0 === t4 && (t4 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.prod(this, t4, e2);
    }, t3.prototype.mean = function(t4, e2) {
      return void 0 === t4 && (t4 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.mean(this, t4, e2);
    }, t3.prototype.min = function(t4, e2) {
      return void 0 === t4 && (t4 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.min(this, t4, e2);
    }, t3.prototype.max = function(t4, e2) {
      return void 0 === t4 && (t4 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.max(this, t4, e2);
    }, t3.prototype.argMin = function(t4) {
      return void 0 === t4 && (t4 = null), this.throwIfDisposed(), ft.argMin(this, t4);
    }, t3.prototype.argMax = function(t4) {
      return void 0 === t4 && (t4 = null), this.throwIfDisposed(), ft.argMax(this, t4);
    }, t3.prototype.cast = function(t4) {
      return this.throwIfDisposed(), ft.cast(this, t4);
    }, t3.prototype.add = function(t4) {
      return this.throwIfDisposed(), ft.add(this, t4);
    }, t3.prototype.addStrict = function(t4) {
      return this.throwIfDisposed(), ft.addStrict(this, t4);
    }, t3.prototype.atan2 = function(t4) {
      return this.throwIfDisposed(), ft.atan2(this, t4);
    }, t3.prototype.sub = function(t4) {
      return this.throwIfDisposed(), ft.sub(this, t4);
    }, t3.prototype.subStrict = function(t4) {
      return this.throwIfDisposed(), ft.subStrict(this, t4);
    }, t3.prototype.pow = function(t4) {
      return this.throwIfDisposed(), ft.pow(this, t4);
    }, t3.prototype.powStrict = function(t4) {
      return this.throwIfDisposed(), ft.powStrict(this, t4);
    }, t3.prototype.mul = function(t4) {
      return this.throwIfDisposed(), ft.mul(this, t4);
    }, t3.prototype.mulStrict = function(t4) {
      return this.throwIfDisposed(), ft.mulStrict(this, t4);
    }, t3.prototype.div = function(t4) {
      return this.throwIfDisposed(), ft.div(this, t4);
    }, t3.prototype.floorDiv = function(t4) {
      return this.throwIfDisposed(), ft.floorDiv(this, t4);
    }, t3.prototype.divStrict = function(t4) {
      return this.throwIfDisposed(), ft.divStrict(this, t4);
    }, t3.prototype.minimum = function(t4) {
      return this.throwIfDisposed(), ft.minimum(this, t4);
    }, t3.prototype.minimumStrict = function(t4) {
      return this.throwIfDisposed(), ft.minimumStrict(this, t4);
    }, t3.prototype.maximum = function(t4) {
      return this.throwIfDisposed(), ft.maximum(this, t4);
    }, t3.prototype.maximumStrict = function(t4) {
      return this.throwIfDisposed(), ft.maximumStrict(this, t4);
    }, t3.prototype.mod = function(t4) {
      return this.throwIfDisposed(), ft.mod(this, t4);
    }, t3.prototype.modStrict = function(t4) {
      return this.throwIfDisposed(), ft.modStrict(this, t4);
    }, t3.prototype.squaredDifference = function(t4) {
      return this.throwIfDisposed(), ft.squaredDifference(this, t4);
    }, t3.prototype.squaredDifferenceStrict = function(t4) {
      return this.throwIfDisposed(), ft.squaredDifferenceStrict(this, t4);
    }, t3.prototype.transpose = function(t4) {
      return this.throwIfDisposed(), ft.transpose(this, t4);
    }, t3.prototype.notEqual = function(t4) {
      return this.throwIfDisposed(), ft.notEqual(this, t4);
    }, t3.prototype.notEqualStrict = function(t4) {
      return this.throwIfDisposed(), ft.notEqualStrict(this, t4);
    }, t3.prototype.less = function(t4) {
      return this.throwIfDisposed(), ft.less(this, t4);
    }, t3.prototype.lessStrict = function(t4) {
      return this.throwIfDisposed(), ft.lessStrict(this, t4);
    }, t3.prototype.equal = function(t4) {
      return this.throwIfDisposed(), ft.equal(this, t4);
    }, t3.prototype.equalStrict = function(t4) {
      return this.throwIfDisposed(), ft.equalStrict(this, t4);
    }, t3.prototype.lessEqual = function(t4) {
      return this.throwIfDisposed(), ft.lessEqual(this, t4);
    }, t3.prototype.lessEqualStrict = function(t4) {
      return this.throwIfDisposed(), ft.lessEqualStrict(this, t4);
    }, t3.prototype.greater = function(t4) {
      return this.throwIfDisposed(), ft.greater(this, t4);
    }, t3.prototype.greaterStrict = function(t4) {
      return this.throwIfDisposed(), ft.greaterStrict(this, t4);
    }, t3.prototype.greaterEqual = function(t4) {
      return this.throwIfDisposed(), ft.greaterEqual(this, t4);
    }, t3.prototype.greaterEqualStrict = function(t4) {
      return this.throwIfDisposed(), ft.greaterEqualStrict(this, t4);
    }, t3.prototype.logicalAnd = function(t4) {
      return this.throwIfDisposed(), ft.logicalAnd(this, t4);
    }, t3.prototype.logicalOr = function(t4) {
      return this.throwIfDisposed(), ft.logicalOr(this, t4);
    }, t3.prototype.logicalNot = function() {
      return this.throwIfDisposed(), ft.logicalNot(this);
    }, t3.prototype.logicalXor = function(t4) {
      return this.throwIfDisposed(), ft.logicalXor(this, t4);
    }, t3.prototype.where = function(t4, e2) {
      return this.throwIfDisposed(), ft.where(t4, this, e2);
    }, t3.prototype.neg = function() {
      return this.throwIfDisposed(), ft.neg(this);
    }, t3.prototype.ceil = function() {
      return this.throwIfDisposed(), ft.ceil(this);
    }, t3.prototype.floor = function() {
      return this.throwIfDisposed(), ft.floor(this);
    }, t3.prototype.sign = function() {
      return this.throwIfDisposed(), ft.sign(this);
    }, t3.prototype.isNaN = function() {
      return this.throwIfDisposed(), ft.isNaN(this);
    }, t3.prototype.isInf = function() {
      return this.throwIfDisposed(), ft.isInf(this);
    }, t3.prototype.isFinite = function() {
      return this.throwIfDisposed(), ft.isFinite(this);
    }, t3.prototype.exp = function() {
      return this.throwIfDisposed(), ft.exp(this);
    }, t3.prototype.expm1 = function() {
      return this.throwIfDisposed(), ft.expm1(this);
    }, t3.prototype.log = function() {
      return this.throwIfDisposed(), ft.log(this);
    }, t3.prototype.log1p = function() {
      return this.throwIfDisposed(), ft.log1p(this);
    }, t3.prototype.sqrt = function() {
      return this.throwIfDisposed(), ft.sqrt(this);
    }, t3.prototype.rsqrt = function() {
      return this.throwIfDisposed(), ft.rsqrt(this);
    }, t3.prototype.square = function() {
      return this.throwIfDisposed(), ft.square(this);
    }, t3.prototype.reciprocal = function() {
      return this.throwIfDisposed(), ft.reciprocal(this);
    }, t3.prototype.abs = function() {
      return this.throwIfDisposed(), ft.abs(this);
    }, t3.prototype.clipByValue = function(t4, e2) {
      return this.throwIfDisposed(), ft.clipByValue(this, t4, e2);
    }, t3.prototype.relu = function() {
      return this.throwIfDisposed(), ft.relu(this);
    }, t3.prototype.relu6 = function() {
      return this.throwIfDisposed(), ft.relu6(this);
    }, t3.prototype.elu = function() {
      return this.throwIfDisposed(), ft.elu(this);
    }, t3.prototype.selu = function() {
      return this.throwIfDisposed(), ft.selu(this);
    }, t3.prototype.leakyRelu = function(t4) {
      return void 0 === t4 && (t4 = 0.2), this.throwIfDisposed(), ft.leakyRelu(this, t4);
    }, t3.prototype.prelu = function(t4) {
      return this.throwIfDisposed(), ft.prelu(this, t4);
    }, t3.prototype.sigmoid = function() {
      return this.throwIfDisposed(), ft.sigmoid(this);
    }, t3.prototype.logSigmoid = function() {
      return this.throwIfDisposed(), ft.logSigmoid(this);
    }, t3.prototype.softplus = function() {
      return this.throwIfDisposed(), ft.softplus(this);
    }, t3.prototype.zerosLike = function() {
      return this.throwIfDisposed(), ft.zerosLike(this);
    }, t3.prototype.onesLike = function() {
      return this.throwIfDisposed(), ft.onesLike(this);
    }, t3.prototype.sin = function() {
      return this.throwIfDisposed(), ft.sin(this);
    }, t3.prototype.cos = function() {
      return this.throwIfDisposed(), ft.cos(this);
    }, t3.prototype.tan = function() {
      return this.throwIfDisposed(), ft.tan(this);
    }, t3.prototype.asin = function() {
      return this.throwIfDisposed(), ft.asin(this);
    }, t3.prototype.acos = function() {
      return this.throwIfDisposed(), ft.acos(this);
    }, t3.prototype.atan = function() {
      return this.throwIfDisposed(), ft.atan(this);
    }, t3.prototype.sinh = function() {
      return this.throwIfDisposed(), ft.sinh(this);
    }, t3.prototype.cosh = function() {
      return this.throwIfDisposed(), ft.cosh(this);
    }, t3.prototype.tanh = function() {
      return this.throwIfDisposed(), ft.tanh(this);
    }, t3.prototype.asinh = function() {
      return this.throwIfDisposed(), ft.asinh(this);
    }, t3.prototype.acosh = function() {
      return this.throwIfDisposed(), ft.acosh(this);
    }, t3.prototype.atanh = function() {
      return this.throwIfDisposed(), ft.atanh(this);
    }, t3.prototype.erf = function() {
      return this.throwIfDisposed(), ft.erf(this);
    }, t3.prototype.round = function() {
      return this.throwIfDisposed(), ft.round(this);
    }, t3.prototype.step = function(t4) {
      return void 0 === t4 && (t4 = 0), this.throwIfDisposed(), ft.step(this, t4);
    }, t3.prototype.softmax = function(t4) {
      return void 0 === t4 && (t4 = -1), this.throwIfDisposed(), ft.softmax(this, t4);
    }, t3.prototype.logSoftmax = function(t4) {
      return void 0 === t4 && (t4 = -1), this.throwIfDisposed(), ft.logSoftmax(this, t4);
    }, t3.prototype.resizeBilinear = function(t4, e2) {
      return void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.image.resizeBilinear(this, t4, e2);
    }, t3.prototype.resizeNearestNeighbor = function(t4, e2) {
      return void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.image.resizeNearestNeighbor(this, t4, e2);
    }, t3.prototype.conv1d = function(t4, e2, n2, r2, o2, a2) {
      return void 0 === r2 && (r2 = "NWC"), void 0 === o2 && (o2 = 1), this.throwIfDisposed(), ft.conv1d(this, t4, e2, n2, r2, o2, a2);
    }, t3.prototype.conv2d = function(t4, e2, n2, r2, o2, a2) {
      return void 0 === r2 && (r2 = "NHWC"), void 0 === o2 && (o2 = [1, 1]), this.throwIfDisposed(), ft.conv2d(this, t4, e2, n2, r2, o2, a2);
    }, t3.prototype.conv2dTranspose = function(t4, e2, n2, r2, o2) {
      return this.throwIfDisposed(), ft.conv2dTranspose(this, t4, e2, n2, r2, o2);
    }, t3.prototype.depthwiseConv2D = function(t4, e2, n2, r2, o2, a2) {
      return void 0 === r2 && (r2 = "NHWC"), void 0 === o2 && (o2 = [1, 1]), this.throwIfDisposed(), ft.depthwiseConv2d(this, t4, e2, n2, r2, o2, a2);
    }, t3.prototype.separableConv2d = function(t4, e2, n2, r2, o2, a2) {
      return void 0 === o2 && (o2 = [1, 1]), void 0 === a2 && (a2 = "NHWC"), this.throwIfDisposed(), ft.separableConv2d(this, t4, e2, n2, r2, o2, a2);
    }, t3.prototype.avgPool = function(t4, e2, n2, r2) {
      return this.throwIfDisposed(), ft.avgPool(this, t4, e2, n2, r2);
    }, t3.prototype.maxPool = function(t4, e2, n2, r2) {
      return this.throwIfDisposed(), ft.maxPool(this, t4, e2, n2, r2);
    }, t3.prototype.localResponseNormalization = function(t4, e2, n2, r2) {
      return void 0 === t4 && (t4 = 5), void 0 === e2 && (e2 = 1), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0.5), ft.localResponseNormalization(this, t4, e2, n2, r2);
    }, t3.prototype.pool = function(t4, e2, n2, r2, o2) {
      return this.throwIfDisposed(), ft.pool(this, t4, e2, n2, r2, o2);
    }, t3.prototype.variable = function(t4, e2, n2) {
      return void 0 === t4 && (t4 = true), this.throwIfDisposed(), ht().makeVariable(this, t4, e2, n2);
    }, t3.prototype.unsortedSegmentSum = function(t4, e2) {
      return this.throwIfDisposed(), ft.unsortedSegmentSum(this, t4, e2);
    }, t3.prototype.batchToSpaceND = function(t4, e2) {
      return this.throwIfDisposed(), ft.batchToSpaceND(this, t4, e2);
    }, t3.prototype.spaceToBatchND = function(t4, e2) {
      return this.throwIfDisposed(), ft.spaceToBatchND(this, t4, e2);
    }, t3.prototype.topk = function(t4, e2) {
      return void 0 === t4 && (t4 = 1), void 0 === e2 && (e2 = true), this.throwIfDisposed(), ft.topk(this, t4, e2);
    }, t3.prototype.stridedSlice = function(t4, e2, n2, r2, o2, a2, i2, u2) {
      return void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), void 0 === a2 && (a2 = 0), void 0 === i2 && (i2 = 0), void 0 === u2 && (u2 = 0), this.throwIfDisposed(), ft.stridedSlice(this, t4, e2, n2, r2, o2, a2, i2, u2);
    }, t3.prototype.depthToSpace = function(t4, e2) {
      return this.throwIfDisposed(), ft.depthToSpace(this, t4, e2);
    }, t3.prototype.fft = function() {
      return this.throwIfDisposed(), ft.spectral.fft(this);
    }, t3.prototype.ifft = function() {
      return this.throwIfDisposed(), ft.spectral.ifft(this);
    }, t3.prototype.rfft = function() {
      return this.throwIfDisposed(), ft.spectral.rfft(this);
    }, t3.prototype.irfft = function() {
      return this.throwIfDisposed(), ft.spectral.irfft(this);
    }, t3;
  }();
  Object.defineProperty(dt, Symbol.hasInstance, { value: function(t3) {
    return !!t3 && null != t3.dataId && null != t3.shape && null != t3.dtype;
  } });
  var vt;
  var mt;
  var gt;
  var yt;
  var xt;
  var bt = function(t3) {
    function n2(e2, n3, r2, o2) {
      var a2 = t3.call(this, e2.shape, e2.dtype, e2.dataId, o2) || this;
      return a2.trainable = n3, a2.name = r2, a2;
    }
    return e(n2, t3), n2.prototype.assign = function(t4) {
      if (t4.dtype !== this.dtype)
        throw new Error("dtype of the new value (" + t4.dtype + ") and previous value (" + this.dtype + ") must match");
      if (!C(t4.shape, this.shape))
        throw new Error("shape of the new value (" + t4.shape + ") and previous value (" + this.shape + ") must match");
      ht().disposeTensor(this), this.dataId = t4.dataId, ht().incRef(this, null);
    }, n2.prototype.dispose = function() {
      ht().disposeVariable(this), this.isDisposedInternal = true;
    }, n2;
  }(dt);
  Object.defineProperty(bt, Symbol.hasInstance, { value: function(t3) {
    return t3 instanceof dt && null != t3.assign && t3.assign instanceof Function;
  } }), function(t3) {
    t3.R0 = "R0", t3.R1 = "R1", t3.R2 = "R2", t3.R3 = "R3", t3.R4 = "R4", t3.R5 = "R5", t3.R6 = "R6";
  }(vt || (vt = {})), function(t3) {
    t3.float32 = "float32", t3.int32 = "int32", t3.bool = "int32", t3.complex64 = "complex64";
  }(mt || (mt = {})), function(t3) {
    t3.float32 = "float32", t3.int32 = "int32", t3.bool = "bool", t3.complex64 = "complex64";
  }(gt || (gt = {})), function(t3) {
    t3.float32 = "float32", t3.int32 = "float32", t3.bool = "float32", t3.complex64 = "complex64";
  }(yt || (yt = {})), function(t3) {
    t3.float32 = "complex64", t3.int32 = "complex64", t3.bool = "complex64", t3.complex64 = "complex64";
  }(xt || (xt = {}));
  var wt = { float32: yt, int32: mt, bool: gt, complex64: xt };
  function Ct(t3, e2) {
    if ("string" === t3 || "string" === e2) {
      if ("string" === t3 && "string" === e2)
        return "string";
      throw new Error("Can not upcast " + t3 + " with " + e2);
    }
    return wt[t3][e2];
  }
  function Et(t3) {
    return Ct(t3, "int32");
  }
  function Rt(t3, e2) {
    if (t3.dtype === e2.dtype)
      return [t3, e2];
    var n2 = Ct(t3.dtype, e2.dtype);
    return [t3.cast(n2), e2.cast(n2)];
  }
  function It(t3, e2) {
    g(t3.dtype === e2.dtype, function() {
      return "The dtypes of the first(" + t3.dtype + ") and second(" + e2.dtype + ") input must match";
    });
  }
  function kt(t3) {
    var e2 = [];
    return function t4(e3, n2, r2) {
      if (null == e3)
        return;
      if (e3 instanceof dt)
        return void n2.push(e3);
      if (o2 = e3, !Array.isArray(o2) && "object" != typeof o2)
        return;
      var o2;
      var a2 = e3;
      for (var i2 in a2) {
        var u2 = a2[i2];
        r2.has(u2) || (r2.add(u2), t4(u2, n2, r2));
      }
    }(t3, e2, /* @__PURE__ */ new Set()), e2;
  }
  var St;
  var At = Object.freeze({ makeTypesMatch: Rt, assertTypesMatch: It, isTensorInList: function(t3, e2) {
    for (var n2 = 0; n2 < e2.length; n2++)
      if (e2[n2].id === t3.id)
        return true;
    return false;
  }, getTensorsInContainer: kt });
  var Dt = function() {
    function t3() {
      this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = false, this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null };
    }
    return t3.prototype.dispose = function() {
      for (var t4 in this.registeredVariables)
        this.registeredVariables[t4].dispose();
    }, t3;
  }();
  var Tt = function() {
    function t3(t4) {
      this.ENV = t4, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Dt();
    }
    return t3.prototype.ready = function() {
      return n(this, void 0, void 0, function() {
        var t4, e2, n2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              if (null != this.pendingBackendInit)
                return [2, this.pendingBackendInit.then(function() {
                })];
              if (null != this.backendInstance)
                return [2];
              t4 = this.getSortedBackends(), e2 = 0, r2.label = 1;
            case 1:
              return e2 < t4.length ? (n2 = t4[e2], [4, this.initializeBackend(n2).success]) : [3, 5];
            case 2:
              return r2.sent() ? [4, this.setBackend(n2)] : [3, 4];
            case 3:
              return r2.sent(), [2];
            case 4:
              return e2++, [3, 1];
            case 5:
              throw new Error("Could not initialize any backends, all backend initializations failed.");
          }
        });
      });
    }, Object.defineProperty(t3.prototype, "backend", { get: function() {
      if (null != this.pendingBackendInit)
        throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() before calling other methods");
      if (null == this.backendInstance) {
        var t4 = this.initializeBackendsAndReturnBest(), e2 = t4.name;
        if (t4.asyncInit)
          throw new Error("The highest priority backend '" + e2 + "' has not yet been initialized. Make sure to await tf.ready() before calling other methods");
        this.setBackend(e2);
      }
      return this.backendInstance;
    }, enumerable: true, configurable: true }), t3.prototype.backendNames = function() {
      return Object.keys(this.registryFactory);
    }, t3.prototype.findBackend = function(t4) {
      if (!(t4 in this.registry)) {
        if (!(t4 in this.registryFactory))
          return null;
        if (this.initializeBackend(t4).asyncInit)
          return null;
      }
      return this.registry[t4];
    }, t3.prototype.findBackendFactory = function(t4) {
      return t4 in this.registryFactory ? this.registryFactory[t4].factory : null;
    }, t3.prototype.registerBackend = function(t4, e2, n2) {
      return void 0 === n2 && (n2 = 1), t4 in this.registryFactory ? (console.warn(t4 + " backend was already registered. Reusing existing backend factory."), false) : (this.registryFactory[t4] = { factory: e2, priority: n2 }, true);
    }, t3.prototype.setBackend = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2, o2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              if (null == this.registryFactory[t4])
                throw new Error("Backend name '" + t4 + "' not found in registry");
              return this.backendName = t4, null != this.registry[t4] ? [3, 4] : (this.backendInstance = null, e2 = this.initializeBackend(t4), n2 = e2.success, e2.asyncInit ? [4, n2] : [3, 2]);
            case 1:
              return o2 = r2.sent(), [3, 3];
            case 2:
              o2 = n2, r2.label = 3;
            case 3:
              if (!o2)
                return [2, false];
              r2.label = 4;
            case 4:
              return this.backendInstance = this.registry[t4], this.setupRegisteredKernels(), this.profiler = new et(this.backendInstance), [2, true];
          }
        });
      });
    }, t3.prototype.setupRegisteredKernels = function() {
      var t4 = this;
      c(this.backendName).forEach(function(e2) {
        null != e2.setupFunc && e2.setupFunc(t4.backendInstance);
      });
    }, t3.prototype.disposeRegisteredKernels = function(t4) {
      var e2 = this;
      c(t4).forEach(function(n2) {
        null != n2.disposeFunc && n2.disposeFunc(e2.registry[t4]);
      });
    }, t3.prototype.initializeBackend = function(t4) {
      var e2 = this, n2 = this.registryFactory[t4];
      if (null == n2)
        throw new Error("Cannot initialize backend " + t4 + ", no registration found.");
      try {
        var r2 = n2.factory();
        if (Promise.resolve(r2) === r2) {
          var o2 = ++this.pendingBackendInitId, a2 = r2.then(function(n3) {
            return !(o2 < e2.pendingBackendInitId) && (e2.registry[t4] = n3, e2.pendingBackendInit = null, true);
          }).catch(function(n3) {
            return !(o2 < e2.pendingBackendInitId) && (e2.pendingBackendInit = null, console.warn("Initialization of backend " + t4 + " failed"), console.warn(n3.stack || n3.message), false);
          });
          return this.pendingBackendInit = a2, { success: a2, asyncInit: true };
        }
        return this.registry[t4] = r2, { success: true, asyncInit: false };
      } catch (e3) {
        return console.warn("Initialization of backend " + t4 + " failed"), console.warn(e3.stack || e3.message), { success: false, asyncInit: false };
      }
    }, t3.prototype.removeBackend = function(t4) {
      if (!(t4 in this.registryFactory))
        throw new Error(t4 + " backend not found in registry");
      this.backendName === t4 && null != this.pendingBackendInit && this.pendingBackendInitId++, t4 in this.registry && (this.disposeRegisteredKernels(t4), this.registry[t4].dispose(), delete this.registry[t4]), delete this.registryFactory[t4], this.backendName === t4 && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
    }, t3.prototype.getSortedBackends = function() {
      var t4 = this;
      if (0 === Object.keys(this.registryFactory).length)
        throw new Error("No backend found in registry.");
      return Object.keys(this.registryFactory).sort(function(e2, n2) {
        return t4.registryFactory[n2].priority - t4.registryFactory[e2].priority;
      });
    }, t3.prototype.initializeBackendsAndReturnBest = function() {
      for (var t4 = this.getSortedBackends(), e2 = 0; e2 < t4.length; e2++) {
        var n2 = t4[e2], r2 = this.initializeBackend(n2), o2 = r2.success, a2 = r2.asyncInit;
        if (a2 || o2)
          return { name: n2, asyncInit: a2 };
      }
      throw new Error("Could not initialize any backends, all backend initializations failed.");
    }, t3.prototype.moveData = function(t4, e2) {
      var n2 = this.state.tensorInfo.get(e2), r2 = n2.backend, o2 = this.readSync(e2);
      r2.disposeData(e2), n2.backend = t4, t4.move(e2, o2, n2.shape, n2.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }, t3.prototype.tidy = function(t4, e2) {
      var n2, r2 = this, o2 = null;
      if (null == e2) {
        if ("function" != typeof t4)
          throw new Error("Please provide a function to tidy()");
        e2 = t4;
      } else {
        if ("string" != typeof t4 && !(t4 instanceof String))
          throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
        if ("function" != typeof e2)
          throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
        o2 = t4;
      }
      return this.scopedRun(function() {
        return r2.startScope(o2);
      }, function() {
        return r2.endScope(n2);
      }, function() {
        return (n2 = e2()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n2;
      });
    }, t3.prototype.scopedRun = function(t4, e2, n2) {
      t4();
      try {
        var r2 = n2();
        return e2(), r2;
      } catch (t5) {
        throw e2(), t5;
      }
    }, t3.prototype.nextTensorId = function() {
      return t3.nextTensorId++;
    }, t3.prototype.nextVariableId = function() {
      return t3.nextVariableId++;
    }, t3.prototype.clone = function(t4) {
      var e2 = this.makeTensorFromDataId(t4.dataId, t4.shape, t4.dtype), n2 = { x: t4 };
      return this.addTapeNode(this.state.activeScope.name, n2, [e2], function(t5) {
        return { x: function() {
          return t5.toFloat();
        } };
      }, []), e2;
    }, t3.prototype.runKernel = function(t4, e2, n2, r2, o2) {
      return this.runKernelFunc(null, e2, null, t4, n2, r2, o2);
    }, t3.prototype.shouldCheckForMemLeaks = function() {
      return this.ENV.getBool("IS_TEST");
    }, t3.prototype.checkKernelForMemLeak = function(t4, e2, n2) {
      var r2 = this.backend.numDataIds(), o2 = 0;
      n2.forEach(function(t5) {
        o2 += "complex64" === t5.dtype ? 3 : 1;
      });
      var a2 = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i2 = r2 - e2 - o2 - a2;
      if (i2 > 0)
        throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + i2 + " data ids) after running '" + t4 + "'");
    }, t3.prototype.runKernelFunc = function(t4, e2, n2, r2, o2, a2, i2) {
      var u2, c2 = this;
      void 0 === a2 && (a2 = []), void 0 === i2 && (i2 = []);
      var l3, h = [], f2 = this.isTapeOn(), p2 = null != this.state.activeScope ? this.state.activeScope.name : "", d2 = function(t5) {
        f2 && (h = t5.map(function(t6) {
          return c2.keep(c2.clone(t6));
        }));
      }, v2 = this.state.numBytes, m2 = this.state.numTensors;
      this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
      var g2, y2 = s(r2, this.backendName);
      return l3 = null != y2 ? function() {
        var t5 = c2.backend.numDataIds();
        g2 = y2.kernelFunc({ inputs: e2, attrs: o2, backend: c2.backend });
        var n3 = Array.isArray(g2) ? g2 : [g2];
        c2.shouldCheckForMemLeaks() && c2.checkKernelForMemLeak(p2, t5, n3);
        var r3 = n3.map(function(t6) {
          var e3 = t6.dataId, n4 = t6.shape, r4 = t6.dtype;
          return c2.makeTensorFromDataId(e3, n4, r4);
        }), u3 = r3.filter(function(t6, e3) {
          return i2[e3];
        });
        return d2(a2.slice().concat(u3)), r3;
      } : function() {
        var e3 = c2.backend.numDataIds();
        g2 = c2.tidy(function() {
          return t4(c2.backend, d2);
        });
        var n3 = Array.isArray(g2) ? g2 : [g2];
        return c2.shouldCheckForMemLeaks() && c2.checkKernelForMemLeak(p2, e3, n3), n3;
      }, this.scopedRun(function() {
        return c2.state.kernelDepth++;
      }, function() {
        return c2.state.kernelDepth--;
      }, function() {
        u2 = c2.ENV.getBool("DEBUG") ? c2.profiler.profileKernel(p2, e2, function() {
          return l3();
        }) : l3();
      }), f2 && this.addTapeNode(p2, e2, u2, n2, h), this.state.profiling && this.state.activeProfile.kernels.push({ name: p2, bytesAdded: this.state.numBytes - v2, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - m2, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(e2).map(function(t5) {
        return e2[t5].shape;
      }), outputShapes: u2.map(function(t5) {
        return t5.shape;
      }) }), Array.isArray(g2) ? u2 : u2[0];
    }, t3.prototype.makeTensor = function(t4, e2, n2, r2) {
      if (null == t4)
        throw new Error("Values passed to engine.makeTensor() are null");
      n2 = n2 || "float32", r2 = r2 || this.backend;
      var o2 = t4;
      "string" === n2 && W(t4[0]) && (o2 = t4.map(function(t5) {
        return J(t5);
      }));
      var a2 = r2.write(o2, e2, n2), i2 = new dt(e2, n2, a2, this.nextTensorId());
      if (this.incRef(i2, r2), "string" === n2) {
        var u2 = this.state.tensorInfo.get(a2), s2 = L(o2);
        this.state.numBytes += s2 - u2.bytes, u2.bytes = s2;
      }
      return i2;
    }, t3.prototype.makeTensorFromDataId = function(t4, e2, n2, r2) {
      var o2 = new dt(e2, n2 = n2 || "float32", t4, this.nextTensorId());
      return this.incRef(o2, r2), o2;
    }, t3.prototype.makeVariable = function(t4, e2, n2, r2) {
      void 0 === e2 && (e2 = true), n2 = n2 || this.nextVariableId().toString(), null != r2 && r2 !== t4.dtype && (t4 = t4.asType(r2));
      var o2 = new bt(t4, e2, n2, this.nextTensorId());
      if (null != this.state.registeredVariables[o2.name])
        throw new Error("Variable with name " + o2.name + " was already registered");
      return this.state.registeredVariables[o2.name] = o2, this.incRef(o2, this.backend), o2;
    }, t3.prototype.incRef = function(t4, e2) {
      var n2 = this.state.tensorInfo.has(t4.dataId) ? this.state.tensorInfo.get(t4.dataId).refCount : 0;
      if (this.state.numTensors++, "string" === t4.dtype && this.state.numStringTensors++, 0 === n2) {
        this.state.numDataBuffers++;
        var r2 = 0;
        "complex64" !== t4.dtype && "string" !== t4.dtype && (r2 = t4.size * P(t4.dtype)), this.state.tensorInfo.set(t4.dataId, { backend: e2 || this.backend, dtype: t4.dtype, shape: t4.shape, bytes: r2, refCount: 0 }), this.state.numBytes += r2;
      }
      this.state.tensorInfo.get(t4.dataId).refCount++, t4 instanceof bt || this.track(t4);
    }, t3.prototype.disposeTensor = function(t4) {
      if (this.state.tensorInfo.has(t4.dataId)) {
        this.state.numTensors--, "string" === t4.dtype && this.state.numStringTensors--;
        var e2 = this.state.tensorInfo.get(t4.dataId);
        e2.refCount <= 1 ? ("complex64" !== t4.dtype && (this.state.numBytes -= e2.bytes), this.state.numDataBuffers--, e2.backend.disposeData(t4.dataId), this.state.tensorInfo.delete(t4.dataId)) : this.state.tensorInfo.get(t4.dataId).refCount--;
      }
    }, t3.prototype.disposeVariables = function() {
      for (var t4 in this.state.registeredVariables) {
        var e2 = this.state.registeredVariables[t4];
        this.disposeVariable(e2);
      }
    }, t3.prototype.disposeVariable = function(t4) {
      this.disposeTensor(t4), null != this.state.registeredVariables[t4.name] && delete this.state.registeredVariables[t4.name];
    }, t3.prototype.memory = function() {
      var t4 = this.backend.memory();
      return t4.numTensors = this.state.numTensors, t4.numDataBuffers = this.state.numDataBuffers, t4.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t4.unreliable = true, null == t4.reasons && (t4.reasons = []), t4.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t4;
    }, t3.prototype.profile = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2;
        return r(this, function(r2) {
          return this.state.profiling = true, e2 = this.state.numBytes, n2 = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t4(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(t5) {
            return t5.totalBytesSnapshot;
          })), this.state.activeProfile.newBytes = this.state.numBytes - e2, this.state.activeProfile.newTensors = this.state.numTensors - n2, [2, this.state.activeProfile];
        });
      });
    }, t3.prototype.isTapeOn = function() {
      return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
    }, t3.prototype.addTapeNode = function(t4, e2, n2, r2, o2) {
      var a2 = this, i2 = { id: this.state.nextTapeNodeId++, name: t4, inputs: e2, outputs: n2, saved: o2 };
      null != r2 && (i2.gradient = function(t5) {
        return t5 = t5.map(function(t6, e3) {
          if (null == t6) {
            var r3 = n2[e3], o3 = $(r3.size, r3.dtype);
            return a2.makeTensor(o3, r3.shape, r3.dtype);
          }
          return t6;
        }), r2(t5.length > 1 ? t5 : t5[0], o2);
      }), this.state.activeTape.push(i2);
    }, t3.prototype.keep = function(t4) {
      return t4.kept = true, t4;
    }, t3.prototype.startTape = function() {
      0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
    }, t3.prototype.endTape = function() {
      this.state.gradientDepth--;
    }, t3.prototype.startScope = function(t4) {
      var e2 = { track: [], name: "unnamed scope", id: this.state.nextScopeId++ };
      t4 && (e2.name = t4), this.state.scopeStack.push(e2), this.state.activeScope = e2;
    }, t3.prototype.endScope = function(t4) {
      for (var e2 = this, n2 = kt(t4), r2 = new Set(n2.map(function(t5) {
        return t5.id;
      })), o2 = 0; o2 < this.state.activeScope.track.length; o2++) {
        var a2 = this.state.activeScope.track[o2];
        a2.kept || r2.has(a2.id) || a2.dispose();
      }
      var i2 = this.state.scopeStack.pop();
      this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n2.forEach(function(t5) {
        t5.kept || t5.scopeId !== i2.id || e2.track(t5);
      });
    }, t3.prototype.gradients = function(t4, e2, n2, r2) {
      var o2 = this;
      if (void 0 === r2 && (r2 = false), g(e2.length > 0, function() {
        return "gradients() received an empty list of xs.";
      }), null != n2 && "float32" !== n2.dtype)
        throw new Error("dy must have 'float32' dtype, but has '" + n2.dtype + "'");
      var a2 = this.scopedRun(function() {
        return o2.startTape();
      }, function() {
        return o2.endTape();
      }, function() {
        return o2.tidy("forward", t4);
      });
      g(a2 instanceof dt, function() {
        return "The result y returned by f() must be a tensor.";
      });
      var i2 = function(t5, e3, n3) {
        for (var r3 = {}, o3 = {}, a3 = 0; a3 < e3.length; a3++)
          r3[e3[a3].id] = true;
        for (a3 = 0; a3 < t5.length; a3++) {
          var i3 = (d2 = t5[a3]).inputs;
          for (var u2 in i3) {
            for (var s2 = i3[u2], c2 = false, l3 = 0; l3 < e3.length; l3++)
              if (r3[s2.id]) {
                d2.outputs.forEach(function(t6) {
                  return r3[t6.id] = true;
                }), c2 = true, o3[d2.id] = true;
                break;
              }
            if (c2)
              break;
          }
        }
        var h = {};
        h[n3.id] = true;
        var f2 = {};
        for (a3 = t5.length - 1; a3 >= 0; a3--)
          for (i3 = (d2 = t5[a3]).inputs, l3 = 0; l3 < d2.outputs.length; l3++)
            if (h[d2.outputs[l3].id]) {
              for (var u2 in i3)
                h[i3[u2].id] = true, f2[d2.id] = true;
              break;
            }
        var p2 = [];
        for (a3 = 0; a3 < t5.length; a3++) {
          var d2;
          if (o3[(d2 = t5[a3]).id] && f2[d2.id]) {
            var v2 = {};
            for (var u2 in d2.inputs) {
              var m2 = d2.inputs[u2];
              r3[m2.id] && (v2[u2] = m2);
            }
            var g2 = Object.assign({}, d2);
            g2.inputs = v2, g2.outputs = d2.outputs, p2.push(g2);
          }
        }
        return p2;
      }(this.state.activeTape, e2, a2);
      if (!r2 && 0 === i2.length && e2.length > 0)
        throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
      return this.tidy("backward", function() {
        var t5, r3, u2 = {};
        u2[a2.id] = null == n2 ? (t5 = a2.shape, r3 = X(w(t5), "float32"), Nt.makeTensor(r3, t5, "float32")) : n2, function(t6, e3, n3) {
          for (var r4 = function(r5) {
            var o4 = e3[r5], a3 = [];
            if (o4.outputs.forEach(function(e4) {
              var n4 = t6[e4.id];
              null != n4 ? a3.push(n4) : a3.push(null);
            }), null == o4.gradient)
              throw new Error("Cannot compute gradient: gradient function not found for " + o4.name + ".");
            var i3 = o4.gradient(a3), u3 = function(e4) {
              if (!(e4 in i3))
                throw new Error("Cannot backprop through input " + e4 + ". Available gradients found: " + Object.keys(i3) + ".");
              var r6 = n3(function() {
                return i3[e4]();
              });
              if ("float32" !== r6.dtype)
                throw new Error("Error in gradient for op " + o4.name + ". The gradient of input " + e4 + " must have 'float32' dtype, but has '" + r6.dtype + "'");
              var a4 = o4.inputs[e4];
              if (!C(r6.shape, a4.shape))
                throw new Error("Error in gradient for op " + o4.name + ". The gradient of input '" + e4 + "' has shape '" + r6.shape + "', which does not match the shape of the input '" + a4.shape + "'");
              if (null == t6[a4.id])
                t6[a4.id] = r6;
              else {
                var u4 = t6[a4.id];
                t6[a4.id] = u4.add(r6), u4.dispose();
              }
            };
            for (var s3 in o4.inputs)
              u3(s3);
          }, o3 = e3.length - 1; o3 >= 0; o3--)
            r4(o3);
        }(u2, i2, function(t6) {
          return o2.tidy(t6);
        });
        var s2 = e2.map(function(t6) {
          return u2[t6.id];
        });
        return 0 === o2.state.gradientDepth && (o2.state.activeTape.forEach(function(t6) {
          for (var e3 in t6.saved)
            t6.saved[e3].dispose();
        }), o2.state.activeTape = null), { value: a2, grads: s2 };
      });
    }, t3.prototype.customGrad = function(t4) {
      var e2 = this;
      return g(G(t4), function() {
        return "The f passed in customGrad(f) must be a function.";
      }), function() {
        for (var n2, r2 = [], o2 = 0; o2 < arguments.length; o2++)
          r2[o2] = arguments[o2];
        g(r2.every(function(t5) {
          return t5 instanceof dt;
        }), function() {
          return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
        });
        var a2 = {};
        return r2.forEach(function(t5, e3) {
          a2[e3] = t5;
        }), e2.runKernelFunc(function(e3, o3) {
          return g((n2 = t4.apply(void 0, r2.concat([o3]))).value instanceof dt, function() {
            return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
          }), g(G(n2.gradFunc), function() {
            return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
          }), n2.value;
        }, a2, function(t5, e3) {
          var o3 = n2.gradFunc(t5, e3), a3 = Array.isArray(o3) ? o3 : [o3];
          g(a3.length === r2.length, function() {
            return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
          }), g(a3.every(function(t6) {
            return t6 instanceof dt;
          }), function() {
            return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
          });
          var i2 = {};
          return a3.forEach(function(t6, e4) {
            i2[e4] = function() {
              return t6;
            };
          }), i2;
        });
      };
    }, t3.prototype.readSync = function(t4) {
      return this.state.tensorInfo.get(t4).backend.readSync(t4);
    }, t3.prototype.read = function(t4) {
      return this.state.tensorInfo.get(t4).backend.read(t4);
    }, t3.prototype.fromPixels = function(t4, e2) {
      return this.backend.fromPixels(t4, e2);
    }, t3.prototype.time = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              return e2 = Y(), [4, this.backend.time(t4)];
            case 1:
              return (n2 = r2.sent()).wallMs = Y() - e2, [2, n2];
          }
        });
      });
    }, t3.prototype.track = function(t4) {
      return null != this.state.activeScope && (t4.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t4)), t4;
    }, Object.defineProperty(t3.prototype, "registeredVariables", { get: function() {
      return this.state.registeredVariables;
    }, enumerable: true, configurable: true }), t3.prototype.reset = function() {
      for (var t4 in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Dt(), this.registry)
        this.disposeRegisteredKernels(t4), this.registry[t4].dispose(), delete this.registry[t4];
      this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
    }, t3.nextTensorId = 0, t3.nextVariableId = 0, t3;
  }();
  var Nt = function() {
    var t3 = function() {
      if (null == St) {
        var t4 = void 0;
        if ("undefined" != typeof window)
          t4 = window;
        else if ("undefined" != typeof global)
          t4 = global;
        else if ("undefined" != typeof process)
          t4 = process;
        else {
          if ("undefined" == typeof self)
            throw new Error("Could not find a global object");
          t4 = self;
        }
        St = t4;
      }
      return St;
    }();
    if (null == t3._tfengine) {
      var e2 = new o(t3);
      t3._tfengine = new Tt(e2);
    }
    return function(t4) {
      i = t4;
    }(t3._tfengine.ENV), ht = function() {
      return t3._tfengine;
    }, t3._tfengine;
  }();
  function Ft() {
    return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
  }
  var Ot = a();
  Ot.registerFlag("DEBUG", function() {
    return false;
  }, function(t3) {
    t3 && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
  }), Ot.registerFlag("IS_BROWSER", function() {
    return Ft();
  }), Ot.registerFlag("IS_NODE", function() {
    return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
  }), Ot.registerFlag("IS_CHROME", function() {
    return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }), Ot.registerFlag("PROD", function() {
    return false;
  }), Ot.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function() {
    return Ot.getBool("DEBUG");
  }), Ot.registerFlag("DEPRECATION_WARNINGS_ENABLED", function() {
    return true;
  }), Ot.registerFlag("IS_TEST", function() {
    return false;
  });
  var _t;
  var Mt;
  var Bt;
  var Pt = {};
  var Lt = { alpha: false, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: true };
  function Wt(t3, e2) {
    Pt[t3] = e2;
  }
  function Ut(t3) {
    t3 in Pt || (Pt[t3] = function(t4) {
      if (1 !== t4 && 2 !== t4)
        throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
      var e3 = Vt(t4);
      if (e3.addEventListener("webglcontextlost", function(e4) {
        e4.preventDefault(), delete Pt[t4];
      }, false), 1 === t4)
        return e3.getContext("webgl", Lt) || e3.getContext("experimental-webgl", Lt);
      return e3.getContext("webgl2", Lt);
    }(t3));
    var e2 = Pt[t3];
    return e2.isContextLost() ? (delete Pt[t3], Ut(t3)) : (e2.disable(e2.DEPTH_TEST), e2.disable(e2.STENCIL_TEST), e2.disable(e2.BLEND), e2.disable(e2.DITHER), e2.disable(e2.POLYGON_OFFSET_FILL), e2.disable(e2.SAMPLE_COVERAGE), e2.enable(e2.SCISSOR_TEST), e2.enable(e2.CULL_FACE), e2.cullFace(e2.BACK), Pt[t3]);
  }
  function Vt(t3) {
    if ("undefined" != typeof OffscreenCanvas && 2 === t3)
      return new OffscreenCanvas(300, 150);
    if ("undefined" != typeof document)
      return document.createElement("canvas");
    throw new Error("Cannot create a canvas in this context");
  }
  function zt(t3, e2) {
    return [e2, t3];
  }
  function Gt(t3) {
    var e2 = w(t3);
    return I(Math.ceil(e2 / 4));
  }
  function Ht(t3, e2) {
    return [Math.max(1, Math.ceil(e2 / 2)), Math.max(1, Math.ceil(t3 / 2))];
  }
  function qt(t3, e2) {
    var n2, r2, o2, i2, u2, s2, c2, l3, h, f2 = t3;
    return 2 === a().getNumber("WEBGL_VERSION") ? (n2 = f2.R32F, r2 = f2.R16F, o2 = f2.RGBA16F, i2 = f2.RGBA32F, u2 = f2.RED, s2 = 4, c2 = 1, l3 = f2.HALF_FLOAT, h = f2.FLOAT) : (n2 = t3.RGBA, r2 = t3.RGBA, o2 = t3.RGBA, i2 = f2.RGBA, u2 = t3.RGBA, s2 = 4, c2 = 4, l3 = null != e2 ? e2.HALF_FLOAT_OES : null, h = t3.FLOAT), { internalFormatFloat: n2, internalFormatHalfFloat: r2, internalFormatPackedHalfFloat: o2, internalFormatPackedFloat: i2, textureFormatFloat: u2, downloadTextureFormat: t3.RGBA, downloadUnpackNumChannels: s2, defaultNumChannels: c2, textureTypeHalfFloat: l3, textureTypeFloat: h };
  }
  function Kt(t3, e2, n2) {
    var r2 = n2();
    return e2 && function(t4) {
      var e3 = t4.getError();
      if (e3 !== t4.NO_ERROR)
        throw new Error("WebGL Error: " + Yt(t4, e3));
    }(t3), r2;
  }
  !function(t3) {
    t3[t3.DENSE = 0] = "DENSE", t3[t3.SHARED_BATCH = 1] = "SHARED_BATCH";
  }(_t || (_t = {})), function(t3) {
    t3[t3.RENDER = 0] = "RENDER", t3[t3.UPLOAD = 1] = "UPLOAD", t3[t3.PIXELS = 2] = "PIXELS", t3[t3.DOWNLOAD = 3] = "DOWNLOAD";
  }(Mt || (Mt = {})), function(t3) {
    t3[t3.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t3[t3.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t3[t3.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t3[t3.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t3[t3.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
  }(Bt || (Bt = {}));
  var jt = 596e-10;
  var Xt = 65504;
  function $t(t3) {
    return !!(a().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t3 || jt < Math.abs(t3) && Math.abs(t3) < Xt);
  }
  function Yt(t3, e2) {
    switch (e2) {
      case t3.NO_ERROR:
        return "NO_ERROR";
      case t3.INVALID_ENUM:
        return "INVALID_ENUM";
      case t3.INVALID_VALUE:
        return "INVALID_VALUE";
      case t3.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case t3.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case t3.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      case t3.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      default:
        return "Unknown error code " + e2;
    }
  }
  function Qt(t3, e2, n2) {
    return be(t3, e2, function() {
      return t3.getExtension(n2);
    }, 'Extension "' + n2 + '" not supported on this browser.');
  }
  function Jt(t3, e2, n2) {
    var r2 = be(t3, e2, function() {
      return t3.createShader(t3.VERTEX_SHADER);
    }, "Unable to create vertex WebGLShader.");
    if (Kt(t3, e2, function() {
      return t3.shaderSource(r2, n2);
    }), Kt(t3, e2, function() {
      return t3.compileShader(r2);
    }), false === t3.getShaderParameter(r2, t3.COMPILE_STATUS))
      throw console.log(t3.getShaderInfoLog(r2)), new Error("Failed to compile vertex shader.");
    return r2;
  }
  function Zt(t3, e2, n2) {
    var r2 = be(t3, e2, function() {
      return t3.createShader(t3.FRAGMENT_SHADER);
    }, "Unable to create fragment WebGLShader.");
    if (Kt(t3, e2, function() {
      return t3.shaderSource(r2, n2);
    }), Kt(t3, e2, function() {
      return t3.compileShader(r2);
    }), false === t3.getShaderParameter(r2, t3.COMPILE_STATUS))
      throw function(t4, e3) {
        var n3 = ne.exec(e3);
        if (null == n3)
          return console.log("Couldn't parse line number in error: " + e3), void console.log(t4);
        for (var r3 = +n3[1], o2 = t4.split("\n"), a2 = o2.length.toString().length + 2, i2 = o2.map(function(t5, e4) {
          return k((e4 + 1).toString(), a2) + t5;
        }), u2 = 0, s2 = 0; s2 < i2.length; s2++)
          u2 = Math.max(i2[s2].length, u2);
        var c2 = i2.slice(0, r3 - 1), l3 = i2.slice(r3 - 1, r3), h = i2.slice(r3);
        console.log(c2.join("\n")), console.log(e3.split("\n")[0]), console.log("%c " + k(l3[0], u2), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h.join("\n"));
      }(n2, t3.getShaderInfoLog(r2)), new Error("Failed to compile fragment shader.");
    return r2;
  }
  var te;
  var ee;
  var ne = /ERROR: [0-9]+:([0-9]+):/g;
  function re(t3, e2) {
    return be(t3, e2, function() {
      return t3.createProgram();
    }, "Unable to create WebGLProgram.");
  }
  function oe(t3, e2, n2) {
    if (Kt(t3, e2, function() {
      return t3.linkProgram(n2);
    }), false === t3.getProgramParameter(n2, t3.LINK_STATUS))
      throw console.log(t3.getProgramInfoLog(n2)), new Error("Failed to link vertex and fragment shaders.");
  }
  function ae(t3, e2, n2) {
    if (Kt(t3, e2, function() {
      return t3.validateProgram(n2);
    }), false === t3.getProgramParameter(n2, t3.VALIDATE_STATUS))
      throw console.log(t3.getProgramInfoLog(n2)), new Error("Shader program validation failed.");
  }
  function ie(t3, e2, n2) {
    var r2 = be(t3, e2, function() {
      return t3.createBuffer();
    }, "Unable to create WebGLBuffer");
    return Kt(t3, e2, function() {
      return t3.bindBuffer(t3.ARRAY_BUFFER, r2);
    }), Kt(t3, e2, function() {
      return t3.bufferData(t3.ARRAY_BUFFER, n2, t3.STATIC_DRAW);
    }), r2;
  }
  function ue(t3, e2, n2) {
    var r2 = be(t3, e2, function() {
      return t3.createBuffer();
    }, "Unable to create WebGLBuffer");
    return Kt(t3, e2, function() {
      return t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, r2);
    }), Kt(t3, e2, function() {
      return t3.bufferData(t3.ELEMENT_ARRAY_BUFFER, n2, t3.STATIC_DRAW);
    }), r2;
  }
  function se(t3, e2) {
    return be(t3, e2, function() {
      return t3.createTexture();
    }, "Unable to create WebGLTexture.");
  }
  function ce(t3, e2) {
    var n2 = a().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (t3 <= 0 || e2 <= 0) {
      var r2 = "[" + t3 + "x" + e2 + "]";
      throw new Error("Requested texture size " + r2 + " is invalid.");
    }
    if (t3 > n2 || e2 > n2) {
      r2 = "[" + t3 + "x" + e2 + "]";
      throw new Error("Requested texture size " + r2 + " greater than WebGL maximum on this browser / GPU " + ("[" + n2 + "x" + n2 + "]") + ".");
    }
  }
  function le(t3, e2) {
    return be(t3, e2, function() {
      return t3.createFramebuffer();
    }, "Unable to create WebGLFramebuffer.");
  }
  function he(t3, e2, n2, r2, o2, a2, i2, u2) {
    var s2 = t3.getAttribLocation(n2, r2);
    return -1 !== s2 && (Kt(t3, e2, function() {
      return t3.bindBuffer(t3.ARRAY_BUFFER, o2);
    }), Kt(t3, e2, function() {
      return t3.vertexAttribPointer(s2, a2, t3.FLOAT, false, i2, u2);
    }), Kt(t3, e2, function() {
      return t3.enableVertexAttribArray(s2);
    }), true);
  }
  function fe(t3, e2, n2, r2) {
    we(t3, r2), Kt(t3, e2, function() {
      return t3.activeTexture(t3.TEXTURE0 + r2);
    }), Kt(t3, e2, function() {
      return t3.bindTexture(t3.TEXTURE_2D, n2);
    });
  }
  function pe(t3, e2, n2, r2) {
    return be(t3, e2, function() {
      return t3.getUniformLocation(n2, r2);
    }, 'uniform "' + r2 + '" not present in program.');
  }
  function de(t3, e2, n2) {
    return t3.getUniformLocation(e2, n2);
  }
  function ve(t3, e2, n2, r2, o2, a2) {
    Kt(t3, e2, function() {
      return fe(t3, e2, r2, a2);
    }), Kt(t3, e2, function() {
      return t3.uniform1i(o2, a2);
    });
  }
  function me(t3, e2, n2, r2) {
    Kt(t3, e2, function() {
      return t3.bindFramebuffer(t3.FRAMEBUFFER, r2);
    }), Kt(t3, e2, function() {
      return t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, n2, 0);
    });
  }
  function ge(t3, e2, n2) {
    Kt(t3, e2, function() {
      return t3.bindFramebuffer(t3.FRAMEBUFFER, n2);
    }), Kt(t3, e2, function() {
      return t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, null, 0);
    });
  }
  function ye(t3) {
    var e2 = t3.checkFramebufferStatus(t3.FRAMEBUFFER);
    if (e2 !== t3.FRAMEBUFFER_COMPLETE)
      throw new Error("Error binding framebuffer: " + xe(t3, e2));
  }
  function xe(t3, e2) {
    switch (e2) {
      case t3.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case t3.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case t3.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case t3.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
      default:
        return "unknown error " + e2;
    }
  }
  function be(t3, e2, n2, r2) {
    var o2 = Kt(t3, e2, function() {
      return n2();
    });
    if (null == o2)
      throw new Error(r2);
    return o2;
  }
  function we(t3, e2) {
    var n2 = t3.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r2 = e2 + t3.TEXTURE0;
    if (r2 < t3.TEXTURE0 || r2 > n2)
      throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + n2 + "]") + ".");
  }
  function Ce(t3, e2) {
    return void 0 === e2 && (e2 = 2), w(t3.slice(0, t3.length - e2));
  }
  function Ee(t3) {
    if (0 === t3.length)
      throw Error("Cannot get rows and columns of an empty shape array.");
    return [t3.length > 1 ? t3[t3.length - 2] : 1, t3[t3.length - 1]];
  }
  function Re(t3) {
    var e2 = [1, 1, 1];
    return 0 === t3.length || 1 === t3.length && 1 === t3[0] || (e2 = [Ce(t3)].concat(Ee(t3))), e2;
  }
  function Ie(t3, e2) {
    var n2;
    void 0 === e2 && (e2 = false);
    var r2 = a().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (e2 && (r2 *= 2, 1 === (t3 = t3.map(function(e3, n3) {
      return n3 >= t3.length - 2 ? v(t3[n3]) : t3[n3];
    })).length && (t3 = [2, t3[0]])), 2 !== t3.length) {
      var o2 = T(t3);
      t3 = o2.newShape;
    }
    var i2 = w(t3);
    if (t3.length <= 1 && i2 <= r2)
      return [1, i2];
    if (2 === t3.length && t3[0] <= r2 && t3[1] <= r2)
      return t3;
    if (3 === t3.length && t3[0] * t3[1] <= r2 && t3[2] <= r2)
      return [t3[0] * t3[1], t3[2]];
    if (3 === t3.length && t3[0] <= r2 && t3[1] * t3[2] <= r2)
      return [t3[0], t3[1] * t3[2]];
    if (4 === t3.length && t3[0] * t3[1] * t3[2] <= r2 && t3[3] <= r2)
      return [t3[0] * t3[1] * t3[2], t3[3]];
    if (4 === t3.length && t3[0] <= r2 && t3[1] * t3[2] * t3[3] <= r2)
      return [t3[0], t3[1] * t3[2] * t3[3]];
    if (e2) {
      var u2 = Ce(t3), s2 = 2, c2 = 2;
      return t3.length && (s2 = (n2 = Ee(t3))[0], c2 = n2[1]), I(i2 = u2 * (s2 / 2) * (c2 / 2)).map(function(t4) {
        return 2 * t4;
      });
    }
    return I(i2);
  }
  function ke(t3) {
    return t3 % 2 == 0;
  }
  function Se(t3, e2) {
    if (C(t3 = t3.slice(-2), e2 = e2.slice(-2)))
      return true;
    if (!t3.length || !e2.length)
      return true;
    if (0 === t3[0] || 0 === t3[1] || 0 === e2[0] || 0 === e2[1])
      return true;
    if (t3.length !== e2.length) {
      var n2 = t3.slice(-1)[0], r2 = e2.slice(-1)[0];
      if (n2 === r2)
        return true;
      if (ke(n2) && ke(r2) && (1 === t3[0] || 1 === e2[0]))
        return true;
    }
    return t3[1] === e2[1] && ke(t3[0]) && ke(e2[0]);
  }
  function Ae(t3) {
    if (null == te) {
      var e2 = Ut(t3);
      te = e2.getParameter(e2.MAX_TEXTURE_SIZE);
    }
    return te;
  }
  function De(t3) {
    if (null == ee) {
      var e2 = Ut(t3);
      ee = e2.getParameter(e2.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, ee);
  }
  function Te(t3) {
    if (0 === t3)
      return 0;
    var e2 = Ut(t3);
    return Ne(e2, "EXT_disjoint_timer_query_webgl2") && 2 === t3 ? 2 : Ne(e2, "EXT_disjoint_timer_query") ? 1 : 0;
  }
  function Ne(t3, e2) {
    return null != t3.getExtension(e2);
  }
  function Fe(t3) {
    try {
      if (null != Ut(t3))
        return true;
    } catch (t4) {
      return false;
    }
    return false;
  }
  function Oe(t3) {
    if (0 === t3)
      return false;
    var e2 = Ut(t3);
    if (1 === t3) {
      if (!Ne(e2, "OES_texture_float"))
        return false;
    } else if (!Ne(e2, "EXT_color_buffer_float"))
      return false;
    return Me(e2);
  }
  function _e(t3) {
    if (0 === t3)
      return false;
    var e2 = Ut(t3);
    if (1 !== t3) {
      if (Ne(e2, "EXT_color_buffer_float"))
        return Me(e2);
      if (Ne(e2, "EXT_color_buffer_half_float")) {
        var n2 = e2.getExtension("EXT_color_buffer_half_float");
        return function(t4, e3) {
          var n3 = qt(t4, e3), r2 = t4.createTexture();
          t4.bindTexture(t4.TEXTURE_2D, r2);
          t4.texImage2D(t4.TEXTURE_2D, 0, n3.internalFormatHalfFloat, 1, 1, 0, n3.textureFormatFloat, n3.textureTypeHalfFloat, null);
          var o2 = t4.createFramebuffer();
          t4.bindFramebuffer(t4.FRAMEBUFFER, o2), t4.framebufferTexture2D(t4.FRAMEBUFFER, t4.COLOR_ATTACHMENT0, t4.TEXTURE_2D, r2, 0);
          var a2 = t4.checkFramebufferStatus(t4.FRAMEBUFFER) === t4.FRAMEBUFFER_COMPLETE;
          return t4.bindTexture(t4.TEXTURE_2D, null), t4.bindFramebuffer(t4.FRAMEBUFFER, null), t4.deleteTexture(r2), t4.deleteFramebuffer(o2), a2;
        }(e2, n2);
      }
      return false;
    }
    return !!Ne(e2, "OES_texture_float") && (!!Ne(e2, "WEBGL_color_buffer_float") && Me(e2));
  }
  function Me(t3) {
    var e2 = qt(t3), n2 = t3.createTexture();
    t3.bindTexture(t3.TEXTURE_2D, n2);
    t3.texImage2D(t3.TEXTURE_2D, 0, e2.internalFormatFloat, 1, 1, 0, e2.textureFormatFloat, e2.textureTypeFloat, null);
    var r2 = t3.createFramebuffer();
    t3.bindFramebuffer(t3.FRAMEBUFFER, r2), t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, n2, 0);
    var o2 = t3.checkFramebufferStatus(t3.FRAMEBUFFER) === t3.FRAMEBUFFER_COMPLETE;
    return t3.bindTexture(t3.TEXTURE_2D, null), t3.bindFramebuffer(t3.FRAMEBUFFER, null), t3.deleteTexture(n2), t3.deleteFramebuffer(r2), o2;
  }
  function Be(t3) {
    return 2 === t3 && null != Ut(t3).fenceSync;
  }
  var Pe = Object.freeze({ callAndCheck: Kt, canBeRepresented: $t, getWebGLErrorMessage: Yt, getExtensionOrThrow: Qt, createVertexShader: Jt, createFragmentShader: Zt, createProgram: re, linkProgram: oe, validateProgram: ae, createStaticVertexBuffer: ie, createStaticIndexBuffer: ue, getNumChannels: function() {
    return 2 === a().getNumber("WEBGL_VERSION") ? 1 : 4;
  }, createTexture: se, validateTextureSize: ce, createFramebuffer: le, bindVertexBufferToProgramAttribute: he, bindTextureUnit: fe, unbindTextureUnit: function(t3, e2, n2) {
    we(t3, n2), Kt(t3, e2, function() {
      return t3.activeTexture(t3.TEXTURE0 + n2);
    }), Kt(t3, e2, function() {
      return t3.bindTexture(t3.TEXTURE_2D, null);
    });
  }, getProgramUniformLocationOrThrow: pe, getProgramUniformLocation: de, bindTextureToProgramUniformSampler: ve, bindCanvasToFramebuffer: function(t3, e2) {
    Kt(t3, e2, function() {
      return t3.bindFramebuffer(t3.FRAMEBUFFER, null);
    }), Kt(t3, e2, function() {
      return t3.viewport(0, 0, t3.canvas.width, t3.canvas.height);
    }), Kt(t3, e2, function() {
      return t3.scissor(0, 0, t3.canvas.width, t3.canvas.height);
    });
  }, bindColorTextureToFramebuffer: me, unbindColorTextureFromFramebuffer: ge, validateFramebuffer: ye, getFramebufferErrorMessage: xe, getBatchDim: Ce, getRowsCols: Ee, getShapeAs3D: Re, getTextureShapeFromLogicalShape: Ie, isReshapeFree: Se, getWebGLMaxTextureSize: Ae, resetMaxTextureSize: function() {
    te = null;
  }, resetMaxTexturesInShader: function() {
    ee = null;
  }, getMaxTexturesInShader: De, getWebGLDisjointQueryTimerVersion: Te, hasExtension: Ne, isWebGLVersionEnabled: Fe, isCapableOfRenderingToFloatTexture: Oe, isDownloadFloatTextureEnabled: _e, isWebGLFenceEnabled: Be });
  var Le = a();
  function ze(t3) {
    a().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t3 + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
  }
  function qe() {
    return Nt.memory();
  }
  function je(t3, e2) {
    return Nt.tidy(t3, e2);
  }
  function Xe(t3) {
    kt(t3).forEach(function(t4) {
      return t4.dispose();
    });
  }
  function $e(t3) {
    return Nt.keep(t3);
  }
  function Je() {
    return Nt.ready();
  }
  function on() {
    return Nt.backend;
  }
  function un() {
    for (var t3 = [], e2 = 0; e2 < arguments.length; e2++)
      t3[e2] = arguments[e2];
    a().getBool("IS_TEST") || console.warn.apply(console, t3);
  }
  function sn(t3, e2) {
    var n2 = t3;
    if (B(t3))
      return "string" === e2 ? [] : [t3.length];
    if (!Array.isArray(t3))
      return [];
    for (var r2 = []; Array.isArray(n2) || B(n2) && "string" !== e2; )
      r2.push(n2.length), n2 = n2[0];
    return Array.isArray(t3) && a().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function t4(e3, n3, r3) {
      r3 = r3 || [];
      if (!Array.isArray(e3) && !B(e3))
        return void g(0 === n3.length, function() {
          return "Element arr[" + r3.join("][") + "] is a primitive, but should be an array/TypedArray of " + n3[0] + " elements";
        });
      g(n3.length > 0, function() {
        return "Element arr[" + r3.join("][") + "] should be a primitive, but is an array of " + e3.length + " elements";
      });
      g(e3.length === n3[0], function() {
        return "Element arr[" + r3.join("][") + "] should have " + n3[0] + " elements, but has " + e3.length + " elements";
      });
      var o2 = n3.slice(1);
      for (var a2 = 0; a2 < e3.length; ++a2)
        t4(e3[a2], o2, r3.concat(a2));
    }(t3, r2, []), r2;
  }
  function cn(t3, e2, n2, r2) {
    if (null != t3 && ("numeric" !== t3 && t3 !== e2 || "numeric" === t3 && "string" === e2))
      throw new Error("Argument '" + n2 + "' passed to '" + r2 + "' must be " + t3 + " tensor, but got " + e2 + " tensor");
  }
  function ln(t3, e2, n2, r2) {
    if (void 0 === r2 && (r2 = "numeric"), t3 instanceof dt)
      return cn(r2, t3.dtype, e2, n2), t3;
    var o2 = z(t3);
    if ("string" !== o2 && ["bool", "int32", "float32"].indexOf(r2) >= 0 && (o2 = r2), cn(r2, o2, e2, n2), null == t3 || !B(t3) && !Array.isArray(t3) && "number" != typeof t3 && "boolean" != typeof t3 && "string" != typeof t3) {
      var i2 = null == t3 ? "null" : t3.constructor.name;
      throw new Error("Argument '" + e2 + "' passed to '" + n2 + "' must be a Tensor or TensorLike, but got '" + i2 + "'");
    }
    var u2 = sn(t3, o2);
    B(t3) || Array.isArray(t3) || (t3 = [t3]);
    var s2 = "string" !== o2 ? K(t3, o2, a().getBool("DEBUG")) : b(t3, [], true);
    return Nt.makeTensor(s2, u2, o2);
  }
  function hn(t3, e2, n2, r2) {
    if (void 0 === r2 && (r2 = "numeric"), !Array.isArray(t3))
      throw new Error("Argument " + e2 + " passed to " + n2 + " must be a `Tensor[]` or `TensorLike[]`");
    return t3.map(function(t4, r3) {
      return ln(t4, e2 + "[" + r3 + "]", n2);
    }, r2);
  }
  function fn(t3, e2) {
    for (var n2 = 0; n2 < t3.length; ++n2)
      if (t3[t3.length - n2 - 1] !== e2 - 1 - n2)
        return false;
    return true;
  }
  function pn(t3, e2, n2) {
    for (var r2 = t3.length + e2.length, o2 = [], a2 = 0, i2 = 0, u2 = 0; u2 < r2; u2++)
      -1 === n2.indexOf(u2) ? o2.push(t3[a2++]) : o2.push(e2[i2++]);
    return o2;
  }
  function dn(t3, e2) {
    for (var n2 = [], r2 = t3.length, o2 = 0; o2 < r2; o2++)
      -1 === e2.indexOf(o2) && n2.push(t3[o2]);
    return [n2, e2.map(function(e3) {
      return t3[e3];
    })];
  }
  function vn(t3, e2) {
    return pn(t3, e2.map(function(t4) {
      return 1;
    }), e2);
  }
  function mn(t3, e2, n2) {
    g(fn(e2, n2), function() {
      return t3 + " supports only inner-most axes for now. Got axes " + e2 + " and rank-" + n2 + " input.";
    });
  }
  function gn(t3, e2) {
    if (fn(t3, e2))
      return null;
    for (var n2 = [], r2 = 0; r2 < e2; ++r2)
      -1 === t3.indexOf(r2) && n2.push(r2);
    return t3.forEach(function(t4) {
      return n2.push(t4);
    }), n2;
  }
  function yn(t3) {
    return t3.map(function(t4, e2) {
      return [e2, t4];
    }).sort(function(t4, e2) {
      return t4[1] - e2[1];
    }).map(function(t4) {
      return t4[0];
    });
  }
  function xn(t3, e2) {
    for (var n2 = [], r2 = e2 - t3; r2 < e2; ++r2)
      n2.push(r2);
    return n2;
  }
  function bn(t3, e2) {
    var n2 = t3[0].length;
    t3.forEach(function(t4, e3) {
      g(t4.length === n2, function() {
        return "Error in concat" + n2 + "D: rank of tensors[" + e3 + "] must be the same as the rank of the rest (" + n2 + ")";
      });
    }), g(e2 >= 0 && e2 < n2, function() {
      return "Error in concat" + n2 + "D: axis must be between 0 and " + (n2 - 1) + ".";
    });
    var r2 = t3[0];
    t3.forEach(function(t4, o2) {
      for (var a2 = 0; a2 < n2; a2++)
        g(a2 === e2 || t4[a2] === r2[a2], function() {
          return "Error in concat" + n2 + "D: Shape of tensors[" + o2 + "] (" + t4 + ") does not match the shape of the rest (" + r2 + ") along the non-concatenated axis " + o2 + ".";
        });
    });
  }
  function wn(t3, e2) {
    for (var n2 = t3[0].slice(), r2 = 1; r2 < t3.length; r2++)
      n2[e2] += t3[r2][e2];
    return n2;
  }
  function Cn(t3) {
    var e2 = Object.keys(t3);
    if (1 !== e2.length)
      throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e2.length + " keys.");
    var n2 = e2[0], r2 = t3[n2];
    n2.endsWith("_") && (n2 = n2.substring(0, n2.length - 1));
    var o2 = function() {
      for (var t4 = [], e3 = 0; e3 < arguments.length; e3++)
        t4[e3] = arguments[e3];
      Nt.startScope(n2);
      try {
        var o3 = r2.apply(void 0, t4);
        return o3 instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Nt.endScope(o3), o3;
      } catch (t5) {
        throw Nt.endScope(null), t5;
      }
    };
    return Object.defineProperty(o2, "name", { value: n2, configurable: true }), o2;
  }
  Le.registerFlag("HAS_WEBGL", function() {
    return Le.getNumber("WEBGL_VERSION") > 0;
  }), Le.registerFlag("WEBGL_VERSION", function() {
    return Fe(2) ? 2 : Fe(1) ? 1 : 0;
  }), Le.registerFlag("WEBGL_BUFFER_SUPPORTED", function() {
    return 2 === Le.get("WEBGL_VERSION");
  }), Le.registerFlag("WEBGL_CPU_FORWARD", function() {
    return true;
  }), Le.registerFlag("WEBGL_FORCE_F16_TEXTURES", function() {
    return false;
  }), Le.registerFlag("WEBGL_PACK", function() {
    return Le.getBool("HAS_WEBGL");
  }), Le.registerFlag("WEBGL_PACK_NORMALIZATION", function() {
    return Le.getBool("WEBGL_PACK");
  }), Le.registerFlag("WEBGL_PACK_CLIP", function() {
    return Le.getBool("WEBGL_PACK");
  }), Le.registerFlag("WEBGL_PACK_DEPTHWISECONV", function() {
    return false;
  }), Le.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function() {
    return Le.getBool("WEBGL_PACK");
  }), Le.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function() {
    return Le.getBool("WEBGL_PACK");
  }), Le.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function() {
    return Le.getBool("WEBGL_PACK");
  }), Le.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function() {
    return Le.getBool("WEBGL_PACK");
  }), Le.registerFlag("WEBGL_PACK_REDUCE", function() {
    return Le.getBool("WEBGL_PACK");
  }), Le.registerFlag("WEBGL_LAZILY_UNPACK", function() {
    return Le.getBool("WEBGL_PACK");
  }), Le.registerFlag("WEBGL_CONV_IM2COL", function() {
    return Le.getBool("WEBGL_PACK");
  }), Le.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function() {
    return Ae(Le.getNumber("WEBGL_VERSION"));
  }), Le.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function() {
    return De(Le.getNumber("WEBGL_VERSION"));
  }), Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function() {
    var t3 = Le.getNumber("WEBGL_VERSION");
    return 0 === t3 ? 0 : Te(t3);
  }), Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function() {
    return Le.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t3 = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t3) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t3.substr(0, 4))));
    var t3;
  }), Le.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function() {
    return Oe(Le.getNumber("WEBGL_VERSION"));
  }), Le.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function() {
    return !Le.getBool("WEBGL_FORCE_F16_TEXTURES") && Le.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
  }), Le.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function() {
    return _e(Le.getNumber("WEBGL_VERSION"));
  }), Le.registerFlag("WEBGL_FENCE_API_ENABLED", function() {
    return Be(Le.getNumber("WEBGL_VERSION"));
  }), Le.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function() {
    return Le.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
  }), pt = ze;
  var En = Cn({ complex_: function(t3, e2) {
    var n2 = ln(t3, "real", "complex"), r2 = ln(e2, "imag", "complex");
    return y(n2.shape, r2.shape, "real and imag shapes, " + n2.shape + " and " + r2.shape + ", must match in call to tf.complex()."), Nt.runKernelFunc(function(t4) {
      return t4.complex(n2, r2);
    }, { $real: n2, $imag: r2 });
  } });
  var Rn = Cn({ real_: function(t3) {
    var e2 = ln(t3, "input", "real");
    return Nt.runKernelFunc(function(t4) {
      return t4.real(e2);
    }, { $input: e2 });
  } });
  var In = Cn({ imag_: function(t3) {
    var e2 = ln(t3, "input", "imag");
    return Nt.runKernelFunc(function(t4) {
      return t4.imag(e2);
    }, { $input: e2 });
  } });
  function kn(t3, e2, n2) {
    return Sn(t3, e2, sn(t3, n2), n2);
  }
  function Sn(t3, e2, n2, r2) {
    if (null == r2 && (r2 = z(t3)), "complex64" === r2)
      throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
    if (!B(t3) && !Array.isArray(t3) && "number" != typeof t3 && "boolean" != typeof t3 && "string" != typeof t3)
      throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    if (null != e2) {
      Q(e2);
      var o2 = w(e2), i2 = w(n2);
      g(o2 === i2, function() {
        return "Based on the provided shape, [" + e2 + "], the tensor should have " + o2 + " values but has " + i2;
      });
      for (var u2 = 0; u2 < n2.length; ++u2) {
        var s2 = n2[u2], c2 = u2 !== n2.length - 1 || s2 !== w(e2.slice(u2));
        g(n2[u2] === e2[u2] || !c2, function() {
          return "Error creating a new Tensor. Inferred shape (" + n2 + ") does not match the provided shape (" + e2 + "). ";
        });
      }
    }
    return B(t3) || Array.isArray(t3) || (t3 = [t3]), e2 = e2 || n2, t3 = "string" !== r2 ? K(t3, r2, a().getBool("DEBUG")) : b(t3, [], true), Nt.makeTensor(t3, e2, r2);
  }
  function An(t3, e2) {
    if ((B(t3) && "string" !== e2 || Array.isArray(t3)) && "complex64" !== e2)
      throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    if ("string" === e2 && B(t3) && !(t3 instanceof Uint8Array))
      throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    return Sn(t3, [], [], e2);
  }
  function Dn(t3, e2) {
    x(t3);
    var n2 = sn(t3, e2);
    if (1 !== n2.length)
      throw new Error("tensor1d() requires values to be a flat/TypedArray");
    return Sn(t3, null, n2, e2);
  }
  function Tn(t3, e2, n2) {
    if (x(t3), null != e2 && 2 !== e2.length)
      throw new Error("tensor2d() requires shape to have two numbers");
    var r2 = sn(t3, n2);
    if (2 !== r2.length && 1 !== r2.length)
      throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    if (1 === r2.length && null == e2)
      throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    return Sn(t3, e2, r2, n2);
  }
  function Nn(t3, e2, n2) {
    if (x(t3), null != e2 && 3 !== e2.length)
      throw new Error("tensor3d() requires shape to have three numbers");
    var r2 = sn(t3, n2);
    if (3 !== r2.length && 1 !== r2.length)
      throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
    if (1 === r2.length && null == e2)
      throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
    return Sn(t3, e2, r2, n2);
  }
  function Fn(t3, e2, n2) {
    if (x(t3), null != e2 && 4 !== e2.length)
      throw new Error("tensor4d() requires shape to have four numbers");
    var r2 = sn(t3, n2);
    if (4 !== r2.length && 1 !== r2.length)
      throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
    if (1 === r2.length && null == e2)
      throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
    return Sn(t3, e2, r2, n2);
  }
  function On(t3, e2, n2) {
    if (x(t3), null != e2 && 5 !== e2.length)
      throw new Error("tensor5d() requires shape to have five numbers");
    var r2 = sn(t3, n2);
    if (5 !== r2.length && 1 !== r2.length)
      throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
    if (1 === r2.length && null == e2)
      throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
    return Sn(t3, e2, r2, n2);
  }
  function _n(t3, e2, n2) {
    if (x(t3), null != e2 && 6 !== e2.length)
      throw new Error("tensor6d() requires shape to have six numbers");
    var r2 = sn(t3, n2);
    if (6 !== r2.length && 1 !== r2.length)
      throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
    if (1 === r2.length && null == e2)
      throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
    return Sn(t3, e2 = e2 || r2, r2, n2);
  }
  function Mn(t3, e2, n2, r2) {
    return void 0 === e2 && (e2 = true), Nt.makeVariable(t3, e2, n2, r2);
  }
  function Bn(t3, e2) {
    if (void 0 === e2 && (e2 = "float32"), "complex64" === e2) {
      var n2 = Bn(t3, "float32"), r2 = Pn(t3, "float32");
      return En(n2, r2);
    }
    var o2 = X(w(t3), e2);
    return Nt.makeTensor(o2, t3, e2);
  }
  function Pn(t3, e2) {
    if (void 0 === e2 && (e2 = "float32"), "complex64" === e2) {
      var n2 = Pn(t3, "float32"), r2 = Pn(t3, "float32");
      return En(n2, r2);
    }
    var o2 = $(w(t3), e2);
    return Nt.makeTensor(o2, t3, e2);
  }
  function Ln(t3, e2, n2) {
    return Nt.runKernelFunc(function(r2) {
      return r2.fill(t3, e2, n2);
    }, {});
  }
  function Wn(t3, e2, n2) {
    if (n2 <= 0)
      throw new Error("The number of values should be positive.");
    return Nt.runKernelFunc(function(r2) {
      return r2.linspace(t3, e2, n2);
    }, {});
  }
  function Un(t3, e2, n2, r2) {
    if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32"), 0 === n2)
      throw new Error("Cannot have a step of zero");
    if (t3 === e2 || t3 < e2 && n2 < 0 || e2 < t3 && n2 > 1)
      return Pn([0], r2);
    var o2 = $(Math.abs(Math.ceil((e2 - t3) / n2)), r2);
    e2 < t3 && 1 === n2 && (n2 = -1), o2[0] = t3;
    for (var a2 = 1; a2 < o2.length; a2++)
      o2[a2] = o2[a2 - 1] + n2;
    return Dn(o2, r2);
  }
  var Vn = Cn({ onesLike_: function(t3) {
    var e2 = ln(t3, "x", "onesLike");
    if ("complex64" === e2.dtype) {
      var n2 = Vn(Rn(e2)), r2 = zn(In(e2));
      return En(n2, r2);
    }
    return Nt.runKernelFunc(function(t4) {
      return t4.onesLike(e2);
    }, { $x: e2 }, function(t4, e3) {
      return { $x: function() {
        return zn(t4);
      } };
    });
  } });
  var zn = Cn({ zerosLike_: function(t3) {
    var e2 = ln(t3, "x", "zerosLike");
    return Nt.runKernelFunc(function(t4) {
      return t4.zerosLike(e2);
    }, { $x: e2 }, function(t4, e3) {
      return { $x: function() {
        return zn(t4);
      } };
    });
  } });
  var Gn = Cn({ concat_: function(t3, e2) {
    void 0 === e2 && (e2 = 0), g(t3.length >= 1, function() {
      return "Pass at least one tensor to concat";
    });
    var n2 = hn(t3, "tensors", "concat");
    "complex64" === n2[0].dtype && n2.forEach(function(t4) {
      if ("complex64" !== t4.dtype)
        throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t4.dtype + ". ");
    }), e2 = D(e2, n2[0].shape)[0];
    var r2 = wn(n2.map(function(t4) {
      return t4.shape;
    }), e2);
    if (0 === w(r2))
      return kn([], r2);
    if (1 === (n2 = n2.filter(function(t4) {
      return t4.size > 0;
    })).length)
      return n2[0];
    var o2 = n2.map(function(t4) {
      return t4.shape;
    });
    bn(o2, e2);
    var a2 = n2;
    return Nt.runKernelFunc(function(t4) {
      return t4.concat(n2, e2);
    }, a2, function(t4) {
      var n3 = o2.map(function(t5) {
        return t5[e2];
      });
      return Xn(t4, n3, e2).map(function(t5) {
        return function() {
          return t5;
        };
      });
    });
  } });
  var Hn = Cn({ concat1d_: function(t3) {
    return Gn(t3, 0);
  } });
  var qn = Cn({ concat2d_: function(t3, e2) {
    return Gn(t3, e2);
  } });
  var Kn = Cn({ concat3d_: function(t3, e2) {
    return Gn(t3, e2);
  } });
  var jn = Cn({ concat4d_: function(t3, e2) {
    return Gn(t3, e2);
  } });
  var Xn = Cn({ split_: function(t3, e2, n2) {
    void 0 === n2 && (n2 = 0);
    var r2, o2 = ln(t3, "x", "split");
    return n2 = D(n2, o2.shape)[0], "number" == typeof e2 ? (g(o2.shape[n2] % e2 == 0, function() {
      return "Number of splits must evenly divide the axis.";
    }), r2 = new Array(e2).fill(o2.shape[n2] / e2)) : (g(o2.shape[n2] === e2.reduce(function(t4, e3) {
      return t4 + e3;
    }), function() {
      return "The sum of sizes must match the size of the axis dimension.";
    }), r2 = e2), Nt.runKernelFunc(function(t4) {
      return t4.split(o2, r2, n2);
    }, { $x: o2 }, function(t4) {
      return { $x: function() {
        return Gn(t4, n2);
      } };
    });
  } });
  function $n(t3, e2) {
    return t3(e2 = { exports: {} }, e2.exports), e2.exports;
  }
  var Yn = $n(function(t3) {
    !function(t4, e2, n2) {
      function r2(t5) {
        var e3, n3 = this, r3 = (e3 = 4022871197, function(t6) {
          t6 = t6.toString();
          for (var n4 = 0; n4 < t6.length; n4++) {
            var r4 = 0.02519603282416938 * (e3 += t6.charCodeAt(n4));
            r4 -= e3 = r4 >>> 0, e3 = (r4 *= e3) >>> 0, e3 += 4294967296 * (r4 -= e3);
          }
          return 23283064365386963e-26 * (e3 >>> 0);
        });
        n3.next = function() {
          var t6 = 2091639 * n3.s0 + 23283064365386963e-26 * n3.c;
          return n3.s0 = n3.s1, n3.s1 = n3.s2, n3.s2 = t6 - (n3.c = 0 | t6);
        }, n3.c = 1, n3.s0 = r3(" "), n3.s1 = r3(" "), n3.s2 = r3(" "), n3.s0 -= r3(t5), n3.s0 < 0 && (n3.s0 += 1), n3.s1 -= r3(t5), n3.s1 < 0 && (n3.s1 += 1), n3.s2 -= r3(t5), n3.s2 < 0 && (n3.s2 += 1), r3 = null;
      }
      function o2(t5, e3) {
        return e3.c = t5.c, e3.s0 = t5.s0, e3.s1 = t5.s1, e3.s2 = t5.s2, e3;
      }
      function a2(t5, e3) {
        var n3 = new r2(t5), a3 = e3 && e3.state, i2 = n3.next;
        return i2.int32 = function() {
          return 4294967296 * n3.next() | 0;
        }, i2.double = function() {
          return i2() + 11102230246251565e-32 * (2097152 * i2() | 0);
        }, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
          return o2(n3, {});
        }), i2;
      }
      e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
        return a2;
      }) : this.alea = a2;
    }(0, t3, false);
  });
  var Qn = $n(function(t3) {
    !function(t4, e2, n2) {
      function r2(t5) {
        var e3 = this, n3 = "";
        e3.x = 0, e3.y = 0, e3.z = 0, e3.w = 0, e3.next = function() {
          var t6 = e3.x ^ e3.x << 11;
          return e3.x = e3.y, e3.y = e3.z, e3.z = e3.w, e3.w ^= e3.w >>> 19 ^ t6 ^ t6 >>> 8;
        }, t5 === (0 | t5) ? e3.x = t5 : n3 += t5;
        for (var r3 = 0; r3 < n3.length + 64; r3++)
          e3.x ^= 0 | n3.charCodeAt(r3), e3.next();
      }
      function o2(t5, e3) {
        return e3.x = t5.x, e3.y = t5.y, e3.z = t5.z, e3.w = t5.w, e3;
      }
      function a2(t5, e3) {
        var n3 = new r2(t5), a3 = e3 && e3.state, i2 = function() {
          return (n3.next() >>> 0) / 4294967296;
        };
        return i2.double = function() {
          do {
            var t6 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
          } while (0 === t6);
          return t6;
        }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
          return o2(n3, {});
        }), i2;
      }
      e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
        return a2;
      }) : this.xor128 = a2;
    }(0, t3, false);
  });
  var Jn = $n(function(t3) {
    !function(t4, e2, n2) {
      function r2(t5) {
        var e3 = this, n3 = "";
        e3.next = function() {
          var t6 = e3.x ^ e3.x >>> 2;
          return e3.x = e3.y, e3.y = e3.z, e3.z = e3.w, e3.w = e3.v, (e3.d = e3.d + 362437 | 0) + (e3.v = e3.v ^ e3.v << 4 ^ t6 ^ t6 << 1) | 0;
        }, e3.x = 0, e3.y = 0, e3.z = 0, e3.w = 0, e3.v = 0, t5 === (0 | t5) ? e3.x = t5 : n3 += t5;
        for (var r3 = 0; r3 < n3.length + 64; r3++)
          e3.x ^= 0 | n3.charCodeAt(r3), r3 == n3.length && (e3.d = e3.x << 10 ^ e3.x >>> 4), e3.next();
      }
      function o2(t5, e3) {
        return e3.x = t5.x, e3.y = t5.y, e3.z = t5.z, e3.w = t5.w, e3.v = t5.v, e3.d = t5.d, e3;
      }
      function a2(t5, e3) {
        var n3 = new r2(t5), a3 = e3 && e3.state, i2 = function() {
          return (n3.next() >>> 0) / 4294967296;
        };
        return i2.double = function() {
          do {
            var t6 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
          } while (0 === t6);
          return t6;
        }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
          return o2(n3, {});
        }), i2;
      }
      e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
        return a2;
      }) : this.xorwow = a2;
    }(0, t3, false);
  });
  var Zn = $n(function(t3) {
    !function(t4, e2, n2) {
      function r2(t5) {
        var e3 = this;
        e3.next = function() {
          var t6, n3, r3 = e3.x, o3 = e3.i;
          return t6 = r3[o3], n3 = (t6 ^= t6 >>> 7) ^ t6 << 24, n3 ^= (t6 = r3[o3 + 1 & 7]) ^ t6 >>> 10, n3 ^= (t6 = r3[o3 + 3 & 7]) ^ t6 >>> 3, n3 ^= (t6 = r3[o3 + 4 & 7]) ^ t6 << 7, t6 = r3[o3 + 7 & 7], n3 ^= (t6 ^= t6 << 13) ^ t6 << 9, r3[o3] = n3, e3.i = o3 + 1 & 7, n3;
        }, function(t6, e4) {
          var n3, r3 = [];
          if (e4 === (0 | e4))
            r3[0] = e4;
          else
            for (e4 = "" + e4, n3 = 0; n3 < e4.length; ++n3)
              r3[7 & n3] = r3[7 & n3] << 15 ^ e4.charCodeAt(n3) + r3[n3 + 1 & 7] << 13;
          for (; r3.length < 8; )
            r3.push(0);
          for (n3 = 0; n3 < 8 && 0 === r3[n3]; ++n3)
            ;
          for (8 == n3 ? r3[7] = -1 : r3[n3], t6.x = r3, t6.i = 0, n3 = 256; n3 > 0; --n3)
            t6.next();
        }(e3, t5);
      }
      function o2(t5, e3) {
        return e3.x = t5.x.slice(), e3.i = t5.i, e3;
      }
      function a2(t5, e3) {
        null == t5 && (t5 = +/* @__PURE__ */ new Date());
        var n3 = new r2(t5), a3 = e3 && e3.state, i2 = function() {
          return (n3.next() >>> 0) / 4294967296;
        };
        return i2.double = function() {
          do {
            var t6 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
          } while (0 === t6);
          return t6;
        }, i2.int32 = n3.next, i2.quick = i2, a3 && (a3.x && o2(a3, n3), i2.state = function() {
          return o2(n3, {});
        }), i2;
      }
      e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
        return a2;
      }) : this.xorshift7 = a2;
    }(0, t3, false);
  });
  var tr = $n(function(t3) {
    !function(t4, e2, n2) {
      function r2(t5) {
        var e3 = this;
        e3.next = function() {
          var t6, n3, r3 = e3.w, o3 = e3.X, a3 = e3.i;
          return e3.w = r3 = r3 + 1640531527 | 0, n3 = o3[a3 + 34 & 127], t6 = o3[a3 = a3 + 1 & 127], n3 ^= n3 << 13, t6 ^= t6 << 17, n3 ^= n3 >>> 15, t6 ^= t6 >>> 12, n3 = o3[a3] = n3 ^ t6, e3.i = a3, n3 + (r3 ^ r3 >>> 16) | 0;
        }, function(t6, e4) {
          var n3, r3, o3, a3, i2, u2 = [], s2 = 128;
          for (e4 === (0 | e4) ? (r3 = e4, e4 = null) : (e4 += "\0", r3 = 0, s2 = Math.max(s2, e4.length)), o3 = 0, a3 = -32; a3 < s2; ++a3)
            e4 && (r3 ^= e4.charCodeAt((a3 + 32) % e4.length)), 0 === a3 && (i2 = r3), r3 ^= r3 << 10, r3 ^= r3 >>> 15, r3 ^= r3 << 4, r3 ^= r3 >>> 13, a3 >= 0 && (i2 = i2 + 1640531527 | 0, o3 = 0 == (n3 = u2[127 & a3] ^= r3 + i2) ? o3 + 1 : 0);
          for (o3 >= 128 && (u2[127 & (e4 && e4.length || 0)] = -1), o3 = 127, a3 = 512; a3 > 0; --a3)
            r3 = u2[o3 + 34 & 127], n3 = u2[o3 = o3 + 1 & 127], r3 ^= r3 << 13, n3 ^= n3 << 17, r3 ^= r3 >>> 15, n3 ^= n3 >>> 12, u2[o3] = r3 ^ n3;
          t6.w = i2, t6.X = u2, t6.i = o3;
        }(e3, t5);
      }
      function o2(t5, e3) {
        return e3.i = t5.i, e3.w = t5.w, e3.X = t5.X.slice(), e3;
      }
      function a2(t5, e3) {
        null == t5 && (t5 = +/* @__PURE__ */ new Date());
        var n3 = new r2(t5), a3 = e3 && e3.state, i2 = function() {
          return (n3.next() >>> 0) / 4294967296;
        };
        return i2.double = function() {
          do {
            var t6 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
          } while (0 === t6);
          return t6;
        }, i2.int32 = n3.next, i2.quick = i2, a3 && (a3.X && o2(a3, n3), i2.state = function() {
          return o2(n3, {});
        }), i2;
      }
      e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
        return a2;
      }) : this.xor4096 = a2;
    }(0, t3, false);
  });
  var er = $n(function(t3) {
    !function(t4, e2, n2) {
      function r2(t5) {
        var e3 = this, n3 = "";
        e3.next = function() {
          var t6 = e3.b, n4 = e3.c, r4 = e3.d, o3 = e3.a;
          return t6 = t6 << 25 ^ t6 >>> 7 ^ n4, n4 = n4 - r4 | 0, r4 = r4 << 24 ^ r4 >>> 8 ^ o3, o3 = o3 - t6 | 0, e3.b = t6 = t6 << 20 ^ t6 >>> 12 ^ n4, e3.c = n4 = n4 - r4 | 0, e3.d = r4 << 16 ^ n4 >>> 16 ^ o3, e3.a = o3 - t6 | 0;
        }, e3.a = 0, e3.b = 0, e3.c = -1640531527, e3.d = 1367130551, t5 === Math.floor(t5) ? (e3.a = t5 / 4294967296 | 0, e3.b = 0 | t5) : n3 += t5;
        for (var r3 = 0; r3 < n3.length + 20; r3++)
          e3.b ^= 0 | n3.charCodeAt(r3), e3.next();
      }
      function o2(t5, e3) {
        return e3.a = t5.a, e3.b = t5.b, e3.c = t5.c, e3.d = t5.d, e3;
      }
      function a2(t5, e3) {
        var n3 = new r2(t5), a3 = e3 && e3.state, i2 = function() {
          return (n3.next() >>> 0) / 4294967296;
        };
        return i2.double = function() {
          do {
            var t6 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
          } while (0 === t6);
          return t6;
        }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
          return o2(n3, {});
        }), i2;
      }
      e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
        return a2;
      }) : this.tychei = a2;
    }(0, t3, false);
  });
  var nr = $n(function(t3) {
    !function(e2, n2) {
      var r2, o2 = this, a2 = 256, i2 = 6, u2 = "random", s2 = n2.pow(a2, i2), c2 = n2.pow(2, 52), l3 = 2 * c2, h = a2 - 1;
      function f2(t4, h2, f3) {
        var g2 = [], y2 = v2(function t5(e3, n3) {
          var r3, o3 = [], a3 = typeof e3;
          if (n3 && "object" == a3)
            for (r3 in e3)
              try {
                o3.push(t5(e3[r3], n3 - 1));
              } catch (t6) {
              }
          return o3.length ? o3 : "string" == a3 ? e3 : e3 + "\0";
        }((h2 = 1 == h2 ? { entropy: true } : h2 || {}).entropy ? [t4, m2(e2)] : null == t4 ? function() {
          try {
            var t5;
            return r2 && (t5 = r2.randomBytes) ? t5 = t5(a2) : (t5 = new Uint8Array(a2), (o2.crypto || o2.msCrypto).getRandomValues(t5)), m2(t5);
          } catch (t6) {
            var n3 = o2.navigator, i3 = n3 && n3.plugins;
            return [+/* @__PURE__ */ new Date(), o2, i3, o2.screen, m2(e2)];
          }
        }() : t4, 3), g2), x2 = new p2(g2), b2 = function() {
          for (var t5 = x2.g(i2), e3 = s2, n3 = 0; t5 < c2; )
            t5 = (t5 + n3) * a2, e3 *= a2, n3 = x2.g(1);
          for (; t5 >= l3; )
            t5 /= 2, e3 /= 2, n3 >>>= 1;
          return (t5 + n3) / e3;
        };
        return b2.int32 = function() {
          return 0 | x2.g(4);
        }, b2.quick = function() {
          return x2.g(4) / 4294967296;
        }, b2.double = b2, v2(m2(x2.S), e2), (h2.pass || f3 || function(t5, e3, r3, o3) {
          return o3 && (o3.S && d2(o3, x2), t5.state = function() {
            return d2(x2, {});
          }), r3 ? (n2[u2] = t5, e3) : t5;
        })(b2, y2, "global" in h2 ? h2.global : this == n2, h2.state);
      }
      function p2(t4) {
        var e3, n3 = t4.length, r3 = this, o3 = 0, i3 = r3.i = r3.j = 0, u3 = r3.S = [];
        for (n3 || (t4 = [n3++]); o3 < a2; )
          u3[o3] = o3++;
        for (o3 = 0; o3 < a2; o3++)
          u3[o3] = u3[i3 = h & i3 + t4[o3 % n3] + (e3 = u3[o3])], u3[i3] = e3;
        (r3.g = function(t5) {
          for (var e4, n4 = 0, o4 = r3.i, i4 = r3.j, u4 = r3.S; t5--; )
            e4 = u4[o4 = h & o4 + 1], n4 = n4 * a2 + u4[h & (u4[o4] = u4[i4 = h & i4 + e4]) + (u4[i4] = e4)];
          return r3.i = o4, r3.j = i4, n4;
        })(a2);
      }
      function d2(t4, e3) {
        return e3.i = t4.i, e3.j = t4.j, e3.S = t4.S.slice(), e3;
      }
      function v2(t4, e3) {
        for (var n3, r3 = t4 + "", o3 = 0; o3 < r3.length; )
          e3[h & o3] = h & (n3 ^= 19 * e3[h & o3]) + r3.charCodeAt(o3++);
        return m2(e3);
      }
      function m2(t4) {
        return String.fromCharCode.apply(0, t4);
      }
      if (n2["seed" + u2] = f2, v2(n2.random(), e2), t3.exports) {
        t3.exports = f2;
        try {
          r2 = require_crypto();
        } catch (t4) {
        }
      }
    }([], Math);
  });
  nr.alea = Yn, nr.xor128 = Qn, nr.xorwow = Jn, nr.xorshift7 = Zn, nr.xor4096 = tr, nr.tychei = er;
  var rr = nr.alea;
  var or = function() {
    function t3(t4, e2, n2, r2, o2) {
      this.mean = t4, this.stdDev = e2, this.dtype = n2, this.nextVal = NaN, this.truncated = r2, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
      var a2 = o2 || Math.random();
      this.random = rr(a2.toString());
    }
    return t3.prototype.nextValue = function() {
      if (!isNaN(this.nextVal)) {
        var t4 = this.nextVal;
        return this.nextVal = NaN, t4;
      }
      for (var e2, n2, r2 = false; !r2; ) {
        var o2 = void 0, a2 = void 0, i2 = void 0;
        do {
          i2 = (o2 = 2 * this.random() - 1) * o2 + (a2 = 2 * this.random() - 1) * a2;
        } while (i2 >= 1 || 0 === i2);
        var u2 = Math.sqrt(-2 * Math.log(i2) / i2);
        e2 = this.mean + this.stdDev * o2 * u2, n2 = this.mean + this.stdDev * a2 * u2, this.truncated && !this.isValidTruncated(e2) || (r2 = true);
      }
      return this.truncated && !this.isValidTruncated(n2) || (this.nextVal = this.convertValue(n2)), this.convertValue(e2);
    }, t3.prototype.convertValue = function(t4) {
      return null == this.dtype || "float32" === this.dtype ? t4 : Math.round(t4);
    }, t3.prototype.isValidTruncated = function(t4) {
      return t4 <= this.upper && t4 >= this.lower;
    }, t3;
  }();
  var ar = function() {
    function t3(t4, e2, n2, r2) {
      this.alpha = t4, this.beta = 1 / e2, this.dtype = n2;
      var o2 = r2 || Math.random();
      this.randu = rr(o2.toString()), this.randn = new or(0, 1, n2, false, this.randu()), this.d = t4 < 1 ? t4 + 2 / 3 : t4 - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
    }
    return t3.prototype.nextValue = function() {
      for (var t4, e2, n2, r2, o2, a2; ; ) {
        do {
          r2 = this.randn.nextValue(), a2 = 1 + this.c * r2;
        } while (a2 <= 0);
        if (a2 *= a2 * a2, e2 = 1 - 0.331 * (t4 = r2 * r2) * t4, n2 = 0.5 * t4 + this.d * (1 - a2 + Math.log(a2)), (o2 = this.randu()) < e2 || Math.log(o2) < n2)
          break;
      }
      return a2 = 1 / this.beta * this.d * a2, this.alpha < 1 && (a2 *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a2);
    }, t3.prototype.convertValue = function(t4) {
      return "float32" === this.dtype ? t4 : Math.round(t4);
    }, t3;
  }();
  var ir = function() {
    function t3(t4, e2, n2, r2) {
      var o2 = this;
      if (void 0 === t4 && (t4 = 0), void 0 === e2 && (e2 = 1), this.canReturnFloat = function() {
        return null == o2.dtype || "float32" === o2.dtype;
      }, this.min = t4, this.range = e2 - t4, this.dtype = n2, null == r2 && (r2 = Math.random()), "number" == typeof r2 && (r2 = r2.toString()), !this.canReturnFloat() && this.range <= 1)
        throw new Error("The difference between " + t4 + " - " + e2 + " <= 1 and dtype is not float");
      this.random = rr(r2);
    }
    return t3.prototype.convertValue = function(t4) {
      return this.canReturnFloat() ? t4 : Math.round(t4);
    }, t3.prototype.nextValue = function() {
      return this.convertValue(this.min + this.range * this.random());
    }, t3;
  }();
  function ur(t3, e2, n2) {
    return void 0 === e2 && (e2 = "float32"), e2 = e2 || "float32", Q(t3), new lt(t3, e2, n2);
  }
  function sr(t3, e2) {
    void 0 === e2 && (e2 = false), console.log(t3.toString(e2));
  }
  var cr = Cn({ batchToSpaceND_: function(t3, e2, n2) {
    var r2 = ln(t3, "x", "batchToSpaceND"), o2 = e2.reduce(function(t4, e3) {
      return t4 * e3;
    });
    return g(r2.rank >= 1 + e2.length, function() {
      return "input rank is " + r2.rank + " but should be > than blockShape.length " + e2.length;
    }), g(n2.length === e2.length, function() {
      return "crops.length is " + n2.length + " but should be equal to blockShape.length  " + e2.length;
    }), g(r2.shape[0] % o2 == 0, function() {
      return "input tensor batch is " + r2.shape[0] + " but is not divisible by the product of the elements of blockShape " + e2.join(" * ") + " === " + o2;
    }), Nt.runKernelFunc(function(t4) {
      return t4.batchToSpaceND(r2, e2, n2);
    }, { $x: r2 }, function(t4) {
      return { $x: function() {
        return t4.spaceToBatchND(e2, n2);
      } };
    });
  } });
  var lr = Cn({ cast_: function(t3, e2) {
    var n2 = ln(t3, "x", "cast");
    if (!_(e2))
      throw new Error("Failed to cast to unknown dtype " + e2);
    if ("string" === e2 && "string" !== n2.dtype || "string" !== e2 && "string" === n2.dtype)
      throw new Error("Only strings can be casted to strings");
    var r2 = { dtype: e2 };
    return Nt.runKernelFunc(function(t4) {
      return t4.cast(n2, e2);
    }, { x: n2 }, function(t4) {
      return { x: function() {
        return t4.clone();
      } };
    }, "Cast", r2);
  } });
  var hr = Cn({ clone_: function(t3) {
    var e2 = ln(t3, "x", "clone", null);
    return Nt.runKernelFunc(function() {
      return Nt.makeTensorFromDataId(e2.dataId, e2.shape, e2.dtype);
    }, { $x: e2 }, function(t4) {
      return { $x: function() {
        return t4.toFloat();
      } };
    });
  } });
  var fr = Cn({ cumsum_: function(t3, e2, n2, r2) {
    void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false);
    var o2 = ln(t3, "x", "cumsum"), a2 = gn([e2 |= 0], o2.rank), i2 = o2;
    null != a2 && (i2 = o2.transpose(a2));
    var u2 = xn(1, o2.rank)[0], s2 = Nt.runKernelFunc(function(t4) {
      return t4.cumsum(i2, u2, n2, r2);
    }, { permutedX: i2 }, function(t4) {
      return { permutedX: function() {
        return t4.cumsum(e2, n2, !r2);
      } };
    });
    return null != a2 && (s2 = s2.transpose(a2)), s2;
  } });
  var pr = Cn({ depthToSpace_: function(t3, e2, n2) {
    void 0 === n2 && (n2 = "NHWC");
    var r2 = ln(t3, "x", "depthToSpace"), o2 = "NHWC" === n2 ? r2.shape[1] : r2.shape[2], a2 = "NHWC" === n2 ? r2.shape[2] : r2.shape[3], i2 = "NHWC" === n2 ? r2.shape[3] : r2.shape[1];
    return g(o2 * e2 >= 0, function() {
      return "Negative dimension size caused by overflow when multiplying\n      " + o2 + " and " + e2 + "  for depthToSpace with input shape\n      " + r2.shape;
    }), g(a2 * e2 >= 0, function() {
      return "Negative dimension size caused by overflow when multiplying\n      " + a2 + " and " + e2 + " for depthToSpace with input shape\n          " + r2.shape;
    }), g(i2 % (e2 * e2) == 0, function() {
      return "Dimension size must be evenly divisible by " + e2 * e2 + " but is " + i2 + " for depthToSpace with input shape " + r2.shape;
    }), Nt.runKernelFunc(function(t4) {
      return t4.depthToSpace(r2, e2, n2);
    }, { $x: r2 });
  } });
  var dr = Cn({ expandDims_: function(t3, e2) {
    void 0 === e2 && (e2 = 0);
    var n2 = ln(t3, "x", "expandDims", null);
    g(e2 <= n2.rank, function() {
      return "Axis must be <= rank of the tensor";
    });
    var r2 = n2.shape.slice();
    return e2 < 0 && (g(-(n2.rank + 1) <= e2, function() {
      return "Axis must be in the interval [" + -(n2.rank + 1) + ", " + n2.rank + "]";
    }), e2 = n2.rank + e2 + 1), r2.splice(e2, 0, 1), Sr(n2, r2);
  } });
  var vr = Cn({ eye_: function(t3, e2, n2, r2) {
    void 0 === r2 && (r2 = "float32"), null == e2 && (e2 = t3);
    for (var o2 = ur([t3, e2], r2), a2 = t3 <= e2 ? t3 : e2, i2 = 0; i2 < a2; ++i2)
      o2.set(1, i2, i2);
    var u2 = o2.toTensor().as2D(t3, e2);
    if (null == n2)
      return u2;
    if (1 === n2.length)
      return Nr(dr(u2, 0), [n2[0], 1, 1]);
    if (2 === n2.length)
      return Nr(dr(dr(u2, 0), 0), [n2[0], n2[1], 1, 1]);
    if (3 === n2.length)
      return Nr(dr(dr(dr(u2, 0), 0), 0), [n2[0], n2[1], n2[2], 1, 1]);
    throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n2.length + "D.");
  } });
  var mr = Cn({ multinomial_: function(t3, e2, n2, r2) {
    void 0 === r2 && (r2 = false);
    var o2 = ln(t3, "logits", "multinomial"), a2 = o2.size, i2 = o2.rank;
    if (a2 < 2)
      throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + a2 + ".");
    if (i2 > 2)
      throw new Error("Rank of probabilities must be 1 or 2, but is " + i2);
    n2 = n2 || Math.random();
    var u2 = 1 === i2 ? o2.as2D(1, -1) : o2, s2 = Nt.runKernelFunc(function(t4) {
      return t4.multinomial(u2, r2, e2, n2);
    }, { logits2D: u2 });
    return 1 === i2 ? s2.as1D() : s2;
  } });
  var gr = Cn({ oneHot_: function(t3, e2, n2, r2) {
    if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0), e2 < 2)
      throw new Error("Error in oneHot: depth must be >=2, but it is " + e2);
    var o2 = ln(t3, "indices", "oneHot", "int32"), a2 = o2.shape.concat([e2]);
    return o2 = o2.flatten(), Nt.runKernelFunc(function(t4) {
      return t4.oneHot(o2, e2, n2, r2);
    }, { $indices: o2 }, function(t4) {
      return { $indices: function() {
        return Pn(o2.shape, "float32");
      } };
    }).reshape(a2);
  } });
  var yr = Cn({ pad_: function(t3, e2, n2) {
    void 0 === n2 && (n2 = 0);
    var r2 = ln(t3, "x", "pad");
    if (0 === r2.rank)
      throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    var o2 = e2.map(function(t4) {
      return t4[0];
    });
    return Nt.runKernelFunc(function(t4) {
      return t4.pad(r2, e2, n2);
    }, { $x: r2 }, function(t4) {
      return { $x: function() {
        return t4.slice(o2, r2.shape);
      } };
    });
  } });
  var xr = Cn({ pad1d_: function(t3, e2, n2) {
    return void 0 === n2 && (n2 = 0), g(2 === e2.length, function() {
      return "Invalid number of paddings. Must be length of 2.";
    }), yr(t3, [e2], n2);
  } });
  var br = Cn({ pad2d_: function(t3, e2, n2) {
    return void 0 === n2 && (n2 = 0), g(2 === e2.length && 2 === e2[0].length && 2 === e2[1].length, function() {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), yr(t3, e2, n2);
  } });
  var wr = Cn({ pad3d_: function(t3, e2, n2) {
    return void 0 === n2 && (n2 = 0), g(3 === e2.length && 2 === e2[0].length && 2 === e2[1].length && 2 === e2[2].length, function() {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), yr(t3, e2, n2);
  } });
  var Cr = Cn({ pad4d_: function(t3, e2, n2) {
    return void 0 === n2 && (n2 = 0), g(4 === e2.length && 2 === e2[0].length && 2 === e2[1].length && 2 === e2[2].length && 2 === e2[3].length, function() {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), yr(t3, e2, n2);
  } });
  var Er = Cn({ rand_: function(t3, e2, n2) {
    var r2 = w(t3), o2 = null;
    if (null == n2 || "float32" === n2)
      o2 = new Float32Array(r2);
    else if ("int32" === n2)
      o2 = new Int32Array(r2);
    else {
      if ("bool" !== n2)
        throw new Error("Unknown data type " + n2);
      o2 = new Uint8Array(r2);
    }
    for (var a2 = 0; a2 < r2; a2++)
      o2[a2] = e2();
    return Nt.makeTensor(o2, t3, n2);
  } });
  var Rr = Cn({ randomNormal_: function(t3, e2, n2, r2, o2) {
    if (void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), null != r2 && "bool" === r2)
      throw new Error("Unsupported data type " + r2);
    for (var a2 = new or(e2, n2, r2, false, o2), i2 = ur(t3, r2), u2 = 0; u2 < i2.values.length; u2++)
      i2.values[u2] = a2.nextValue();
    return i2.toTensor();
  } });
  var Ir = Cn({ randomGamma_: function(t3, e2, n2, r2, o2) {
    if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32"), null == n2 && (n2 = 1), null == r2 && (r2 = "float32"), "float32" !== r2 && "int32" !== r2)
      throw new Error("Unsupported data type " + r2);
    for (var a2 = new ar(e2, n2, r2, o2), i2 = ur(t3, r2), u2 = 0; u2 < i2.values.length; u2++)
      i2.values[u2] = a2.nextValue();
    return i2.toTensor();
  } });
  var kr = Cn({ randomUniform_: function(t3, e2, n2, r2, o2) {
    void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32");
    for (var a2 = ur(t3, r2), i2 = new ir(e2, n2, null, o2), u2 = 0; u2 < a2.values.length; u2++)
      a2.values[u2] = i2.nextValue();
    return a2.toTensor();
  } });
  var Sr = Cn({ reshape_: function(t3, e2) {
    var n2 = ln(t3, "x", "reshape", null);
    e2 = A(e2, n2.size), g(n2.size === w(e2), function() {
      return "new shape and old shape must have the same number of elements.";
    });
    var r2 = { shape: e2 };
    return Nt.runKernelFunc(function(t4) {
      return t4.reshape(n2, e2);
    }, { x: n2 }, function(t4) {
      return { x: function() {
        return t4.reshape(n2.shape);
      } };
    }, "Reshape", r2);
  } });
  var Ar = Cn({ spaceToBatchND_: function(t3, e2, n2) {
    var r2 = ln(t3, "x", "spaceToBatchND");
    return g(r2.rank >= 1 + e2.length, function() {
      return "input rank " + r2.rank + " should be > than [blockShape] " + e2.length;
    }), g(n2.length === e2.length, function() {
      return "paddings.shape[0] " + n2.length + " must be equal to [blockShape] " + e2.length;
    }), g(r2.shape.reduce(function(t4, r3, o2) {
      return o2 > 0 && o2 <= e2.length ? t4 && (r3 + n2[o2 - 1][0] + n2[o2 - 1][1]) % e2[o2 - 1] == 0 : t4;
    }, true), function() {
      return "input spatial dimensions " + r2.shape.slice(1) + " with paddings " + n2.toString() + " must be divisible by blockShapes " + e2.toString();
    }), Nt.runKernelFunc(function(t4) {
      return t4.spaceToBatchND(r2, e2, n2);
    }, { $x: r2 }, function(t4) {
      return { $x: function() {
        return t4.batchToSpaceND(e2, n2);
      } };
    });
  } });
  var Dr = Cn({ squeeze_: function(t3, e2) {
    var n2 = ln(t3, "x", "squeeze");
    return Sr(n2, T(n2.shape, e2).newShape);
  } });
  var Tr = Cn({ stack_: function(t3, e2) {
    void 0 === e2 && (e2 = 0);
    var n2 = hn(t3, "tensors", "stack");
    if (g(n2.length >= 1, function() {
      return "Pass at least one tensor to tf.stack";
    }), 1 === n2.length)
      return n2[0].expandDims(e2);
    var r2 = n2[0].rank, o2 = n2[0].shape, a2 = n2[0].dtype;
    g(e2 <= r2, function() {
      return "Axis must be <= rank of the tensor";
    }), n2.forEach(function(t4) {
      y(o2, t4.shape, "All tensors passed to stack must have matching shapes");
    }), n2.forEach(function(t4) {
      g(a2 === t4.dtype, function() {
        return "All tensors passed to stack must have matching dtypes";
      });
    });
    var i2 = n2.map(function(t4) {
      return t4.expandDims(e2);
    });
    return Gn(i2, e2);
  } });
  var Nr = Cn({ tile_: function(t3, e2) {
    var n2 = ln(t3, "x", "tile", null);
    return g(n2.rank === e2.length, function() {
      return "Error in transpose: rank of input " + n2.rank + " must match length of reps " + e2 + ".";
    }), Nt.runKernelFunc(function(t4, r2) {
      var o2 = t4.tile(n2, e2);
      return r2([n2]), o2;
    }, { $x: n2 }, function(t4, n3) {
      var r2 = n3[0];
      return { $x: function() {
        var n4 = zn(r2);
        if (1 === r2.rank)
          for (var o2 = 0; o2 < e2[0]; ++o2)
            n4 = n4.add(t4.slice([o2 * r2.shape[0]], [r2.shape[0]]));
        else if (2 === r2.rank)
          for (o2 = 0; o2 < e2[0]; ++o2)
            for (var a2 = 0; a2 < e2[1]; ++a2)
              n4 = n4.add(t4.slice([o2 * r2.shape[0], a2 * r2.shape[1]], [r2.shape[0], r2.shape[1]]));
        else if (3 === r2.rank)
          for (o2 = 0; o2 < e2[0]; ++o2)
            for (a2 = 0; a2 < e2[1]; ++a2)
              for (var i2 = 0; i2 < e2[2]; ++i2)
                n4 = n4.add(t4.slice([o2 * r2.shape[0], a2 * r2.shape[1], i2 * r2.shape[2]], [r2.shape[0], r2.shape[1], r2.shape[2]]));
        else {
          if (4 !== r2.rank)
            throw new Error("Gradient for tile operation is not implemented for rank-" + r2.rank + " tensors yet.");
          for (o2 = 0; o2 < e2[0]; ++o2)
            for (a2 = 0; a2 < e2[1]; ++a2)
              for (i2 = 0; i2 < e2[2]; ++i2)
                for (var u2 = 0; u2 < e2[3]; ++u2)
                  n4 = n4.add(t4.slice([o2 * r2.shape[0], a2 * r2.shape[1], i2 * r2.shape[2], u2 * r2.shape[3]], [r2.shape[0], r2.shape[1], r2.shape[2], r2.shape[3]]));
        }
        return n4;
      } };
    });
  } });
  var Fr = Cn({ truncatedNormal_: function(t3, e2, n2, r2, o2) {
    if (void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), null != r2 && "bool" === r2)
      throw new Error("Unsupported data type " + r2);
    for (var a2 = new or(e2, n2, r2, true, o2), i2 = ur(t3, r2), u2 = 0; u2 < i2.values.length; u2++)
      i2.values[u2] = a2.nextValue();
    return i2.toTensor();
  } });
  var Or = Cn({ unstack_: function(t3, e2) {
    void 0 === e2 && (e2 = 0), e2 = e2 || 0;
    var n2 = ln(t3, "x", "unstack");
    return g(e2 >= -n2.shape.length && e2 < n2.shape.length, function() {
      return "Axis = " + e2 + " is not in [-" + n2.shape.length + ", " + n2.shape.length + ")";
    }), e2 < 0 && (e2 += n2.shape.length), Nt.runKernelFunc(function(t4) {
      return t4.unstack(n2, e2);
    }, { $x: n2 }, function(t4) {
      return { $x: function() {
        return Tr(t4, e2);
      } };
    });
  } });
  var _r = function(t3, e2) {
    return n(this, void 0, void 0, function() {
      var n2, o2, a2, i2, u2, s2, c2, l3, h, f2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return n2 = ln(t3, "x", "setdiff1d"), o2 = ln(e2, "y", "setdiff1d"), g(n2.dtype === o2.dtype, function() {
              return "x and y should have the same dtype, but got x (" + n2.dtype + ") and y (" + o2.dtype + ").";
            }), g(1 === n2.rank, function() {
              return "x should be 1D tensor, but got x (" + n2.shape + ").";
            }), g(1 === o2.rank, function() {
              return "y should be 1D tensor, but got y (" + o2.shape + ").";
            }), [4, n2.data()];
          case 1:
            return a2 = r2.sent(), [4, o2.data()];
          case 2:
            for (i2 = r2.sent(), u2 = new Set(i2), s2 = 0, h = 0; h < a2.length; h++)
              u2.has(a2[h]) || s2++;
            for (c2 = new lt([s2], n2.dtype), l3 = new lt([s2], "int32"), h = 0, f2 = 0; h < a2.length; h++)
              u2.has(a2[h]) || (c2.values[f2] = a2[h], l3.values[f2] = h, f2++);
            return [2, [c2.toTensor(), l3.toTensor()]];
        }
      });
    });
  };
  function Mr(t3, e2, n2, r2) {
    void 0 === r2 && (r2 = true);
    var o2 = [];
    if (r2)
      (o2 = o2.concat(e2.slice(0))).push(t3[0] / n2), o2 = o2.concat(t3.slice(1));
    else {
      o2 = o2.concat(t3[0]);
      for (var a2 = e2.length, i2 = 0; i2 < a2; ++i2)
        o2 = o2.concat([t3[i2 + 1] / e2[i2], e2[i2]]);
      o2 = o2.concat(t3.slice(a2 + 1));
    }
    return o2;
  }
  function Br(t3, e2, n2) {
    void 0 === n2 && (n2 = true);
    var r2 = [];
    if (n2) {
      r2.push(e2);
      for (var o2 = e2 + 1; o2 < t3; ++o2)
        o2 <= 2 * e2 ? (r2.push(o2), r2.push(o2 - (e2 + 1))) : r2.push(o2);
    } else {
      var a2 = [], i2 = [];
      for (o2 = 1; o2 < t3; ++o2)
        o2 >= 2 * e2 + 1 || o2 % 2 == 1 ? i2.push(o2) : a2.push(o2);
      r2.push.apply(r2, a2), r2.push(0), r2.push.apply(r2, i2);
    }
    return r2;
  }
  function Pr(t3, e2, n2, r2) {
    void 0 === r2 && (r2 = true);
    var o2 = [];
    r2 ? o2.push(t3[0] / n2) : o2.push(t3[0] * n2);
    for (var a2 = 1; a2 < t3.length; ++a2)
      a2 <= e2.length ? r2 ? o2.push(e2[a2 - 1] * t3[a2]) : o2.push(t3[a2] / e2[a2 - 1]) : o2.push(t3[a2]);
    return o2;
  }
  function Lr(t3, e2) {
    for (var n2 = [0], r2 = 0; r2 < e2; ++r2)
      n2.push(t3[r2][0]);
    return n2;
  }
  function Wr(t3, e2, n2) {
    for (var r2 = t3.slice(0, 1), o2 = 0; o2 < n2; ++o2)
      r2.push(t3[o2 + 1] - e2[o2][0] - e2[o2][1]);
    return r2;
  }
  function Ur(t3, e2) {
    if (t3.rank < 1)
      throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t3.rank + ".");
    if (e2.rank < 1)
      throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e2.rank + ".");
    if ("int32" !== e2.dtype)
      throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e2.dtype + ".");
    if (e2.shape[e2.rank - 1] > t3.rank)
      throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e2.shape[e2.rank - 1] + " vs. " + t3.rank);
    if (0 === t3.size)
      throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t3.shape + ".");
    for (var n2 = e2.shape, r2 = n2[n2.length - 1], o2 = 1, a2 = 0; a2 < n2.length - 1; ++a2)
      o2 *= n2[a2];
    var i2 = t3.shape, u2 = n2.slice();
    u2.pop();
    var s2 = 1;
    for (a2 = r2; a2 < t3.rank; ++a2)
      s2 *= i2[a2], u2.push(i2[a2]);
    var c2 = q(t3.shape).map(function(t4) {
      return t4 / s2;
    }).concat([1]).slice(0, r2);
    return [u2, o2, s2, c2];
  }
  var Vr = 30;
  function zr(t3) {
    return t3 <= Vr ? t3 : H(t3, Math.floor(Math.sqrt(t3)));
  }
  function Gr(t3, e2, n2) {
    if (e2.rank < 1)
      throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e2.rank + ".");
    if (t3.rank < 1)
      throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t3.rank + ".");
    if ("int32" !== e2.dtype)
      throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e2.dtype);
    if (n2.length < 1)
      throw new Error("Output rank must be greater or equal to 1, but got shape: " + n2);
    if (0 === n2.length) {
      if (0 === e2.size)
        throw new Error("Indices specified for empty output. indices shape: " + e2.shape);
      if (0 === t3.size)
        throw new Error("Updates specified for empty output. updates shape: " + t3.shape);
    }
    !function(t4, e3, n3) {
      var r2 = e3.rank > 1 ? e3.shape[e3.rank - 1] : 1, o2 = e3.rank > 1 ? e3.rank - 1 : 1, a2 = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n3.shape + ", indices.shape: " + e3.shape + ", shape: " + t4 + ", sliceDim: " + r2 + ", and batchDim: " + o2 + ".";
      if (n3.rank < o2)
        throw new Error(a2 + " update.rank < " + o2 + ". ");
      if (t4.length < r2 + (n3.rank - o2))
        throw new Error(a2 + " Output shape length < " + (r2 + (n3.rank - o2)));
      if (n3.rank !== o2 + t4.length - r2)
        throw new Error(a2 + " update.rank != " + (o2 + t4.length - r2));
      for (var i2 = 0; i2 < o2; ++i2)
        if (n3.shape[i2] !== e3.shape[i2])
          throw new Error(a2 + " updates.shape[" + i2 + "] (" + n3.shape[i2] + ") != indices.shape[" + i2 + "] (" + e3.shape[i2] + ").");
      for (i2 = 0; i2 < n3.rank - o2; ++i2)
        if (n3.shape[i2 + o2] !== t4[i2 + r2])
          throw new Error(a2 + " updates.shape[" + (i2 + o2) + "] (" + n3.shape[i2 + o2] + ") != shape[" + (i2 + o2) + "] (" + t4[i2 + o2] + ")");
    }(n2, e2, t3);
  }
  function Hr(t3, e2, n2) {
    for (var r2 = e2.rank > 1 ? e2.shape[e2.rank - 1] : 1, o2 = n2.length, a2 = 1, i2 = r2; i2 < o2; ++i2)
      a2 *= n2[i2];
    var u2 = r2 < 1 ? 1 : r2;
    return { sliceRank: r2, numUpdates: e2.size / u2, sliceSize: a2, strides: q(n2.slice(0, r2)).concat([1]), outputSize: w(n2) };
  }
  function qr(t3, e2, n2) {
    g(t3.rank === e2.length, function() {
      return "Error in slice" + t3.rank + "D: Length of begin " + e2 + " must match the rank of the array (" + t3.rank + ").";
    }), g(t3.rank === n2.length, function() {
      return "Error in slice" + t3.rank + "D: Length of size " + n2 + " must match the rank of the array (" + t3.rank + ").";
    });
    for (var r2 = function(r3) {
      g(e2[r3] + n2[r3] <= t3.shape[r3], function() {
        return "Error in slice" + t3.rank + "D: begin[" + r3 + "] + size[" + r3 + "] (" + (e2[r3] + n2[r3]) + ") would overflow input.shape[" + r3 + "] (" + t3.shape[r3] + ")";
      });
    }, o2 = 0; o2 < t3.rank; ++o2)
      r2(o2);
  }
  function Kr(t3) {
    for (var e2 = [], n2 = 0; t3 > 0; )
      1 & t3 && e2.push(n2), t3 /= 2, n2++;
    return e2;
  }
  function jr(t3, e2, n2) {
    for (var r2 = [], o2 = 0; o2 < t3.length; o2++)
      r2[o2] = Math.ceil((e2[o2] - t3[o2]) / n2[o2]);
    return r2;
  }
  function Xr(t3, e2, n2, r2, o2) {
    var a2 = e2[o2], i2 = n2[o2] || 1;
    (t3 & 1 << o2 || null == a2) && (a2 = i2 > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
    var u2 = r2[o2];
    return a2 < 0 && (a2 += u2), a2 = d(0, a2, u2 - 1);
  }
  function $r(t3, e2, n2, r2, o2) {
    var a2 = e2[o2], i2 = n2[o2] || 1;
    (t3 & 1 << o2 || null == a2) && (a2 = i2 > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
    var u2 = r2[o2];
    return a2 < 0 && (a2 += u2), a2 = i2 > 0 ? d(0, a2, u2) : d(-1, a2, u2 - 1);
  }
  function Yr(t3, e2, n2) {
    for (var r2 = n2.length, o2 = 0; o2 < n2.length; o2++)
      if (n2[o2] > 1) {
        r2 = o2;
        break;
      }
    for (o2 = r2 + 1; o2 < n2.length; o2++)
      if (e2[o2] > 0 || n2[o2] !== t3[o2])
        return false;
    return true;
  }
  function Qr(t3, e2) {
    for (var n2 = t3.length > 0 ? t3[t3.length - 1] : 1, r2 = 0; r2 < t3.length - 1; r2++)
      n2 += t3[r2] * e2[r2];
    return n2;
  }
  var Jr = Object.freeze({ assertParamsValid: qr, maskToAxes: Kr, computeOutShape: jr, startForAxis: Xr, stopForAxis: $r, isSliceContinous: Yr, computeFlatOffset: Qr });
  function ro(t3, e2) {
    g(G(t3), function() {
      return "The f passed in variableGrads(f) must be a function";
    }), g(null == e2 || Array.isArray(e2) && e2.every(function(t4) {
      return t4 instanceof bt;
    }), function() {
      return "The varList passed in variableGrads(f, varList) must be an array of variables";
    });
    var n2 = null != e2;
    if (!n2)
      for (var r2 in e2 = [], Nt.registeredVariables)
        e2.push(Nt.registeredVariables[r2]);
    var o2 = n2 ? e2.filter(function(t4) {
      return !t4.trainable;
    }) : null, a2 = e2.length;
    g((e2 = e2.filter(function(t4) {
      return t4.trainable;
    })).length > 0, function() {
      return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + a2 + " variables is trainable.";
    });
    var i2 = Nt.gradients(t3, e2, null, true), u2 = i2.value, s2 = i2.grads;
    g(s2.some(function(t4) {
      return null != t4;
    }), function() {
      return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
    }), g(0 === u2.rank, function() {
      return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + u2.rank + " tensor";
    });
    var c2 = {};
    return e2.forEach(function(t4, e3) {
      null != s2[e3] && (c2[t4.name] = s2[e3]);
    }), null != o2 && o2.forEach(function(t4) {
      return c2[t4.name] = null;
    }), { value: u2, grads: c2 };
  }
  function oo(t3) {
    return Nt.customGrad(t3);
  }
  var io = Cn({ softmax_: function(t3, e2) {
    void 0 === e2 && (e2 = -1);
    var n2 = ln(t3, "logits", "softmax");
    if (-1 === e2 && (e2 = n2.rank - 1), e2 !== n2.rank - 1)
      throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n2.rank + " and dim was " + e2);
    return oo(function(t4, n3) {
      var r2 = t4.logSumExp([e2], true), o2 = t4.toFloat().sub(r2).exp();
      return n3([o2]), { value: o2, gradFunc: function(t5, n4) {
        var r3 = n4[0], o3 = t5.mul(r3);
        return o3.sub(o3.sum([e2], true).mul(r3));
      } };
    })(n2);
  } });
  var uo = Cn({ logSoftmax_: function(t3, e2) {
    void 0 === e2 && (e2 = -1);
    var n2 = ln(t3, "logits", "logSoftmax");
    if (-1 === e2 && (e2 = n2.rank - 1), e2 !== n2.rank - 1)
      throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n2.rank + " and axis was " + e2);
    return oo(function(t4, n3) {
      var r2 = t4.max(e2, true), o2 = t4.sub(r2), a2 = o2.toFloat().sub(o2.exp().sum(e2, true).log());
      return n3([a2]), { value: a2, gradFunc: function(t5, n4) {
        var r3 = n4[0].exp();
        return t5.sub(t5.sum(e2, true).mul(r3));
      } };
    })(n2);
  } });
  var so = function() {
    function t3(t4, e2) {
      this.backend = t4, this.dataMover = e2, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
    }
    return t3.prototype.get = function(t4) {
      return this.data.has(t4) || this.dataMover.moveData(this.backend, t4), this.data.get(t4);
    }, t3.prototype.set = function(t4, e2) {
      this.dataIdsCount++, this.data.set(t4, e2);
    }, t3.prototype.has = function(t4) {
      return this.data.has(t4);
    }, t3.prototype.delete = function(t4) {
      return this.dataIdsCount--, this.data.delete(t4);
    }, t3.prototype.numDataIds = function() {
      return this.dataIdsCount;
    }, t3;
  }();
  var co = function() {
    function t3() {
    }
    return t3.prototype.time = function(t4) {
      return lo();
    }, t3.prototype.read = function(t4) {
      return lo();
    }, t3.prototype.readSync = function(t4) {
      return lo();
    }, t3.prototype.numDataIds = function() {
      return lo();
    }, t3.prototype.disposeData = function(t4) {
      return lo();
    }, t3.prototype.fromPixels = function(t4, e2) {
      return lo();
    }, t3.prototype.write = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.move = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.memory = function() {
      return lo();
    }, t3.prototype.floatPrecision = function() {
      return lo();
    }, t3.prototype.epsilon = function() {
      return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
    }, t3.prototype.batchMatMul = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.fusedBatchMatMul = function(t4) {
      t4.a, t4.b, t4.transposeA, t4.transposeB, t4.bias, t4.activation, t4.preluActivationWeights;
      return lo();
    }, t3.prototype.slice = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.stridedSlice = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.unstack = function(t4, e2) {
      return lo();
    }, t3.prototype.reverse = function(t4, e2) {
      return lo();
    }, t3.prototype.concat = function(t4, e2) {
      return lo();
    }, t3.prototype.neg = function(t4) {
      return lo();
    }, t3.prototype.add = function(t4, e2) {
      return lo();
    }, t3.prototype.addN = function(t4) {
      return lo();
    }, t3.prototype.subtract = function(t4, e2) {
      return lo();
    }, t3.prototype.multiply = function(t4, e2) {
      return lo();
    }, t3.prototype.realDivide = function(t4, e2) {
      return lo();
    }, t3.prototype.floorDiv = function(t4, e2) {
      return lo();
    }, t3.prototype.sum = function(t4, e2) {
      return lo();
    }, t3.prototype.prod = function(t4, e2) {
      return lo();
    }, t3.prototype.unsortedSegmentSum = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.argMin = function(t4, e2) {
      return lo();
    }, t3.prototype.argMax = function(t4, e2) {
      return lo();
    }, t3.prototype.equal = function(t4, e2) {
      return lo();
    }, t3.prototype.notEqual = function(t4, e2) {
      return lo();
    }, t3.prototype.less = function(t4, e2) {
      return lo();
    }, t3.prototype.lessEqual = function(t4, e2) {
      return lo();
    }, t3.prototype.greater = function(t4, e2) {
      return lo();
    }, t3.prototype.greaterEqual = function(t4, e2) {
      return lo();
    }, t3.prototype.logicalNot = function(t4) {
      return lo();
    }, t3.prototype.logicalAnd = function(t4, e2) {
      return lo();
    }, t3.prototype.logicalOr = function(t4, e2) {
      return lo();
    }, t3.prototype.where = function(t4) {
      return lo();
    }, t3.prototype.select = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.topk = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.min = function(t4, e2) {
      return lo();
    }, t3.prototype.minimum = function(t4, e2) {
      return lo();
    }, t3.prototype.mod = function(t4, e2) {
      return lo();
    }, t3.prototype.max = function(t4, e2) {
      return lo();
    }, t3.prototype.maximum = function(t4, e2) {
      return lo();
    }, t3.prototype.all = function(t4, e2) {
      return lo();
    }, t3.prototype.any = function(t4, e2) {
      return lo();
    }, t3.prototype.squaredDifference = function(t4, e2) {
      return lo();
    }, t3.prototype.ceil = function(t4) {
      return lo();
    }, t3.prototype.floor = function(t4) {
      return lo();
    }, t3.prototype.round = function(t4) {
      return lo();
    }, t3.prototype.sign = function(t4) {
      return lo();
    }, t3.prototype.isNaN = function(t4) {
      return lo();
    }, t3.prototype.isInf = function(t4) {
      return lo();
    }, t3.prototype.isFinite = function(t4) {
      return lo();
    }, t3.prototype.pow = function(t4, e2) {
      return lo();
    }, t3.prototype.exp = function(t4) {
      return lo();
    }, t3.prototype.expm1 = function(t4) {
      return lo();
    }, t3.prototype.log = function(t4) {
      return lo();
    }, t3.prototype.log1p = function(t4) {
      return lo();
    }, t3.prototype.sqrt = function(t4) {
      return lo();
    }, t3.prototype.rsqrt = function(t4) {
      return lo();
    }, t3.prototype.square = function(t4) {
      return lo();
    }, t3.prototype.reciprocal = function(t4) {
      return lo();
    }, t3.prototype.relu = function(t4) {
      return lo();
    }, t3.prototype.relu6 = function(t4) {
      return lo();
    }, t3.prototype.prelu = function(t4, e2) {
      return lo();
    }, t3.prototype.elu = function(t4) {
      return lo();
    }, t3.prototype.eluDer = function(t4, e2) {
      return lo();
    }, t3.prototype.selu = function(t4) {
      return lo();
    }, t3.prototype.int = function(t4) {
      return lo();
    }, t3.prototype.clip = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.abs = function(t4) {
      return lo();
    }, t3.prototype.complexAbs = function(t4) {
      return lo();
    }, t3.prototype.sigmoid = function(t4) {
      return lo();
    }, t3.prototype.softplus = function(t4) {
      return lo();
    }, t3.prototype.sin = function(t4) {
      return lo();
    }, t3.prototype.cos = function(t4) {
      return lo();
    }, t3.prototype.tan = function(t4) {
      return lo();
    }, t3.prototype.asin = function(t4) {
      return lo();
    }, t3.prototype.acos = function(t4) {
      return lo();
    }, t3.prototype.atan = function(t4) {
      return lo();
    }, t3.prototype.atan2 = function(t4, e2) {
      return lo();
    }, t3.prototype.sinh = function(t4) {
      return lo();
    }, t3.prototype.cosh = function(t4) {
      return lo();
    }, t3.prototype.tanh = function(t4) {
      return lo();
    }, t3.prototype.asinh = function(t4) {
      return lo();
    }, t3.prototype.acosh = function(t4) {
      return lo();
    }, t3.prototype.atanh = function(t4) {
      return lo();
    }, t3.prototype.erf = function(t4) {
      return lo();
    }, t3.prototype.step = function(t4, e2) {
      return lo();
    }, t3.prototype.fusedConv2d = function(t4) {
      t4.input, t4.filter, t4.convInfo, t4.bias, t4.activation, t4.preluActivationWeights;
      return lo();
    }, t3.prototype.conv2d = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.conv2dDerInput = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.conv2dDerFilter = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.fusedDepthwiseConv2D = function(t4) {
      t4.input, t4.filter, t4.convInfo, t4.bias, t4.activation, t4.preluActivationWeights;
      return lo();
    }, t3.prototype.depthwiseConv2D = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.depthwiseConv2DDerInput = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.depthwiseConv2DDerFilter = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.conv3d = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.conv3dDerInput = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.conv3dDerFilter = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.maxPool = function(t4, e2) {
      return lo();
    }, t3.prototype.maxPoolBackprop = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.avgPool = function(t4, e2) {
      return lo();
    }, t3.prototype.avgPoolBackprop = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.avgPool3d = function(t4, e2) {
      return lo();
    }, t3.prototype.avgPool3dBackprop = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.maxPool3d = function(t4, e2) {
      return lo();
    }, t3.prototype.maxPool3dBackprop = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.reshape = function(t4, e2) {
      return lo();
    }, t3.prototype.cast = function(t4, e2) {
      return lo();
    }, t3.prototype.tile = function(t4, e2) {
      return lo();
    }, t3.prototype.pad = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.transpose = function(t4, e2) {
      return lo();
    }, t3.prototype.gather = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.gatherND = function(t4, e2) {
      return lo();
    }, t3.prototype.scatterND = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.batchToSpaceND = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.spaceToBatchND = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.resizeBilinear = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.resizeBilinearBackprop = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.resizeNearestNeighbor = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.resizeNearestNeighborBackprop = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.batchNormalization = function(t4, e2, n2, r2, o2, a2) {
      return lo();
    }, t3.prototype.localResponseNormalization4D = function(t4, e2, n2, r2, o2) {
      return lo();
    }, t3.prototype.LRNGrad = function(t4, e2, n2, r2, o2, a2, i2) {
      return lo();
    }, t3.prototype.multinomial = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.oneHot = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.cumsum = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.nonMaxSuppression = function(t4, e2, n2, r2, o2) {
      return lo();
    }, t3.prototype.fft = function(t4) {
      return lo();
    }, t3.prototype.ifft = function(t4) {
      return lo();
    }, t3.prototype.complex = function(t4, e2) {
      return lo();
    }, t3.prototype.real = function(t4) {
      return lo();
    }, t3.prototype.imag = function(t4) {
      return lo();
    }, t3.prototype.cropAndResize = function(t4, e2, n2, r2, o2, a2) {
      return lo();
    }, t3.prototype.depthToSpace = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.split = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.sparseToDense = function(t4, e2, n2, r2) {
      return lo();
    }, t3.prototype.diag = function(t4) {
      return lo();
    }, t3.prototype.fill = function(t4, e2, n2) {
      throw new Error("Not yet implemented.");
    }, t3.prototype.onesLike = function(t4) {
      return lo();
    }, t3.prototype.zerosLike = function(t4) {
      return lo();
    }, t3.prototype.linspace = function(t4, e2, n2) {
      return lo();
    }, t3.prototype.dispose = function() {
      return lo();
    }, t3;
  }();
  function lo() {
    throw new Error("Not yet implemented or not found in the registry. Did you forget to import the kernel?");
  }
  function ho(t3, e2) {
    for (var n2 = t3.length, r2 = [], o2 = 0; o2 < n2; o2++) {
      var a2 = n2 - 1 - o2, i2 = t3[a2] || 1;
      (e2[e2.length - 1 - o2] || 1) > 1 && 1 === i2 && r2.unshift(a2);
    }
    return r2;
  }
  function fo(t3, e2) {
    for (var n2 = [], r2 = 0; r2 < e2.length; r2++) {
      var o2 = t3[t3.length - r2 - 1], a2 = e2.length - r2 - 1, i2 = e2[a2];
      (null == o2 || 1 === o2 && i2 > 1) && n2.unshift(a2);
    }
    return n2;
  }
  function po(t3, e2) {
    for (var n2 = [], r2 = Math.max(t3.length, e2.length), o2 = 0; o2 < r2; o2++) {
      var a2 = t3[t3.length - o2 - 1];
      null == a2 && (a2 = 1);
      var i2 = e2[e2.length - o2 - 1];
      if (null == i2 && (i2 = 1), 1 === a2)
        n2.unshift(i2);
      else if (1 === i2)
        n2.unshift(a2);
      else {
        if (a2 !== i2)
          throw Error("Operands could not be broadcast together with shapes " + t3 + " and " + e2 + ".");
        n2.unshift(a2);
      }
    }
    return n2;
  }
  function vo(t3, e2, n2, r2, o2, a2, i2) {
    void 0 === i2 && (i2 = "channelsLast");
    var u2, s2 = bo(e2), c2 = s2[0], l3 = s2[1];
    if ("channelsLast" === i2)
      u2 = [c2, l3, t3[3], t3[3]];
    else {
      if ("channelsFirst" !== i2)
        throw new Error("Unknown dataFormat " + i2);
      u2 = [c2, l3, t3[1], t3[1]];
    }
    return go(t3, u2, n2, r2, o2, a2, false, i2);
  }
  function mo(t3, e2, n2, r2, o2, a2, i2) {
    void 0 === i2 && (i2 = "NDHWC");
    var u2, s2, c2 = wo(e2), l3 = c2[0], h = c2[1], f2 = c2[2];
    if ("NDHWC" === i2)
      s2 = "channelsLast", u2 = [l3, h, f2, t3[4], t3[4]];
    else {
      if ("NCDHW" !== i2)
        throw new Error("Unknown dataFormat " + i2);
      s2 = "channelsFirst", u2 = [l3, h, f2, t3[1], t3[1]];
    }
    return yo(t3, u2, n2, r2, o2, false, s2, a2);
  }
  function go(t3, e2, n2, r2, o2, a2, i2, u2) {
    void 0 === i2 && (i2 = false), void 0 === u2 && (u2 = "channelsLast");
    var s2 = [-1, -1, -1, -1], c2 = s2[0], l3 = s2[1], h = s2[2], f2 = s2[3];
    if ("channelsLast" === u2)
      c2 = t3[0], l3 = t3[1], h = t3[2], f2 = t3[3];
    else {
      if ("channelsFirst" !== u2)
        throw new Error("Unknown dataFormat " + u2);
      c2 = t3[0], f2 = t3[1], l3 = t3[2], h = t3[3];
    }
    var p2, d2 = e2[0], v2 = e2[1], m2 = e2[3], y2 = bo(n2), x2 = y2[0], b2 = y2[1], w2 = bo(r2), C3 = w2[0], R3 = w2[1], I3 = Co(d2, C3), k4 = Co(v2, R3), S3 = function(t4, e3, n3, r3, o3, a3, i3, u3) {
      var s3, c3, l4;
      if ("number" == typeof t4) {
        var h2 = 0 === t4 ? "VALID" : "NUMBER";
        s3 = { top: t4, bottom: t4, left: t4, right: t4, type: h2 };
        var f3 = function(t5, e4, n4, r4, o4) {
          null == r4 && (r4 = xo(t5, e4, n4));
          var a4 = t5[0], i4 = t5[1], u4 = Eo((a4 - e4 + 2 * r4) / n4 + 1, o4);
          g(E(u4), function() {
            return "The output # of rows (" + u4 + ") must be an integer. Change the stride and/or zero pad parameters";
          });
          var s4 = Eo((i4 - e4 + 2 * r4) / n4 + 1, o4);
          return g(E(s4), function() {
            return "The output # of columns (" + s4 + ") must be an integer. Change the stride and/or zero pad parameters";
          }), [u4, s4];
        }([e3, n3], a3, r3, t4, u3);
        c3 = f3[0], l4 = f3[1];
      } else if ("same" === t4) {
        c3 = Math.ceil(e3 / r3), l4 = Math.ceil(n3 / o3);
        var p3 = Math.max(0, (c3 - 1) * r3 + a3 - e3), d3 = Math.max(0, (l4 - 1) * o3 + i3 - n3), v3 = Math.floor(p3 / 2), m3 = p3 - v3, y3 = Math.floor(d3 / 2), x3 = d3 - y3;
        s3 = { top: v3, bottom: m3, left: y3, right: x3, type: "SAME" };
      } else {
        if ("valid" !== t4)
          throw Error("Unknown padding parameter: " + t4);
        s3 = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, c3 = Math.ceil((e3 - a3 + 1) / r3), l4 = Math.ceil((n3 - i3 + 1) / o3);
      }
      return { padInfo: s3, outHeight: c3, outWidth: l4 };
    }(o2, l3, h, x2, b2, I3, k4, a2), A2 = S3.padInfo, D3 = S3.outHeight, T2 = S3.outWidth, N3 = i2 ? m2 * f2 : m2;
    return "channelsFirst" === u2 ? p2 = [c2, N3, D3, T2] : "channelsLast" === u2 && (p2 = [c2, D3, T2, N3]), { batchSize: c2, dataFormat: u2, inHeight: l3, inWidth: h, inChannels: f2, outHeight: D3, outWidth: T2, outChannels: N3, padInfo: A2, strideHeight: x2, strideWidth: b2, filterHeight: d2, filterWidth: v2, effectiveFilterHeight: I3, effectiveFilterWidth: k4, dilationHeight: C3, dilationWidth: R3, inShape: t3, outShape: p2, filterShape: e2 };
  }
  function yo(t3, e2, n2, r2, o2, a2, i2, u2) {
    void 0 === a2 && (a2 = false), void 0 === i2 && (i2 = "channelsLast");
    var s2 = [-1, -1, -1, -1, -1], c2 = s2[0], l3 = s2[1], h = s2[2], f2 = s2[3], p2 = s2[4];
    if ("channelsLast" === i2)
      c2 = t3[0], l3 = t3[1], h = t3[2], f2 = t3[3], p2 = t3[4];
    else {
      if ("channelsFirst" !== i2)
        throw new Error("Unknown dataFormat " + i2);
      c2 = t3[0], p2 = t3[1], l3 = t3[2], h = t3[3], f2 = t3[4];
    }
    var d2, v2 = e2[0], m2 = e2[1], y2 = e2[2], x2 = e2[4], b2 = wo(n2), w2 = b2[0], C3 = b2[1], R3 = b2[2], I3 = wo(r2), k4 = I3[0], S3 = I3[1], A2 = I3[2], D3 = Co(v2, k4), T2 = Co(m2, S3), N3 = Co(y2, A2), F3 = function(t4, e3, n3, r3, o3, a3, i3, u3, s3, c3, l4) {
      var h2, f3, p3, d3;
      if ("number" == typeof t4) {
        var v3 = 0 === t4 ? "VALID" : "NUMBER";
        h2 = { top: t4, bottom: t4, left: t4, right: t4, front: t4, back: t4, type: v3 };
        var m3 = function(t5, e4, n4, r4, o4, a4) {
          null == o4 && (o4 = xo(t5, e4, r4));
          var i4 = t5[0], u4 = t5[1], s4 = t5[2], c4 = Eo((i4 - e4 + 2 * o4) / r4 + 1, a4);
          g(E(c4), function() {
            return "The output # of depths (" + c4 + ") must be an integer. Change the stride and/or zero pad parameters";
          });
          var l5 = Eo((u4 - e4 + 2 * o4) / r4 + 1, a4);
          g(E(l5), function() {
            return "The output # of rows (" + l5 + ") must be an integer. Change the stride and/or zero pad parameters";
          });
          var h3 = Eo((s4 - e4 + 2 * o4) / r4 + 1, a4);
          return g(E(h3), function() {
            return "The output # of columns (" + h3 + ") must be an integer. Change the stride and/or zero pad parameters";
          }), [c4, l5, h3, n4];
        }([e3, n3, r3, 1], u3, 1, o3, t4, l4);
        f3 = m3[0], p3 = m3[1], d3 = m3[2];
      } else if ("same" === t4) {
        f3 = Math.ceil(e3 / o3), p3 = Math.ceil(n3 / a3), d3 = Math.ceil(r3 / i3);
        var y3 = (f3 - 1) * o3 + u3 - e3, x3 = (p3 - 1) * a3 + s3 - n3, b3 = (d3 - 1) * i3 + c3 - r3, w3 = Math.floor(y3 / 2), C4 = y3 - w3, R4 = Math.floor(x3 / 2), I4 = x3 - R4, k5 = Math.floor(b3 / 2), S4 = b3 - k5;
        h2 = { top: R4, bottom: I4, left: k5, right: S4, front: w3, back: C4, type: "SAME" };
      } else {
        if ("valid" !== t4)
          throw Error("Unknown padding parameter: " + t4);
        h2 = { top: 0, bottom: 0, left: 0, right: 0, front: 0, back: 0, type: "VALID" }, f3 = Math.ceil((e3 - u3 + 1) / o3), p3 = Math.ceil((n3 - s3 + 1) / a3), d3 = Math.ceil((r3 - c3 + 1) / i3);
      }
      return { padInfo: h2, outDepth: f3, outHeight: p3, outWidth: d3 };
    }(o2, l3, h, f2, w2, C3, R3, D3, T2, N3, u2), O3 = F3.padInfo, _3 = F3.outDepth, M2 = F3.outHeight, B3 = F3.outWidth, P3 = a2 ? x2 * p2 : x2;
    return "channelsFirst" === i2 ? d2 = [c2, P3, _3, M2, B3] : "channelsLast" === i2 && (d2 = [c2, _3, M2, B3, P3]), { batchSize: c2, dataFormat: i2, inDepth: l3, inHeight: h, inWidth: f2, inChannels: p2, outDepth: _3, outHeight: M2, outWidth: B3, outChannels: P3, padInfo: O3, strideDepth: w2, strideHeight: C3, strideWidth: R3, filterDepth: v2, filterHeight: m2, filterWidth: y2, effectiveFilterDepth: D3, effectiveFilterHeight: T2, effectiveFilterWidth: N3, dilationDepth: k4, dilationHeight: S3, dilationWidth: A2, inShape: t3, outShape: d2, filterShape: e2 };
  }
  function xo(t3, e2, n2, r2) {
    void 0 === r2 && (r2 = 1);
    var o2 = Co(e2, r2);
    return Math.floor((t3[0] * (n2 - 1) - n2 + o2) / 2);
  }
  function bo(t3) {
    return "number" == typeof t3 ? [t3, t3, t3] : 2 === t3.length ? [t3[0], t3[1], 1] : t3;
  }
  function wo(t3) {
    return "number" == typeof t3 ? [t3, t3, t3] : t3;
  }
  function Co(t3, e2) {
    return e2 <= 1 ? t3 : t3 + (t3 - 1) * (e2 - 1);
  }
  function Eo(t3, e2) {
    if (!e2)
      return t3;
    switch (e2) {
      case "round":
        return Math.round(t3);
      case "ceil":
        return Math.ceil(t3);
      case "floor":
        return Math.floor(t3);
      default:
        throw new Error("Unknown roundingMode " + e2);
    }
  }
  function Ro(t3) {
    var e2 = bo(t3), n2 = e2[0], r2 = e2[1], o2 = e2[2];
    return 1 === n2 && 1 === r2 && 1 === o2;
  }
  function Io(t3, e2) {
    return Ro(t3) || Ro(e2);
  }
  function ko(t3) {
    if ("NHWC" === t3)
      return "channelsLast";
    if ("NCHW" === t3)
      return "channelsFirst";
    throw new Error("Unknown dataFormat " + t3);
  }
  function So(t3, e2, n2) {
    if ("complex64" === e2) {
      if ("complex64" === t3.dtype)
        return t3.clone();
      var r2 = Pn(t3.shape), o2 = t3.toFloat(), a2 = n2.complex(o2, r2);
      return r2.dispose(), o2.dispose(), a2;
    }
    if (!M(t3.dtype, e2))
      return Nt.makeTensorFromDataId(t3.dataId, t3.shape, e2);
    if ("complex64" === t3.dtype) {
      var i2 = n2.real(t3);
      a2 = i2.cast(e2);
      return i2.dispose(), a2;
    }
    if ("int32" === e2)
      return n2.int(t3);
    if ("bool" === e2) {
      var u2 = An(0, t3.dtype);
      a2 = n2.notEqual(t3, u2);
      return u2.dispose(), a2;
    }
    throw new Error("Error in Cast: failed to cast " + t3.dtype + " to " + e2);
  }
  function Ao(t3, e2) {
    return Nt.makeTensorFromDataId(t3.dataId, e2, t3.dtype);
  }
  function Do(t3, e2, n2) {
    var r2 = (e2 - t3) / (n2 - 1), o2 = $(n2, "float32");
    o2[0] = t3;
    for (var a2 = 1; a2 < o2.length; a2++)
      o2[a2] = o2[a2 - 1] + r2;
    return Dn(o2, "float32");
  }
  var To = Object.freeze({ castTensor: So, reshapeTensor: Ao, linspaceImpl: Do, upcastType: Ct, axesAreInnerMostDims: fn, combineLocations: pn, computeOutAndReduceShapes: dn, expandShapeToKeepDim: vn, assertAxesAreInnerMostDims: mn, getAxesPermutation: gn, getUndoAxesPermutation: yn, getInnerMostAxes: xn, getBroadcastDims: ho, getReductionAxes: fo, assertAndGetBroadcastShape: po, assertParamsConsistent: bn, computeOutShape: wn, computePool2DInfo: vo, computePool3DInfo: mo, computeConv2DInfo: go, computeConv3DInfo: yo, computeDefaultPad: xo, tupleValuesAreOne: Ro, eitherStridesOrDilationsAreOne: Io, convertConv2DDataFormat: ko });
  function No(t3, e2) {
    if (t3.length !== e2.length)
      throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t3.length + ", imag: " + e2.length + ".");
    for (var n2 = new Float32Array(2 * t3.length), r2 = 0; r2 < n2.length; r2 += 2)
      n2[r2] = t3[r2 / 2], n2[r2 + 1] = e2[r2 / 2];
    return n2;
  }
  function Fo(t3, e2) {
    return { real: t3[2 * e2], imag: t3[2 * e2 + 1] };
  }
  function Oo(t3, e2, n2, r2) {
    t3[2 * r2] = e2, t3[2 * r2 + 1] = n2;
  }
  function _o(t3, e2, n2) {
    var r2 = (n2 ? 2 : -2) * Math.PI * (t3 / e2);
    return { real: Math.cos(r2), imag: Math.sin(r2) };
  }
  function Mo(t3, e2, n2, r2, o2) {
    for (var a2 = Array.from(e2).map(function(t4, e3) {
      return { score: t4, boxIndex: e3 };
    }).filter(function(t4) {
      return t4.score > o2;
    }).sort(function(t4, e3) {
      return e3.score - t4.score;
    }), i2 = [], u2 = 0; u2 < a2.length; u2++) {
      var s2 = a2[u2], c2 = s2.score, l3 = s2.boxIndex;
      if (c2 < o2)
        break;
      for (var h = false, f2 = i2.length - 1; f2 >= 0; --f2) {
        if (Bo(t3, l3, i2[f2]) >= r2) {
          h = true;
          break;
        }
      }
      if (!h && (i2.push(l3), i2.length >= n2))
        break;
    }
    return Dn(i2, "int32");
  }
  function Bo(t3, e2, n2) {
    var r2 = t3.subarray(4 * e2, 4 * e2 + 4), o2 = t3.subarray(4 * n2, 4 * n2 + 4), a2 = Math.min(r2[0], r2[2]), i2 = Math.min(r2[1], r2[3]), u2 = Math.max(r2[0], r2[2]), s2 = Math.max(r2[1], r2[3]), c2 = Math.min(o2[0], o2[2]), l3 = Math.min(o2[1], o2[3]), h = Math.max(o2[0], o2[2]), f2 = Math.max(o2[1], o2[3]), p2 = (u2 - a2) * (s2 - i2), d2 = (h - c2) * (f2 - l3);
    if (p2 <= 0 || d2 <= 0)
      return 0;
    var v2 = Math.max(a2, c2), m2 = Math.max(i2, l3), g2 = Math.min(u2, h), y2 = Math.min(s2, f2), x2 = Math.max(g2 - v2, 0) * Math.max(y2 - m2, 0);
    return x2 / (p2 + d2 - x2);
  }
  function Po(t3, e2, n2) {
    var r2 = new Array(t3.rank).fill(0), o2 = t3.shape.slice();
    return e2.map(function(e3) {
      o2[n2] = e3;
      var a2 = t3.slice(r2, o2);
      return r2[n2] += e3, a2;
    });
  }
  function Lo(t3, e2) {
    for (var n2 = new Array(t3.rank), r2 = 0; r2 < n2.length; r2++)
      n2[r2] = t3.shape[r2] * e2[r2];
    var o2 = ur(n2, t3.dtype);
    for (r2 = 0; r2 < o2.values.length; ++r2) {
      for (var a2 = o2.indexToLoc(r2), i2 = new Array(t3.rank), u2 = 0; u2 < i2.length; u2++)
        i2[u2] = a2[u2] % t3.shape[u2];
      var s2 = t3.locToIndex(i2);
      o2.values[r2] = t3.values[s2];
    }
    return o2.toTensor();
  }
  function Wo(t3, e2, n2, r2, o2) {
    for (var a2 = e2[e2.length - 1], i2 = [t3.length / a2, a2], u2 = i2[0], s2 = i2[1], c2 = N(n2, u2 * r2), l3 = N("int32", u2 * r2), h = 0; h < u2; h++) {
      for (var f2 = h * s2, p2 = t3.subarray(f2, f2 + s2), d2 = [], v2 = 0; v2 < p2.length; v2++)
        d2.push({ value: p2[v2], index: v2 });
      d2.sort(function(t4, e3) {
        return e3.value - t4.value;
      });
      var m2 = h * r2, g2 = c2.subarray(m2, m2 + r2), y2 = l3.subarray(m2, m2 + r2);
      for (v2 = 0; v2 < r2; v2++)
        g2[v2] = d2[v2].value, y2[v2] = d2[v2].index;
    }
    var x2 = e2.slice();
    return x2[x2.length - 1] = r2, [kn(c2, x2, n2), kn(l3, x2, "int32")];
  }
  function Uo(t3, e2) {
    for (var n2 = [], r2 = 0; r2 < e2.length; r2++)
      e2[r2] && n2.push(r2);
    var o2 = ur(t3, "int32"), a2 = ur([n2.length, t3.length], "int32");
    for (r2 = 0; r2 < n2.length; r2++) {
      var i2 = o2.indexToLoc(n2[r2]), u2 = r2 * t3.length;
      a2.values.set(i2, u2);
    }
    return a2.toTensor();
  }
  var Vo = function() {
    return function(t3, e2) {
      this.outputShape = [], this.outputShape = t3, this.variableNames = e2.map(function(t4, e3) {
        return "T" + e3;
      });
      var n2 = [];
      this.variableNames.forEach(function(t4) {
        n2.push("float v" + t4 + " = get" + t4 + "AtOutCoords();");
      });
      var r2 = this.variableNames.map(function(t4) {
        return "v" + t4;
      }).join(" + ");
      this.userCode = "\n      void main() {\n        " + n2.join("\n        ") + "\n\n        float result = " + r2 + ";\n        setOutput(result);\n      }\n    ";
    };
  }();
  var zo = function() {
    return function(t3, e2) {
      this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3, this.variableNames = e2.map(function(t4, e3) {
        return "T" + e3;
      });
      var n2 = [];
      this.variableNames.forEach(function(t4) {
        n2.push("vec4 v" + t4 + " = get" + t4 + "AtOutCoords();");
      });
      var r2 = this.variableNames.map(function(t4) {
        return "v" + t4;
      }).join(" + ");
      this.userCode = "\n      void main() {\n        " + n2.join("\n        ") + "\n\n        vec4 result = " + r2 + ";\n        setOutput(result);\n      }\n    ";
    };
  }();
  var Go = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["A"];
      var r2 = t3.windowSize, o2 = t3.batchSize, a2 = t3.inSize, i2 = Math.ceil(a2 / r2);
      n2 || this.variableNames.push("bestIndicesA"), this.outputShape = [o2, i2];
      var u2 = "max" === e2 ? ">" : "<", s2 = n2 ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
      this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r2 + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r2 + "; i++) {\n          int inIdx = " + s2 + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + u2 + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
    };
  }();
  function Ho(t3, e2) {
    return ["x", "y", "z", "w", "u", "v"].slice(0, e2).map(function(e3) {
      return t3 + "." + e3;
    });
  }
  function qo(t3, e2) {
    return 1 === e2 ? [t3] : Ho(t3, e2);
  }
  function Ko() {
    var t3, e2, n2, r2, o2, i2, u2, s2, c2, l3;
    return 2 === a().getNumber("WEBGL_VERSION") ? (t3 = "#version 300 es", e2 = "in", n2 = "out", r2 = "in", o2 = "texture", i2 = "outputColor", u2 = "out vec4 outputColor;", s2 = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", c2 = "", l3 = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t3 = "", e2 = "attribute", n2 = "varying", r2 = "varying", o2 = "texture2D", i2 = "gl_FragColor", u2 = "", s2 = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", c2 = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l3 = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), { version: t3, attribute: e2, varyingVs: n2, varyingFs: r2, texture2D: o2, output: i2, defineOutput: u2, defineSpecialNaN: s2, defineSpecialInf: c2, defineRound: l3 };
  }
  function jo(t3, e2, n2) {
    void 0 === n2 && (n2 = "index");
    var r2 = q(e2);
    return r2.map(function(e3, o2) {
      return "int " + t3[o2] + " = " + n2 + " / " + e3 + "; " + (o2 === r2.length - 1 ? "int " + t3[o2 + 1] + " = " + n2 + " - " + t3[o2] + " * " + e3 : "index -= " + t3[o2] + " * " + e3) + ";";
    }).join("");
  }
  function Xo(t3) {
    var e2 = q(t3).map(function(t4) {
      return t4.toString();
    });
    return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e2[0] + " + coords.y * " + e2[1] + " + coords.z;\n  }\n";
  }
  var $o = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
  function Yo(t3, e2, n2, r2) {
    var o2 = [];
    t3.forEach(function(t4) {
      var e3 = w(t4.shapeInfo.logicalShape);
      t4.shapeInfo.isUniform ? o2.push("uniform float " + t4.name + (e3 > 1 ? "[" + e3 + "]" : "") + ";") : (o2.push("uniform sampler2D " + t4.name + ";"), o2.push("uniform int offset" + t4.name + ";"));
    });
    var a2, i2, u2 = o2.join("\n"), s2 = t3.map(function(t4) {
      return function(t5, e3, n3) {
        void 0 === n3 && (n3 = false);
        var r3 = "";
        r3 += n3 ? Jo(t5) : Qo(t5);
        var o3 = t5.shapeInfo.logicalShape, a3 = e3.logicalShape;
        o3.length <= a3.length && (r3 += n3 ? function(t6, e4) {
          var n4, r4 = t6.name, o4 = r4.charAt(0).toUpperCase() + r4.slice(1), a4 = "get" + o4 + "AtOutCoords", i3 = t6.shapeInfo.logicalShape.length, u3 = e4.logicalShape.length, s3 = ho(t6.shapeInfo.logicalShape, e4.logicalShape), c3 = aa(u3), l4 = u3 - i3, h2 = ["x", "y", "z", "w", "u", "v"];
          n4 = 0 === i3 ? "" : u3 < 2 && s3.length >= 1 ? "coords = 0;" : s3.map(function(t7) {
            return "coords." + h2[t7 + l4] + " = 0;";
          }).join("\n");
          var f3 = "";
          f3 = u3 < 2 && i3 > 0 ? "coords" : t6.shapeInfo.logicalShape.map(function(t7, e5) {
            return "coords." + h2[e5 + l4];
          }).join(", ");
          var p2 = "return outputValue;", d2 = 1 === w(t6.shapeInfo.logicalShape), v2 = 1 === w(e4.logicalShape);
          if (1 !== i3 || d2 || v2) {
            if (d2 && !v2)
              p2 = 1 === u3 ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
            else if (s3.length) {
              var m2 = i3 - 2, g2 = i3 - 1;
              s3.indexOf(m2) > -1 && s3.indexOf(g2) > -1 ? p2 = "return vec4(outputValue.x);" : s3.indexOf(m2) > -1 ? p2 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : s3.indexOf(g2) > -1 && (p2 = "return vec4(outputValue.xx, outputValue.zz);");
            }
          } else
            p2 = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
          return "\n    vec4 " + a4 + "() {\n      " + c3 + " coords = getOutputCoords();\n      " + n4 + "\n      vec4 outputValue = get" + o4 + "(" + f3 + ");\n      " + p2 + "\n    }\n  ";
        }(t5, e3) : function(t6, e4) {
          var n4 = t6.name, r4 = n4.charAt(0).toUpperCase() + n4.slice(1), o4 = "get" + r4 + "AtOutCoords", a4 = e4.texShape, i3 = t6.shapeInfo.texShape, u3 = t6.shapeInfo.logicalShape.length, s3 = e4.logicalShape.length;
          if (!t6.shapeInfo.isUniform && u3 === s3 && null == t6.shapeInfo.flatOffset && C(i3, a4))
            return "\n      float " + o4 + "() {\n        return sampleTexture(" + n4 + ", resultUV);\n      }\n    ";
          var c3, l4 = aa(s3), h2 = ho(t6.shapeInfo.logicalShape, e4.logicalShape), f3 = s3 - u3, p2 = ["x", "y", "z", "w", "u", "v"];
          c3 = 0 === u3 ? "" : s3 < 2 && h2.length >= 1 ? "coords = 0;" : h2.map(function(t7) {
            return "coords." + p2[t7 + f3] + " = 0;";
          }).join("\n");
          var d2 = "";
          d2 = s3 < 2 && u3 > 0 ? "coords" : t6.shapeInfo.logicalShape.map(function(t7, e5) {
            return "coords." + p2[e5 + f3];
          }).join(", ");
          return "\n    float " + o4 + "() {\n      " + l4 + " coords = getOutputCoords();\n      " + c3 + "\n      return get" + r4 + "(" + d2 + ");\n    }\n  ";
        }(t5, e3));
        return r3;
      }(t4, e2, r2);
    }).join("\n"), c2 = e2.texShape, l3 = Ko(), h = function(t4) {
      return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t4.texture2D + "(textureSampler, uv).r;\n    }\n  ";
    }(l3), f2 = function(t4) {
      return t4.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t4.varyingFs + " vec2 resultUV;\n    " + t4.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t4.defineSpecialNaN + "\n    " + t4.defineSpecialInf + "\n    " + t4.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + Zo + "\n    " + ta + "\n    " + ea + "\n  ";
    }(l3);
    return e2.isPacked ? (a2 = function(t4, e3) {
      switch (t4.length) {
        case 0:
          return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
        case 1:
          return function(t5, e4) {
            var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)];
            if (1 === n4[0])
              return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n4[1] + ".0);\n      }\n    ";
            if (1 === n4[1])
              return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n4[0] + ".0);\n      }\n    ";
            return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n      return 2 * (resTexRC.x * " + n4[1] + " + resTexRC.y);\n    }\n  ";
          }(0, e3);
        case 2:
          return function(t5, e4) {
            var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)];
            if (C(t5, e4))
              return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n4[0] + ", " + n4[1] + "));\n      }\n    ";
            var r4 = Math.ceil(t5[1] / 2);
            return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n\n      int index = resTexRC.x * " + n4[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r4 + ");\n      int c = imod(index, " + r4 + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
          }(t4, e3);
        case 3:
          return n3 = t4, r3 = e3, o3 = [Math.ceil(r3[0] / 2), Math.ceil(r3[1] / 2)], a3 = Math.ceil(n3[2] / 2), i3 = a3 * Math.ceil(n3[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + o3[0] + ", " + o3[1] + "));\n      int index = resTexRC.x * " + o3[1] + " + resTexRC.y;\n\n      int b = index / " + i3 + ";\n      index -= b * " + i3 + ";\n\n      int r = 2 * (index / " + a3 + ");\n      int c = imod(index, " + a3 + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
        default:
          return function(t5, e4) {
            for (var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)], r4 = Math.ceil(t5[t5.length - 1] / 2), o4 = r4 * Math.ceil(t5[t5.length - 2] / 2), a4 = o4, i4 = "", u3 = "b, r, c", s3 = 2; s3 < t5.length - 1; s3++)
              a4 *= t5[t5.length - s3 - 1], i4 = "\n      int b" + s3 + " = index / " + a4 + ";\n      index -= b" + s3 + " * " + a4 + ";\n    " + i4, u3 = "b" + s3 + ", " + u3;
            return "\n    ivec" + t5.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n      int index = resTexRC.x * " + n4[1] + " + resTexRC.y;\n\n      " + i4 + "\n\n      int b = index / " + o4 + ";\n      index -= b * " + o4 + ";\n\n      int r = 2 * (index / " + r4 + ");\n      int c = imod(index, " + r4 + ") * 2;\n\n      return ivec" + t5.length + "(" + u3 + ");\n    }\n  ";
          }(t4, e3);
      }
      var n3, r3, o3, a3, i3;
    }(e2.logicalShape, c2), i2 = function(t4) {
      return "\n    void setOutput(vec4 val) {\n      " + t4.output + " = val;\n    }\n  ";
    }(l3)) : (a2 = function(t4, e3) {
      switch (t4.length) {
        case 0:
          return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
        case 1:
          return function(t5, e4) {
            if (1 === e4[0])
              return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e4[1] + ".0);\n      }\n    ";
            if (1 === e4[1])
              return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e4[0] + ".0);\n      }\n    ";
            return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e4[0] + ", " + e4[1] + "));\n      return resTexRC.x * " + e4[1] + " + resTexRC.y;\n    }\n  ";
          }(0, e3);
        case 2:
          return function(t5, e4) {
            if (C(t5, e4))
              return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e4[0] + ", " + e4[1] + "));\n      }\n    ";
            if (1 === t5[1])
              return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e4[0] + ", " + e4[1] + "));\n        int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
            if (1 === t5[0])
              return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e4[0] + ", " + e4[1] + "));\n        int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
            return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n      int r = index / " + t5[1] + ";\n      int c = index - r * " + t5[1] + ";\n      return ivec2(r, c);\n    }\n  ";
          }(t4, e3);
        case 3:
          return n3 = e3, r3 = jo(["r", "c", "d"], t4), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n3[0] + ", " + n3[1] + "));\n      int index = resTexRC.x * " + n3[1] + " + resTexRC.y;\n      " + r3 + "\n      return ivec3(r, c, d);\n    }\n  ";
        case 4:
          return function(t5, e4) {
            var n4 = jo(["r", "c", "d", "d2"], t5);
            return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n      " + n4 + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
          }(t4, e3);
        case 5:
          return function(t5, e4) {
            var n4 = jo(["r", "c", "d", "d2", "d3"], t5);
            return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e4[0] + ",\n                             " + e4[1] + "));\n\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n\n      " + n4 + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
          }(t4, e3);
        case 6:
          return function(t5, e4) {
            var n4 = jo(["r", "c", "d", "d2", "d3", "d4"], t5);
            return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n\n      " + n4 + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
          }(t4, e3);
        default:
          throw new Error(t4.length + "-D output sampling is not yet supported");
      }
      var n3, r3;
    }(e2.logicalShape, c2), i2 = function(t4) {
      return "\n    void setOutput(float val) {\n      " + t4.output + " = vec4(val, 0, 0, 0);\n    }\n  ";
    }(l3)), r2 && (f2 += na), [f2, h, i2, u2, a2, s2, n2].join("\n");
  }
  function Qo(t3) {
    var e2 = t3.shapeInfo.logicalShape;
    switch (e2.length) {
      case 0:
        return function(t4) {
          var e3 = t4.name, n2 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1);
          if (t4.shapeInfo.isUniform)
            return "float " + n2 + "() {return " + e3 + ";}";
          var r2 = t4.shapeInfo.texShape, o2 = r2[0], a2 = r2[1];
          if (1 === o2 && 1 === a2)
            return "\n      float " + n2 + "() {\n        return sampleTexture(" + e3 + ", halfCR);\n      }\n    ";
          var i2 = t4.shapeInfo.texShape, u2 = i2[0], s2 = i2[1], c2 = ra(e3);
          return "\n    float " + n2 + "() {\n      vec2 uv = uvFromFlat(" + u2 + ", " + s2 + ", " + c2 + ");\n      return sampleTexture(" + e3 + ", uv);\n    }\n  ";
        }(t3);
      case 1:
        return function(t4) {
          var e3 = t4.name, n2 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1);
          if (t4.shapeInfo.isUniform)
            return "\n      float " + n2 + "(int index) {\n        " + oa(t4) + "\n      }\n    ";
          var r2 = t4.shapeInfo.texShape, o2 = r2[0], a2 = r2[1];
          if (1 === a2 && 1 === o2)
            return "\n      float " + n2 + "(int index) {\n        return sampleTexture(" + e3 + ", halfCR);\n      }\n    ";
          var i2 = ra(e3);
          if (1 === a2)
            return "\n      float " + n2 + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + i2 + ") + 0.5) / " + o2 + ".0);\n        return sampleTexture(" + e3 + ", uv);\n      }\n    ";
          if (1 === o2)
            return "\n      float " + n2 + "(int index) {\n        vec2 uv = vec2((float(index + " + i2 + ") + 0.5) / " + a2 + ".0, 0.5);\n        return sampleTexture(" + e3 + ", uv);\n      }\n    ";
          return "\n    float " + n2 + "(int index) {\n      vec2 uv = uvFromFlat(" + o2 + ", " + a2 + ", index + " + i2 + ");\n      return sampleTexture(" + e3 + ", uv);\n    }\n  ";
        }(t3);
      case 2:
        return function(t4) {
          var e3 = t4.shapeInfo.logicalShape, n2 = t4.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = t4.shapeInfo.texShape;
          if (null != o2 && C(e3, o2)) {
            var a2 = o2[0], i2 = o2[1];
            return "\n    float " + r2 + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i2 + ".0, " + a2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
          }
          var u2 = T(e3), s2 = u2.newShape, c2 = u2.keptDims, l3 = s2;
          if (l3.length < e3.length) {
            var h = ia(t4, l3);
            return "\n      " + Qo(h) + "\n      float " + r2 + "(int row, int col) {\n        return " + r2 + "(" + ua(["row", "col"], c2) + ");\n      }\n    ";
          }
          if (t4.shapeInfo.isUniform)
            return "\n      float " + r2 + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e3[1] + ", 1)));\n        " + oa(t4) + "\n      }\n    ";
          var f2 = o2[0], p2 = o2[1], d2 = ra(n2);
          if (1 === p2)
            return "\n    float " + r2 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d2 + "), vec3(" + e3[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
          if (1 === f2)
            return "\n    float " + r2 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d2 + "), vec3(" + e3[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + p2 + ".0, 0.5);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
          return "\n  float " + r2 + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e3[1] + " + col + " + d2 + ";\n    vec2 uv = uvFromFlat(" + f2 + ", " + p2 + ", index);\n    return sampleTexture(" + n2 + ", uv);\n  }\n";
        }(t3);
      case 3:
        return function(t4) {
          var e3 = t4.shapeInfo.logicalShape, n2 = t4.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[1] * e3[2], a2 = e3[2], i2 = T(e3), u2 = i2.newShape, s2 = i2.keptDims, c2 = u2;
          if (c2.length < e3.length) {
            var l3 = ia(t4, c2);
            return "\n        " + Qo(l3) + "\n        float " + r2 + "(int row, int col, int depth) {\n          return " + r2 + "(" + ua(["row", "col", "depth"], s2) + ");\n        }\n      ";
          }
          if (t4.shapeInfo.isUniform)
            return "\n      float " + r2 + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + o2 + ", " + a2 + ", 1)));\n        " + oa(t4) + "\n      }\n    ";
          var h = t4.shapeInfo.texShape, f2 = h[0], p2 = h[1], d2 = t4.shapeInfo.flatOffset;
          if (p2 === o2 && null == d2)
            return "\n        float " + r2 + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + a2 + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + p2 + ".0, " + f2 + ".0);\n          return sampleTexture(" + n2 + ", uv);\n        }\n      ";
          if (p2 === a2 && null == d2)
            return "\n    float " + r2 + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e3[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + p2 + ".0, " + f2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
          var v2 = ra(n2);
          return "\n      float " + r2 + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + o2 + " + col * " + a2 + " + depth + " + v2 + ";\n        vec2 uv = uvFromFlat(" + f2 + ", " + p2 + ", index);\n        return sampleTexture(" + n2 + ", uv);\n      }\n  ";
        }(t3);
      case 4:
        return function(t4) {
          var e3 = t4.shapeInfo.logicalShape, n2 = t4.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[3], a2 = e3[2] * o2, i2 = e3[1] * a2, u2 = T(e3), s2 = u2.newShape, c2 = u2.keptDims;
          if (s2.length < e3.length) {
            var l3 = ia(t4, s2);
            return "\n      " + Qo(l3) + "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        return " + r2 + "(" + ua(["row", "col", "depth", "depth2"], c2) + ");\n      }\n    ";
          }
          if (t4.shapeInfo.isUniform)
            return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + i2 + ", " + a2 + ", " + o2 + ", 1)));\n        " + oa(t4) + "\n      }\n    ";
          var h = t4.shapeInfo.flatOffset, f2 = t4.shapeInfo.texShape, p2 = f2[0], d2 = f2[1];
          if (d2 === i2 && null == h)
            return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + a2 + ", " + o2 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + d2 + ".0, " + p2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
          if (d2 === o2 && null == h)
            return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e3[1] * e3[2] + ", " + e3[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + d2 + ".0, " + p2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
          var v2 = ra(n2);
          return "\n    float " + r2 + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + i2 + " + col * " + a2 + " +\n          depth * " + o2 + " + depth2;\n      vec2 uv = uvFromFlat(" + p2 + ", " + d2 + ", index + " + v2 + ");\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        }(t3);
      case 5:
        return function(t4) {
          var e3 = t4.shapeInfo.logicalShape, n2 = t4.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[4], a2 = e3[3] * o2, i2 = e3[2] * a2, u2 = e3[1] * i2, s2 = T(e3), c2 = s2.newShape, l3 = s2.keptDims;
          if (c2.length < e3.length) {
            var h = ia(t4, c2);
            return "\n      " + Qo(h) + "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r2 + "(" + ua(["row", "col", "depth", "depth2", "depth3"], l3) + ");\n      }\n    ";
          }
          if (t4.shapeInfo.isUniform)
            return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + u2 + ", " + i2 + ", " + a2 + ", " + o2 + ")) +\n          depth3;\n        " + oa(t4) + "\n      }\n    ";
          var f2 = t4.shapeInfo.flatOffset, p2 = t4.shapeInfo.texShape, d2 = p2[0], v2 = p2[1];
          if (v2 === u2 && null == f2)
            return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + i2 + ", " + a2 + ", " + o2 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v2 + ".0, " + d2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
          if (v2 === o2 && null == f2)
            return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e3[1] * e3[2] * e3[3] + ",\n               " + e3[2] * e3[3] + ", " + e3[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v2 + ".0, " + d2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
          var m2 = ra(n2);
          return "\n    float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + u2 + " + col * " + i2 + " + depth * " + a2 + " +\n          depth2 * " + o2 + " + depth3 + " + m2 + ";\n      vec2 uv = uvFromFlat(" + d2 + ", " + v2 + ", index);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        }(t3);
      case 6:
        return function(t4) {
          var e3 = t4.shapeInfo.logicalShape, n2 = t4.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = T(e3), a2 = o2.newShape, i2 = o2.keptDims;
          if (a2.length < e3.length) {
            var u2 = ia(t4, a2);
            return "\n      " + Qo(u2) + "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r2 + "(" + ua(["row", "col", "depth", "depth2", "depth3", "depth4"], i2) + ");\n      }\n    ";
          }
          var s2 = e3[5], c2 = e3[4] * s2, l3 = e3[3] * c2, h = e3[2] * l3, f2 = e3[1] * h;
          if (t4.shapeInfo.isUniform)
            return "\n      float " + r2 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f2 + ", " + h + ", " + l3 + ", " + c2 + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + s2 + ", 1)));\n        " + oa(t4) + "\n      }\n    ";
          var p2 = t4.shapeInfo.flatOffset, d2 = t4.shapeInfo.texShape, v2 = d2[0], m2 = d2[1];
          if (m2 === f2 && null == p2)
            return "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h + ", " + l3 + ", " + c2 + ", " + s2 + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m2 + ".0, " + v2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
          if (m2 === s2 && null == p2)
            return "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e3[1] * e3[2] * e3[3] * e3[4] + ",\n               " + e3[2] * e3[3] * e3[4] + ",\n               " + e3[3] * e3[4] + ",\n               " + e3[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m2 + ".0, " + v2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
          var g2 = ra(n2);
          return "\n    float " + r2 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f2 + " + col * " + h + " + depth * " + l3 + " +\n          depth2 * " + c2 + " + depth3 * " + s2 + " + depth4 + " + g2 + ";\n      vec2 uv = uvFromFlat(" + v2 + ", " + m2 + ", index);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        }(t3);
      default:
        throw new Error(e2.length + "-D input sampling is not yet supported");
    }
  }
  function Jo(t3) {
    var e2, n2, r2;
    switch (t3.shapeInfo.logicalShape.length) {
      case 0:
        return e2 = t3.name, n2 = "get" + e2.charAt(0).toUpperCase() + e2.slice(1), r2 = Ko(), "\n    vec4 " + n2 + "() {\n      return " + r2.texture2D + "(" + e2 + ", halfCR);\n    }\n  ";
      case 1:
        return function(t4) {
          var e3 = t4.name, n3 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1), r3 = t4.shapeInfo.texShape, o2 = [Math.ceil(r3[0] / 2), Math.ceil(r3[1] / 2)], a2 = Ko();
          return "\n    vec4 " + n3 + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + o2[0] + ", " + o2[1] + ", index);\n      return " + a2.texture2D + "(" + e3 + ", uv);\n    }\n  ";
        }(t3);
      case 2:
        return function(t4) {
          var e3 = t4.shapeInfo.logicalShape, n3 = t4.name, r3 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1), o2 = t4.shapeInfo.texShape, a2 = o2[0], i2 = o2[1], u2 = Ko();
          if (null != o2 && C(e3, o2))
            return "\n      vec4 " + r3 + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i2 + ".0, " + a2 + ".0);\n\n        return " + u2.texture2D + "(" + n3 + ", uv);\n      }\n    ";
          var s2 = [Math.ceil(o2[0] / 2), Math.ceil(o2[1] / 2)], c2 = Math.ceil(e3[1] / 2);
          return "\n    vec4 " + r3 + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c2 + ", " + s2[0] + ", " + s2[1] + ", row, col);\n      return " + u2.texture2D + "(" + n3 + ", uv);\n    }\n  ";
        }(t3);
      case 3:
        return function(t4) {
          var e3 = t4.shapeInfo.logicalShape, n3 = t4.name, r3 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1), o2 = t4.shapeInfo.texShape, a2 = [Math.ceil(o2[0] / 2), Math.ceil(o2[1] / 2)];
          if (1 === e3[0]) {
            var i2 = e3.slice(1), u2 = ia(t4, i2);
            return "\n        " + Jo(u2) + "\n        vec4 " + r3 + "(int b, int row, int col) {\n          return " + r3 + "(" + ua(["b", "row", "col"], [1, 2]) + ");\n        }\n      ";
          }
          var s2 = a2[0], c2 = a2[1], l3 = Math.ceil(e3[2] / 2), h = l3 * Math.ceil(e3[1] / 2), f2 = Ko();
          return "\n    vec4 " + r3 + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + s2 + ", " + c2 + ", " + h + ", " + l3 + ", b, row, col);\n      return " + f2.texture2D + "(" + n3 + ", uv);\n    }\n  ";
        }(t3);
      default:
        return function(t4) {
          for (var e3 = t4.shapeInfo.logicalShape, n3 = e3.length, r3 = t4.name, o2 = "get" + r3.charAt(0).toUpperCase() + r3.slice(1), a2 = t4.shapeInfo.texShape, i2 = [Math.ceil(a2[0] / 2), Math.ceil(a2[1] / 2)], u2 = i2[0], s2 = i2[1], c2 = Math.ceil(e3[n3 - 1] / 2), l3 = c2 * Math.ceil(e3[n3 - 2] / 2), h = "int b, int row, int col", f2 = "b * " + l3 + " + (row / 2) * " + c2 + " + (col / 2)", p2 = 2; p2 < n3 - 1; p2++)
            h = "int b" + p2 + ", " + h, l3 *= e3[n3 - p2 - 1], f2 = "b" + p2 + " * " + l3 + " + " + f2;
          var d2 = Ko();
          return "\n    vec4 " + o2 + "(" + h + ") {\n      int index = " + f2 + ";\n      int texR = index / " + s2 + ";\n      int texC = index - texR * " + s2 + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + s2 + ", " + u2 + ");\n      return " + d2.texture2D + "(" + r3 + ", uv);\n    }\n  ";
        }(t3);
    }
  }
  var Zo = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
  var ta = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
  var ea = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
  var na = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
  function ra(t3) {
    return "offset" + t3;
  }
  function oa(t3) {
    var e2 = t3.name, n2 = w(t3.shapeInfo.logicalShape);
    return n2 < 2 ? "return " + e2 + ";" : "\n    for (int i = 0; i < " + n2 + "; i++) {\n      if (i == index) {\n        return " + e2 + "[i];\n      }\n    }\n  ";
  }
  function aa(t3) {
    if (t3 <= 1)
      return "int";
    if (2 === t3)
      return "ivec2";
    if (3 === t3)
      return "ivec3";
    if (4 === t3)
      return "ivec4";
    if (5 === t3)
      return "ivec5";
    if (6 === t3)
      return "ivec6";
    throw Error("GPU for rank " + t3 + " is not yet supported");
  }
  function ia(t3, e2) {
    var n2 = JSON.parse(JSON.stringify(t3));
    return n2.shapeInfo.logicalShape = e2, n2;
  }
  function ua(t3, e2) {
    return e2.map(function(e3) {
      return t3[e3];
    }).join(", ");
  }
  var sa = function() {
    return function(t3, e2, n2, r2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, g(t3.length > 2, function() {
        return "Packed arg" + (n2.charAt(0).toUpperCase() + n2.slice(1)) + " supports only inputs with rank above 2.";
      });
      var o2 = t3[t3.length - 1], a2 = Math.ceil(o2 / e2);
      this.outputShape = t3.slice(0, -1), a2 > 1 && this.outputShape.push(a2), r2 || this.variableNames.push("bestIndicesA");
      var i2, u2, s2 = this.outputShape, c2 = s2.length, l3 = aa(c2), h = qo("coords", c2);
      if (1 === a2) {
        var f2 = aa(u2 = c2 + 1);
        i2 = "\n        " + f2 + " sourceLocR = " + f2 + "(" + h.join() + ", 0);\n        ++" + h[c2 - 1] + ";\n        " + f2 + " sourceLocG = " + f2 + "(" + h.join() + ", 0);\n        ++" + h[c2 - 2] + ";\n        " + f2 + " sourceLocA = " + f2 + "(" + h.join() + ", 0);\n        --" + h[c2 - 1] + ";\n        " + f2 + " sourceLocB = " + f2 + "(" + h.join() + ", 0);\n        --" + h[c2 - 2] + ";";
      } else
        u2 = c2, i2 = "\n        " + l3 + " sourceLocR = coords;\n        ++" + h[c2 - 1] + ";\n        " + l3 + " sourceLocG = coords;\n        ++" + h[c2 - 2] + ";\n        " + l3 + " sourceLocA = coords;\n        --" + h[c2 - 1] + ";\n        " + l3 + " sourceLocB = coords;\n        --" + h[c2 - 2] + ";";
      var p2 = ["x", "y", "z", "w", "u", "v"].slice(0, u2), d2 = "." + p2[u2 - 1], v2 = p2.map(function(t4) {
        return "int " + t4;
      }), m2 = qo("sourceLocR", u2 - 1).concat("inIdx.r"), y2 = qo("sourceLocG", u2 - 1).concat("inIdx.g"), x2 = qo("sourceLocB", u2 - 1).concat("inIdx.b"), b2 = qo("sourceLocA", u2 - 1).concat("inIdx.a"), w2 = "max" === n2 ? "greaterThan" : "lessThan", C3 = r2 ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + m2.join() + "),\n                             getBestIndicesAChannel(" + y2.join() + "),\n                             getBestIndicesAChannel(" + x2.join() + "),\n                             getBestIndicesAChannel(" + b2.join() + ")));", E3 = "vec4(\n            getAChannel(" + m2.join() + "),\n            hasNextCol ? getAChannel(" + y2.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + x2.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + b2.join() + ") : 0.)", R3 = r2 ? "" : "\n      float getBestIndicesAChannel(" + v2.join() + ") {\n        return getChannel(getBestIndicesA(" + p2.join() + "),\n                                          vec2(" + p2.slice(-2).join() + "));\n      }";
      this.userCode = "\n      float getAChannel(" + v2.join() + ") {\n        return getChannel(getA(" + p2.join() + "),\n                               vec2(" + p2.slice(-2).join() + "));\n      }\n      " + R3 + "\n      void main() {\n        " + l3 + " coords = getOutputCoords();\n        bool hasNextCol = " + h[c2 - 1] + " < " + (s2[c2 - 1] - 1) + ";\n        bool hasNextRow = " + h[c2 - 2] + " < " + (s2[c2 - 2] - 1) + ";\n        " + i2 + "\n        ivec4 srcIdx = ivec4(sourceLocR" + d2 + ", sourceLocG" + d2 + ",\n          sourceLocB" + d2 + ", sourceLocA" + d2 + ") * " + e2 + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + E3 + ";\n\n        for (int i = 0; i < " + e2 + "; i++) {\n          inIdx = srcIdx;\n          " + C3 + "\n          vec4 candidate = " + E3 + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + w2 + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
    };
  }();
  var ca = function() {
    return function(t3) {
      this.variableNames = ["dy"], this.outputShape = t3.inShape;
      var e2 = t3.filterHeight, n2 = t3.filterWidth, r2 = t3.strideHeight, o2 = t3.strideWidth, a2 = t3.dilationHeight, i2 = t3.dilationWidth, u2 = t3.effectiveFilterHeight, s2 = t3.effectiveFilterWidth, c2 = u2 - 1 - t3.padInfo.top, l3 = s2 - 1 - t3.padInfo.left, h = 1 / (e2 * n2);
      this.userCode = "\n      const ivec2 pads = ivec2(" + c2 + ", " + l3 + ");\n      const float avgMultiplier = float(" + h + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + u2 + ";\n            wR += " + a2 + ") {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t3.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + s2 + ";\n            wC+= " + i2 + ") {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t3.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var la = function() {
    return function(t3) {
      this.variableNames = ["dy"], this.outputShape = t3.inShape;
      var e2 = t3.filterDepth, n2 = t3.filterHeight, r2 = t3.filterWidth, o2 = t3.strideDepth, a2 = t3.strideHeight, i2 = t3.strideWidth, u2 = t3.dilationDepth, s2 = t3.dilationHeight, c2 = t3.dilationWidth, l3 = t3.effectiveFilterDepth, h = t3.effectiveFilterHeight, f2 = t3.effectiveFilterWidth, p2 = l3 - 1 - t3.padInfo.front, d2 = h - 1 - t3.padInfo.top, v2 = f2 - 1 - t3.padInfo.left, m2 = 1 / (e2 * n2 * r2);
      this.userCode = "\n      const ivec3 pads = ivec3(" + p2 + ", " + d2 + ", " + v2 + ");\n      const float avgMultiplier = float(" + m2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l3 + ";\n            wD += " + u2 + ") {\n          float dyD = float(dyDCorner + wD) / " + o2 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t3.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h + ";\n              wR += " + s2 + ") {\n            float dyR = float(dyRCorner + wR) / " + a2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t3.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + f2 + ";\n                wC += " + c2 + ") {\n              float dyC = float(dyCCorner + wC) / " + i2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t3.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var ha = function() {
    return function(t3, e2, n2, r2, o2, a2) {
      this.outputShape = [], this.variableNames = ["x", "mean", "variance"], po(t3, e2), po(t3, n2);
      var i2 = "0.0";
      null != r2 && (po(t3, r2), this.variableNames.push("offset"), i2 = "getOffsetAtOutCoords()");
      var u2 = "1.0";
      null != o2 && (po(t3, o2), this.variableNames.push("scale"), u2 = "getScaleAtOutCoords()"), this.outputShape = t3, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + i2 + ";\n        float scale = " + u2 + ";\n        float inv = scale * inversesqrt(variance + float(" + a2 + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ";
    };
  }();
  var fa = function() {
    return function(t3, e2, n2, r2, o2, a2) {
      this.packedInputs = true, this.packedOutput = true, this.variableNames = ["x", "mean", "variance"], po(t3, e2), po(t3, n2);
      var i2 = "vec4(0.0)";
      null != r2 && (po(t3, r2), this.variableNames.push("offset"), i2 = "getOffsetAtOutCoords()");
      var u2 = "vec4(1.0)";
      null != o2 && (po(t3, o2), this.variableNames.push("scale"), u2 = "getScaleAtOutCoords()"), this.outputShape = t3, this.userCode = "\n      void main() {\n        vec4 offset = " + i2 + ";\n        vec4 scale = " + u2 + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + a2 + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
    };
  }();
  var pa = "return areal * breal - aimag * bimag;";
  var da = "return areal * bimag + aimag * breal;";
  var va = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = po(e2, n2), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t3 + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
    };
  }();
  var ma = "return a + b;";
  var ga = "return a - b;";
  var ya = "return a * b;";
  var xa = "return (a < 0.) ? b * a : a;";
  var ba = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["A", "B"], this.outputShape = po(e2, n2), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t3 + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
    };
  }();
  var wa = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
  var Ca = function() {
    return function(t3, e2, n2, r2) {
      void 0 === r2 && (r2 = false), this.variableNames = ["A", "B"], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = po(e2, n2);
      var o2 = this.outputShape.length, a2 = "";
      if (r2)
        if (0 === o2 || 1 === w(this.outputShape))
          a2 = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
        else if (a2 = "\n          " + aa(o2) + " coords = getOutputCoords();\n        ", 1 === o2)
          a2 += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
        else {
          var i2 = qo("coords", o2);
          a2 += "\n            bool nextRowOutOfBounds =\n              (" + i2[o2 - 2] + " + 1) >= " + this.outputShape[o2 - 2] + ";\n            bool nextColOutOfBounds =\n              (" + i2[o2 - 1] + " + 1) >= " + this.outputShape[o2 - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
        }
      this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t3 + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + a2 + "\n\n        setOutput(result);\n      }\n    ";
    };
  }();
  var Ea = function() {
    function t3(t4) {
      this.variableNames = ["A"], this.outputShape = t4, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
    }
    return t3.prototype.getCustomSetupFunc = function(t4, e2) {
      var n2 = this;
      return function(r2, o2) {
        null == n2.minLoc && (n2.minLoc = r2.getUniformLocationNoThrow(o2, "minVal"), n2.maxLoc = r2.getUniformLocationNoThrow(o2, "maxVal")), r2.gl.uniform1f(n2.minLoc, t4), r2.gl.uniform1f(n2.maxLoc, e2);
      };
    }, t3;
  }();
  var Ra = function() {
    function t3(t4) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t4, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
    }
    return t3.prototype.getCustomSetupFunc = function(t4, e2) {
      var n2 = this;
      return function(r2, o2) {
        null == n2.minLoc && (n2.minLoc = r2.getUniformLocationNoThrow(o2, "minVal"), n2.maxLoc = r2.getUniformLocationNoThrow(o2, "maxVal")), r2.gl.uniform1f(n2.minLoc, t4), r2.gl.uniform1f(n2.maxLoc, e2);
      };
    }, t3;
  }();
  var Ia = function() {
    return function(t3) {
      this.variableNames = ["real", "imag"], this.outputShape = t3, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
    };
  }();
  var ka = function() {
    return function(t3) {
      this.outputShape = [], this.outputShape = wn(t3, 1), this.variableNames = t3.map(function(t4, e3) {
        return "T" + e3;
      });
      var e2 = new Array(t3.length - 1);
      e2[0] = t3[0][1];
      for (var n2 = 1; n2 < e2.length; n2++)
        e2[n2] = e2[n2 - 1] + t3[n2][1];
      var r2 = ["if (yC < " + e2[0] + ") setOutput(getT0(yR, yC));"];
      for (n2 = 1; n2 < e2.length; n2++) {
        var o2 = e2[n2 - 1];
        r2.push("else if (yC < " + e2[n2] + ") setOutput(getT" + n2 + "(yR, yC-" + o2 + "));");
      }
      var a2 = e2.length, i2 = e2[e2.length - 1];
      r2.push("else setOutput(getT" + a2 + "(yR, yC-" + i2 + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r2.join("\n        ") + "\n      }\n    ";
    };
  }();
  var Sa = function() {
    return function(t3, e2) {
      this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = wn(t3, e2);
      var n2 = this.outputShape, r2 = n2.length, o2 = aa(r2), a2 = qo("coords", r2), i2 = ["x", "y", "z", "w", "u", "v"].slice(0, r2);
      this.variableNames = t3.map(function(t4, e3) {
        return "T" + e3;
      });
      var u2 = new Array(t3.length - 1);
      u2[0] = t3[0][e2];
      for (var s2 = 1; s2 < u2.length; s2++)
        u2[s2] = u2[s2 - 1] + t3[s2][e2];
      var c2 = i2[e2], l3 = i2.slice(-2), h = i2.join(), f2 = "if (" + c2 + " < " + u2[0] + ") {\n        return getChannel(\n            getT0(" + h + "), vec2(" + l3.join() + "));\n        }";
      for (s2 = 1; s2 < u2.length; s2++) {
        var p2 = u2[s2 - 1];
        f2 += "\n        if (" + c2 + " < " + u2[s2] + "  && " + c2 + " >= " + u2[s2 - 1] + ") {\n          return getChannel(\n            getT" + s2 + "(" + Aa(i2, c2, p2) + "),\n            vec2(" + Aa(l3, c2, p2) + "));\n        }";
      }
      var d2 = u2.length, v2 = u2[u2.length - 1];
      f2 += "\n        return getChannel(\n          getT" + d2 + "(" + Aa(i2, c2, v2) + "),\n          vec2(" + Aa(l3, c2, v2) + "));", this.userCode = "\n      float getValue(" + i2.map(function(t4) {
        return "int " + t4;
      }) + ") {\n        " + f2 + "\n      }\n\n      void main() {\n        " + o2 + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + a2 + "), 0., 0., 0.);\n\n        " + a2[r2 - 1] + " = " + a2[r2 - 1] + " + 1;\n        if (" + a2[r2 - 1] + " < " + n2[r2 - 1] + ") {\n          result.g = getValue(" + a2 + ");\n        }\n\n        " + a2[r2 - 2] + " = " + a2[r2 - 2] + " + 1;\n        if (" + a2[r2 - 2] + " < " + n2[r2 - 2] + ") {\n          result.a = getValue(" + a2 + ");\n        }\n\n        " + a2[r2 - 1] + " = " + a2[r2 - 1] + " - 1;\n        if (" + a2[r2 - 2] + " < " + n2[r2 - 2] + " &&\n            " + a2[r2 - 1] + " < " + n2[r2 - 1] + ") {\n          result.b = getValue(" + a2 + ");\n        }\n        setOutput(result);\n      }\n    ";
    };
  }();
  function Aa(t3, e2, n2) {
    var r2 = t3.indexOf(e2);
    return t3.map(function(t4, e3) {
      return e3 === r2 ? t4 + " - " + n2 : t4;
    }).join();
  }
  var Da = function() {
    return function(t3) {
      this.variableNames = ["x", "dy"], this.outputShape = t3.filterShape;
      var e2 = t3.strideHeight, n2 = t3.strideWidth, r2 = t3.padInfo.top, o2 = t3.padInfo.left, a2 = "channelsLast" === t3.dataFormat;
      this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t3.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t3.outHeight + "; yR++) {\n            int xR = wR + yR * " + e2 + " - " + r2 + ";\n\n            if (xR < 0 || xR >= " + t3.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t3.outWidth + "; yC++) {\n              int xC = wC + yC * " + n2 + " - " + o2 + ";\n\n              if (xC < 0 || xC >= " + t3.inWidth + ") {\n                continue;\n              }\n\n              if (" + a2 + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var Ta = function() {
    return function(t3) {
      this.variableNames = ["dy", "W"], this.outputShape = t3.inShape;
      var e2 = t3.filterHeight, n2 = t3.filterWidth, r2 = t3.strideHeight, o2 = t3.strideWidth, a2 = "channelsLast" === t3.dataFormat, i2 = e2 - 1 - t3.padInfo.top, u2 = n2 - 1 - t3.padInfo.left, s2 = a2 ? 1 : 2, c2 = a2 ? 2 : 3, l3 = a2 ? 3 : 1;
      this.userCode = "\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l3 + "];\n\n        ivec2 dyCorner = ivec2(coords[" + s2 + "], coords[" + c2 + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e2 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t3.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e2 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t3.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n2 + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t3.outChannels + "; d2++) {\n\n              if (" + a2 + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var Na = function() {
    return function(t3) {
      this.variableNames = ["x", "dy"], this.outputShape = t3.filterShape;
      var e2 = t3.strideDepth, n2 = t3.strideHeight, r2 = t3.strideWidth, o2 = t3.padInfo.front, a2 = t3.padInfo.top, i2 = t3.padInfo.left;
      this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t3.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t3.outDepth + "; yF++) {\n            int xF = wF + yF * " + e2 + " - " + o2 + ";\n\n            if (xF < 0 || xF >= " + t3.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t3.outHeight + "; yR++) {\n              int xR = wR + yR * " + n2 + " - " + a2 + ";\n\n              if (xR < 0 || xR >= " + t3.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t3.outWidth + "; yC++) {\n                int xC = wC + yC * " + r2 + " - " + i2 + ";\n\n                if (xC < 0 || xC >= " + t3.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var Fa = function() {
    return function(t3) {
      this.variableNames = ["dy", "W"], this.outputShape = t3.inShape;
      var e2 = t3.filterDepth, n2 = t3.filterHeight, r2 = t3.filterWidth, o2 = t3.strideDepth, a2 = t3.strideHeight, i2 = t3.strideWidth, u2 = e2 - 1 - t3.padInfo.front, s2 = n2 - 1 - t3.padInfo.top, c2 = r2 - 1 - t3.padInfo.left;
      this.userCode = "\n      const ivec3 pads = ivec3(" + u2 + ", " + s2 + ", " + c2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e2 + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + o2 + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t3.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e2 + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n2 + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + a2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t3.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n2 + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r2 + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + i2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t3.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r2 + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t3.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var Oa = function() {
    return function(t3) {
      this.variableNames = ["x", "dy"], this.outputShape = t3.filterShape;
      var e2 = t3.strideHeight, n2 = t3.strideWidth, r2 = t3.padInfo.top, o2 = t3.padInfo.left, a2 = t3.outChannels / t3.inChannels;
      this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + a2 + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t3.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t3.outHeight + "; yR++) {\n            int xR = wR + yR * " + e2 + " - " + r2 + ";\n\n            if (xR < 0 || xR >= " + t3.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t3.outWidth + "; yC++) {\n              int xC = wC + yC * " + n2 + " - " + o2 + ";\n\n              if (xC < 0 || xC >= " + t3.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var _a = function() {
    return function(t3) {
      this.variableNames = ["dy", "W"], this.outputShape = t3.inShape;
      var e2 = t3.filterHeight, n2 = t3.filterWidth, r2 = t3.strideHeight, o2 = t3.strideWidth, a2 = e2 - 1 - t3.padInfo.top, i2 = n2 - 1 - t3.padInfo.left, u2 = t3.outChannels / t3.inChannels;
      this.userCode = "\n      const ivec2 pads = ivec2(" + a2 + ", " + i2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e2 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t3.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e2 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t3.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n2 + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + u2 + "; dm++) {\n              int d2 = d1 * " + u2 + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var Ma = function() {
    return function(t3, e2, n2, r2) {
      void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.outputShape = t3.outShape;
      var o2 = t3.padInfo.top, a2 = t3.padInfo.left, i2 = t3.strideHeight, u2 = t3.strideWidth, s2 = t3.dilationHeight, c2 = t3.dilationWidth, l3 = t3.filterHeight, h = t3.filterWidth, f2 = 4 * Math.floor(t3.inChannels / 4), p2 = t3.inChannels % 4, d2 = "channelsLast" === t3.dataFormat, v2 = d2 ? 1 : 2, m2 = d2 ? 2 : 3, g2 = d2 ? 3 : 1, y2 = "", x2 = "";
      n2 && (y2 = r2 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "\n          float activation(float x) {\n            " + n2 + "\n          }\n        ", x2 = "result = activation(result);");
      var b2 = e2 ? "result += getBiasAtOutCoords();" : "";
      e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y2 + "\n\n      const ivec2 strides = ivec2(" + i2 + ", " + u2 + ");\n      const ivec2 pads = ivec2(" + o2 + ", " + a2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + g2 + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v2 + "], coords[" + m2 + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l3 + "; wR++) {\n          int xR = xRCorner + wR * " + s2 + ";\n\n          if (xR < 0 || xR >= " + t3.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h + "; wC++) {\n            int xC = xCCorner + wC * " + c2 + ";\n\n            if (xC < 0 || xC >= " + t3.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + f2 + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + d2 + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === p2) + ") {\n\n              if (" + d2 + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + f2 + ") *\n                    getW(wR, wC, " + f2 + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + f2 + ", xR, xC) *\n                    getW(wR, wC, " + f2 + ", d2);\n              }\n\n            } else if (" + (2 === p2) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + f2 + ", d2),\n                getW(wR, wC, " + f2 + " + 1, d2)\n              );\n\n              if (" + d2 + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + f2 + "),\n                  getX(batch, xR, xC, " + f2 + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + f2 + ", xR, xC),\n                  getX(batch, " + f2 + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === p2) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + f2 + ", d2),\n                getW(wR, wC, " + f2 + " + 1, d2),\n                getW(wR, wC, " + f2 + " + 2, d2)\n              );\n\n              if (" + d2 + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + f2 + "),\n                  getX(batch, xR, xC, " + f2 + " + 1),\n                  getX(batch, xR, xC, " + f2 + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + f2 + ", xR, xC),\n                  getX(batch, " + f2 + " + 1, xR, xC),\n                  getX(batch, " + f2 + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + b2 + "\n        " + x2 + "\n        setOutput(result);\n      }\n    ";
    };
  }();
  var Ba = function() {
    return function(t3) {
      this.variableNames = ["x", "W"], this.outputShape = t3.outShape;
      var e2 = t3.padInfo.front, n2 = t3.padInfo.top, r2 = t3.padInfo.left, o2 = t3.strideDepth, a2 = t3.strideHeight, i2 = t3.strideWidth, u2 = t3.dilationDepth, s2 = t3.dilationHeight, c2 = t3.dilationWidth, l3 = t3.filterDepth, h = t3.filterHeight, f2 = t3.filterWidth, p2 = 4 * Math.floor(t3.inChannels / 4), d2 = t3.inChannels % 4;
      this.userCode = "\n      const ivec3 strides = ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n      const ivec3 pads = ivec3(" + e2 + ", " + n2 + ", " + r2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l3 + "; wF++) {\n          int xF = xFCorner + wF * " + u2 + ";\n\n          if (xF < 0 || xF >= " + t3.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + "; wR++) {\n            int xR = xRCorner + wR * " + s2 + ";\n\n            if (xR < 0 || xR >= " + t3.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + f2 + "; wC++) {\n              int xC = xCCorner + wC * " + c2 + ";\n\n              if (xC < 0 || xC >= " + t3.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + p2 + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === d2) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + p2 + ") *\n                  getW(wF, wR, wC, " + p2 + ", d2);\n              } else if (" + (2 === d2) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + p2 + "),\n                  getX(batch, xF, xR, xC, " + p2 + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + p2 + ", d2),\n                  getW(wF, wR, wC, " + p2 + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === d2) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + p2 + "),\n                  getX(batch, xF, xR, xC, " + p2 + " + 1),\n                  getX(batch, xF, xR, xC, " + p2 + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + p2 + ", d2),\n                  getW(wF, wR, wC, " + p2 + " + 1, d2),\n                  getW(wF, wR, wC, " + p2 + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var Pa = function() {
    return function(t3, e2, n2, r2) {
      void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.outputShape = t3.outShape;
      var o2 = t3.inHeight, a2 = t3.inWidth, i2 = t3.padInfo.top, u2 = t3.padInfo.left, s2 = t3.strideHeight, c2 = t3.strideWidth, l3 = t3.dilationHeight, h = t3.dilationWidth, f2 = t3.filterHeight, p2 = t3.filterWidth, d2 = t3.outChannels / t3.inChannels, v2 = "", m2 = "";
      n2 && (v2 = r2 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "\n          float activation(float x) {\n            " + n2 + "\n          }\n        ", m2 = "result = activation(result);");
      var g2 = e2 ? "result += getBiasAtOutCoords();" : "";
      e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v2 + "\n\n      const ivec2 strides = ivec2(" + s2 + ", " + c2 + ");\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + d2 + ";\n        int q = d2 - d1 * " + d2 + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + f2 + "; wR++) {\n          int xR = xRCorner + wR * " + l3 + ";\n\n          if (xR < 0 || xR >= " + o2 + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + p2 + "; wC++) {\n            int xC = xCCorner + wC * " + h + ";\n\n            if (xC < 0 || xC >= " + a2 + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + g2 + "\n        " + m2 + "\n        setOutput(result);\n      }\n    ";
    };
  }();
  var La = function() {
    return function(t3, e2, n2, r2) {
      void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3.outShape;
      for (var o2 = t3.inHeight, a2 = t3.inWidth, i2 = t3.padInfo.top, u2 = t3.padInfo.left, s2 = t3.strideHeight, c2 = t3.strideWidth, l3 = t3.dilationHeight, h = t3.dilationWidth, f2 = t3.filterHeight, p2 = t3.filterWidth, d2 = p2, m2 = "int xR; int xC; int xCOffset;", g2 = 0; g2 < f2; g2++)
        for (var y2 = 0; y2 < p2; y2++)
          m2 += "\n          vec4 xTexelR" + g2 + "C" + 2 * y2 + " = vec4(0.);\n          vec4 wR" + g2 + "C" + y2 + " = vec4(0.);\n          vec4 xR" + g2 + "C" + y2 + " = vec4(0.);";
      for (g2 = 0; g2 < f2; g2++)
        for (var x2 = 0; x2 < d2; x2++) {
          if (m2 += "\n          xR = xRCorner + " + g2 * l3 + ";\n          xC = xCCorner + " + (y2 = 2 * x2) * h + ";\n        ", 1 === c2) {
            if (y2 < p2 && (m2 += u2 % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + o2 + " && xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + o2 + " && xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n                  xR" + g2 + "C" + y2 + " = vec4(previous.zw, xTexelR" + g2 + "C" + y2 + ".xy);\n                } else {\n                  xR" + g2 + "C" + y2 + " = vec4(0, 0, xTexelR" + g2 + "C" + y2 + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + o2 + " && xC >= 0 && xC < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                xR" + g2 + "C" + y2 + " = xTexelR" + g2 + "C" + y2 + ";\n              ", y2 + 1 < p2)) {
              var b2 = u2 % 2 == 0 ? v(h) : h;
              h % 2 == 0 && u2 % 2 == 1 || h % 2 != 0 && u2 % 2 != 1 ? (m2 += "\n                  xCOffset = xC + " + u2 % 2 + " + " + b2 + ";\n\n                  if(xR >= 0 && xR < " + o2 + " &&\n                    xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h > 1 && (m2 += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + o2 + " &&\n                      xCOffset >= 0 && xCOffset < " + a2 + ") {\n                      xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                    }\n                  "), m2 += "\n                  xR" + g2 + "C" + (y2 + 1) + " = vec4(\n                    xTexelR" + g2 + "C" + y2 + ".zw, xTexelR" + g2 + "C" + (y2 + 2) + ".xy);\n                ") : m2 += "\n                  xCOffset = xC + " + b2 + ";\n\n                  if(xR >= 0 && xR < " + o2 + " &&\n                    xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + g2 + "C" + (y2 + 1) + " = xTexelR" + g2 + "C" + (y2 + 2) + ";\n                ";
            }
          } else
            y2 < p2 && (m2 += "\n              if(xR >= 0 && xR < " + o2 + ") {\n            ", u2 % 2 == 1 ? (m2 += "\n                xCOffset = xC + 1 - " + c2 + ";\n                if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + a2 + ") {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = vec4(0.);\n                }\n\n                xR" + g2 + "C" + y2 + " = vec4(\n                  xTexelR" + g2 + "C" + y2 + ".zw, xTexelR" + g2 + "C" + (y2 + 2) + ".zw);\n              ", y2 + 1 < p2 && (m2 += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c2 + ";\n                  if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + g2 + "C" + (y2 + 1) + " = vec4(xTexelR" + g2 + "C" + (y2 + 2) + ".xy, final.xy);\n                ")) : (m2 += "\n                if(xC >= 0 && xC < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c2 + ";\n                if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = vec4(0.);\n                }\n\n                xR" + g2 + "C" + y2 + " = vec4(\n                  xTexelR" + g2 + "C" + y2 + ".xy, xTexelR" + g2 + "C" + (y2 + 2) + ".xy);\n              ", y2 + 1 < p2 && (m2 += "\n                  xR" + g2 + "C" + (y2 + 1) + " = vec4(\n                    xTexelR" + g2 + "C" + y2 + ".zw, xTexelR" + g2 + "C" + (y2 + 2) + ".zw);\n                ")), m2 += "}");
          y2 < p2 && (m2 += "\n            vec4 wTexelR" + g2 + "C" + y2 + " = getW(" + g2 + ", " + y2 + ", d1, q);\n            wR" + g2 + "C" + y2 + " = vec4(wTexelR" + g2 + "C" + y2 + ".xz, wTexelR" + g2 + "C" + y2 + ".xz);\n          ", y2 + 1 < p2 && (m2 += "\n              vec4 wTexelR" + g2 + "C" + (y2 + 1) + " = getW(" + g2 + ", " + (y2 + 1) + ", d1, q);\n              wR" + g2 + "C" + (y2 + 1) + " =\n                vec4(wTexelR" + g2 + "C" + (y2 + 1) + ".xz, wTexelR" + g2 + "C" + (y2 + 1) + ".xz);"));
        }
      for (g2 = 0; g2 < f2; g2++)
        for (y2 = 0; y2 < p2; y2++)
          m2 += "dotProd += xR" + g2 + "C" + y2 + " * wR" + g2 + "C" + y2 + ";";
      var w2 = "", C3 = "";
      n2 && (w2 = r2 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "vec4 activation(vec4 x) {\n          " + n2 + "\n        }", C3 = "result = activation(result);");
      var E3 = e2 ? "result += getBiasAtOutCoords();" : "";
      e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + w2 + "\n\n      const ivec2 strides = ivec2(" + s2 + ", " + c2 + ");\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + m2 + "\n\n        vec4 result = dotProd;\n        " + E3 + "\n        " + C3 + "\n        setOutput(result);\n      }\n    ";
    };
  }();
  var Wa = function() {
    return function(t3, e2, n2, r2, o2) {
      this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
      var a2 = t3[0], i2 = t3[1], u2 = t3[2], s2 = t3[3], c2 = e2[0], l3 = n2[0], h = n2[1];
      this.outputShape = [c2, l3, h, s2];
      var f2 = "bilinear" === r2 ? 1 : 0, p2 = [i2 - 1 + ".0", u2 - 1 + ".0"], d2 = p2[0], v2 = p2[1], m2 = l3 > 1 ? ["" + (i2 - 1) / (l3 - 1), "(y2-y1) * height_ratio", "y1*" + d2 + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + d2], g2 = m2[0], y2 = m2[1], x2 = m2[2], b2 = h > 1 ? ["" + (u2 - 1) / (h - 1), "(x2-x1) * width_ratio", "x1*" + v2 + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + v2], w2 = b2[0], C3 = b2[1], E3 = b2[2];
      this.userCode = "\n      const float height_ratio = float(" + g2 + ");\n      const float width_ratio = float(" + w2 + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + a2 + ") {\n          return;\n        }\n\n        float height_scale = " + y2 + ";\n        float width_scale = " + C3 + ";\n\n        float in_y = " + x2 + ";\n        if( in_y < 0.0 || in_y > " + d2 + " ) {\n          setOutput(float(" + o2 + "));\n          return;\n        }\n        float in_x = " + E3 + ";\n        if( in_x < 0.0 || in_x > " + v2 + " ) {\n          setOutput(float(" + o2 + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + f2 + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
    };
  }();
  var Ua = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["x"], this.outputShape = t3;
      var r2 = t3.length, o2 = t3[t3.length - 1], a2 = n2 ? "<" : ">";
      this.userCode = "\n      int getIndex(int i) {\n        " + (n2 ? "return " + o2 + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + aa(r2) + " coords = getOutputCoords();\n        int end = " + Va(r2, "coords") + ";\n        float val = 0.0;\n        for (int i = " + o2 + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + a2 + " end) {\n            continue;\n          }\n          if (idx == end && " + e2 + ") {\n            continue;\n          }\n          " + Va(r2, "coords") + " = idx;\n          val += getX(" + function(t4, e3) {
        if (1 === t4)
          return "" + e3;
        if (2 === t4)
          return e3 + ".x, " + e3 + ".y";
        if (3 === t4)
          return e3 + ".x, " + e3 + ".y, " + e3 + ".z";
        if (4 === t4)
          return e3 + ".x, " + e3 + ".y, " + e3 + ".z, " + e3 + ".w";
        throw Error("Cumulative sum for rank " + t4 + " is not yet supported");
      }(r2, "coords") + ");\n        }\n        setOutput(val);\n      }\n    ";
    };
  }();
  function Va(t3, e2) {
    if (1 === t3)
      return "" + e2;
    if (2 === t3)
      return e2 + ".y";
    if (3 === t3)
      return e2 + ".z";
    if (4 === t3)
      return e2 + ".w";
    throw Error("Cumulative sum for rank " + t3 + " is not yet supported");
  }
  var za = function() {
    return function(t3) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = _t.DENSE;
      var e2 = Gt(t3), n2 = Ko();
      this.outputShape = t3, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + jo(["r", "c", "d"], t3) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e2[0] + ", " + e2[1] + "));\n        int index = 4 * (resTexRC.x * " + e2[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n2.output + " = result;\n      }\n    ";
    };
  }();
  var Ga = function() {
    return function(t3) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = _t.DENSE;
      var e2 = Gt(t3), n2 = Ko();
      this.outputShape = t3, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + jo(["r", "c", "d"], t3) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e2[0] + ", " + e2[1] + "));\n        int index = 4 * (resTexRC.x * " + e2[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n2.output + " = result;\n      }\n    ";
    };
  }();
  var Ha = function() {
    function t3(t4, e2, n2) {
      this.variableNames = ["x"], this.outputShape = [], this.outputShape = t4, this.blockSize = e2, this.dataFormat = n2, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e2 + ";\n      int offset_h = imod(h, " + e2 + ");\n      int in_w = w / " + e2 + ";\n      int offset_w = imod(w, " + e2 + ");\n      int offset_d = (offset_h * " + e2 + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  ";
    }
    return t3.prototype.getHeightCoordString = function() {
      return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
    }, t3.prototype.getWidthCoordString = function() {
      return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
    }, t3.prototype.getDepthCoordString = function() {
      return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
    }, t3.prototype.getOutputDepthSize = function() {
      return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
    }, t3.prototype.getInputSamplingString = function() {
      return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }, t3;
  }();
  var qa = function() {
    return function(t3) {
      this.variableNames = ["X"], this.outputShape = [t3, t3], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
    };
  }();
  var Ka = function() {
    return function(t3) {
      this.variableNames = ["A"], this.outTexUsage = Mt.DOWNLOAD;
      var e2 = Ko();
      this.outputShape = t3, this.userCode = "\n      " + $o + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e2.output + " = encode_float(x);\n      }\n    ";
    };
  }();
  var ja = function() {
    return function(t3) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = Mt.DOWNLOAD;
      var e2 = Ko();
      this.outputShape = t3, this.userCode = "\n      " + $o + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e2.output + " = encode_float(x);\n      }\n    ";
    };
  }();
  var Xa = function() {
    return function(t3, e2, n2) {
      void 0 === n2 && (n2 = false), this.variableNames = ["A"];
      var r2 = Ko(), o2 = e2[0], a2 = e2[1];
      this.outputShape = t3;
      var i2 = "result";
      n2 && (i2 = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + Xo(t3) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + a2 + ";\n        int c = imod(flatIndex, " + a2 + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + a2 + ".0, " + o2 + ".0);\n        vec4 values = " + r2.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r2.output + " = vec4(" + i2 + ", 0., 0., 0.);\n      }\n    ";
    };
  }();
  var $a = function() {
    return function(t3, e2, n2) {
      void 0 === n2 && (n2 = false), this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
      var r2 = Ko(), o2 = e2[0], a2 = e2[1];
      this.outputShape = t3;
      var i2 = "", u2 = "result";
      n2 && (u2 = "floor(result * 255. + 0.5)");
      for (var s2 = 0; s2 <= 1; s2++)
        for (var c2 = 0; c2 <= 1; c2++) {
          var l3 = 2 * s2 + c2;
          i2 += "\n          localCoords = coords;\n          if(localCoords[2] + " + c2 + " < " + t3[2] + ") {\n            localCoords[2] += " + c2 + ";\n            if(localCoords[1] + " + s2 + " < " + t3[1] + ") {\n              localCoords[1] += " + s2 + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + a2 + ";\n              c = imod(flatIndex, " + a2 + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + a2 + ".0, " + o2 + ".0);\n              values = " + r2.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l3 + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l3 + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l3 + "] = values[2];\n              } else {\n                result[" + l3 + "] = values[3];\n              }\n            }\n          }\n        ";
        }
      this.userCode = "\n      " + Xo(t3) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + i2 + "\n\n        " + r2.output + " = " + u2 + ";\n      }\n    ";
    };
  }();
  var Ya = "return real * expR - imag * expI;";
  var Qa = "return real * expI + imag * expR;";
  var Ja = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["real", "imag"];
      var r2 = e2[1];
      this.outputShape = e2;
      var o2 = n2 ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI, a2 = n2 ? r2 + ".0" : "1.0";
      this.userCode = "\n      const float exponentMultiplier = " + o2 + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t3 + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r2 + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r2 + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + a2 + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
    };
  }();
  var Za = function() {
    function t3(t4, e2) {
      this.outputShape = [], this.variableNames = ["x"], this.outputShape = t4, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
    }
    return t3.prototype.getCustomSetupFunc = function(t4) {
      var e2 = this;
      return function(n2, r2) {
        null == e2.valueLoc && (e2.valueLoc = n2.getUniformLocationNoThrow(r2, "value")), n2.gl.uniform1f(e2.valueLoc, t4);
      };
    }, t3;
  }();
  var ti = function() {
    return function(t3) {
      this.variableNames = ["A"];
      var e2 = Ko(), n2 = t3[0], r2 = t3[1];
      this.outputShape = t3, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r2 + ".0, " + n2 + ".0);\n\n        vec4 values = " + e2.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
    };
  }();
  var ei = function() {
    return function(t3) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
      var e2 = Ko(), n2 = t3[0], r2 = t3[1];
      this.outputShape = t3, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r2 + ".0, " + n2 + ".0);\n            vec4 values = " + e2.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e2.output + " = result;\n      }\n    ";
    };
  }();
  var ni = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["A", "indices"];
      var r2 = t3.slice();
      r2[n2] = e2, this.outputShape = r2, this.rank = r2.length;
      var o2 = aa(this.rank), a2 = function(t4, e3) {
        var n3 = t4.length;
        if (n3 > 4)
          throw Error("Gather for rank " + n3 + " is not yet supported");
        if (1 === n3)
          return "int(getIndices(resRC))";
        for (var r3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o3 = [], a3 = 0; a3 < t4.length; a3++)
          a3 === e3 ? o3.push("int(getIndices(" + r3[a3] + "))") : o3.push("" + r3[a3]);
        return o3.join();
      }(t3, n2);
      this.userCode = "\n      void main() {\n        " + o2 + " resRC = getOutputCoords();\n        setOutput(getA(" + a2 + "));\n      }\n    ";
    };
  }();
  var ri = function() {
    return function(t3, e2, n2) {
      this.sliceDim = t3, this.strides = e2, this.variableNames = ["x", "indices"], this.outputShape = n2;
      var r2 = aa(e2.length), o2 = aa(n2.length), a2 = this.sliceDim > 1 ? "strides[j]" : "strides";
      this.userCode = "\n        " + r2 + " strides = " + r2 + "(" + this.strides + ");\n         void main() {\n          " + o2 + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + a2 + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
    };
  }();
  function oi(t3, e2) {
    var n2 = Ko();
    return Jt(t3, e2, n2.version + "\n    precision highp float;\n    " + n2.attribute + " vec3 clipSpacePos;\n    " + n2.attribute + " vec2 uv;\n    " + n2.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }");
  }
  function ai(t3, e2) {
    return ie(t3, e2, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
  }
  function ii(t3, e2) {
    return ue(t3, e2, new Uint16Array([0, 1, 2, 2, 1, 3]));
  }
  function ui(t3, e2, n2, r2, o2, a2, i2) {
    ce(n2, r2);
    var u2 = se(t3, e2), s2 = t3.TEXTURE_2D;
    return Kt(t3, e2, function() {
      return t3.bindTexture(s2, u2);
    }), Kt(t3, e2, function() {
      return t3.texParameteri(s2, t3.TEXTURE_WRAP_S, t3.CLAMP_TO_EDGE);
    }), Kt(t3, e2, function() {
      return t3.texParameteri(s2, t3.TEXTURE_WRAP_T, t3.CLAMP_TO_EDGE);
    }), Kt(t3, e2, function() {
      return t3.texParameteri(s2, t3.TEXTURE_MIN_FILTER, t3.NEAREST);
    }), Kt(t3, e2, function() {
      return t3.texParameteri(s2, t3.TEXTURE_MAG_FILTER, t3.NEAREST);
    }), Kt(t3, e2, function() {
      return t3.texImage2D(s2, 0, o2, n2, r2, 0, a2, i2, null);
    }), Kt(t3, e2, function() {
      return t3.bindTexture(t3.TEXTURE_2D, null);
    }), u2;
  }
  function si(t3, e2, n2, r2, o2) {
    var a2 = zt(n2, r2);
    return ui(t3, e2, a2[0], a2[1], o2.internalFormatFloat, o2.textureFormatFloat, t3.FLOAT);
  }
  function ci(t3, e2, n2, r2, o2) {
    var a2 = zt(n2, r2);
    return ui(t3, e2, a2[0], a2[1], o2.internalFormatHalfFloat, o2.textureFormatFloat, o2.textureTypeHalfFloat);
  }
  function li(t3, e2, n2, r2, o2) {
    var a2 = zt(n2, r2);
    return ui(t3, e2, a2[0], a2[1], t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE);
  }
  function hi(t3, e2, n2, r2, o2) {
    var a2 = Ht(n2, r2);
    return ui(t3, e2, a2[0], a2[1], o2.internalFormatPackedFloat, t3.RGBA, t3.FLOAT);
  }
  function fi(t3, e2, n2, r2, o2) {
    var a2 = Ht(n2, r2);
    return ui(t3, e2, a2[0], a2[1], o2.internalFormatPackedHalfFloat, t3.RGBA, o2.textureTypeHalfFloat);
  }
  function pi(t3, e2, n2, r2) {
    return Kt(t3, e2, function() {
      return t3.bindBuffer(t3.ARRAY_BUFFER, r2);
    }), he(t3, e2, n2, "clipSpacePos", r2, 3, 20, 0) && he(t3, e2, n2, "uv", r2, 2, 20, 12);
  }
  function di(t3, e2, n2, r2, o2, a2, i2) {
    var u2, s2, c2;
    Kt(t3, e2, function() {
      return t3.bindTexture(t3.TEXTURE_2D, n2);
    }), a2 instanceof Uint8Array ? (u2 = new Uint8Array(r2 * o2 * 4), s2 = t3.UNSIGNED_BYTE, c2 = t3.RGBA) : (u2 = new Float32Array(r2 * o2 * 4), s2 = t3.FLOAT, c2 = i2.internalFormatPackedFloat), u2.set(a2), Kt(t3, e2, function() {
      return t3.texImage2D(t3.TEXTURE_2D, 0, c2, r2, o2, 0, t3.RGBA, s2, u2);
    }), Kt(t3, e2, function() {
      return t3.bindTexture(t3.TEXTURE_2D, null);
    });
  }
  function vi(t3, e2, n2, r2) {
    Kt(t3, e2, function() {
      return t3.bindTexture(t3.TEXTURE_2D, n2);
    }), r2.data instanceof Uint8Array ? Kt(t3, e2, function() {
      return t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, r2.width, r2.height, 0, t3.RGBA, t3.UNSIGNED_BYTE, r2.data);
    }) : Kt(t3, e2, function() {
      return t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, r2);
    }), Kt(t3, e2, function() {
      return t3.bindTexture(t3.TEXTURE_2D, null);
    });
  }
  function mi(t3, e2, n2, r2, o2) {
    var a2 = t3.createBuffer();
    Kt(t3, e2, function() {
      return t3.bindBuffer(t3.PIXEL_PACK_BUFFER, a2);
    });
    var i2 = 16 * n2 * r2;
    return Kt(t3, e2, function() {
      return t3.bufferData(t3.PIXEL_PACK_BUFFER, i2, t3.STREAM_READ);
    }), Kt(t3, e2, function() {
      return t3.readPixels(0, 0, r2, n2, t3.RGBA, t3.FLOAT, 0);
    }), Kt(t3, e2, function() {
      return t3.bindBuffer(t3.PIXEL_PACK_BUFFER, null);
    }), a2;
  }
  function gi(t3, e2, n2) {
    var r2 = t3, o2 = new Float32Array(n2);
    return r2.bindBuffer(r2.PIXEL_PACK_BUFFER, e2), r2.getBufferSubData(r2.PIXEL_PACK_BUFFER, 0, o2), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, null), o2;
  }
  function yi(t3, e2, n2, r2, o2) {
    var a2 = zt(n2, r2), i2 = a2[0], u2 = a2[1], s2 = new Uint8Array(n2 * r2 * 4);
    return Kt(t3, e2, function() {
      return t3.readPixels(0, 0, i2, u2, o2.downloadTextureFormat, t3.UNSIGNED_BYTE, s2);
    }), new Float32Array(s2.buffer);
  }
  function xi(t3, e2, n2, r2, o2, a2, i2, u2) {
    var s2 = t3, c2 = new Float32Array(function(t4, e3) {
      var n3 = Ht(t4, e3);
      return n3[0] * n3[1] * 4;
    }(a2, i2));
    return s2.bindBuffer(s2.PIXEL_PACK_BUFFER, e2), s2.getBufferSubData(s2.PIXEL_PACK_BUFFER, 0, c2), s2.bindBuffer(s2.PIXEL_PACK_BUFFER, null), c2;
  }
  function bi(t3, e2, n2, r2) {
    var o2 = new Float32Array(n2 * r2 * 4);
    return Kt(t3, e2, function() {
      return t3.readPixels(0, 0, r2, n2, t3.RGBA, t3.FLOAT, o2);
    }), o2;
  }
  var wi = Object.freeze({ createVertexShader: oi, createVertexBuffer: ai, createIndexBuffer: ii, createFloat32MatrixTexture: si, createFloat16MatrixTexture: ci, createUnsignedBytesMatrixTexture: li, createPackedMatrixTexture: hi, createFloat16PackedMatrixTexture: fi, bindVertexProgramAttributeStreams: pi, uploadDenseMatrixToTexture: di, uploadPixelDataToTexture: vi, createBufferFromOutputTexture: mi, downloadFloat32MatrixFromBuffer: gi, downloadByteEncodedFloatMatrixFromOutputTexture: yi, downloadPackedMatrixFromBuffer: xi, downloadMatrixFromPackedOutputTexture: bi });
  var Ci = function() {
    function t3(t4) {
      this.outputTexture = null, this.program = null, this.disposed = false, this.vertexAttrsAreBound = false, this.itemsToPoll = [];
      var e2 = a().getNumber("WEBGL_VERSION");
      if (null != t4 ? (this.gl = t4, Wt(e2, t4)) : this.gl = Ut(e2), 1 === a().getNumber("WEBGL_VERSION"))
        this.textureFloatExtension = Qt(this.gl, this.debug, "OES_texture_float"), this.colorBufferFloatExtension = this.gl.getExtension("WEBGL_color_buffer_float"), this.textureHalfFloatExtension = Qt(this.gl, this.debug, "OES_texture_half_float"), this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
      else {
        if (Ne(this.gl, "EXT_color_buffer_float"))
          this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float");
        else {
          if (!Ne(this.gl, "EXT_color_buffer_half_float"))
            throw new Error("GL context does not support color renderable floats");
          this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
        }
      }
      this.vertexBuffer = ai(this.gl, this.debug), this.indexBuffer = ii(this.gl, this.debug), this.framebuffer = le(this.gl, this.debug), this.textureConfig = qt(this.gl, this.textureHalfFloatExtension);
    }
    return Object.defineProperty(t3.prototype, "debug", { get: function() {
      return a().getBool("DEBUG");
    }, enumerable: true, configurable: true }), t3.prototype.dispose = function() {
      var t4 = this;
      if (!this.disposed) {
        null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
        var e2 = this.gl;
        Kt(e2, this.debug, function() {
          return e2.finish();
        }), Kt(e2, this.debug, function() {
          return e2.bindFramebuffer(e2.FRAMEBUFFER, null);
        }), Kt(e2, this.debug, function() {
          return e2.deleteFramebuffer(t4.framebuffer);
        }), Kt(e2, this.debug, function() {
          return e2.bindBuffer(e2.ARRAY_BUFFER, null);
        }), Kt(e2, this.debug, function() {
          return e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, null);
        }), Kt(e2, this.debug, function() {
          return e2.deleteBuffer(t4.indexBuffer);
        }), this.disposed = true;
      }
    }, t3.prototype.createFloat32MatrixTexture = function(t4, e2) {
      return this.throwIfDisposed(), si(this.gl, this.debug, t4, e2, this.textureConfig);
    }, t3.prototype.createFloat16MatrixTexture = function(t4, e2) {
      return this.throwIfDisposed(), ci(this.gl, this.debug, t4, e2, this.textureConfig);
    }, t3.prototype.createUnsignedBytesMatrixTexture = function(t4, e2) {
      return this.throwIfDisposed(), li(this.gl, this.debug, t4, e2, this.textureConfig);
    }, t3.prototype.uploadPixelDataToTexture = function(t4, e2) {
      this.throwIfDisposed(), vi(this.gl, this.debug, t4, e2);
    }, t3.prototype.uploadDenseMatrixToTexture = function(t4, e2, n2, r2) {
      this.throwIfDisposed(), di(this.gl, this.debug, t4, e2, n2, r2, this.textureConfig);
    }, t3.prototype.createFloat16PackedMatrixTexture = function(t4, e2) {
      return this.throwIfDisposed(), fi(this.gl, this.debug, t4, e2, this.textureConfig);
    }, t3.prototype.createPackedMatrixTexture = function(t4, e2) {
      return this.throwIfDisposed(), hi(this.gl, this.debug, t4, e2, this.textureConfig);
    }, t3.prototype.deleteMatrixTexture = function(t4) {
      var e2 = this;
      this.throwIfDisposed(), this.outputTexture === t4 && (ge(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Kt(this.gl, this.debug, function() {
        return e2.gl.deleteTexture(t4);
      });
    }, t3.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(t4, e2, n2) {
      var r2 = this;
      return this.downloadMatrixDriver(t4, function() {
        return yi(r2.gl, r2.debug, e2, n2, r2.textureConfig);
      });
    }, t3.prototype.downloadPackedMatrixFromBuffer = function(t4, e2, n2, r2, o2, a2) {
      return xi(this.gl, t4, 0, 0, 0, o2, a2, this.textureConfig);
    }, t3.prototype.downloadFloat32MatrixFromBuffer = function(t4, e2) {
      return gi(this.gl, t4, e2);
    }, t3.prototype.createBufferFromTexture = function(t4, e2, n2) {
      this.bindTextureToFrameBuffer(t4);
      var r2 = mi(this.gl, this.debug, e2, n2, this.textureConfig);
      return this.unbindTextureToFrameBuffer(), r2;
    }, t3.prototype.createAndWaitForFence = function() {
      var t4 = this.createFence(this.gl);
      return this.pollFence(t4);
    }, t3.prototype.createFence = function(t4) {
      var e2, n2, r2 = this;
      if (a().getBool("WEBGL_FENCE_API_ENABLED")) {
        var o2 = t4, i2 = o2.fenceSync(o2.SYNC_GPU_COMMANDS_COMPLETE, 0);
        t4.flush(), n2 = function() {
          var t5 = o2.clientWaitSync(i2, 0, 0);
          return t5 === o2.ALREADY_SIGNALED || t5 === o2.CONDITION_SATISFIED;
        }, e2 = i2;
      } else
        a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e2 = this.beginQuery(), this.endQuery(), n2 = function() {
          return r2.isQueryAvailable(e2, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
        }) : n2 = function() {
          return true;
        };
      return { query: e2, isFencePassed: n2 };
    }, t3.prototype.downloadMatrixFromPackedTexture = function(t4, e2, n2) {
      var r2 = this;
      return this.downloadMatrixDriver(t4, function() {
        return bi(r2.gl, r2.debug, e2, n2);
      });
    }, t3.prototype.createProgram = function(t4) {
      this.throwIfDisposed();
      var e2 = this.gl, n2 = Zt(e2, this.debug, t4), r2 = oi(e2, this.debug), o2 = re(e2, this.debug);
      return Kt(e2, this.debug, function() {
        return e2.attachShader(o2, r2);
      }), Kt(e2, this.debug, function() {
        return e2.attachShader(o2, n2);
      }), oe(e2, this.debug, o2), this.debug && ae(e2, this.debug, o2), this.vertexAttrsAreBound || (this.setProgram(o2), this.vertexAttrsAreBound = pi(e2, this.debug, this.program, this.vertexBuffer)), o2;
    }, t3.prototype.deleteProgram = function(t4) {
      var e2 = this;
      this.throwIfDisposed(), t4 === this.program && (this.program = null), null != t4 && Kt(this.gl, this.debug, function() {
        return e2.gl.deleteProgram(t4);
      });
    }, t3.prototype.setProgram = function(t4) {
      var e2 = this;
      this.throwIfDisposed(), this.program = t4, null != this.program && this.debug && ae(this.gl, this.debug, this.program), Kt(this.gl, this.debug, function() {
        return e2.gl.useProgram(t4);
      });
    }, t3.prototype.getUniformLocation = function(t4, e2, n2) {
      return void 0 === n2 && (n2 = true), this.throwIfDisposed(), n2 ? pe(this.gl, this.debug, t4, e2) : de(this.gl, t4, e2);
    }, t3.prototype.getAttributeLocation = function(t4, e2) {
      var n2 = this;
      return this.throwIfDisposed(), Kt(this.gl, this.debug, function() {
        return n2.gl.getAttribLocation(t4, e2);
      });
    }, t3.prototype.getUniformLocationNoThrow = function(t4, e2) {
      return this.throwIfDisposed(), this.gl.getUniformLocation(t4, e2);
    }, t3.prototype.setInputMatrixTexture = function(t4, e2, n2) {
      this.throwIfDisposed(), this.throwIfNoProgram(), ve(this.gl, this.debug, this.program, t4, e2, n2);
    }, t3.prototype.setOutputMatrixTexture = function(t4, e2, n2) {
      this.setOutputMatrixTextureDriver(t4, n2, e2);
    }, t3.prototype.setOutputPackedMatrixTexture = function(t4, e2, n2) {
      this.throwIfDisposed();
      var r2 = Ht(e2, n2), o2 = r2[0], a2 = r2[1];
      this.setOutputMatrixTextureDriver(t4, o2, a2);
    }, t3.prototype.setOutputMatrixWriteRegion = function(t4, e2, n2, r2) {
      this.setOutputMatrixWriteRegionDriver(n2, t4, r2, e2);
    }, t3.prototype.setOutputPackedMatrixWriteRegion = function(t4, e2, n2, r2) {
      throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }, t3.prototype.debugValidate = function() {
      null != this.program && ae(this.gl, this.debug, this.program), ye(this.gl);
    }, t3.prototype.executeProgram = function() {
      this.throwIfDisposed(), this.throwIfNoProgram();
      var t4 = this.gl;
      this.debug && this.debugValidate(), Kt(t4, this.debug, function() {
        return t4.drawElements(t4.TRIANGLES, 6, t4.UNSIGNED_SHORT, 0);
      });
    }, t3.prototype.blockUntilAllProgramsCompleted = function() {
      var t4 = this;
      this.throwIfDisposed(), Kt(this.gl, this.debug, function() {
        return t4.gl.finish();
      });
    }, t3.prototype.getQueryTimerExtension = function() {
      return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = Qt(this.gl, this.debug, 2 === a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
    }, t3.prototype.getQueryTimerExtensionWebGL2 = function() {
      return this.getQueryTimerExtension();
    }, t3.prototype.getQueryTimerExtensionWebGL1 = function() {
      return this.getQueryTimerExtension();
    }, t3.prototype.beginQuery = function() {
      if (2 === a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
        var t4 = this.gl, e2 = this.getQueryTimerExtensionWebGL2(), n2 = t4.createQuery();
        return t4.beginQuery(e2.TIME_ELAPSED_EXT, n2), n2;
      }
      var r2 = this.getQueryTimerExtensionWebGL1(), o2 = r2.createQueryEXT();
      return r2.beginQueryEXT(r2.TIME_ELAPSED_EXT, o2), o2;
    }, t3.prototype.endQuery = function() {
      if (2 !== a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
        var t4 = this.getQueryTimerExtensionWebGL1();
        t4.endQueryEXT(t4.TIME_ELAPSED_EXT);
      } else {
        var e2 = this.gl, n2 = this.getQueryTimerExtensionWebGL2();
        e2.endQuery(n2.TIME_ELAPSED_EXT);
      }
    }, t3.prototype.waitForQueryAndGetTime = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2 = this;
        return r(this, function(n2) {
          switch (n2.label) {
            case 0:
              return [4, S(function() {
                return e2.disposed || e2.isQueryAvailable(t4, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
              })];
            case 1:
              return n2.sent(), [2, this.getQueryTime(t4, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))];
          }
        });
      });
    }, t3.prototype.getQueryTime = function(t4, e2) {
      if (0 === e2)
        return null;
      if (2 === e2) {
        var n2 = this.gl;
        return n2.getQueryParameter(t4, n2.QUERY_RESULT) / 1e6;
      }
      var r2 = this.getQueryTimerExtensionWebGL1();
      return r2.getQueryObjectEXT(t4, r2.QUERY_RESULT_EXT) / 1e6;
    }, t3.prototype.isQueryAvailable = function(t4, e2) {
      if (0 === e2)
        return true;
      if (2 === e2) {
        var n2 = this.gl, r2 = this.getQueryTimerExtensionWebGL2(), o2 = n2.getQueryParameter(t4, n2.QUERY_RESULT_AVAILABLE);
        return null == this.disjoint && (this.disjoint = this.gl.getParameter(r2.GPU_DISJOINT_EXT)), o2 && !this.disjoint;
      }
      o2 = (r2 = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t4, r2.QUERY_RESULT_AVAILABLE_EXT);
      return null == this.disjoint && (this.disjoint = this.gl.getParameter(r2.GPU_DISJOINT_EXT)), o2 && !this.disjoint;
    }, t3.prototype.pollFence = function(t4) {
      var e2 = this;
      return new Promise(function(n2) {
        e2.addItemToPoll(function() {
          return t4.isFencePassed();
        }, function() {
          return n2();
        });
      });
    }, t3.prototype.pollItems = function() {
      for (var t4 = function(t5) {
        for (var e3 = 0; e3 < t5.length; ++e3) {
          var n2 = t5[e3]();
          if (!n2)
            break;
        }
        return e3 - 1;
      }(this.itemsToPoll.map(function(t5) {
        return t5.isDoneFn;
      })), e2 = 0; e2 <= t4; ++e2) {
        (0, this.itemsToPoll[e2].resolveFn)();
      }
      this.itemsToPoll = this.itemsToPoll.slice(t4 + 1);
    }, t3.prototype.addItemToPoll = function(t4, e2) {
      var n2 = this;
      this.itemsToPoll.push({ isDoneFn: t4, resolveFn: e2 }), this.itemsToPoll.length > 1 || S(function() {
        return n2.pollItems(), 0 === n2.itemsToPoll.length;
      });
    }, t3.prototype.bindTextureToFrameBuffer = function(t4) {
      this.throwIfDisposed(), me(this.gl, this.debug, t4, this.framebuffer), this.debug && ye(this.gl);
    }, t3.prototype.unbindTextureToFrameBuffer = function() {
      null != this.outputTexture ? (me(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && ye(this.gl)) : ge(this.gl, this.debug, this.framebuffer);
    }, t3.prototype.downloadMatrixDriver = function(t4, e2) {
      this.bindTextureToFrameBuffer(t4);
      var n2 = e2();
      return this.unbindTextureToFrameBuffer(), n2;
    }, t3.prototype.setOutputMatrixTextureDriver = function(t4, e2, n2) {
      this.throwIfDisposed();
      var r2 = this.gl;
      me(r2, this.debug, t4, this.framebuffer), this.debug && ye(r2), this.outputTexture = t4, Kt(r2, this.debug, function() {
        return r2.viewport(0, 0, e2, n2);
      }), Kt(r2, this.debug, function() {
        return r2.scissor(0, 0, e2, n2);
      });
    }, t3.prototype.setOutputMatrixWriteRegionDriver = function(t4, e2, n2, r2) {
      var o2 = this;
      this.throwIfDisposed(), Kt(this.gl, this.debug, function() {
        return o2.gl.scissor(t4, e2, n2, r2);
      });
    }, t3.prototype.throwIfDisposed = function() {
      if (this.disposed)
        throw new Error("Attempted to use disposed GPGPUContext.");
    }, t3.prototype.throwIfNoProgram = function() {
      if (null == this.program)
        throw new Error("No GPU program is currently set.");
    }, t3;
  }();
  function Ei(t3, e2) {
    if (t3.length !== e2.length)
      throw Error("Binary was compiled with " + t3.length + " inputs, but was executed with " + e2.length + " inputs");
    t3.forEach(function(t4, n2) {
      var r2 = t4.logicalShape, o2 = e2[n2], a2 = o2.shape;
      if (!C(r2, a2))
        throw Error("Binary was compiled with different shapes than the current args. Shapes " + r2 + " and " + a2 + " must match");
      if (!t4.isUniform || !o2.isUniform) {
        var i2 = t4.texShape, u2 = o2.isUniform ? null : o2.texData.texShape;
        if (!C(i2, u2))
          throw Error("Binary was compiled with different texture shapes than the current args. Shape " + i2 + " and " + u2 + " must match");
      }
    });
  }
  var Ri = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3;
      for (var r2 = n2.filterWidth, o2 = n2.inChannels, a2 = n2.strideWidth, i2 = n2.strideHeight, u2 = n2.padInfo, s2 = n2.outWidth, c2 = n2.dilationWidth, l3 = n2.dilationHeight, h = n2.dataFormat, f2 = u2.left, p2 = u2.top, d2 = o2 * r2, v2 = Ko(), m2 = "channelsLast" === h, g2 = m2 ? 0 : 1, y2 = m2 ? 1 : 2, x2 = "", b2 = 0; b2 <= 1; b2++)
        for (var w2 = 0; w2 <= 1; w2++)
          x2 += "\n          blockIndex = rc.y + " + w2 + ";\n          pos = rc.x + " + b2 + ";\n\n          if(blockIndex < " + t3[1] + " && pos < " + t3[0] + ") {\n            offsetY = int(blockIndex / (" + s2 + ")) * " + i2 + " - " + p2 + ";\n            d0 = offsetY + " + l3 + " * (pos / " + d2 + ");\n\n            if(d0 < " + e2[g2] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + s2 + ".) * " + a2 + ". - " + f2 + ".);\n              d1 = offsetX + " + c2 + " * (int(mod(float(pos), " + d2 + ".) / " + o2 + ".));\n\n              if(d1 < " + e2[y2] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + o2 + ".));\n\n                if (" + m2 + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * b2 + w2) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * b2 + w2) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
      this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + x2 + "\n\n        " + v2.output + " = result;\n      }\n    ";
    };
  }();
  var Ii = function() {
    return function(t3, e2, n2, r2, o2) {
      this.variableNames = ["x"], this.outputShape = [];
      var a2, i2 = e2, u2 = t3[3] - 1;
      this.outputShape = t3;
      var s2 = "float(" + n2 + ") + float(" + r2 + ") * sum";
      a2 = 0.5 === o2 ? "inversesqrt(" + s2 + ")" : 1 === o2 ? "1.0/(" + s2 + ")" : "exp(log(" + s2 + ") * float(-" + o2 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + i2 + "; j <= " + i2 + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + u2 + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + a2 + ";\n        setOutput(val);\n      }\n    ";
    };
  }();
  var ki = function() {
    return function(t3, e2, n2, r2, o2) {
      this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t3, this.depth = t3[3], this.depthRadius = e2, this.bias = n2, this.alpha = r2, this.beta = o2, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e2 + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e2 + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r2 + ") * norm + float(" + n2 + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r2 + ")\n                * float(" + o2 + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + o2 + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ";
    };
  }();
  var Si = function() {
    return function(t3, e2, n2, r2, o2) {
      this.variableNames = ["x"], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
      var a2, i2 = e2, u2 = t3[3] - 1;
      this.outputShape = t3;
      var s2 = "float(" + n2 + ") + float(" + r2 + ") * sum";
      a2 = 0.5 === o2 ? "inversesqrt(" + s2 + ")" : 1 === o2 ? "1.0/(" + s2 + ")" : "exp(log(" + s2 + ") * float(-" + o2 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + i2 + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + i2 + "; j <= " + i2 + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + u2 + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + a2 + ";\n        setOutput(result);\n      }\n    ";
    };
  }();
  var Ai = function() {
    return function(t3) {
      this.variableNames = ["dy", "maxPos"], this.outputShape = t3.inShape;
      var e2 = t3.strideHeight, n2 = t3.strideWidth, r2 = t3.dilationHeight, o2 = t3.effectiveFilterHeight, a2 = t3.effectiveFilterWidth, i2 = o2 - 1 - t3.padInfo.top, u2 = a2 - 1 - t3.padInfo.left, s2 = o2 * a2 - 1;
      this.userCode = "\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + o2 + ";\n          wR += " + r2 + ") {\n          float dyR = float(dyRCorner + wR) / " + e2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t3.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + a2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t3.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + s2 + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + a2 + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var Di = function() {
    return function(t3) {
      this.variableNames = ["dy", "maxPos"], this.outputShape = t3.inShape;
      var e2 = t3.strideDepth, n2 = t3.strideHeight, r2 = t3.strideWidth, o2 = t3.dilationDepth, a2 = t3.dilationHeight, i2 = t3.dilationWidth, u2 = t3.effectiveFilterDepth, s2 = t3.effectiveFilterHeight, c2 = t3.effectiveFilterWidth, l3 = u2 - 1 - t3.padInfo.front, h = s2 - 1 - t3.padInfo.top, f2 = c2 - 1 - t3.padInfo.left, p2 = u2 * s2 * c2 - 1;
      this.userCode = "\n      const ivec3 pads = ivec3(" + l3 + ", " + h + ", " + f2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + u2 + ";\n           wD += " + o2 + ") {\n          float dyD = float(dyDCorner + wD) / " + e2 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t3.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + s2 + ";\n              wR += " + a2 + ") {\n            float dyR = float(dyRCorner + wR) / " + n2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t3.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c2 + ";\n                wC += " + i2 + ") {\n              float dyC = float(dyCCorner + wC) / " + r2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t3.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + p2 + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + s2 + " * " + c2 + " +\n                  wR * " + c2 + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
  }();
  var Ti = function() {
    return function(t3, e2, n2, r2, o2, a2, i2) {
      void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false), void 0 === o2 && (o2 = false), void 0 === a2 && (a2 = null), void 0 === i2 && (i2 = false), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e2;
      var u2 = n2 ? t3[1] : t3[2], s2 = Math.ceil(u2 / 2), c2 = n2 ? "i * 2, rc.y" : "rc.y, i * 2", l3 = r2 ? "rc.z, i * 2" : "i * 2, rc.z", h = n2 ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], f2 = r2 ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], p2 = "", d2 = "";
      a2 && (p2 = i2 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + a2 + "\n        }" : "vec4 activation(vec4 x) {\n          " + a2 + "\n        }", d2 = "result = activation(result);");
      var v2 = o2 ? "result += getBiasAtOutCoords();" : "";
      o2 && this.variableNames.push("bias"), i2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + p2 + "\n\n      const float sharedDimension = " + s2 + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + s2 + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c2 + ");\n          vec4 b = getMatrixB(rc.x, " + l3 + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h[0] + " * " + f2[0] + ");\n          result += (" + h[1] + " * " + f2[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v2 + "\n\n        " + d2 + "\n\n        setOutput(result);\n      }\n    ";
    };
  }();
  var Ni = function() {
    function t3(t4, e2, n2) {
      this.variableNames = ["probs"], this.outputShape = [t4, n2], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e2 - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e2 - 1) + "));\n      }\n    ";
    }
    return t3.prototype.getCustomSetupFunc = function(t4) {
      var e2 = this;
      return function(n2, r2) {
        null == e2.seedLoc && (e2.seedLoc = n2.getUniformLocation(r2, "seed")), n2.gl.uniform1f(e2.seedLoc, t4);
      };
    }, t3;
  }();
  var Fi = function() {
    return function(t3, e2, n2, r2) {
      this.variableNames = ["indices"], this.outputShape = [t3, e2], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r2 + "), float(" + n2 + "),\n                      float(index == coords.y)));\n      }\n    ";
    };
  }();
  var Oi = function() {
    return function(t3) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outputShape = t3;
      var e2 = t3.length;
      if (0 === e2)
        this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
      else {
        var n2 = qo("rc", e2), r2 = aa(e2), o2 = function(t4, e3, n3) {
          if (1 === t4)
            return "rc > " + e3[0];
          for (var r3 = "", o3 = t4 - 2; o3 < t4; o3++)
            r3 += n3[o3] + " >= " + e3[o3], o3 < t4 - 1 && (r3 += "||");
          return r3;
        }(e2, t3, n2), a2 = function(t4, e3, n3, r3) {
          if (1 === t4)
            return "";
          var o3 = r3.slice(-2);
          return "\n    int r = " + o3[0] + ";\n    int c = " + o3[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e3 + ";\n    bool rEdge = rp1 >= " + n3 + ";\n  ";
        }(e2, t3[t3.length - 1], t3[t3.length - 2], n2), i2 = function(t4, e3) {
          var n3 = t4.length, r3 = function(t5, e4) {
            for (var n4 = [], r4 = 0; r4 <= 1; r4++)
              for (var o3 = 0; o3 <= 1; o3++) {
                for (var a3 = (0 === r4 ? "r" : "rp1") + ", " + (0 === o3 ? "c" : "cp1"), i3 = 2; i3 < t5; i3++)
                  a3 = e4[e4.length - 1 - i3] + "," + a3;
                n4.push(a3);
              }
            return n4;
          }(n3, e3);
          return 1 === n3 ? "getA(rc),\n            rc + 1 >= " + t4[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r3[0] + "),\n          cEdge ? 0. : getA(" + r3[1] + "),\n          rEdge ? 0. : getA(" + r3[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r3[3] + ")";
        }(t3, n2);
        this.userCode = "\n        void main() {\n          " + r2 + " rc = getOutputCoords();\n\n          if(" + o2 + ") {\n            setOutput(vec4(0));\n          } else {\n            " + a2 + "\n\n            setOutput(vec4(" + i2 + "));\n          }\n        }\n      ";
      }
    };
  }();
  var _i = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["x"], this.outputShape = e2.map(function(e3, n3) {
        return e3[0] + t3[n3] + e3[1];
      });
      var r2 = t3.length, o2 = aa(r2), a2 = e2.map(function(t4) {
        return t4[0];
      }).join(","), i2 = e2.map(function(e3, n3) {
        return e3[0] + t3[n3];
      }).join(","), u2 = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r2);
      this.userCode = 1 !== r2 ? "\n      " + o2 + " start = " + o2 + "(" + a2 + ");\n      " + o2 + " end = " + o2 + "(" + i2 + ");\n\n      void main() {\n        " + o2 + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n2 + "));\n        } else {\n          " + o2 + " coords = outC - start;\n          setOutput(getX(" + u2 + "));\n        }\n      }\n    " : "\n        int start = " + a2 + ";\n        int end = " + i2 + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n2 + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
    };
  }();
  var Mi = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e2.map(function(e3, n3) {
        return e3[0] + t3[n3] + e3[1];
      });
      for (var r2 = t3.length, o2 = aa(r2), a2 = e2.map(function(t4) {
        return t4[0];
      }).join(","), i2 = e2.map(function(e3, n3) {
        return e3[0] + t3[n3];
      }).join(","), u2 = qo("rc", r2), s2 = qo("source", r2), c2 = u2[r2 - 1] + " < " + this.outputShape[r2 - 1], l3 = 1 === r2 ? "source" : "vec2(" + s2.slice(-2).join() + ")", h = [o2 + " rc = outputLoc;", u2[r2 - 1] + " += 1;\n       if(" + c2 + ") {\n      ", 1 === r2 ? "" : "}\n       rc = outputLoc;\n       " + u2[r2 - 2] + " += 1;\n       if(" + u2[r2 - 2] + " < " + this.outputShape[r2 - 2] + ") {", 1 === r2 ? "" : "  " + u2[r2 - 1] + " += 1;\n         if(" + c2 + ") {"], f2 = 1 === r2 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", p2 = "", d2 = 0, v2 = 1 === r2 ? 2 : 4; d2 < v2; d2++)
        p2 += "\n        " + h[d2] + "\n        if (" + f2 + ") {\n          result[" + d2 + "] = float(" + n2 + ");\n        } else {\n          " + o2 + " source = rc - start;\n          result[" + d2 + "] = getChannel(getX(" + s2.join() + "), " + l3 + ");\n        }\n      ";
      p2 += 1 === r2 ? "} " : "}}", this.userCode = "\n      const " + o2 + " start = " + o2 + "(" + a2 + ");\n      const " + o2 + " end = " + o2 + "(" + i2 + ");\n\n      void main() {\n        " + o2 + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + p2 + "\n        setOutput(result);\n      }\n    ";
    };
  }();
  var Bi = function() {
    return function(t3, e2, n2) {
      if (this.variableNames = ["x"], "avg" === e2 && n2)
        throw new Error("Cannot compute positions for average pool.");
      var r2 = t3.filterWidth, o2 = t3.strideHeight, a2 = t3.strideWidth, i2 = t3.dilationHeight, u2 = t3.dilationWidth, s2 = t3.effectiveFilterHeight, c2 = t3.effectiveFilterWidth, l3 = t3.padInfo.top, h = t3.padInfo.left;
      this.outputShape = t3.outShape;
      var f2 = "avg" === e2, p2 = "0.0";
      if (f2 || (p2 = "-1.0 / 1e-20"), n2)
        this.userCode = "\n        const ivec2 strides = ivec2(" + o2 + ", " + a2 + ");\n        const ivec2 pads = ivec2(" + l3 + ", " + h + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + s2 + ";\n              wR += " + i2 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t3.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + c2 + ";\n                wC += " + u2 + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t3.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + c2 + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
      else {
        var d2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e2 && (d2 = "avgValue / count");
        var v2 = 4 * Math.floor(r2 / 4), m2 = r2 % 4, g2 = "\n      if (" + f2 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + o2 + ", " + a2 + ");\n      const ivec2 pads = ivec2(" + l3 + ", " + h + ");\n      const float initializationValue = " + p2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t3.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + p2 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + s2 + ";\n            wR += " + i2 + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t3.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + v2 + "; wC += 4) {\n            int xC = xCCorner + wC * " + u2 + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u2 + ", d),\n              getValue(batch, xR, xC + 2 * " + u2 + ", d),\n              getValue(batch, xR, xC + 3 * " + u2 + ", d)\n            );\n\n            " + g2 + "\n          }\n\n          int xC = xCCorner + " + v2 + ";\n          if (" + (1 === m2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + g2 + "\n          } else if (" + (2 === m2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u2 + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + g2 + "\n          } else if (" + (3 === m2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u2 + ", d),\n              getValue(batch, xR, xC + 2 * " + u2 + ", d),\n              initializationValue\n            );\n\n            " + g2 + "\n          }\n        }\n        setOutput(" + d2 + ");\n      }\n    ";
      }
    };
  }();
  var Pi = function() {
    return function(t3, e2, n2) {
      if (this.variableNames = ["x"], "avg" === e2 && n2)
        throw new Error("Cannot compute positions for average pool.");
      var r2 = t3.filterWidth, o2 = t3.strideDepth, a2 = t3.strideHeight, i2 = t3.strideWidth, u2 = t3.dilationDepth, s2 = t3.dilationHeight, c2 = t3.dilationWidth, l3 = t3.effectiveFilterDepth, h = t3.effectiveFilterHeight, f2 = t3.effectiveFilterWidth, p2 = t3.padInfo.front, d2 = t3.padInfo.top, v2 = t3.padInfo.left;
      this.outputShape = t3.outShape;
      var m2 = "avg" === e2, g2 = "0.0";
      if (m2 || (g2 = "-1.0 / 1e-20"), n2)
        this.userCode = "\n        const ivec3 strides =\n            ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n        const ivec3 pads = ivec3(" + p2 + ", " + d2 + ", " + v2 + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + l3 + ";\n              wD += " + u2 + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t3.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + h + ";\n                wR += " + s2 + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t3.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + f2 + ";\n                  wC += " + c2 + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t3.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + h + " * " + f2 + " +\n                      wR * " + f2 + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
      else {
        var y2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e2 && (y2 = "avgValue / count");
        var x2 = 4 * Math.floor(r2 / 4), b2 = r2 % 4, w2 = "\n      if (" + m2 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec3 strides =\n        ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n      const ivec3 pads = ivec3(" + p2 + ", " + d2 + ", " + v2 + ");\n      const float initializationValue = " + g2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t3.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g2 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + l3 + ";\n            wD += " + u2 + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t3.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + ";\n            wR += " + s2 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t3.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + x2 + "; wC += 4) {\n              int xC = xCCorner + wC * " + c2 + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + c2 + ", ch)\n              );\n\n              " + w2 + "\n            }\n\n            int xC = xCCorner + " + x2 + ";\n            if (" + (1 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w2 + "\n            } else if (" + (2 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w2 + "\n            } else if (" + (3 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c2 + ", ch),\n                initializationValue\n              );\n\n              " + w2 + "\n            }\n          }\n          setOutput(" + y2 + ");\n        }\n      }\n    ";
      }
    };
  }();
  var Li = function() {
    return function(t3, e2) {
      this.variableNames = ["x"];
      var n2 = t3.windowSize, r2 = t3.batchSize, o2 = t3.inSize, a2 = Math.ceil(o2 / n2);
      this.outputShape = [r2, a2];
      var i2 = "0.0", u2 = "";
      "prod" === e2 ? i2 = "1.0" : "min" === e2 ? (i2 = "1.0 / 1e-20", u2 = "min") : "max" === e2 && (i2 = "-1.0 / 1e-20", u2 = "max");
      var s2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
      "sum" === e2 ? s2 = "sumValue" : "prod" === e2 ? s2 = "prodValue" : "all" === e2 ? s2 = "allValue" : "any" === e2 && (s2 = "anyValue");
      var c2 = 4 * Math.floor(n2 / 4), l3 = n2 % 4, h = "\n      if (" + ("sum" === e2) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e2) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + u2 + "(values, minMaxValue);\n      }\n    ", f2 = "vec4";
      "all" === e2 ? (i2 = "1.0", h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", f2 = "bvec4") : "any" === e2 && (i2 = "0.0", h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", f2 = "bvec4");
      var p2 = "";
      o2 % n2 > 0 && (p2 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + i2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + p2 + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n2 + ";\n\n        vec4 minMaxValue = vec4(" + i2 + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c2 + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h + "\n        }\n\n        int inIdx = inOffset + " + c2 + ";\n        if (" + (1 === l3) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (2 === l3) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (3 === l3) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h + "\n        }\n        setOutput(" + s2 + ");\n      }\n    ";
    };
  }();
  var Wi = function() {
    return function(t3, e2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3;
      for (var n2 = "", r2 = 0; r2 < 4; r2++) {
        var o2 = "thisRC = rc;";
        r2 % 2 == 1 && (o2 += "thisRC.z += 1;"), r2 > 1 && (o2 += "thisRC.y += 1;"), n2 += "\n        " + o2 + "\n        " + (r2 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r2 + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r2 > 0 ? "}" : "") + "\n      ";
      }
      this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + jo(["r", "c", "d"], e2) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + Xo(t3) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t3[1] + ";\n        int cols = " + t3[2] + ";\n\n        " + n2 + "\n\n        setOutput(result);\n      }\n    ";
    };
  }();
  var Ui = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e2.shape;
      var r2 = e2.shape, o2 = r2[1], a2 = r2[2], i2 = t3.shape, u2 = i2[1], s2 = i2[2], c2 = [n2 && u2 > 1 ? o2 - 1 : o2, n2 && s2 > 1 ? a2 - 1 : a2], l3 = [n2 && u2 > 1 ? u2 - 1 : u2, n2 && s2 > 1 ? s2 - 1 : s2], h = c2[0] / l3[0], f2 = c2[1] / l3[1], p2 = 1 / h, d2 = 1 / f2, v2 = 2 * Math.ceil(p2) + 2, m2 = 2 * Math.ceil(d2) + 2;
      this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + f2 + ");\n\n        const float invHeightScale = float(" + p2 + ");\n        const float invWidthScale = float(" + d2 + ");\n\n        const int winHeight = int(" + v2 + ");\n        const int winWidth = int(" + m2 + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + u2 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + s2 + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (o2 - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (a2 - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
    };
  }();
  var Vi = function() {
    return function(t3, e2, n2, r2) {
      this.variableNames = ["A"], this.outputShape = [];
      var o2 = t3[0], a2 = t3[1], i2 = t3[2], u2 = t3[3];
      this.outputShape = [o2, e2, n2, u2];
      var s2 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2];
      this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + s2[0] / c2[0] + ",\n          " + s2[1] / c2[1] + ");\n      const vec2 inputShapeRC = vec2(" + a2 + ".0, " + i2 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
    };
  }();
  var zi = function() {
    return function(t3, e2, n2, r2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
      var o2 = t3[0], a2 = t3[1], i2 = t3[2], u2 = t3[3];
      this.outputShape = [o2, e2, n2, u2];
      var s2 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2];
      this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + s2[0] / c2[0] + ",\n          " + s2[1] / c2[1] + ",\n          " + s2[1] / c2[1] + ");\n      const vec3 inputShapeRC = vec3(" + a2 + ".0, " + i2 + ".0,\n                                     " + i2 + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (u2 - 1) + ";\n        bool hasNextRow = coords.z < " + (n2 - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
    };
  }();
  var Gi = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e2.shape;
      var r2 = e2.shape, o2 = r2[1], a2 = r2[2], i2 = t3.shape, u2 = i2[1], s2 = i2[2], c2 = [n2 && u2 > 1 ? o2 - 1 : o2, n2 && s2 > 1 ? a2 - 1 : a2], l3 = [n2 && u2 > 1 ? u2 - 1 : u2, n2 && s2 > 1 ? s2 - 1 : s2], h = c2[0] / l3[0], f2 = c2[1] / l3[1], p2 = 1 / h, d2 = 1 / f2, v2 = 2 * Math.ceil(p2) + 2, m2 = 2 * Math.ceil(d2) + 2;
      this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + f2 + ");\n\n        const float invHeightScale = float(" + p2 + ");\n        const float invWidthScale = float(" + d2 + ");\n\n        const int winHeight = int(" + v2 + ");\n        const int winWidth = int(" + m2 + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + u2 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + s2 + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c2[0] + ") *\n                (float(dyR) / float(" + l3[0] + "));\n\n            float sourceFracCol =\n                float(" + c2[1] + ") *\n                  (float(dyC) / float(" + l3[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + o2 + ") - 1),\n                " + n2 + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + a2 + ") - 1),\n                " + n2 + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
    };
  }();
  var Hi = function() {
    return function(t3, e2, n2, r2) {
      this.variableNames = ["A"], this.outputShape = [];
      var o2 = t3[0], a2 = t3[1], i2 = t3[2], u2 = t3[3];
      this.outputShape = [o2, e2, n2, u2];
      var s2 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], l3 = r2 ? "0.5" : "0.0";
      this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + s2[0] / c2[0] + ",\n          " + s2[1] / c2[1] + ");\n      const vec2 inputShapeRC = vec2(" + a2 + ".0, " + i2 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l3 + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
    };
  }();
  var qi = function() {
    return function(t3, e2) {
      this.variableNames = ["x"];
      var n2 = t3.length;
      if (n2 > 4)
        throw new Error("WebGL backend: Reverse of rank-" + n2 + " tensor is not yet supported");
      if (this.outputShape = t3, 1 !== n2) {
        var r2 = t3.map(function(n3, r3) {
          return function(n4) {
            return -1 !== e2.indexOf(n4) && 1 !== t3[n4] ? t3[n4] + " - coords[" + n4 + "] - 1" : "coords[" + n4 + "]";
          }(r3);
        }).join(","), o2 = aa(n2);
        this.userCode = "\n      void main() {\n        " + o2 + " coords = getOutputCoords();\n        setOutput(getX(" + r2 + "));\n      }\n    ";
      } else
        this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t3[0] + " - coord - 1));\n        }\n      ";
    };
  }();
  var Ki = function() {
    return function(t3, e2) {
      this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true;
      var n2 = t3.length;
      if (n2 > 4)
        throw new Error("WebGL backend: Reverse of rank-" + n2 + " tensor is not yet supported");
      this.outputShape = t3;
      var r2 = qo("rc", n2), o2 = r2[n2 - 1] + " + 1 < " + this.outputShape[n2 - 1], a2 = r2[n2 - 2] + " + 1 < " + this.outputShape[n2 - 2], i2 = aa(n2);
      function u2(n3) {
        var r3 = t3.map(function(r4, o3) {
          return function(n4, r5) {
            return -1 !== e2.indexOf(n4) && 1 !== t3[n4] ? t3[n4] + " - " + r5[n4] + " - 1" : "" + r5[n4];
          }(o3, n3);
        });
        return "getChannel(getX(" + r3.join(",") + "), vec2(" + r3.slice(-2).join(",") + "))";
      }
      this.userCode = 1 === n2 ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t3[0] + " - rc - 1),\n            " + t3[0] + " - rc - 1);\n          if(" + o2 + "){\n              result.g = getChannel(getX(" + t3[0] + " - (rc  + 1) - 1),\n                " + t3[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + i2 + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + function(t4) {
        return u2(t4);
      }(r2.slice()) + ";\n          if(" + o2 + "){\n            result.g = " + function(t4) {
        return t4[n2 - 1] = "(" + t4[n2 - 1] + " + 1)", u2(t4);
      }(r2.slice()) + ";\n          }\n          if(" + a2 + ") {\n            result.b = " + function(t4) {
        return t4[n2 - 2] = "(" + t4[n2 - 2] + " + 1)", u2(t4);
      }(r2.slice()) + ";\n            if(" + o2 + ") {\n              result.a = " + function(t4) {
        return t4[n2 - 1] = "(" + t4[n2 - 1] + " + 1)", t4[n2 - 2] = "(" + t4[n2 - 2] + " + 1)", u2(t4);
      }(r2.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
    };
  }();
  var ji = function() {
    return function(t3, e2, n2, r2, o2, a2, i2) {
      void 0 === i2 && (i2 = true), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a2;
      var u2 = aa(o2.length), s2 = aa(a2.length), c2 = "";
      1 === n2 ? c2 = "i" : 2 === n2 && (c2 = "i, j");
      var l3 = "getIndices(" + c2 + ")", h = "";
      1 === r2 ? h = "i" : 2 === r2 && (h = "i, coords[1]");
      var f2 = "getUpdates(" + h + ")", p2 = e2 > 1 ? "strides[j]" : "strides";
      this.userCode = "\n        " + u2 + " strides = " + u2 + "(" + o2 + ");\n\n        void main() {\n          " + s2 + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t3 + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e2 + "; j++) {\n              int index = round(" + l3 + ");\n              flattenedIndex += index * " + p2 + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + f2 + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
    };
  }();
  var Xi = function() {
    return function(t3, e2) {
      this.variableNames = ["x", "segmentIds"];
      var n2 = t3.windowSize, r2 = t3.batchSize, o2 = t3.inSize, a2 = t3.numSegments, i2 = a2 * Math.ceil(o2 / n2);
      this.outputShape = [r2, i2];
      var u2 = 4 * Math.floor(n2 / 4), s2 = n2 % 4, c2 = "\n        sumValue += dot(values, segFilter);\n    ", l3 = "";
      o2 % n2 > 0 && (l3 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return initializationValue;\n        }\n      ");
      var h = "";
      o2 % n2 > 0 && (h = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l3 + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + a2 + ")) * float(" + n2 + "));\n        int currentSeg = int(mod(float(outIdx), float(" + a2 + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + u2 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c2 + "\n        }\n\n        int inIdx = inOffset + " + u2 + ";\n        if (" + (1 === s2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c2 + "\n        } else if (" + (2 === s2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c2 + "\n        } else if (" + (3 === s2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c2 + "\n        }\n        setOutput(sumValue);\n      }\n    ";
    };
  }();
  var $i = function() {
    return function(t3, e2, n2) {
      var r2, o2;
      if (this.variableNames = ["c", "a", "b"], this.outputShape = e2, n2 > 4)
        throw Error("Where for rank " + n2 + " is not yet supported");
      if (1 === n2)
        o2 = "resRC", r2 = "resRC";
      else {
        for (var a2 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i2 = [], u2 = [], s2 = 0; s2 < e2.length; s2++)
          u2.push("" + a2[s2]), s2 < t3 && i2.push("" + a2[s2]);
        r2 = i2.join(), o2 = u2.join();
      }
      var c2 = aa(n2);
      this.userCode = "\n      void main() {\n        " + c2 + " resRC = getOutputCoords();\n        float cVal = getC(" + r2 + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + o2 + "));\n        } else {\n          setOutput(getB(" + o2 + "));\n        }\n      }\n    ";
    };
  }();
  var Yi = function() {
    function t3(t4) {
      this.variableNames = ["source"], this.outputShape = t4, this.rank = t4.length;
      var e2, n2 = aa(this.rank), r2 = "uniform int start[" + this.rank + "];", o2 = function(t5) {
        if (1 === t5)
          return "sourceLoc";
        if (t5 <= 6)
          return Qi.slice(0, t5).map(function(t6) {
            return "sourceLoc." + t6;
          }).join(",");
        throw Error("Slicing for rank " + t5 + " is not yet supported");
      }(this.rank);
      e2 = "\n        " + n2 + " sourceLoc;\n        " + n2 + " coords = getOutputCoords();\n        " + t4.map(function(t5, e3) {
        return "sourceLoc." + Qi[e3] + " = start[" + e3 + "] + coords." + Qi[e3] + ";";
      }).join("\n") + "\n      ", this.userCode = "\n      " + r2 + "\n      void main() {\n        " + e2 + "\n        setOutput(getSource(" + o2 + "));\n      }\n    ";
    }
    return t3.prototype.getCustomSetupFunc = function(t4) {
      var e2 = this;
      if (t4.length !== this.rank)
        throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t4.length + ")");
      return function(n2, r2) {
        null == e2.startLoc && (e2.startLoc = n2.getUniformLocationNoThrow(r2, "start"), null == e2.startLoc) || n2.gl.uniform1iv(e2.startLoc, t4);
      };
    }, t3;
  }();
  var Qi = ["x", "y", "z", "w", "u", "v"];
  var Ji = function() {
    function t3(t4) {
      this.variableNames = ["source"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t4, this.rank = t4.length;
      var e2 = aa(this.rank), n2 = qo("coords", this.rank), r2 = qo("sourceLoc", this.rank), o2 = 1 === this.rank ? "sourceLoc" : "vec2(" + r2.slice(-2).join() + ")", a2 = "getChannel(getSource(" + r2.join() + "), " + o2 + ")", i2 = "\n      result.x = " + a2 + ";\n      if (++" + n2[this.rank - 1] + " < " + t4[this.rank - 1] + ") {\n        ++" + r2[this.rank - 1] + ";\n        result.y = " + a2 + ";\n        --" + r2[this.rank - 1] + ";\n      }\n    ", u2 = 1 === this.rank ? "" : "\n      --" + n2[this.rank - 1] + ";\n      if (++" + n2[this.rank - 2] + " < " + t4[this.rank - 2] + ") {\n        ++" + r2[this.rank - 2] + ";\n        result.z = " + a2 + ";\n        if (++" + n2[this.rank - 1] + " < " + t4[this.rank - 1] + ") {\n          ++" + r2[this.rank - 1] + ";\n          result.w = " + a2 + ";\n        }\n      }\n    ", s2 = this.rank <= 4 ? "sourceLoc = coords +\n            " + e2 + "(" + t4.map(function(t5, e3) {
        return "start[" + e3 + "]";
      }).join() + ");" : t4.map(function(t5, e3) {
        return r2[e3] + " = " + n2[e3] + " + start[" + e3 + "];";
      }).join("\n");
      this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e2 + " coords = getOutputCoords();\n        " + e2 + " sourceLoc;\n        " + s2 + "\n        vec4 result = vec4(0.);\n        " + i2 + "\n        " + u2 + "\n        setOutput(result);\n      }\n    ";
    }
    return t3.prototype.getCustomSetupFunc = function(t4) {
      var e2 = this;
      if (t4.length !== this.rank)
        throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t4.length + ")");
      return function(n2, r2) {
        null == e2.startLoc && (e2.startLoc = n2.getUniformLocationNoThrow(r2, "start"), null == e2.startLoc) || n2.gl.uniform1iv(e2.startLoc, t4);
      };
    }, t3;
  }();
  var Zi = function() {
    return function(t3, e2, n2) {
      this.variableNames = ["x"], this.outputShape = n2;
      var r2 = n2.length, o2 = aa(n2.length), a2 = aa(n2.length), i2 = "";
      if (1 === r2)
        i2 = "coords * strides + begin";
      else {
        var u2 = 0;
        i2 = n2.map(function(t4, e3) {
          return u2++, 1 === n2.length ? "coords * strides[" + e3 + "] + begin[" + e3 + "]" : "coords[" + (u2 - 1) + "] * strides[" + e3 + "] + begin[" + e3 + "]";
        }).join(",");
      }
      this.userCode = "\n      " + o2 + " begin = " + o2 + "(" + t3 + ");\n      " + o2 + " strides = " + o2 + "(" + e2 + ");\n\n      void main() {\n        " + a2 + " coords = getOutputCoords();\n        setOutput(getX(" + i2 + "));\n      }\n    ";
    };
  }();
  var tu = function() {
    function t3(t4) {
      this.gpgpu = t4, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = false, this.usedTextures = {};
    }
    return t3.prototype.acquireTexture = function(t4, e2, n2) {
      var r2, o2 = eu(e2, n2), a2 = nu(t4, o2, n2);
      if (a2 in this.freeTextures || (this.freeTextures[a2] = []), a2 in this.usedTextures || (this.usedTextures[a2] = []), this.freeTextures[a2].length > 0) {
        this.numFreeTextures--, this.numUsedTextures++, this.log();
        var i2 = this.freeTextures[a2].shift();
        return this.usedTextures[a2].push(i2), i2;
      }
      return this.numUsedTextures++, this.log(), o2 === Bt.PACKED_2X2_FLOAT32 ? r2 = this.gpgpu.createPackedMatrixTexture(t4[0], t4[1]) : o2 === Bt.PACKED_2X2_FLOAT16 ? r2 = this.gpgpu.createFloat16PackedMatrixTexture(t4[0], t4[1]) : o2 === Bt.UNPACKED_FLOAT32 ? r2 = this.gpgpu.createFloat32MatrixTexture(t4[0], t4[1]) : o2 === Bt.UNPACKED_FLOAT16 ? r2 = this.gpgpu.createFloat16MatrixTexture(t4[0], t4[1]) : o2 === Bt.PACKED_4X1_UNSIGNED_BYTE && (r2 = this.gpgpu.createUnsignedBytesMatrixTexture(t4[0], t4[1])), this.usedTextures[a2].push(r2), r2;
    }, t3.prototype.releaseTexture = function(t4, e2, n2, r2) {
      if (null != this.freeTextures) {
        var o2 = nu(e2, eu(n2, r2), r2);
        o2 in this.freeTextures || (this.freeTextures[o2] = []), this.freeTextures[o2].push(t4), this.numFreeTextures++, this.numUsedTextures--;
        var a2 = this.usedTextures[o2], i2 = a2.indexOf(t4);
        if (i2 < 0)
          throw new Error("Cannot release a texture that was never provided by this texture manager");
        a2.splice(i2, 1), this.log();
      }
    }, t3.prototype.log = function() {
      if (this.logEnabled) {
        var t4 = this.numFreeTextures + this.numUsedTextures;
        console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t4 + ")");
      }
    }, t3.prototype.getNumUsedTextures = function() {
      return this.numUsedTextures;
    }, t3.prototype.getNumFreeTextures = function() {
      return this.numFreeTextures;
    }, t3.prototype.dispose = function() {
      var t4 = this;
      if (null != this.freeTextures) {
        for (var e2 in this.freeTextures)
          this.freeTextures[e2].forEach(function(e3) {
            t4.gpgpu.deleteMatrixTexture(e3);
          });
        for (var e2 in this.usedTextures)
          this.usedTextures[e2].forEach(function(e3) {
            t4.gpgpu.deleteMatrixTexture(e3);
          });
        this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
      }
    }, t3;
  }();
  function eu(t3, e2) {
    if (t3 === Mt.UPLOAD)
      return Bt.PACKED_2X2_FLOAT32;
    if (t3 === Mt.RENDER || null == t3)
      return function(t4) {
        return a().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t4 ? Bt.PACKED_2X2_FLOAT32 : Bt.UNPACKED_FLOAT32 : t4 ? Bt.PACKED_2X2_FLOAT16 : Bt.UNPACKED_FLOAT16;
      }(e2);
    if (t3 === Mt.DOWNLOAD || t3 === Mt.PIXELS)
      return Bt.PACKED_4X1_UNSIGNED_BYTE;
    throw new Error("Unknown logical texture type " + t3);
  }
  function nu(t3, e2, n2) {
    return t3[0] + "_" + t3[1] + "_" + e2 + "_" + n2;
  }
  var ru = function() {
    return function(t3, e2) {
      this.variableNames = ["A"];
      for (var n2 = new Array(t3.length), r2 = 0; r2 < n2.length; r2++)
        n2[r2] = t3[r2] * e2[r2];
      this.outputShape = n2, this.rank = n2.length;
      var o2 = aa(this.rank), a2 = function(t4) {
        var e3 = t4.length;
        if (e3 > 5)
          throw Error("Tile for rank " + e3 + " is not yet supported");
        if (1 === e3)
          return "imod(resRC, " + t4[0] + ")";
        for (var n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r3 = [], o3 = 0; o3 < t4.length; o3++)
          r3.push("imod(" + n3[o3] + ", " + t4[o3] + ")");
        return r3.join();
      }(t3);
      this.userCode = "\n      void main() {\n        " + o2 + " resRC = getOutputCoords();\n        setOutput(getA(" + a2 + "));\n      }\n    ";
    };
  }();
  var ou = function() {
    return function(t3, e2) {
      this.variableNames = ["A"];
      for (var n2 = new Array(t3.length), r2 = 0; r2 < n2.length; r2++)
        n2[r2] = t3[e2[r2]];
      this.outputShape = n2, this.rank = n2.length;
      var o2 = aa(this.rank), a2 = function(t4) {
        var e3 = t4.length;
        if (e3 > 6)
          throw Error("Transpose for rank " + e3 + " is not yet supported");
        for (var n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r3 = new Array(e3), o3 = 0; o3 < t4.length; o3++)
          r3[t4[o3]] = n3[o3];
        return r3.join();
      }(e2);
      this.userCode = "\n    void main() {\n      " + o2 + " resRC = getOutputCoords();\n      setOutput(getA(" + a2 + "));\n    }\n    ";
    };
  }();
  var au = function() {
    return function(t3, e2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true;
      for (var n2 = new Array(t3.length), r2 = 0; r2 < n2.length; r2++)
        n2[r2] = t3[e2[r2]];
      if (this.outputShape = n2, this.rank = n2.length, this.rank > 6)
        throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
      var o2 = aa(this.rank), a2 = Ho("rc", this.rank), i2 = new Array(this.rank);
      for (r2 = 0; r2 < e2.length; r2++)
        i2[e2[r2]] = a2[r2];
      var u2 = "vec2(" + i2.slice(-2).join() + ")", s2 = "++" + a2[this.rank - 1] + " < " + n2[this.rank - 1], c2 = "getChannel(getA(" + i2.join() + "), " + u2 + ")";
      this.userCode = "\n    void main() {\n      " + o2 + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c2 + ";\n      if(" + s2 + ") {\n        result[1] = " + c2 + ";\n      }\n      --" + a2[this.rank - 1] + ";\n      if(++" + a2[this.rank - 2] + " < " + n2[this.rank - 2] + ") {\n        result[2] = " + c2 + ";\n        if(" + s2 + ") {\n          result[3] = " + c2 + ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
    };
  }();
  var iu = 1.7580993408473768;
  var uu = 1.0507009873554805;
  var su = function() {
    return function(t3, e2) {
      this.variableNames = ["A"], this.outputShape = t3, this.userCode = "\n      float unaryOperation(float x) {\n        " + e2 + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    };
  }();
  var cu = "if (isnan(x)) return x;";
  var lu = "return x;";
  var hu = "return abs(x);";
  var fu = cu + "\n  return (x < 0.0) ? 0.0 : x;\n";
  var pu = cu + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
  var du = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
  var vu = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + iu + ";\n  float scale = " + uu + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
  var mu = "return -x;";
  var gu = "return ceil(x);";
  var yu = "return floor(x);";
  var xu = "return exp(x);";
  var bu = "return exp(x) - 1.0;";
  var wu = cu + "\n  return sin(x);\n";
  var Cu = cu + "\n  return cos(x);\n";
  var Eu = cu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n";
  var Ru = cu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n";
  var Iu = cu + "\n  return atan(x);\n";
  var ku = cu + "return log(x + sqrt(x * x + 1.0));";
  var Su = cu + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));";
  var Au = cu + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;";
  var Du = "return x;";
  var Tu = "return x;";
  var Nu = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
  var Fu = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
  var Ou = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";
  var _u = function() {
    return function(t3, e2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e2 + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    };
  }();
  var Mu = function() {
    return function(t3) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outputShape = t3;
      var e2 = t3.length, n2 = qo("rc", e2), r2 = aa(e2), o2 = function(t4, e3) {
        if (1 === t4)
          return "rc";
        for (var n3 = "", r3 = 0; r3 < t4; r3++)
          n3 += e3[r3], r3 < t4 - 1 && (n3 += ",");
        return n3;
      }(e2, n2), a2 = n2.slice(-2), i2 = e2 <= 1 ? "rc" : "vec2(" + a2.join(",") + ")";
      this.userCode = "\n      void main() {\n        " + r2 + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + o2 + ");\n\n        setOutput(getChannel(packedInput, " + i2 + "));\n      }\n    ";
    };
  }();
  var Bu = {};
  function Pu(t3, e2) {
    if (void 0 === e2 && (e2 = false), "linear" === t3)
      return e2 ? Tu : lu;
    if ("relu" === t3)
      return e2 ? Nu : fu;
    if ("elu" === t3)
      return e2 ? Ou : du;
    if ("relu6" === t3)
      return e2 ? Fu : pu;
    if ("prelu" === t3)
      return e2 ? wa : xa;
    throw new Error("Activation " + t3 + " has not been implemented for the WebGL backend.");
  }
  var Lu = 600;
  var Wu = function(t3) {
    function o2(e2) {
      var n2, r2 = t3.call(this) || this;
      if (r2.gpgpu = e2, r2.pendingRead = /* @__PURE__ */ new WeakMap(), r2.pendingDisposal = /* @__PURE__ */ new WeakSet(), r2.dataRefCount = /* @__PURE__ */ new WeakMap(), r2.numBytesInGPU = 0, r2.uploadWaitMs = 0, r2.downloadWaitMs = 0, r2.warnedAboutMemory = false, r2.pendingDeletes = 0, r2.disposed = false, !a().getBool("HAS_WEBGL"))
        throw new Error("WebGL is not supported on this device");
      if (null == e2) {
        var o3 = Ut(a().getNumber("WEBGL_VERSION"));
        r2.binaryCache = (n2 = a().getNumber("WEBGL_VERSION")) in Bu ? Bu[n2] : (Bu[n2] = {}, Bu[n2]), r2.gpgpu = new Ci(o3), r2.canvas = o3.canvas, r2.gpgpuCreatedLocally = true;
      } else
        r2.binaryCache = {}, r2.gpgpuCreatedLocally = false, r2.canvas = e2.gl.canvas;
      return r2.textureManager = new tu(r2.gpgpu), r2.numMBBeforeWarning = null == a().global.screen ? 1024 : a().global.screen.height * a().global.screen.width * window.devicePixelRatio * Lu / 1024 / 1024, r2.texData = new so(r2, Nt), r2;
    }
    return e(o2, t3), o2.prototype.numDataIds = function() {
      return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
    }, o2.prototype.fromPixels = function(t4, e2) {
      if (null == t4)
        throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
      var n2 = "undefined" != typeof OffscreenCanvas && t4 instanceof OffscreenCanvas || "undefined" != typeof HTMLCanvasElement && t4 instanceof HTMLCanvasElement, r2 = t4.data instanceof Uint8Array, o3 = "undefined" != typeof ImageData && t4 instanceof ImageData, i2 = "undefined" != typeof HTMLVideoElement && t4 instanceof HTMLVideoElement, u2 = "undefined" != typeof HTMLImageElement && t4 instanceof HTMLImageElement, s2 = i2 ? [t4.videoWidth, t4.videoHeight] : [t4.width, t4.height], c2 = s2[0], l3 = s2[1], h = [l3, c2], f2 = [l3, c2, e2];
      if (!(n2 || r2 || o3 || i2 || u2))
        throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t4.constructor.name);
      (u2 || i2) && (null == this.fromPixels2DContext && (this.fromPixels2DContext = Vt(a().getNumber("WEBGL_VERSION")).getContext("2d")), this.fromPixels2DContext.canvas.width = c2, this.fromPixels2DContext.canvas.height = l3, this.fromPixels2DContext.drawImage(t4, 0, 0, c2, l3), t4 = this.fromPixels2DContext.canvas);
      var p2, d2, v2 = this.makeTensorInfo(h, "int32");
      return this.texData.get(v2.dataId).usage = Mt.PIXELS, this.gpgpu.uploadPixelDataToTexture(this.getTexture(v2.dataId), t4), a().getBool("WEBGL_PACK") ? (p2 = new ei(f2), d2 = this.compileAndRun(p2, [v2])) : (p2 = new ti(f2), d2 = this.compileAndRun(p2, [v2])), this.disposeData(v2.dataId), d2;
    }, o2.prototype.write = function(t4, e2, n2) {
      if (a().getBool("DEBUG") && this.checkNumericalProblems(t4), "complex64" === n2 && null != t4)
        throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      var r2 = {};
      return this.texData.set(r2, { shape: e2, dtype: n2, values: t4, usage: Mt.UPLOAD }), r2;
    }, o2.prototype.move = function(t4, e2, n2, r2) {
      if (a().getBool("DEBUG") && this.checkNumericalProblems(e2), "complex64" === r2)
        throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      this.texData.set(t4, { shape: n2, dtype: r2, values: e2, usage: Mt.UPLOAD });
    }, o2.prototype.readSync = function(t4) {
      var e2 = this.texData.get(t4), n2 = e2.values, r2 = e2.dtype, o3 = e2.complexTensors, a2 = e2.slice, i2 = e2.shape, u2 = e2.isPacked;
      if (null != a2) {
        var s2 = void 0;
        s2 = u2 ? new _u(i2, Du) : new su(i2, Du);
        var c2 = this.runWebGLProgram(s2, [{ dataId: t4, shape: i2, dtype: r2 }], r2), l3 = this.readSync(c2.dataId);
        return this.disposeData(c2.dataId), l3;
      }
      if (null != n2)
        return this.convertAndCacheOnCPU(t4);
      if ("string" === r2)
        return n2;
      var h, f2, p2 = null != this.activeTimers;
      (p2 && (h = Y()), "complex64" === r2) ? f2 = No(o3.real.dataSync(), o3.imag.dataSync()) : f2 = this.getValuesFromTexture(t4);
      return p2 && (this.downloadWaitMs += Y() - h), this.convertAndCacheOnCPU(t4, f2);
    }, o2.prototype.read = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2, o3, i2, u2, s2, c2, l3, h, f2, p2, d2, v2, m2, g2, y2, x2, b2, C3, E3, R3, I3;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              if (this.pendingRead.has(t4))
                return e2 = this.pendingRead.get(t4), [2, new Promise(function(t5) {
                  return e2.push(t5);
                })];
              if (n2 = this.texData.get(t4), o3 = n2.values, i2 = n2.shape, u2 = n2.slice, s2 = n2.dtype, c2 = n2.complexTensors, l3 = n2.isPacked, null != u2)
                return h = void 0, h = l3 ? new _u(i2, Du) : new su(i2, Du), f2 = this.runWebGLProgram(h, [{ dataId: t4, shape: i2, dtype: s2 }], s2), p2 = this.read(f2.dataId), this.disposeData(f2.dataId), [2, p2];
              if (null != o3)
                return [2, this.convertAndCacheOnCPU(t4)];
              if (!a().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === a().getNumber("WEBGL_VERSION"))
                throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
              return d2 = null, "complex64" !== s2 && a().get("WEBGL_BUFFER_SUPPORTED") && (v2 = this.decode(t4), m2 = this.texData.get(v2.dataId), d2 = (I3 = this.gpgpu).createBufferFromTexture.apply(I3, [m2.texture].concat(Gt(i2)))), this.pendingRead.set(t4, []), "complex64" === s2 ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];
            case 1:
              r2.sent(), r2.label = 2;
            case 2:
              return "complex64" !== s2 ? [3, 4] : [4, Promise.all([c2.real.data(), c2.imag.data()])];
            case 3:
              return y2 = r2.sent(), x2 = y2[0], b2 = y2[1], g2 = No(x2, b2), [3, 5];
            case 4:
              null == d2 ? g2 = this.getValuesFromTexture(t4) : (C3 = w(i2), g2 = this.gpgpu.downloadFloat32MatrixFromBuffer(d2, C3)), r2.label = 5;
            case 5:
              return null != v2 && this.disposeData(v2.dataId), E3 = this.convertAndCacheOnCPU(t4, g2), R3 = this.pendingRead.get(t4), this.pendingRead.delete(t4), R3.forEach(function(t5) {
                return t5(E3);
              }), this.pendingDisposal.has(t4) && (this.pendingDisposal.delete(t4), this.disposeData(t4), this.pendingDeletes--), [2, E3];
          }
        });
      });
    }, o2.prototype.checkNumericalProblems = function(t4) {
      if (null != t4)
        for (var e2 = 0; e2 < t4.length; e2++) {
          var n2 = t4[e2];
          if (!$t(n2)) {
            if (a().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))
              throw Error("The value " + n2 + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
            throw Error("The value " + n2 + " cannot be represented on this device.");
          }
        }
    }, o2.prototype.getValuesFromTexture = function(t4) {
      var e2, n2 = this.texData.get(t4), r2 = n2.shape, o3 = n2.dtype, i2 = n2.isPacked, u2 = w(r2);
      if (a().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
        var s2 = this.decode(t4), c2 = this.texData.get(s2.dataId), l3 = (e2 = this.gpgpu).downloadMatrixFromPackedTexture.apply(e2, [c2.texture].concat(Gt(r2))).subarray(0, u2);
        return this.disposeData(s2.dataId), l3;
      }
      var h = a().getBool("WEBGL_PACK") && true === i2, f2 = h ? Re(r2) : r2, p2 = h ? new ja(f2) : new Ka(f2), d2 = this.runWebGLProgram(p2, [{ shape: f2, dtype: o3, dataId: t4 }], "float32"), v2 = this.texData.get(d2.dataId), m2 = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v2.texture, v2.texShape[0], v2.texShape[1]).subarray(0, u2);
      return this.disposeData(d2.dataId), m2;
    }, o2.prototype.time = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2, o3, a2, i2, u2, s2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              return e2 = this.activeTimers, n2 = [], o3 = false, null == this.programTimersStack ? (this.programTimersStack = n2, o3 = true) : this.activeTimers.push(n2), this.activeTimers = n2, t4(), a2 = b(this.activeTimers.map(function(t5) {
                return t5.query;
              })).filter(function(t5) {
                return null != t5;
              }), i2 = b(this.activeTimers.map(function(t5) {
                return t5.name;
              })).filter(function(t5) {
                return null != t5;
              }), this.activeTimers = e2, o3 && (this.programTimersStack = null), [4, Promise.all(a2)];
            case 1:
              return u2 = r2.sent(), s2 = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: m(u2), getExtraProfileInfo: function() {
                return u2.map(function(t5, e3) {
                  return { name: i2[e3], ms: t5 };
                }).map(function(t5) {
                  return t5.name + ": " + t5.ms;
                }).join(", ");
              }, wallMs: null }, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, s2];
          }
        });
      });
    }, o2.prototype.memory = function() {
      return { unreliable: false, numBytesInGPU: this.numBytesInGPU };
    }, o2.prototype.startTimer = function() {
      return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? this.gpgpu.beginQuery() : { startMs: Y(), endMs: null };
    }, o2.prototype.endTimer = function(t4) {
      return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (this.gpgpu.endQuery(), t4) : (t4.endMs = Y(), t4);
    }, o2.prototype.getQueryTime = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2;
        return r(this, function(n2) {
          return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t4)] : [2, (e2 = t4).endMs - e2.startMs];
        });
      });
    }, o2.prototype.disposeData = function(t4) {
      if (!this.pendingDisposal.has(t4)) {
        if (this.pendingRead.has(t4))
          return this.pendingDisposal.add(t4), void this.pendingDeletes++;
        if (this.texData.has(t4)) {
          this.releaseGPUData(t4);
          var e2 = this.texData.get(t4).complexTensors;
          null != e2 && (e2.real.dispose(), e2.imag.dispose()), this.texData.delete(t4);
        }
      }
    }, o2.prototype.releaseGPUData = function(t4) {
      var e2 = this.texData.get(t4), n2 = e2.texture, r2 = e2.dtype, o3 = e2.texShape, a2 = e2.usage, i2 = e2.isPacked, u2 = e2.slice, s2 = u2 && u2.origDataId || t4, c2 = this.dataRefCount.get(s2);
      c2 > 1 ? this.dataRefCount.set(s2, c2 - 1) : (this.dataRefCount.delete(s2), null != n2 && (this.numBytesInGPU -= this.computeBytes(o3, r2), this.textureManager.releaseTexture(n2, o3, a2, i2)));
      var l3 = this.texData.get(t4);
      l3.texture = null, l3.texShape = null, l3.isPacked = false, l3.slice = null;
    }, o2.prototype.getTexture = function(t4) {
      return this.uploadToGPU(t4), this.texData.get(t4).texture;
    }, o2.prototype.getDataInfo = function(t4) {
      return this.texData.get(t4);
    }, o2.prototype.getCPUBackend = function() {
      return a().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Nt.findBackend("cpu")), this.cpuBackend) : null;
    }, o2.prototype.shouldExecuteOnCPU = function(t4, e2) {
      var n2 = this;
      return void 0 === e2 && (e2 = 128), null != this.getCPUBackend() && t4.every(function(t5) {
        return null == n2.texData.get(t5.dataId).texture && t5.size < e2;
      });
    }, o2.prototype.getGPGPUContext = function() {
      return this.gpgpu;
    }, o2.prototype.complex = function(t4, e2) {
      var n2 = this.makeOutput(t4.shape, "complex64");
      return this.texData.get(n2.dataId).complexTensors = { real: Nt.keep(t4.clone()), imag: Nt.keep(e2.clone()) }, n2;
    }, o2.prototype.real = function(t4) {
      return this.texData.get(t4.dataId).complexTensors.real.clone();
    }, o2.prototype.imag = function(t4) {
      return this.texData.get(t4.dataId).complexTensors.imag.clone();
    }, o2.prototype.slice = function(t4, e2, n2) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.slice(t4, e2, n2);
      if (0 === w(n2))
        return kn([], n2, t4.dtype);
      var r2 = this.texData.get(t4.dataId).isPacked, o3 = Yr(t4.shape, e2, n2);
      if (r2 || !o3) {
        var i2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ji(n2) : new Yi(n2), u2 = i2.getCustomSetupFunc(e2);
        return this.compileAndRun(i2, [t4], null, u2);
      }
      return this.uploadToGPU(t4.dataId), this.shallowSlice(t4, e2, n2);
    }, o2.prototype.shallowSlice = function(t4, e2, n2) {
      var r2 = this.texData.get(t4.dataId), o3 = this.makeOutput(n2, t4.dtype), a2 = this.texData.get(o3.dataId);
      Object.assign(a2, r2), a2.shape = n2, a2.dtype = t4.dtype;
      var i2 = Qr(e2, t4.strides);
      r2.slice && (i2 += r2.slice.flatOffset), a2.slice = { flatOffset: i2, origDataId: r2.slice && r2.slice.origDataId || t4.dataId };
      var u2 = this.dataRefCount.get(a2.slice.origDataId) || 1;
      return this.dataRefCount.set(a2.slice.origDataId, u2 + 1), o3;
    }, o2.prototype.stridedSlice = function(t4, e2, n2, r2) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.stridedSlice(t4, e2, n2, r2);
      var o3 = jr(e2, n2, r2);
      if (o3.some(function(t5) {
        return 0 === t5;
      }))
        return kn([], o3);
      var a2 = new Zi(e2, r2, o3);
      return this.compileAndRun(a2, [t4]);
    }, o2.prototype.reverse = function(t4, e2) {
      var n2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ki(t4.shape, e2) : new qi(t4.shape, e2);
      return this.compileAndRun(n2, [t4]);
    }, o2.prototype.concat = function(t4, e2) {
      if ("complex64" === t4[0].dtype) {
        var n2 = t4.map(function(t5) {
          return Rn(t5);
        }), r2 = t4.map(function(t5) {
          return In(t5);
        });
        return En(this.concat(n2, e2), this.concat(r2, e2));
      }
      if (this.shouldExecuteOnCPU(t4))
        return this.cpuBackend.concat(t4, e2);
      if (1 === t4.length)
        return t4[0];
      if (t4.length > a().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
        var o3 = Math.floor(t4.length / 2), i2 = this.concat(t4.slice(0, o3), e2), u2 = this.concat(t4.slice(o3), e2);
        return this.concat([i2, u2], e2);
      }
      if (a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t4[0].rank > 1) {
        var s2 = new Sa(t4.map(function(t5) {
          return t5.shape;
        }), e2);
        return this.compileAndRun(s2, t4);
      }
      var c2 = wn(t4.map(function(t5) {
        return t5.shape;
      }), e2), l3 = t4.map(function(t5) {
        return t5.as2D(-1, w(t5.shape.slice(e2)));
      }), h = new ka(l3.map(function(t5) {
        return t5.shape;
      }));
      return this.compileAndRun(h, l3).reshape(c2);
    }, o2.prototype.neg = function(t4) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.neg(t4);
      if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
        return this.packedUnaryOp(t4, mu, t4.dtype);
      var e2 = new su(t4.shape, mu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.batchMatMul = function(t4, e2, n2, r2) {
      var o3 = n2 ? t4.shape[2] : t4.shape[1], a2 = r2 ? e2.shape[1] : e2.shape[2], i2 = n2 ? t4.shape[1] : t4.shape[2], u2 = t4.shape[0];
      if ((1 === o3 || 1 === a2) && i2 > 1e3) {
        n2 && (t4 = t4.transpose([0, 2, 1])), r2 && (e2 = e2.transpose([0, 2, 1]));
        var s2 = 1 === a2 ? t4 : t4.as3D(u2, i2, 1), c2 = 1 === a2 ? 2 : 1, l3 = 1 === a2 ? e2.as3D(u2, 1, i2) : e2;
        return this.multiply(s2, l3).sum(c2, true);
      }
      var h = Ct(t4.dtype, e2.dtype), f2 = new Ti(t4.shape, [u2, o3, a2], n2, r2);
      return this.compileAndRun(f2, [t4, e2], h);
    }, o2.prototype.fusedBatchMatMul = function(t4) {
      var e2 = t4.a, n2 = t4.b, r2 = t4.transposeA, o3 = t4.transposeB, a2 = t4.bias, i2 = t4.activation, u2 = t4.preluActivationWeights, s2 = r2 ? e2.shape[2] : e2.shape[1], c2 = o3 ? n2.shape[1] : n2.shape[2], l3 = e2.shape[0], h = Ct(e2.dtype, n2.dtype), f2 = null != a2, p2 = null != u2, d2 = i2 ? Pu(i2, true) : null, v2 = new Ti(e2.shape, [l3, s2, c2], r2, o3, f2, d2, p2), m2 = [e2, n2];
      return a2 && m2.push(a2), u2 && m2.push(u2), this.compileAndRun(v2, m2, h);
    }, o2.prototype.multiply = function(t4, e2) {
      if ("complex64" === t4.dtype) {
        var n2 = this.texData.get(t4.dataId), r2 = this.texData.get(e2.dataId), o3 = new va(pa, t4.shape, e2.shape), i2 = new va(da, t4.shape, e2.shape), u2 = [this.makeComplexComponentTensorInfo(t4, n2.complexTensors.real), this.makeComplexComponentTensorInfo(t4, n2.complexTensors.imag), this.makeComplexComponentTensorInfo(e2, r2.complexTensors.real), this.makeComplexComponentTensorInfo(e2, r2.complexTensors.imag)], s2 = this.compileAndRun(o3, u2), c2 = this.compileAndRun(i2, u2), l3 = this.complex(s2, c2);
        return s2.dispose(), c2.dispose(), l3;
      }
      if (this.shouldExecuteOnCPU([t4, e2]))
        return this.cpuBackend.multiply(t4, e2);
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, ya, t4.dtype);
      var h = new ba(ya, t4.shape, e2.shape);
      return this.compileAndRun(h, [t4, e2], t4.dtype);
    }, o2.prototype.batchNormalization = function(t4, e2, n2, r2, o3, i2) {
      var u2 = [t4, e2, n2], s2 = null;
      null != i2 && (s2 = i2.shape, u2.push(i2));
      var c2 = null;
      if (null != o3 && (c2 = o3.shape, u2.push(o3)), a().getBool("WEBGL_PACK_NORMALIZATION")) {
        var l3 = new fa(t4.shape, e2.shape, n2.shape, s2, c2, r2);
        return this.compileAndRun(l3, u2);
      }
      var h = new ha(t4.shape, e2.shape, n2.shape, s2, c2, r2);
      return this.compileAndRun(h, u2);
    }, o2.prototype.localResponseNormalization4D = function(t4, e2, n2, r2, o3) {
      var i2 = a().getBool("WEBGL_PACK_NORMALIZATION") ? new Si(t4.shape, e2, n2, r2, o3) : new Ii(t4.shape, e2, n2, r2, o3);
      return this.compileAndRun(i2, [t4]);
    }, o2.prototype.LRNGrad = function(t4, e2, n2, r2, o3, a2, i2) {
      var u2 = new ki(e2.shape, r2, o3, a2, i2);
      return this.compileAndRun(u2, [e2, n2, t4]);
    }, o2.prototype.tile = function(t4, e2) {
      if ("string" === t4.dtype) {
        var n2 = this.readSync(t4.dataId).map(function(t5) {
          return Z(t5);
        });
        return Lo(ur(t4.shape, t4.dtype, n2), e2);
      }
      var r2 = new ru(t4.shape, e2);
      return this.compileAndRun(r2, [t4]);
    }, o2.prototype.pad = function(t4, e2, n2) {
      var r2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Mi(t4.shape, e2, n2) : new _i(t4.shape, e2, n2);
      return this.compileAndRun(r2, [t4]);
    }, o2.prototype.transpose = function(t4, e2) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.transpose(t4, e2);
      var n2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new au(t4.shape, e2) : new ou(t4.shape, e2);
      return this.compileAndRun(n2, [t4]);
    }, o2.prototype.gather = function(t4, e2, n2) {
      if (this.shouldExecuteOnCPU([t4, e2]))
        return this.cpuBackend.gather(t4, e2, n2);
      var r2 = new ni(t4.shape, e2.size, n2);
      return this.compileAndRun(r2, [t4, e2]);
    }, o2.prototype.batchToSpaceND = function(t4, e2, n2) {
      g(t4.rank <= 4, function() {
        return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
      });
      var r2 = e2.reduce(function(t5, e3) {
        return t5 * e3;
      }), o3 = Mr(t4.shape, e2, r2), a2 = Br(o3.length, e2.length), i2 = Pr(t4.shape, e2, r2), u2 = Lr(n2, e2.length), s2 = Wr(i2, n2, e2.length);
      return t4.reshape(o3).transpose(a2).reshape(i2).slice(u2, s2);
    }, o2.prototype.spaceToBatchND = function(t4, e2, n2) {
      g(t4.rank <= 4, function() {
        return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
      });
      var r2 = e2.reduce(function(t5, e3) {
        return t5 * e3;
      }), o3 = [[0, 0]];
      o3.push.apply(o3, n2);
      for (var a2 = 1 + e2.length; a2 < t4.shape.length; ++a2)
        o3.push([0, 0]);
      var i2 = t4.pad(o3), u2 = Mr(i2.shape, e2, r2, false), s2 = Br(u2.length, e2.length, false), c2 = Pr(i2.shape, e2, r2, false);
      return i2.reshape(u2).transpose(s2).reshape(c2);
    }, o2.prototype.reduce = function(t4, e2, n2) {
      var r2 = t4.shape[0], o3 = t4.shape[1], a2 = zr(o3), i2 = new Li({ windowSize: a2, inSize: o3, batchSize: r2 }, e2), u2 = this.compileAndRun(i2, [t4], n2);
      return 1 === u2.shape[1] ? u2 : this.reduce(u2, e2, n2);
    }, o2.prototype.argReduce = function(t4, e2, n2) {
      void 0 === n2 && (n2 = null);
      var r2 = t4.shape[0], o3 = t4.shape[1];
      null != n2 && (r2 = n2.shape[0], o3 = n2.shape[1]);
      var a2 = zr(o3), i2 = new Go({ windowSize: a2, inSize: o3, batchSize: r2 }, e2, null == n2), u2 = [t4];
      null != n2 && u2.push(n2);
      var s2 = this.compileAndRun(i2, u2, "int32");
      return 1 === s2.shape[1] ? s2 : this.argReduce(t4, e2, s2);
    }, o2.prototype.argReducePacked = function(t4, e2, n2) {
      void 0 === n2 && (n2 = null);
      var r2 = null != n2 ? n2.shape : t4.shape, o3 = zr(r2[r2.length - 1]), a2 = new sa(r2, o3, e2, null == n2), i2 = null == n2 ? [t4] : [t4, n2], u2 = this.compileAndRun(a2, i2, "int32");
      return u2.rank === t4.rank ? this.argReducePacked(t4, e2, u2) : u2;
    }, o2.prototype.sum = function(t4, e2) {
      mn("sum", e2, t4.rank);
      var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t4.as2D(-1, o3), i2 = Et(t4.dtype);
      return this.reduce(a2, "sum", i2).reshape(r2);
    }, o2.prototype.prod = function(t4, e2) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.prod(t4, e2);
      var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t4.as2D(-1, o3), i2 = Et(t4.dtype);
      return this.reduce(a2, "prod", i2).reshape(r2);
    }, o2.prototype.unsortedSegmentSum = function(t4, e2, n2) {
      var r2 = 0, o3 = gn([r2], t4.rank), a2 = t4;
      null != o3 && (a2 = t4.transpose(o3), r2 = xn(1, t4.rank)[0]);
      var i2 = function(t5, e3, n3) {
        for (var r3 = [], o4 = t5.length, a3 = 0; a3 < o4; a3++)
          a3 !== e3 ? r3.push(t5[a3]) : r3.push(n3);
        return r3;
      }(a2.shape, r2, n2), u2 = w([a2.shape[r2]]), s2 = a2.as2D(-1, u2), c2 = Et(t4.dtype), l3 = this.segOpCompute(s2, "unsortedSegmentSum", e2, c2, n2).reshape(i2);
      return null != o3 && (l3 = l3.transpose(yn(o3))), l3;
    }, o2.prototype.segOpCompute = function(t4, e2, n2, r2, o3) {
      var a2 = t4.shape[0], i2 = t4.shape[1], u2 = function(t5, e3) {
        var n3, r3 = false;
        for (t5 <= Vr ? (n3 = t5, r3 = true) : n3 = H(t5, Math.floor(Math.sqrt(t5))); !r3; )
          n3 > e3 || n3 === t5 ? r3 = true : n3 = H(t5, n3 + 1);
        return n3;
      }(i2, o3), s2 = new Xi({ windowSize: u2, inSize: i2, batchSize: a2, numSegments: o3 }, e2), c2 = this.compileAndRun(s2, [t4, n2], r2);
      return c2.shape[1] === o3 ? c2 : (n2 = Un(0, o3).tile([i2 / u2]), this.segOpCompute(c2, e2, n2, r2, o3));
    }, o2.prototype.argMinMaxReduce = function(t4, e2, n2) {
      var r2 = [e2];
      if (mn("arg" + n2.charAt(0).toUpperCase() + n2.slice(1), r2, t4.rank), !a().getBool("WEBGL_PACK_REDUCE") || t4.rank <= 2) {
        var o3 = dn(t4.shape, r2), i2 = o3[0], u2 = w(o3[1]), s2 = t4.as2D(-1, u2);
        return this.argReduce(s2, n2).reshape(i2);
      }
      return this.argReducePacked(t4, n2);
    }, o2.prototype.argMin = function(t4, e2) {
      return this.argMinMaxReduce(t4, e2, "min");
    }, o2.prototype.argMax = function(t4, e2) {
      return this.argMinMaxReduce(t4, e2, "max");
    }, o2.prototype.cumsum = function(t4, e2, n2, r2) {
      if (e2 !== t4.rank - 1)
        throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t4.rank - 1) + " but got axis=" + e2);
      var o3 = new Ua(t4.shape, n2, r2);
      return this.compileAndRun(o3, [t4]);
    }, o2.prototype.equal = function(t4, e2) {
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, "\n  return vec4(equal(a, b));\n", "bool");
      var n2 = new ba("return float(a == b);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2], "bool");
    }, o2.prototype.notEqual = function(t4, e2) {
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, "\n  return vec4(notEqual(a, b));\n", "bool");
      var n2 = new ba("return float(a != b);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2], "bool");
    }, o2.prototype.less = function(t4, e2) {
      if (this.shouldExecuteOnCPU([t4, e2]))
        return this.cpuBackend.less(t4, e2);
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, "\n  return vec4(lessThan(a, b));\n", "bool");
      var n2 = new ba("return float(a < b);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2], "bool");
    }, o2.prototype.lessEqual = function(t4, e2) {
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
      var n2 = new ba("return float(a <= b);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2], "bool");
    }, o2.prototype.greater = function(t4, e2) {
      if (this.shouldExecuteOnCPU([t4, e2]))
        return this.cpuBackend.greater(t4, e2);
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, "\n  return vec4(greaterThan(a, b));\n", "bool");
      var n2 = new ba("return float(a > b);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2], "bool");
    }, o2.prototype.greaterEqual = function(t4, e2) {
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
      var n2 = new ba("return float(a >= b);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2], "bool");
    }, o2.prototype.logicalNot = function(t4) {
      var e2 = new su(t4.shape, "return float(!(x >= 1.0));");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.logicalAnd = function(t4, e2) {
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
      var n2 = new ba("return float(a >= 1.0 && b >= 1.0);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2], "bool");
    }, o2.prototype.logicalOr = function(t4, e2) {
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
      var n2 = new ba("return float(a >= 1.0 || b >= 1.0);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2], "bool");
    }, o2.prototype.select = function(t4, e2, n2) {
      var r2 = new $i(t4.rank, e2.shape, e2.rank);
      return this.compileAndRun(r2, [t4, e2, n2], Ct(e2.dtype, n2.dtype));
    }, o2.prototype.where = function(t4) {
      un("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
      var e2 = t4.dataSync();
      return Uo(t4.shape, e2);
    }, o2.prototype.topk = function(t4, e2, n2) {
      return Wo(t4.dataSync(), t4.shape, t4.dtype, e2);
    }, o2.prototype.min = function(t4, e2) {
      mn("min", e2, t4.rank);
      var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t4.as2D(-1, o3);
      return this.reduce(a2, "min", a2.dtype).reshape(r2);
    }, o2.prototype.minimum = function(t4, e2) {
      if (this.shouldExecuteOnCPU([t4, e2]))
        return this.cpuBackend.minimum(t4, e2);
      var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t4.shape, e2.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2]);
    }, o2.prototype.mod = function(t4, e2) {
      var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t4.shape, e2.shape) : new ba("if (b == 0.0) return NAN;\n  return mod(a, b);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2]);
    }, o2.prototype.max = function(t4, e2) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.max(t4, e2);
      mn("max", e2, t4.rank);
      var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t4.as2D(-1, o3);
      return this.reduce(a2, "max", a2.dtype).reshape(r2);
    }, o2.prototype.maximum = function(t4, e2) {
      if (this.shouldExecuteOnCPU([t4, e2]))
        return this.cpuBackend.maximum(t4, e2);
      var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t4.shape, e2.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2]);
    }, o2.prototype.all = function(t4, e2) {
      mn("all", e2, t4.rank);
      var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t4.as2D(-1, o3);
      return this.reduce(a2, "all", a2.dtype).reshape(r2);
    }, o2.prototype.any = function(t4, e2) {
      mn("any", e2, t4.rank);
      var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t4.as2D(-1, o3);
      return this.reduce(a2, "any", a2.dtype).reshape(r2);
    }, o2.prototype.squaredDifference = function(t4, e2) {
      var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("return (a - b) * (a - b);", t4.shape, e2.shape) : new ba("return (a - b) * (a - b);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2]);
    }, o2.prototype.realDivide = function(t4, e2) {
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
        return this.packedBinaryOp(t4, e2, "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", "float32", true);
      }
      var n2 = new ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2], "float32");
    }, o2.prototype.floorDiv = function(t4, e2) {
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
      var n2 = new ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2], "int32");
    }, o2.prototype.add = function(t4, e2) {
      if ("complex64" === t4.dtype && "complex64" === e2.dtype)
        return this.complexSeparableBinaryOp(t4, e2, ma);
      if (this.shouldExecuteOnCPU([t4, e2]))
        return this.cpuBackend.add(t4, e2);
      var n2 = Ct(t4.dtype, e2.dtype);
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, ma, n2);
      var r2 = new ba(ma, t4.shape, e2.shape);
      return this.compileAndRun(r2, [t4, e2], n2);
    }, o2.prototype.packedUnaryOp = function(t4, e2, n2) {
      var r2 = new _u(t4.shape, e2);
      return this.compileAndRun(r2, [t4], n2);
    }, o2.prototype.packedBinaryOp = function(t4, e2, n2, r2, o3) {
      void 0 === o3 && (o3 = false);
      var a2 = new Ca(n2, t4.shape, e2.shape, o3);
      return this.compileAndRun(a2, [t4, e2], r2);
    }, o2.prototype.complexSeparableBinaryOp = function(t4, e2, n2) {
      var r2 = this, o3 = this.texData.get(t4.dataId), a2 = this.texData.get(e2.dataId), i2 = [[o3.complexTensors.real, a2.complexTensors.real], [o3.complexTensors.imag, a2.complexTensors.imag]].map(function(o4) {
        var a3 = o4[0], i3 = o4[1], u3 = r2.makeComplexComponentTensorInfo(t4, a3), s3 = r2.makeComplexComponentTensorInfo(e2, i3), c3 = new ba(n2, t4.shape, e2.shape);
        return r2.compileAndRun(c3, [u3, s3], Ct(a3.dtype, i3.dtype));
      }), u2 = i2[0], s2 = i2[1], c2 = this.complex(u2, s2);
      return u2.dispose(), s2.dispose(), c2;
    }, o2.prototype.makeComplexComponentTensorInfo = function(t4, e2) {
      return { dataId: e2.dataId, dtype: e2.dtype, shape: t4.shape };
    }, o2.prototype.addN = function(t4) {
      if (1 === t4.length)
        return t4[0];
      if (t4.length > a().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
        var e2 = Math.floor(t4.length / 2), n2 = this.addN(t4.slice(0, e2)), r2 = this.addN(t4.slice(e2));
        return this.addN([n2, r2]);
      }
      var o3 = t4.map(function(t5) {
        return t5.dtype;
      }).reduce(function(t5, e3) {
        return Ct(t5, e3);
      }), i2 = t4.map(function(t5) {
        return t5.shape;
      }), u2 = a().getBool("WEBGL_PACK") ? new zo(t4[0].shape, i2) : new Vo(t4[0].shape, i2);
      return this.compileAndRun(u2, t4, o3);
    }, o2.prototype.subtract = function(t4, e2) {
      if ("complex64" === t4.dtype && "complex64" === e2.dtype)
        return this.complexSeparableBinaryOp(t4, e2, ga);
      if (this.shouldExecuteOnCPU([t4, e2]))
        return this.cpuBackend.subtract(t4, e2);
      var n2 = Ct(t4.dtype, e2.dtype);
      if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
        return this.packedBinaryOp(t4, e2, ga, t4.dtype);
      var r2 = new ba(ga, t4.shape, e2.shape);
      return this.compileAndRun(r2, [t4, e2], n2);
    }, o2.prototype.pow = function(t4, e2) {
      var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t4.shape, e2.shape) : new ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t4.shape, e2.shape), r2 = Ct(t4.dtype, e2.dtype);
      return this.compileAndRun(n2, [t4, e2], r2);
    }, o2.prototype.ceil = function(t4) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.ceil(t4);
      if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
        return this.packedUnaryOp(t4, gu, t4.dtype);
      var e2 = new su(t4.shape, gu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.floor = function(t4) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.floor(t4);
      if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
        return this.packedUnaryOp(t4, yu, t4.dtype);
      var e2 = new su(t4.shape, yu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.sign = function(t4) {
      var e2 = new su(t4.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.isNaN = function(t4) {
      var e2 = new su(t4.shape, "return float(isnan(x));");
      return this.compileAndRun(e2, [t4], "bool");
    }, o2.prototype.isInf = function(t4) {
      var e2 = new su(t4.shape, "return float(isinf(x));");
      return this.compileAndRun(e2, [t4], "bool");
    }, o2.prototype.isFinite = function(t4) {
      var e2 = new su(t4.shape, "return float(!isnan(x) && !isinf(x));");
      return this.compileAndRun(e2, [t4], "bool");
    }, o2.prototype.round = function(t4) {
      var e2 = new su(t4.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.exp = function(t4) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.exp(t4);
      if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
        return this.packedUnaryOp(t4, xu, t4.dtype);
      var e2 = new su(t4.shape, xu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.expm1 = function(t4) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.expm1(t4);
      if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
        return this.packedUnaryOp(t4, bu, t4.dtype);
      var e2 = new su(t4.shape, bu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.log = function(t4) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.log(t4);
      if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
        return this.packedUnaryOp(t4, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t4.dtype);
      var e2 = new su(t4.shape, "if (x < 0.0) return NAN;\n  return log(x);");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.log1p = function(t4) {
      var e2 = new su(t4.shape, "return log(1.0 + x);");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.sqrt = function(t4) {
      var e2 = new su(t4.shape, "return sqrt(x);");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.rsqrt = function(t4) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.rsqrt(t4);
      var e2 = new su(t4.shape, "return inversesqrt(x);");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.reciprocal = function(t4) {
      var e2 = new su(t4.shape, "return 1.0 / x;");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.relu = function(t4) {
      var e2;
      return e2 = a().getBool("WEBGL_PACK") ? new _u(t4.shape, Nu) : new su(t4.shape, fu), this.compileAndRun(e2, [t4]);
    }, o2.prototype.relu6 = function(t4) {
      var e2;
      return e2 = a().getBool("WEBGL_PACK") ? new _u(t4.shape, Fu) : new su(t4.shape, pu), this.compileAndRun(e2, [t4]);
    }, o2.prototype.prelu = function(t4, e2) {
      var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca(wa, t4.shape, e2.shape) : new ba(xa, t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2]);
    }, o2.prototype.elu = function(t4) {
      if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
        return this.packedUnaryOp(t4, Ou, t4.dtype);
      var e2 = new su(t4.shape, du);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.eluDer = function(t4, e2) {
      var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t4.shape, e2.shape) : new ba("return (b >= 1.0) ? a : a * (b + 1.0);", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2]);
    }, o2.prototype.selu = function(t4) {
      var e2 = new su(t4.shape, vu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.int = function(t4) {
      var e2 = new su(t4.shape, "return float(int(x));");
      return this.compileAndRun(e2, [t4], "int32");
    }, o2.prototype.clip = function(t4, e2, n2) {
      var r2, o3 = (r2 = a().getBool("WEBGL_PACK_CLIP") ? new Ra(t4.shape) : new Ea(t4.shape)).getCustomSetupFunc(e2, n2);
      return this.compileAndRun(r2, [t4], null, o3);
    }, o2.prototype.abs = function(t4) {
      if (this.shouldExecuteOnCPU([t4]))
        return this.cpuBackend.abs(t4);
      if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
        return this.packedUnaryOp(t4, hu, t4.dtype);
      var e2 = new su(t4.shape, hu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.complexAbs = function(t4) {
      var e2 = this.texData.get(t4.dataId), n2 = new Ia(t4.shape), r2 = [this.makeComplexComponentTensorInfo(t4, e2.complexTensors.real), this.makeComplexComponentTensorInfo(t4, e2.complexTensors.imag)];
      return this.compileAndRun(n2, r2);
    }, o2.prototype.sigmoid = function(t4) {
      var e2 = new su(t4.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.softplus = function(t4) {
      var e2 = new su(t4.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.sin = function(t4) {
      var e2 = new su(t4.shape, wu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.cos = function(t4) {
      var e2 = new su(t4.shape, Cu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.tan = function(t4) {
      var e2 = new su(t4.shape, "return tan(x);");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.asin = function(t4) {
      var e2 = new su(t4.shape, Eu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.acos = function(t4) {
      var e2 = new su(t4.shape, Ru);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.atan = function(t4) {
      var e2 = new su(t4.shape, Iu);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.atan2 = function(t4, e2) {
      var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t4.shape, e2.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t4.shape, e2.shape);
      return this.compileAndRun(n2, [t4, e2]);
    }, o2.prototype.sinh = function(t4) {
      var e2 = new su(t4.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.cosh = function(t4) {
      var e2 = new su(t4.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.tanh = function(t4) {
      var e2 = new su(t4.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.asinh = function(t4) {
      var e2 = new su(t4.shape, ku);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.acosh = function(t4) {
      var e2 = new su(t4.shape, Su);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.atanh = function(t4) {
      var e2 = new su(t4.shape, Au);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.erf = function(t4) {
      var e2 = new su(t4.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.step = function(t4, e2) {
      var n2 = new su(t4.shape, function(t5) {
        return void 0 === t5 && (t5 = 0), cu + "\n    return x > 0.0 ? 1.0 : float(" + t5 + ");\n  ";
      }(e2));
      return this.compileAndRun(n2, [t4]);
    }, o2.prototype.conv2dByMatMul = function(t4, e2, n2, r2, o3, i2) {
      var u2 = t4.shape, s2 = this.texData.get(t4.dataId), c2 = n2.inChannels, l3 = u2[0] * u2[1] * u2[2], h = n2.outChannels, f2 = "channelsLast" === n2.dataFormat, p2 = (1 === l3 || 1 === h) && c2 > 1e3, d2 = u2[2] % 2 != 0 && !!s2.isPacked;
      if (p2 || !a().getBool("WEBGL_LAZILY_UNPACK") || !a().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !d2) {
        var v2 = f2 ? u2[0] * u2[1] * u2[2] : u2[0] * u2[2] * u2[3], m2 = this.reshape(t4, [1, v2, n2.inChannels]), y2 = this.reshape(e2, [1, n2.inChannels, n2.outChannels]);
        return this.reshape(this.fusedBatchMatMul({ a: m2, b: y2, transposeA: false, transposeB: false, bias: r2, activation: o3, preluActivationWeights: i2 }), n2.outShape);
      }
      var x2 = f2 ? u2[0] * u2[1] * (u2[2] + 1) : u2[0] * u2[2] * (u2[3] + 1), b2 = { dataId: t4.dataId, shape: [1, x2, n2.inChannels], dtype: t4.dtype }, w2 = s2.shape;
      s2.shape = s2.shape.slice(), s2.shape[s2.shape.length - 2]++, g(Se(s2.shape, b2.shape), function() {
        return "packed reshape " + s2.shape + " to " + b2.shape + " isn't free";
      });
      var C3 = this.reshape(e2, [1, n2.inChannels, n2.outChannels]), E3 = this.fusedBatchMatMul({ a: b2, b: C3, transposeA: false, transposeB: false, bias: r2, activation: o3, preluActivationWeights: i2 }), R3 = this.texData.get(E3.dataId);
      return g(R3.isPacked, function() {
        return "batchMatMul result is expected to be packed";
      }), s2.shape = w2, R3.shape = n2.outShape, Nt.makeTensorFromDataId(E3.dataId, n2.outShape, E3.dtype);
    }, o2.prototype.conv2dWithIm2Row = function(t4, e2, n2, r2, o3, a2) {
      var i2 = n2.filterWidth, u2 = n2.filterHeight, s2 = n2.inChannels, c2 = n2.outWidth, l3 = n2.outHeight, h = "channelsLast" === n2.dataFormat, f2 = i2 * u2 * s2, p2 = l3 * c2, d2 = [f2, p2], v2 = t4.squeeze([0]), m2 = e2.reshape([1, f2, -1]), g2 = new Ri(d2, v2.shape, n2), y2 = this.compileAndRun(g2, [v2]).reshape([1, d2[0], d2[1]]), x2 = null != r2, b2 = null != a2, w2 = o3 ? Pu(o3, true) : null, C3 = new Ti(y2.shape, [1, p2, n2.outChannels], true, false, x2, w2, b2), E3 = [y2, m2];
      r2 && E3.push(r2), b2 && E3.push(a2);
      var R3 = this.compileAndRun(C3, E3);
      return h ? R3.reshape([1, l3, c2, n2.outChannels]) : R3.reshape([1, n2.outChannels, l3, c2]);
    }, o2.prototype.fusedConv2d = function(t4) {
      var e2 = t4.input, n2 = t4.filter, r2 = t4.convInfo, o3 = t4.bias, i2 = t4.activation, u2 = t4.preluActivationWeights;
      if (1 === r2.filterHeight && 1 === r2.filterWidth && 1 === r2.dilationHeight && 1 === r2.dilationWidth && 1 === r2.strideHeight && 1 === r2.strideWidth && ("SAME" === r2.padInfo.type || "VALID" === r2.padInfo.type))
        return this.conv2dByMatMul(e2, n2, r2, o3, i2, u2);
      if (a().getBool("WEBGL_CONV_IM2COL") && 1 === e2.shape[0])
        return this.conv2dWithIm2Row(e2, n2, r2, o3, i2, u2);
      var s2 = null != o3, c2 = null != u2, l3 = i2 ? Pu(i2, false) : null, h = new Ma(r2, s2, l3, c2), f2 = [e2, n2];
      return o3 && f2.push(o3), u2 && f2.push(u2), this.compileAndRun(h, f2);
    }, o2.prototype.conv2d = function(t4, e2, n2) {
      if (1 === n2.filterHeight && 1 === n2.filterWidth && 1 === n2.dilationHeight && 1 === n2.dilationWidth && 1 === n2.strideHeight && 1 === n2.strideWidth && ("SAME" === n2.padInfo.type || "VALID" === n2.padInfo.type))
        return this.conv2dByMatMul(t4, e2, n2);
      if (a().getBool("WEBGL_CONV_IM2COL") && 1 === t4.shape[0])
        return this.conv2dWithIm2Row(t4, e2, n2);
      var r2 = new Ma(n2);
      return this.compileAndRun(r2, [t4, e2]);
    }, o2.prototype.conv2dDerInput = function(t4, e2, n2) {
      var r2 = new Ta(n2);
      return this.compileAndRun(r2, [t4, e2]);
    }, o2.prototype.conv2dDerFilter = function(t4, e2, n2) {
      var r2 = new Da(n2);
      return this.compileAndRun(r2, [t4, e2]);
    }, o2.prototype.fusedDepthwiseConv2D = function(t4) {
      var e2, n2 = t4.input, r2 = t4.filter, o3 = t4.convInfo, i2 = t4.bias, u2 = t4.activation, s2 = t4.preluActivationWeights, c2 = a().getBool("WEBGL_PACK_DEPTHWISECONV") && o3.strideWidth <= 2 && o3.outChannels / o3.inChannels == 1, l3 = u2 ? Pu(u2, c2) : null, h = [n2, r2], f2 = null != i2, p2 = null != s2;
      return f2 && h.push(i2), p2 && h.push(s2), c2 ? (e2 = new La(o3, f2, l3, p2), this.compileAndRun(e2, h)) : (e2 = new Pa(o3, f2, l3, p2), this.compileAndRun(e2, h));
    }, o2.prototype.depthwiseConv2D = function(t4, e2, n2) {
      var r2;
      return a().getBool("WEBGL_PACK_DEPTHWISECONV") && n2.strideWidth <= 2 && n2.outChannels / n2.inChannels == 1 ? (r2 = new La(n2), this.compileAndRun(r2, [t4, e2])) : (r2 = new Pa(n2), this.compileAndRun(r2, [t4, e2]));
    }, o2.prototype.depthwiseConv2DDerInput = function(t4, e2, n2) {
      var r2 = new _a(n2);
      return this.compileAndRun(r2, [t4, e2]);
    }, o2.prototype.depthwiseConv2DDerFilter = function(t4, e2, n2) {
      var r2 = new Oa(n2);
      return this.compileAndRun(r2, [t4, e2]);
    }, o2.prototype.conv3d = function(t4, e2, n2) {
      var r2 = new Ba(n2);
      return this.compileAndRun(r2, [t4, e2]);
    }, o2.prototype.conv3dDerInput = function(t4, e2, n2) {
      var r2 = new Fa(n2);
      return this.compileAndRun(r2, [t4, e2]);
    }, o2.prototype.conv3dDerFilter = function(t4, e2, n2) {
      var r2 = new Na(n2);
      return this.compileAndRun(r2, [t4, e2]);
    }, o2.prototype.maxPool = function(t4, e2) {
      var n2 = new Bi(e2, "max", false);
      return this.compileAndRun(n2, [t4]);
    }, o2.prototype.avgPool = function(t4, e2) {
      var n2 = new Bi(e2, "avg", false);
      return this.compileAndRun(n2, [t4], "float32");
    }, o2.prototype.maxPoolBackprop = function(t4, e2, n2, r2) {
      var o3 = new Bi(r2, "max", true), a2 = this.compileAndRun(o3, [e2]), i2 = new Ai(r2), u2 = this.compileAndRun(i2, [t4, a2], e2.dtype);
      return a2.dispose(), u2;
    }, o2.prototype.avgPoolBackprop = function(t4, e2, n2) {
      var r2 = new ca(n2);
      return this.compileAndRun(r2, [t4], e2.dtype);
    }, o2.prototype.cast = function(t4, e2) {
      return So(t4, e2, this);
    }, o2.prototype.unstack = function(t4, e2) {
      for (var n2 = t4.shape[e2], r2 = new Array(t4.rank - 1), o3 = 0, a2 = 0; a2 < t4.rank; a2++)
        a2 !== e2 && (r2[o3++] = t4.shape[a2]);
      var i2 = new Array(t4.rank).fill(0), u2 = t4.shape.slice();
      u2[e2] = 1;
      var s2 = new Array(n2);
      for (a2 = 0; a2 < s2.length; a2++)
        i2[e2] = a2, s2[a2] = this.slice(t4, i2, u2).reshape(r2);
      return s2;
    }, o2.prototype.avgPool3d = function(t4, e2) {
      var n2 = new Pi(e2, "avg", false);
      return this.compileAndRun(n2, [t4], "float32");
    }, o2.prototype.avgPool3dBackprop = function(t4, e2, n2) {
      var r2 = new la(n2);
      return this.compileAndRun(r2, [t4], e2.dtype);
    }, o2.prototype.maxPool3d = function(t4, e2) {
      var n2 = new Pi(e2, "max", false);
      return this.compileAndRun(n2, [t4], "float32");
    }, o2.prototype.maxPool3dBackprop = function(t4, e2, n2, r2) {
      var o3 = new Pi(r2, "max", true), a2 = this.compileAndRun(o3, [e2]), i2 = new Di(r2), u2 = this.compileAndRun(i2, [t4, a2], e2.dtype);
      return a2.dispose(), u2;
    }, o2.prototype.reshape = function(t4, e2) {
      var n2 = this.texData.get(t4.dataId);
      if (n2.isPacked && !Se(t4.shape, e2) && (null === n2.texture || !Se(n2.shape, e2))) {
        var r2 = this.packedReshape(t4, e2);
        return Nt.makeTensorFromDataId(r2.dataId, r2.shape, r2.dtype);
      }
      return Ao(t4, e2);
    }, o2.prototype.resizeBilinear = function(t4, e2, n2, r2) {
      var o3 = a().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new zi(t4.shape, e2, n2, r2) : new Vi(t4.shape, e2, n2, r2);
      return this.compileAndRun(o3, [t4]);
    }, o2.prototype.resizeBilinearBackprop = function(t4, e2, n2) {
      var r2 = new Ui(t4, e2, n2);
      return this.compileAndRun(r2, [t4]);
    }, o2.prototype.resizeNearestNeighbor = function(t4, e2, n2, r2) {
      var o3 = new Hi(t4.shape, e2, n2, r2);
      return this.compileAndRun(o3, [t4]);
    }, o2.prototype.resizeNearestNeighborBackprop = function(t4, e2, n2) {
      var r2 = new Gi(t4, e2, n2);
      return this.compileAndRun(r2, [t4]);
    }, o2.prototype.multinomial = function(t4, e2, n2, r2) {
      var o3 = e2 ? t4 : io(t4), a2 = o3.shape[0], i2 = o3.shape[1], u2 = new Ni(a2, i2, n2), s2 = u2.getCustomSetupFunc(r2);
      return this.compileAndRun(u2, [o3], "int32", s2);
    }, o2.prototype.oneHot = function(t4, e2, n2, r2) {
      var o3 = new Fi(t4.size, e2, n2, r2);
      return this.compileAndRun(o3, [t4]);
    }, o2.prototype.diag = function(t4) {
      var e2 = new qa(t4.size);
      return this.compileAndRun(e2, [t4]);
    }, o2.prototype.nonMaxSuppression = function(t4, e2, n2, r2, o3) {
      return un("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), Mo(t4.dataSync(), e2.dataSync(), n2, r2, o3);
    }, o2.prototype.cropAndResize = function(t4, e2, n2, r2, o3, a2) {
      var i2 = new Wa(t4.shape, e2.shape, r2, o3, a2);
      return this.compileAndRun(i2, [t4, e2, n2]);
    }, o2.prototype.depthToSpace = function(t4, e2, n2) {
      g(e2 > 1, function() {
        return "blockSize should be > 1 for depthToSpace, but was: " + e2;
      });
      var r2 = t4.shape[0], o3 = "NHWC" === n2 ? t4.shape[1] : t4.shape[2], a2 = "NHWC" === n2 ? t4.shape[2] : t4.shape[3], i2 = "NHWC" === n2 ? t4.shape[3] : t4.shape[1], u2 = o3 * e2, s2 = a2 * e2, c2 = i2 / (e2 * e2), l3 = new Ha("NHWC" === n2 ? [r2, u2, s2, c2] : [r2, c2, u2, s2], e2, n2);
      return this.compileAndRun(l3, [t4]);
    }, o2.prototype.split = function(t4, e2, n2) {
      return Po(t4, e2, n2);
    }, o2.prototype.scatterND = function(t4, e2, n2) {
      var r2 = Hr(0, t4, n2), o3 = r2.sliceRank, a2 = r2.numUpdates, i2 = r2.sliceSize, u2 = r2.strides, s2 = r2.outputSize, c2 = [s2 / i2, i2], l3 = t4.reshape([a2, o3]), h = e2.reshape([a2, i2]);
      if (0 === s2)
        return Ao(kn([]), n2);
      var f2 = An(0), p2 = new ji(a2, o3, l3.rank, h.rank, u2, c2);
      return this.compileAndRun(p2, [h, l3, f2]).reshape(n2);
    }, o2.prototype.sparseToDense = function(t4, e2, n2, r2) {
      var o3 = Hr(0, t4, n2), a2 = o3.sliceRank, i2 = o3.numUpdates, u2 = o3.strides, s2 = o3.outputSize, c2 = new ji(i2, a2, t4.rank, e2.rank, u2, [s2, 1], false);
      return this.compileAndRun(c2, [e2, t4, r2]).reshape(n2);
    }, o2.prototype.fft = function(t4) {
      return this.fftImpl(t4, false);
    }, o2.prototype.ifft = function(t4) {
      return this.fftImpl(t4, true);
    }, o2.prototype.fftImpl = function(t4, e2) {
      var n2 = this.texData.get(t4.dataId), r2 = new Ja(Ya, t4.shape, e2), o3 = new Ja(Qa, t4.shape, e2), a2 = [this.makeComplexComponentTensorInfo(t4, n2.complexTensors.real), this.makeComplexComponentTensorInfo(t4, n2.complexTensors.imag)], i2 = this.compileAndRun(r2, a2), u2 = this.compileAndRun(o3, a2), s2 = this.complex(i2, u2).as2D(t4.shape[0], t4.shape[1]);
      return i2.dispose(), u2.dispose(), s2;
    }, o2.prototype.gatherND = function(t4, e2) {
      var n2 = e2.shape, r2 = n2[n2.length - 1], o3 = Ur(t4, e2), a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3], c2 = e2.reshape([i2, r2]), l3 = t4.reshape([t4.size / u2, u2]), h = new ri(r2, s2, [i2, u2]);
      return this.compileAndRun(h, [l3, c2]).reshape(a2);
    }, o2.prototype.fill = function(t4, e2, n2) {
      if ("string" === (n2 = n2 || z(e2))) {
        var r2 = F(n2, w(t4));
        return r2.fill(e2), Nt.makeTensor(r2, t4, n2, this);
      }
      var o3 = new Za(t4, e2), a2 = o3.getCustomSetupFunc(e2);
      return this.compileAndRun(o3, [], n2, a2);
    }, o2.prototype.onesLike = function(t4) {
      if ("string" === t4.dtype)
        throw new Error("onesLike is not supported under string dtype");
      return this.fill(t4.shape, 1, t4.dtype);
    }, o2.prototype.zerosLike = function(t4) {
      return this.fill(t4.shape, "string" === t4.dtype ? "" : 0, t4.dtype);
    }, o2.prototype.linspace = function(t4, e2, n2) {
      return Do(t4, e2, n2);
    }, o2.prototype.makeTensorInfo = function(t4, e2) {
      var n2 = this.write(null, t4, e2);
      return this.texData.get(n2).usage = null, { dataId: n2, shape: t4, dtype: e2 };
    }, o2.prototype.makeOutput = function(t4, e2) {
      var n2 = this.makeTensorInfo(t4, e2).dataId;
      return Nt.makeTensorFromDataId(n2, t4, e2, this);
    }, o2.prototype.unpackTensor = function(t4) {
      var e2 = new Mu(t4.shape);
      return this.runWebGLProgram(e2, [t4], t4.dtype);
    }, o2.prototype.packTensor = function(t4) {
      var e2 = new Oi(t4.shape);
      return this.runWebGLProgram(e2, [t4], t4.dtype, null, true);
    }, o2.prototype.packedReshape = function(t4, e2) {
      var n2 = [Ce(t4.shape)].concat(Ee(t4.shape)), r2 = { dtype: t4.dtype, shape: n2, dataId: t4.dataId }, o3 = [Ce(e2)].concat(Ee(e2)), a2 = new Wi(o3, n2), i2 = this.runWebGLProgram(a2, [r2], t4.dtype, null, true);
      return { dataId: i2.dataId, shape: e2, dtype: i2.dtype };
    }, o2.prototype.decode = function(t4) {
      var e2, n2 = this.texData.get(t4), r2 = n2.isPacked, o3 = n2.shape, a2 = n2.dtype, i2 = Re(o3);
      e2 = r2 ? new Ga(i2) : new za(i2);
      return { dtype: a2, shape: o3, dataId: this.runWebGLProgram(e2, [{ shape: i2, dtype: a2, dataId: t4 }], a2, null, true).dataId };
    }, o2.prototype.runWebGLProgram = function(t4, e2, n2, r2, o3) {
      var i2 = this;
      void 0 === o3 && (o3 = false);
      var u2 = this.makeTensorInfo(t4.outputShape, n2), s2 = this.texData.get(u2.dataId);
      if (t4.packedOutput && (s2.isPacked = true), t4.outPackingScheme === _t.DENSE) {
        var c2 = Gt(t4.outputShape);
        s2.texShape = c2.map(function(t5) {
          return 2 * t5;
        });
      }
      if (null != t4.outTexUsage && (s2.usage = t4.outTexUsage), 0 === w(u2.shape))
        return s2.values = N(u2.dtype, 0), u2;
      var l3 = [], h = e2.map(function(e3) {
        if ("complex64" === e3.dtype)
          throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
        var n3 = i2.texData.get(e3.dataId);
        if (null == n3.texture) {
          if (!t4.packedInputs && w(e3.shape) <= a().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))
            return { shape: e3.shape, texData: null, isUniform: true, uniformValues: n3.values };
          t4.packedInputs && (n3.isPacked = true, n3.shape = e3.shape);
        } else if (!!n3.isPacked != !!t4.packedInputs)
          e3 = n3.isPacked ? i2.unpackTensor(e3) : i2.packTensor(e3), l3.push(e3), n3 = i2.texData.get(e3.dataId);
        else if (n3.isPacked && !Se(n3.shape, e3.shape)) {
          var r3 = e3, o4 = e3.shape;
          e3.shape = n3.shape, e3 = i2.packedReshape(e3, o4), l3.push(e3), n3 = i2.texData.get(e3.dataId), r3.shape = o4;
        }
        return i2.uploadToGPU(e3.dataId), { shape: e3.shape, texData: n3, isUniform: false };
      });
      this.uploadToGPU(u2.dataId);
      var f2, p2 = { shape: u2.shape, texData: s2, isUniform: false }, d2 = function(t5, e3, n3) {
        var r3 = "";
        e3.concat(n3).forEach(function(t6) {
          var e4 = null != t6.texData && null != t6.texData.slice && t6.texData.slice.flatOffset > 0, n4 = t6.isUniform ? "uniform" : t6.texData.texShape;
          r3 += t6.shape + "_" + n4 + "_" + e4;
        });
        var o4 = t5.userCode, a2 = t5.constructor.name;
        return a2 += "_" + r3 + "_" + o4;
      }(t4, h, p2), v2 = this.getAndSaveBinary(d2, function() {
        return function(t5, e3, n3, r3) {
          var o4 = e3.userCode, i3 = n3.map(function(t6, n4) {
            var r4 = { logicalShape: t6.shape, texShape: t6.isUniform ? null : t6.texData.texShape, isUniform: t6.isUniform, isPacked: !t6.isUniform && t6.texData.isPacked, flatOffset: null };
            return null != t6.texData && null != t6.texData.slice && t6.texData.slice.flatOffset > 0 && (r4.flatOffset = t6.texData.slice.flatOffset), { name: e3.variableNames[n4], shapeInfo: r4 };
          }), u3 = i3.map(function(t6) {
            return t6.shapeInfo;
          }), s3 = { logicalShape: r3.shape, texShape: r3.texData.texShape, isUniform: false, isPacked: r3.texData.isPacked, flatOffset: null }, c3 = Yo(i3, s3, o4, e3.packedInputs), l4 = t5.createProgram(c3), h2 = null, f3 = t5.getUniformLocation(l4, "NAN", false);
          1 === a().getNumber("WEBGL_VERSION") && (h2 = t5.getUniformLocation(l4, "INFINITY", false));
          for (var p3 = {}, d3 = 0; d3 < e3.variableNames.length; d3++) {
            var v3 = e3.variableNames[d3];
            p3[v3] = t5.getUniformLocation(l4, v3, false), p3["offset" + v3] = t5.getUniformLocation(l4, "offset" + v3, false);
          }
          return { program: e3, source: c3, webGLProgram: l4, uniformLocations: p3, inShapeInfos: u3, outShapeInfo: s3, infLoc: h2, nanLoc: f3 };
        }(i2.gpgpu, t4, h, p2);
      }), m2 = null != this.activeTimers;
      if (m2 && (f2 = this.startTimer()), function(t5, e3, n3, r3, o4) {
        Ei(e3.inShapeInfos, n3), Ei([e3.outShapeInfo], [r3]);
        var i3 = r3.texData.texture, u3 = r3.texData.texShape;
        r3.texData.isPacked ? t5.setOutputPackedMatrixTexture(i3, u3[0], u3[1]) : t5.setOutputMatrixTexture(i3, u3[0], u3[1]), t5.setProgram(e3.webGLProgram), 1 === a().getNumber("WEBGL_VERSION") && null !== e3.infLoc && t5.gl.uniform1f(e3.infLoc, 1 / 0), null !== e3.nanLoc && t5.gl.uniform1f(e3.nanLoc, NaN), n3.forEach(function(n4, r4) {
          var o5 = e3.program.variableNames[r4], a2 = e3.uniformLocations[o5], i4 = e3.uniformLocations["offset" + o5];
          if (null != a2)
            if (n4.isUniform)
              if (w(n4.shape) < 2)
                t5.gl.uniform1f(a2, n4.uniformValues[0]);
              else {
                var u4 = n4.uniformValues;
                u4 instanceof Float32Array || (u4 = new Float32Array(u4)), t5.gl.uniform1fv(a2, u4);
              }
            else
              null != n4.texData.slice && null != i4 && t5.gl.uniform1i(i4, n4.texData.slice.flatOffset), t5.setInputMatrixTexture(n4.texData.texture, a2, r4);
        }), null != o4 && o4(t5, e3.webGLProgram), t5.executeProgram();
      }(this.gpgpu, v2, h, p2, r2), l3.forEach(function(t5) {
        return i2.disposeData(t5.dataId);
      }), m2 && (f2 = this.endTimer(f2), this.activeTimers.push({ name: t4.constructor.name, query: this.getQueryTime(f2) })), !a().getBool("WEBGL_LAZILY_UNPACK") && s2.isPacked && false === o3) {
        var g2 = this.unpackTensor(u2);
        return this.disposeData(u2.dataId), g2;
      }
      return u2;
    }, o2.prototype.compileAndRun = function(t4, e2, n2, r2, o3) {
      void 0 === o3 && (o3 = false), n2 = n2 || e2[0].dtype;
      var a2 = this.runWebGLProgram(t4, e2, n2, r2, o3);
      return Nt.makeTensorFromDataId(a2.dataId, a2.shape, a2.dtype);
    }, o2.prototype.getAndSaveBinary = function(t4, e2) {
      return t4 in this.binaryCache || (this.binaryCache[t4] = e2()), this.binaryCache[t4];
    }, o2.prototype.getTextureManager = function() {
      return this.textureManager;
    }, o2.prototype.dispose = function() {
      this.disposed || (this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, null != this.fromPixels2DContext && this.fromPixels2DContext.canvas.remove && this.fromPixels2DContext.canvas.remove(), this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true);
    }, o2.prototype.floatPrecision = function() {
      var t4 = this;
      return null == this.floatPrecisionValue && (this.floatPrecisionValue = je(function() {
        if (!a().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
          var e2 = a().getBool("DEBUG");
          a().set("DEBUG", false);
          var n2 = t4.abs(An(1e-8)).dataSync()[0];
          if (a().set("DEBUG", e2), n2 > 0)
            return 32;
        }
        return 16;
      })), this.floatPrecisionValue;
    }, o2.prototype.epsilon = function() {
      return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
    }, o2.prototype.uploadToGPU = function(t4) {
      var e2, n2 = this.texData.get(t4), r2 = n2.shape, o3 = n2.dtype, a2 = n2.values, i2 = n2.texture, u2 = n2.usage, s2 = n2.isPacked;
      if (null == i2) {
        var c2, l3 = null != this.activeTimers;
        l3 && (c2 = Y());
        var h = n2.texShape;
        if (null == h && (h = Ie(r2, s2), n2.texShape = h), null != a2) {
          var f2 = Re(r2), p2 = void 0, d2 = h[1], v2 = h[0], m2 = a2 instanceof Uint8Array;
          s2 ? (d2 = (e2 = Ht(h[0], h[1]))[0], v2 = e2[1], p2 = new $a(f2, [v2, d2], m2)) : p2 = new Xa(f2, [v2, d2], m2);
          var g2 = this.makeTensorInfo([v2, d2], o3);
          this.texData.get(g2.dataId).usage = m2 ? Mt.PIXELS : Mt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g2.dataId), d2, v2, a2);
          var y2 = this.runWebGLProgram(p2, [g2], o3, null, true), x2 = this.texData.get(y2.dataId);
          n2.texture = x2.texture, n2.texShape = x2.texShape, n2.isPacked = x2.isPacked, n2.usage = x2.usage, this.disposeData(g2.dataId), this.texData.delete(y2.dataId), n2.values = null, l3 && (this.uploadWaitMs += Y() - c2);
        } else {
          var b2 = this.acquireTexture(h, u2, o3, s2);
          n2.texture = b2;
        }
      }
    }, o2.prototype.convertAndCacheOnCPU = function(t4, e2) {
      var n2 = this.texData.get(t4), r2 = n2.dtype;
      return this.releaseGPUData(t4), null != e2 && (n2.values = function(t5, e3) {
        if ("float32" === e3 || "complex64" === e3)
          return t5;
        if ("int32" === e3 || "bool" === e3) {
          for (var n3 = "int32" === e3 ? new Int32Array(t5.length) : new Uint8Array(t5.length), r3 = 0; r3 < n3.length; ++r3)
            n3[r3] = Math.round(t5[r3]);
          return n3;
        }
        throw new Error("Unknown dtype " + e3);
      }(e2, r2)), n2.values;
    }, o2.prototype.acquireTexture = function(t4, e2, n2, r2) {
      if (this.numBytesInGPU += this.computeBytes(t4, n2), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
        var o3 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
        this.warnedAboutMemory = true, console.warn("High memory usage in GPU: " + o3 + " MB, most likely due to a memory leak");
      }
      return this.textureManager.acquireTexture(t4, e2, r2);
    }, o2.prototype.computeBytes = function(t4, e2) {
      return t4[0] * t4[1] * P(e2);
    }, o2;
  }(co);
  Ft() && Nt.registerBackend("webgl", function() {
    return new Wu();
  }, 2);
  var Uu = Cn({ square_: function(t3) {
    var e2 = ln(t3, "x", "square"), n2 = [e2];
    return Nt.runKernelFunc(function(t4, n3) {
      return n3([e2]), t4.square(e2);
    }, { x: e2 }, function(t4, e3) {
      var n3 = e3[0];
      return { x: function() {
        return t4.mul(n3.toFloat().mul(2));
      } };
    }, "Square", {}, n2, []);
  } });
  var Vu = Cn({ abs_: function(t3) {
    var e2 = ln(t3, "x", "abs");
    return "complex64" === e2.dtype ? Nt.runKernelFunc(function(t4) {
      return t4.complexAbs(e2);
    }, { $x: e2 }) : Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.abs(e2);
      return n2([e2]), r2;
    }, { x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { x: function() {
        return t4.mul(n2.toFloat().step(-1));
      } };
    }, "Abs");
  } });
  var zu = Cn({ acos_: function(t3) {
    var e2 = ln(t3, "x", "acos");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.acos(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.divStrict(An(1).sub(n2.toFloat().square()).sqrt()).neg();
      } };
    });
  } });
  var Gu = Cn({ acosh_: function(t3) {
    var e2 = ln(t3, "x", "acosh");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.acosh(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.divStrict(n2.toFloat().square().sub(1).sqrt());
      } };
    });
  } });
  var Hu = Cn({ asin_: function(t3) {
    var e2 = ln(t3, "x", "asin");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.asin(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.divStrict(An(1).sub(n2.toFloat().square()).sqrt());
      } };
    });
  } });
  var qu = Cn({ asinh_: function(t3) {
    var e2 = ln(t3, "x", "asinh");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.asinh(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.divStrict(An(1).add(n2.toFloat().square()).sqrt());
      } };
    });
  } });
  var Ku = Cn({ atan_: function(t3) {
    var e2 = ln(t3, "x", "atan");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.atan(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.div(n2.toFloat().square().add(1));
      } };
    });
  } });
  var ju = Cn({ atanh_: function(t3) {
    var e2 = ln(t3, "x", "atanh");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.atanh(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.div(An(1).sub(n2.toFloat().square()));
      } };
    });
  } });
  var Xu = Cn({ ceil_: function(t3) {
    var e2 = ln(t3, "x", "ceil");
    return Nt.runKernelFunc(function(t4) {
      return t4.ceil(e2);
    }, { $x: e2 }, function(t4) {
      return { $x: function() {
        return zn(t4);
      } };
    });
  } });
  var $u = Cn({ clipByValue_: function(t3, e2, n2) {
    var r2 = ln(t3, "x", "clipByValue");
    return g(e2 <= n2, function() {
      return "Error in clip: min (" + e2 + ") must be less than or equal to max (" + n2 + ").";
    }), Nt.runKernelFunc(function(t4, o2) {
      var a2 = t4.clip(r2, e2, n2);
      return o2([r2]), a2;
    }, { $x: r2 }, function(t4, r3) {
      var o2 = r3[0];
      return { $x: function() {
        return t4.where(o2.greaterEqual(e2).logicalAnd(o2.lessEqual(n2)), zn(t4));
      } };
    });
  } });
  var Yu = Cn({ cos_: function(t3) {
    var e2 = ln(t3, "x", "cos");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.cos(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return n2.toFloat().sin().neg().mul(t4);
      } };
    });
  } });
  var Qu = Cn({ cosh_: function(t3) {
    var e2 = ln(t3, "x", "cosh");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.cosh(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return n2.toFloat().sinh().mulStrict(t4);
      } };
    });
  } });
  var Ju = Cn({ erf_: function(t3) {
    var e2 = ln(t3, "x", "erf");
    return g("int32" === e2.dtype || "float32" === e2.dtype, function() {
      return "Input dtype must be `int32` or `float32`.";
    }), "int32" === e2.dtype && (e2 = e2.toFloat()), Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.erf(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.mul(n2.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
      } };
    });
  } });
  var Zu = Cn({ exp_: function(t3) {
    var e2 = ln(t3, "x", "exp");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.exp(e2);
      return n2([r2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      return { $x: function() {
        return t4.mulStrict(e3[0]);
      } };
    });
  } });
  var ts = Cn({ expm1_: function(t3) {
    var e2 = ln(t3, "x", "expm1");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.expm1(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.mul(n2.exp());
      } };
    });
  } });
  var es = Cn({ floor_: function(t3) {
    var e2 = ln(t3, "x", "floor");
    return Nt.runKernelFunc(function(t4) {
      return t4.floor(e2);
    }, { $x: e2 }, function(t4) {
      return { $x: function() {
        return zn(t4);
      } };
    });
  } });
  var ns = Cn({ log_: function(t3) {
    var e2 = ln(t3, "x", "log");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.log(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.div(n2.toFloat());
      } };
    });
  } });
  var rs = Cn({ log1p_: function(t3) {
    var e2 = ln(t3, "x", "log1p");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.log1p(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.div(n2.add(1));
      } };
    });
  } });
  var os = Cn({ logSigmoid_: function(t3) {
    var e2 = ln(t3, "x", "logSigmoid");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.softplus(e2.neg()).neg();
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.mul(n2.neg().sigmoid());
      } };
    });
  } });
  var as = Cn({ neg_: function(t3) {
    var e2 = ln(t3, "x", "neg");
    return Nt.runKernelFunc(function(t4) {
      return t4.neg(e2);
    }, { $x: e2 }, function(t4) {
      return { $x: function() {
        return t4.neg();
      } };
    });
  } });
  var is = Cn({ reciprocal_: function(t3) {
    var e2 = ln(t3, "x", "reciprocal");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.reciprocal(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.div(n2.square().neg());
      } };
    });
  } });
  var us = Cn({ round_: function(t3) {
    var e2 = ln(t3, "x", "round");
    return Nt.runKernelFunc(function(t4) {
      return t4.round(e2);
    }, { $x: e2 }, function(t4) {
      return { $x: function() {
        return zn(t4);
      } };
    });
  } });
  var ss = Cn({ rsqrt_: function(t3) {
    var e2 = ln(t3, "x", "rsqrt");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.rsqrt(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.div(n2.pow(1.5).mul(2)).neg();
      } };
    });
  } });
  var cs = Cn({ sigmoid_: function(t3) {
    var e2 = ln(t3, "x", "sigmoid");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.sigmoid(e2);
      return n2([r2]), r2;
    }, { x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { x: function() {
        return t4.mul(n2.mul(An(1).sub(n2)));
      } };
    }, "Sigmoid");
  } });
  var ls = Cn({ sign_: function(t3) {
    var e2 = ln(t3, "x", "sign");
    return Nt.runKernelFunc(function(t4) {
      return t4.sign(e2);
    }, { $x: e2 }, function(t4) {
      return { $x: function() {
        return zn(t4);
      } };
    });
  } });
  var hs = Cn({ isNaN_: function(t3) {
    var e2 = ln(t3, "x", "isNaN");
    return Nt.runKernelFunc(function(t4) {
      return t4.isNaN(e2);
    }, { $x: e2 }, function(t4) {
      return { $x: function() {
        return zn(t4);
      } };
    });
  } });
  var fs = Cn({ isInf_: function(t3) {
    var e2 = ln(t3, "x", "isInf");
    return Nt.runKernelFunc(function(t4) {
      return t4.isInf(e2);
    }, { $x: e2 }, function(t4) {
      return { $x: function() {
        return zn(t4);
      } };
    });
  } });
  var ps = Cn({ isFinite_: function(t3) {
    var e2 = ln(t3, "x", "isFinite");
    return Nt.runKernelFunc(function(t4) {
      return t4.isFinite(e2);
    }, { $x: e2 }, function(t4) {
      return { $x: function() {
        return zn(t4);
      } };
    });
  } });
  var ds = Cn({ sin_: function(t3) {
    var e2 = ln(t3, "x", "sin");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.sin(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return n2.toFloat().cos().mul(t4);
      } };
    });
  } });
  var vs = Cn({ sinh_: function(t3) {
    var e2 = ln(t3, "x", "sinh");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.sinh(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return n2.toFloat().cosh().mulStrict(t4);
      } };
    });
  } });
  var ms = Cn({ softplus_: function(t3) {
    var e2 = ln(t3, "x", "softplus");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.softplus(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.mul(n2.sigmoid());
      } };
    });
  } });
  var gs = Cn({ sqrt_: function(t3) {
    var e2 = ln(t3, "x", "sqrt");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.sqrt(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.div(n2.toFloat().sqrt().mul(2));
      } };
    });
  } });
  var ys = Cn({ step_: function(t3, e2) {
    void 0 === e2 && (e2 = 0);
    var n2 = ln(t3, "x", "step");
    return Nt.runKernelFunc(function(t4) {
      return t4.step(n2, e2);
    }, { $x: n2 }, function(t4) {
      return { $x: function() {
        return zn(t4);
      } };
    });
  } });
  var xs = Cn({ tan_: function(t3) {
    var e2 = ln(t3, "x", "tan");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.tan(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.div(n2.cos().square());
      } };
    });
  } });
  var bs = Cn({ tanh_: function(t3) {
    var e2 = ln(t3, "x", "tanh");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.tanh(e2);
      return n2([r2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return An(1).sub(n2.square()).mulStrict(t4);
      } };
    });
  } });
  function ws(t3, e2, n2, r2, o2, a2) {
    var i2, u2, s2 = ln(t3, "x", "batchNorm"), c2 = ln(e2, "mean", "batchNorm"), l3 = ln(n2, "variance", "batchNorm");
    return null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(2 === s2.rank, function() {
      return "Error in batchNorm3D: x must be rank 3 but got rank " + s2.rank + ".";
    }), g(2 === c2.rank || 1 === c2.rank, function() {
      return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c2.rank + ".";
    }), g(2 === l3.rank || 1 === l3.rank, function() {
      return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l3.rank + ".";
    }), null != i2 && g(2 === i2.rank || 1 === i2.rank, function() {
      return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + i2.rank + ".";
    }), null != u2 && g(2 === u2.rank || 1 === u2.rank, function() {
      return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + u2.rank + ".";
    }), Rs(s2, c2, l3, u2, i2, a2);
  }
  function Cs(t3, e2, n2, r2, o2, a2) {
    var i2, u2, s2 = ln(t3, "x", "batchNorm"), c2 = ln(e2, "mean", "batchNorm"), l3 = ln(n2, "variance", "batchNorm");
    return null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(3 === s2.rank, function() {
      return "Error in batchNorm3D: x must be rank 3 but got rank " + s2.rank + ".";
    }), g(3 === c2.rank || 1 === c2.rank, function() {
      return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c2.rank + ".";
    }), g(3 === l3.rank || 1 === l3.rank, function() {
      return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l3.rank + ".";
    }), null != i2 && g(3 === i2.rank || 1 === i2.rank, function() {
      return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + i2.rank + ".";
    }), null != u2 && g(3 === u2.rank || 1 === u2.rank, function() {
      return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + u2.rank + ".";
    }), Rs(s2, c2, l3, u2, i2, a2);
  }
  function Es(t3, e2, n2, r2, o2, a2) {
    var i2, u2, s2 = ln(t3, "x", "batchNorm"), c2 = ln(e2, "mean", "batchNorm"), l3 = ln(n2, "variance", "batchNorm");
    return null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(4 === s2.rank, function() {
      return "Error in batchNorm4D: x must be rank 4 but got rank " + s2.rank + ".";
    }), g(4 === c2.rank || 1 === c2.rank, function() {
      return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c2.rank + ".";
    }), g(4 === l3.rank || 1 === l3.rank, function() {
      return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l3.rank + ".";
    }), null != i2 && g(4 === i2.rank || 1 === i2.rank, function() {
      return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + i2.rank + ".";
    }), null != u2 && g(4 === u2.rank || 1 === u2.rank, function() {
      return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + u2.rank + ".";
    }), Rs(s2, c2, l3, u2, i2, a2);
  }
  function Rs(t3, e2, n2, r2, o2, a2) {
    null == a2 && (a2 = 1e-3);
    var i2, u2, s2, c2 = ln(t3, "x", "batchNorm"), l3 = ln(e2, "mean", "batchNorm"), h = ln(n2, "variance", "batchNorm");
    null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(l3.rank === h.rank, function() {
      return "Batch normalization gradient requires mean and variance to have equal ranks.";
    }), g(null == u2 || l3.rank === u2.rank, function() {
      return "Batch normalization gradient requires mean and offset to have equal ranks.";
    }), g(null == i2 || l3.rank === i2.rank, function() {
      return "Batch normalization gradient requires mean and scale to have equal ranks.";
    }), s2 = 0 === c2.rank || 1 === c2.rank ? c2.as4D(1, 1, 1, c2.size) : 2 === c2.rank ? c2.as4D(1, 1, c2.shape[0], c2.shape[1]) : 3 === c2.rank ? c2.as4D(1, c2.shape[0], c2.shape[1], c2.shape[2]) : c2;
    var f2 = [c2, l3, h, i2];
    return Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.batchNormalization(s2, Is(l3), Is(h), a2, Is(i2), Is(u2));
      return e3([c2, l3, h, i2]), n3;
    }, { x: c2, mean: l3, variance: h, scale: i2, offset: u2 }, function(t4, e3) {
      var n3 = e3, r3 = n3[0], o3 = n3[1], i3 = n3[2], u3 = n3[3], c3 = null == u3 ? An(1) : u3, l4 = fo(o3.shape, s2.shape), h2 = [];
      if (1 === o3.rank) {
        for (var f3 = 0; f3 < s2.shape.length - 1; ++f3)
          h2.push(s2.shape[f3]);
        h2.push(1);
      }
      var p2 = r3.sub(o3), d2 = t4.mul(c3), v2 = ss(i3.add(An(a2))), m2 = v2.mul(v2).mul(v2).mul(An(-0.5));
      return { x: function() {
        return 1 === o3.rank ? t4.mul(Nr(v2.as4D(1, 1, 1, o3.shape[0]), h2)).mul(c3).reshape(r3.shape) : t4.mul(v2).mul(c3).reshape(r3.shape);
      }, mean: function() {
        var t5 = v2.mul(An(-1)).mul(d2);
        return 1 === o3.rank && (t5 = t5.sum(l4)), t5.reshape(o3.shape);
      }, variance: function() {
        var t5 = m2.mul(p2).mul(d2);
        return 1 === o3.rank && (t5 = t5.sum(l4)), t5.reshape(o3.shape);
      }, scale: function() {
        var e4 = p2.mul(v2), n4 = t4.mul(e4);
        return 1 === o3.rank && (n4 = n4.sum(l4)), n4.reshape(o3.shape);
      }, offset: function() {
        var e4 = t4;
        return 1 === o3.rank && (e4 = e4.sum(l4)), e4.reshape(o3.shape);
      } };
    }, "BatchNormalization", { varianceEpsilon: a2 }, f2).reshape(c2.shape);
  }
  function Is(t3) {
    return null == t3 ? null : 0 === t3.rank ? t3.as1D() : 1 === t3.rank ? t3 : 2 === t3.rank ? t3.as4D(1, 1, t3.shape[0], t3.shape[1]) : 3 === t3.rank ? t3.as4D(1, t3.shape[0], t3.shape[1], t3.shape[2]) : t3;
  }
  function ks() {
    ze("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
  }
  var Ss = Cn({ batchNormalization2d_: function(t3, e2, n2, r2, o2, a2) {
    return void 0 === r2 && (r2 = 1e-3), ks(), ws(t3, e2, n2, a2, o2, r2);
  } });
  var As = Cn({ batchNormalization3d_: function(t3, e2, n2, r2, o2, a2) {
    return void 0 === r2 && (r2 = 1e-3), ks(), Cs(t3, e2, n2, a2, o2, r2);
  } });
  var Ds = Cn({ batchNormalization4d_: function(t3, e2, n2, r2, o2, a2) {
    return void 0 === r2 && (r2 = 1e-3), ks(), Es(t3, e2, n2, a2, o2, r2);
  } });
  var Ts = Cn({ batchNormalization_: function(t3, e2, n2, r2, o2, a2) {
    return void 0 === r2 && (r2 = 1e-3), ks(), Rs(t3, e2, n2, a2, o2, r2);
  } });
  var Ns = Cn({ batchNorm_: Rs });
  var Fs = Cn({ batchNorm2d_: ws });
  var Os = Cn({ batchNorm3d_: Cs });
  var _s = Cn({ batchNorm4d_: Es });
  var Ms = Cn({ logicalAnd_: function(t3, e2) {
    var n2 = ln(t3, "a", "logicalAnd", "bool"), r2 = ln(e2, "b", "logicalAnd", "bool");
    return po(n2.shape, r2.shape), Nt.runKernelFunc(function(t4) {
      return t4.logicalAnd(n2, r2);
    }, { $a: n2, $b: r2 });
  } });
  var Bs = Cn({ logicalNot_: function(t3) {
    var e2 = ln(t3, "x", "logicalNot", "bool");
    return Nt.runKernelFunc(function(t4) {
      return t4.logicalNot(e2);
    }, { $x: e2 });
  } });
  var Ps = Cn({ logicalOr_: function(t3, e2) {
    var n2 = ln(t3, "a", "logicalOr", "bool"), r2 = ln(e2, "b", "logicalOr", "bool");
    return po(n2.shape, r2.shape), Nt.runKernelFunc(function(t4) {
      return t4.logicalOr(n2, r2);
    }, { $a: n2, $b: r2 });
  } });
  var Ls = Cn({ logicalXor_: function(t3, e2) {
    var n2 = ln(t3, "a", "logicalXor", "bool"), r2 = ln(e2, "b", "logicalXor", "bool");
    return po(n2.shape, r2.shape), Ps(t3, e2).logicalAnd(Ms(t3, e2).logicalNot());
  } });
  var Ws = Cn({ where_: function(t3, e2, n2) {
    var r2 = ln(e2, "a", "where"), o2 = ln(n2, "b", "where"), a2 = ln(t3, "condition", "where", "bool");
    return y(r2.shape, o2.shape, "Error in where: "), 1 === a2.rank ? g(a2.shape[0] === r2.shape[0], function() {
      return "The first dimension of `a` must match the size of `condition`.";
    }) : y(a2.shape, o2.shape, "Error in where: "), Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.select(a2, r2, o2);
      return e3([a2]), n3;
    }, { $condition: a2, $a: r2, $b: o2 }, function(t4, e3) {
      var n3 = e3[0];
      return { $condition: function() {
        return zn(n3).toFloat();
      }, $a: function() {
        return t4.mul(n3.cast(t4.dtype));
      }, $b: function() {
        return t4.mul(n3.logicalNot().cast(t4.dtype));
      } };
    });
  } });
  var Us = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, (e2 = ln(t3, "condition", "whereAsync", "bool")).data()];
          case 1:
            return n2 = r2.sent(), o2 = Uo(e2.shape, n2), t3 !== e2 && e2.dispose(), [2, o2];
        }
      });
    });
  };
  var Vs = Cn({ add_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "add"), o2 = ln(e2, "b", "add");
    n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
    var a2 = po(r2.shape, o2.shape);
    return Nt.runKernelFunc(function(t4) {
      return t4.add(r2, o2);
    }, { a: r2, b: o2 }, function(t4) {
      return { a: function() {
        var e3 = t4, n3 = fo(r2.shape, a2);
        return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(r2.shape);
      }, b: function() {
        var e3 = t4, n3 = fo(o2.shape, a2);
        return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(o2.shape);
      } };
    }, "Add");
  } });
  var zs = Cn({ addN_: function(t3) {
    g(Array.isArray(t3), function() {
      return "The argument passed to tf.addN() must be a list of tensors";
    }), g(t3.length >= 1, function() {
      return "Must pass at least one tensor to tf.addN(), but got " + t3.length;
    });
    var e2 = t3.map(function(t4, e3) {
      return ln(t4, "tensors" + e3, "addN");
    }), n2 = e2[0];
    e2.forEach(function(t4) {
      if (t4.dtype !== n2.dtype)
        throw new Error("All tensors passed to tf.addN() must have the same dtype");
    }), e2.forEach(function(t4) {
      if (!C(t4.shape, n2.shape))
        throw new Error("All tensors passed to tf.addN() must have the same shape");
    });
    var r2 = e2;
    return Nt.runKernelFunc(function(t4) {
      return t4.addN(e2);
    }, r2, function(t4) {
      var n3 = {};
      return e2.forEach(function(e3, r3) {
        n3[r3] = function() {
          return t4.clone();
        };
      }), n3;
    });
  } });
  var Gs = Cn({ addStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "addStrict"), r2 = ln(e2, "b", "addStrict");
    return y(n2.shape, r2.shape, "Error in addStrict: "), n2.add(r2);
  } });
  var Hs = Cn({ atan2_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "atan2"), o2 = ln(e2, "b", "atan2");
    n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
    var a2 = po(r2.shape, o2.shape);
    return Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.atan2(r2, o2);
      return e3([r2, o2]), n3;
    }, { $a: r2, $b: o2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1];
      return { $a: function() {
        var e4 = Vs(n3.square(), r3.square()), o3 = t4.mul(r3.div(e4)), i2 = fo(n3.shape, a2);
        return i2.length > 0 && (o3 = o3.sum(i2)), o3.reshape(n3.shape);
      }, $b: function() {
        var e4 = Vs(n3.square(), r3.square()), o3 = as(t4.mul(n3.div(e4))), i2 = fo(r3.shape, a2);
        return i2.length > 0 && (o3 = o3.sum(i2)), o3.reshape(r3.shape);
      } };
    });
  } });
  var qs = Cn({ div_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "div"), o2 = ln(e2, "b", "div");
    if (n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], "int32" === r2.dtype && "int32" === o2.dtype)
      return js(r2, o2);
    var a2 = po(r2.shape, o2.shape);
    return Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.realDivide(r2, o2);
      return e3([r2, o2]), n3;
    }, { a: r2, b: o2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1];
      return { a: function() {
        var e4 = t4.div(r3.toFloat()), o3 = fo(n3.shape, a2);
        return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
      }, b: function() {
        var e4 = t4.mul(n3.toFloat()), o3 = fo(r3.shape, a2);
        o3.length > 0 && (e4 = e4.sum(o3).reshape(r3.shape));
        var i2 = r3.square();
        return e4.div(i2.toFloat()).neg();
      } };
    }, "Div");
  } });
  var Ks = Cn({ divStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "div"), r2 = ln(e2, "b", "div");
    return y(n2.shape, r2.shape, "Error in divideStrict: "), n2.div(r2);
  } });
  var js = Cn({ floorDiv_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "floorDiv"), o2 = ln(e2, "b", "floorDiv");
    n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
    var a2 = po(r2.shape, o2.shape);
    return Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.floorDiv(r2, o2);
      return e3([r2, o2]), n3;
    }, { $a: r2, $b: o2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1];
      return { $a: function() {
        var e4 = t4.div(r3.toFloat()), o3 = fo(n3.shape, a2);
        return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
      }, $b: function() {
        var e4 = t4.mul(n3.toFloat()), o3 = fo(r3.shape, a2);
        o3.length > 0 && (e4 = e4.sum(o3).reshape(r3.shape));
        var i2 = r3.square();
        return e4.div(i2.toFloat()).neg();
      } };
    });
  } });
  var Xs = Cn({ maximum_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "maximum"), o2 = ln(e2, "b", "maximum");
    return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], "bool" === r2.dtype && (r2 = r2.toInt(), o2 = o2.toInt()), po(r2.shape, o2.shape), Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.maximum(r2, o2);
      return e3([r2, o2]), n3;
    }, { $a: r2, $b: o2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1];
      return { $a: function() {
        return t4.mul(n3.greaterEqual(r3).toFloat());
      }, $b: function() {
        return t4.mul(n3.less(r3).toFloat());
      } };
    });
  } });
  var $s = Cn({ maximumStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "maximumStrict"), r2 = ln(e2, "b", "maximumStrict");
    return y(n2.shape, r2.shape, "Error in maximumStrict: "), n2.maximum(r2);
  } });
  var Ys = Cn({ minimum_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "minimum"), o2 = ln(e2, "b", "minimum");
    return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], "bool" === r2.dtype && (r2 = r2.toInt(), o2 = o2.toInt()), po(r2.shape, o2.shape), Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.minimum(r2, o2);
      return e3([r2, o2]), n3;
    }, { $a: r2, $b: o2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1];
      return { $a: function() {
        return t4.mul(n3.lessEqual(r3).toFloat());
      }, $b: function() {
        return t4.mul(n3.greater(r3).toFloat());
      } };
    });
  } });
  var Qs = Cn({ minimumStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "minimumStrict"), r2 = ln(e2, "b", "minimumStrict");
    return y(n2.shape, r2.shape, "Error in minimumStrict: "), n2.minimum(r2);
  } });
  var Js = Cn({ mod_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "mod"), o2 = ln(e2, "b", "mod");
    n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
    var a2 = po(r2.shape, o2.shape);
    return Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.mod(r2, o2);
      return e3([r2, o2]), n3;
    }, { $a: r2, $b: o2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1];
      return { $a: function() {
        var e4 = fo(n3.shape, a2);
        return e4.length > 0 ? t4.sum(e4).reshape(n3.shape) : t4;
      }, $b: function() {
        var e4 = t4.mul(n3.div(r3).floor().neg()), o3 = fo(r3.shape, a2);
        return o3.length > 0 ? e4.sum(o3).reshape(r3.shape) : e4;
      } };
    });
  } });
  var Zs = Cn({ modStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "modStrict"), r2 = ln(e2, "b", "modStrict");
    return y(n2.shape, r2.shape, "Error in modStrict: "), n2.mod(r2);
  } });
  var tc = Cn({ mul_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "mul"), o2 = ln(e2, "b", "mul");
    n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
    var a2 = po(r2.shape, o2.shape);
    return Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.multiply(r2, o2);
      return e3([r2, o2]), n3;
    }, { a: r2, b: o2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1];
      return { a: function() {
        var e4 = t4.mul(r3.toFloat()), o3 = fo(n3.shape, a2);
        return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
      }, b: function() {
        var e4 = t4.mul(n3.toFloat()), o3 = fo(r3.shape, a2);
        return o3.length > 0 ? e4.sum(o3).reshape(r3.shape) : e4;
      } };
    }, "Mul");
  } });
  var ec = Cn({ mulStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "mul"), r2 = ln(e2, "b", "mul");
    return y(n2.shape, r2.shape, "Error in multiplyStrict: "), n2.mul(r2);
  } });
  var nc = Cn({ pow_: function(t3, e2) {
    var n2 = ln(t3, "base", "pow"), r2 = ln(e2, "exp", "pow"), o2 = po(n2.shape, r2.shape);
    return t3 = n2.cast(Ct(n2.dtype, r2.dtype)), e2 = r2.cast(Ct(n2.dtype, r2.dtype)), Nt.runKernelFunc(function(t4, e3) {
      var o3 = t4.pow(n2, r2);
      return e3([n2, r2, o3]), o3;
    }, { $base: n2, $exp: r2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1], a2 = e3[2];
      return { $base: function() {
        var e4 = r3.toFloat(), a3 = t4.mul(e4.mul(n3.pow(e4.sub(An(1))))), i2 = fo(n3.shape, o2);
        return i2.length > 0 && (a3 = a3.sum(i2)), a3.reshape(n3.shape);
      }, $exp: function() {
        var e4 = n3.greater(0), i2 = n3.log().where(e4, zn(n3)), u2 = t4.mul(a2.mul(i2)), s2 = fo(r3.shape, o2);
        return s2.length > 0 && (u2 = u2.sum(s2)), u2.reshape(r3.shape);
      } };
    });
  } });
  var rc = Cn({ powStrict_: function(t3, e2) {
    return y(t3.shape, e2.shape, "Error in powStrict: "), t3.pow(e2);
  } });
  var oc = Cn({ squaredDifference_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "squaredDifference"), o2 = ln(e2, "b", "squaredDifference");
    return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.squaredDifference(r2, o2);
      return e3([r2, o2]), n3;
    }, { $a: r2, $b: o2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1], o3 = An(2);
      return { $a: function() {
        return t4.mul(n3.sub(r3).mul(o3));
      }, $b: function() {
        return t4.mul(r3.sub(n3).mul(o3));
      } };
    });
  } });
  var ac = Cn({ squaredDifferenceStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "squaredDifferenceStrict"), r2 = ln(e2, "b", "squaredDifferenceStrict");
    return y(n2.shape, r2.shape, "Error in squaredDifferenceStrict: "), n2.squaredDifference(r2);
  } });
  var ic = Cn({ sub_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "sub"), o2 = ln(e2, "b", "sub");
    n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
    var a2 = po(r2.shape, o2.shape);
    return Nt.runKernelFunc(function(t4) {
      return t4.subtract(r2, o2);
    }, { a: r2, b: o2 }, function(t4) {
      return { a: function() {
        var e3 = t4, n3 = fo(r2.shape, a2);
        return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(r2.shape);
      }, b: function() {
        var e3 = t4, n3 = fo(o2.shape, a2);
        return n3.length > 0 && (e3 = e3.sum(n3)), e3.neg().reshape(o2.shape);
      } };
    }, "Sub");
  } });
  var uc = Cn({ subStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "subStrict"), r2 = ln(e2, "b", "subStrict");
    return y(n2.shape, r2.shape, "Error in subStrict: "), n2.sub(r2);
  } });
  var sc = Cn({ equal_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "equal"), o2 = ln(e2, "b", "equal");
    return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t4) {
      return t4.equal(r2, o2);
    }, { $a: r2, $b: o2 });
  } });
  var cc = Cn({ equalStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "equalStrict"), r2 = ln(e2, "b", "equalStrict");
    return y(n2.shape, r2.shape, "Error in equalStrict: "), n2.equal(r2);
  } });
  var lc = Cn({ greater_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "greater"), o2 = ln(e2, "b", "greater");
    return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t4) {
      return t4.greater(r2, o2);
    }, { $a: r2, $b: o2 });
  } });
  var hc = Cn({ greaterEqual_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "greaterEqual"), o2 = ln(e2, "b", "greaterEqual");
    return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.greaterEqual(r2, o2);
      return e3([r2, o2]), n3;
    }, { $a: r2, $b: o2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1];
      return { $a: function() {
        return zn(n3);
      }, $b: function() {
        return zn(r3);
      } };
    });
  } });
  var fc = Cn({ greaterEqualStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "greaterEqualStrict"), r2 = ln(e2, "b", "greaterEqualStrict");
    return y(n2.shape, r2.shape, "Error in greaterEqualStrict: "), n2.greaterEqual(r2);
  } });
  var pc = Cn({ greaterStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "greaterStrict"), r2 = ln(e2, "b", "greaterStrict");
    return y(n2.shape, r2.shape, "Error in greaterStrict: "), n2.greater(r2);
  } });
  var dc = Cn({ less_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "less"), o2 = ln(e2, "b", "less");
    return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t4) {
      return t4.less(r2, o2);
    }, { $a: r2, $b: o2 });
  } });
  var vc = Cn({ lessEqual_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "lessEqual"), o2 = ln(e2, "b", "lessEqual");
    return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t4) {
      return t4.lessEqual(r2, o2);
    }, { $a: r2, $b: o2 });
  } });
  var mc = Cn({ lessEqualStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "lessEqualStrict"), r2 = ln(e2, "b", "lessEqualStrict");
    return y(n2.shape, r2.shape, "Error in lessEqualStrict: "), n2.lessEqual(r2);
  } });
  var gc = Cn({ lessStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "lessStrict"), r2 = ln(e2, "b", "lessStrict");
    return y(n2.shape, r2.shape, "Error in lessStrict: "), n2.less(r2);
  } });
  var yc = Cn({ notEqual_: function(t3, e2) {
    var n2, r2 = ln(t3, "a", "notEqual"), o2 = ln(e2, "b", "notEqual");
    return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t4) {
      return t4.notEqual(r2, o2);
    }, { $a: r2, $b: o2 });
  } });
  var xc = Cn({ notEqualStrict_: function(t3, e2) {
    var n2 = ln(t3, "a", "notEqualStrict"), r2 = ln(e2, "b", "notEqualStrict");
    return y(n2.shape, r2.shape, "Error in notEqualStrict: "), n2.notEqual(r2);
  } });
  function bc(t3, e2) {
    for (var n2 = [], r2 = t3; r2 < e2; ++r2)
      n2.push(r2);
    return n2;
  }
  function wc(t3) {
    for (var e2 = [], n2 = 0; n2 < t3.length; ++n2)
      for (var r2 = 0; r2 < t3[n2].length; ++r2)
        e2.push(t3[n2][r2]);
    return e2;
  }
  var Cc = Cn({ gather_: function(t3, e2, n2) {
    void 0 === n2 && (n2 = 0);
    var r2 = ln(t3, "x", "gather"), o2 = ln(e2, "indices", "gather", "int32");
    n2 = D(n2, r2.shape)[0];
    var a2 = function(t4, e3, n3) {
      for (var r3 = t4.shape[n3], o3 = [], a3 = 1, i2 = 1, u2 = 0; u2 < n3; u2++)
        o3.push(t4.shape[u2]), a3 *= t4.shape[u2];
      for (u2 = 0; u2 < e3.rank; u2++)
        o3.push(e3.shape[u2]);
      for (u2 = n3 + 1; u2 < t4.rank; u2++)
        o3.push(t4.shape[u2]), i2 *= t4.shape[u2];
      return { batchSize: a3, sliceSize: i2, dimSize: r3, outputShape: o3 };
    }(r2, o2, n2);
    return Nt.runKernelFunc(function(t4, e3) {
      var a3 = t4.gather(r2, o2.flatten(), n2);
      return e3([o2]), a3;
    }, { $x: r2 }, function(t4, e3) {
      var o3 = e3[0];
      return { $x: function() {
        var e4 = r2.shape, a3 = o3.size, i2 = e4.slice(0, n2), u2 = i2.length, s2 = e4.slice(n2, e4.length).slice(1), c2 = s2.length, l3 = bc(0, u2), h = bc(u2 + 1, u2 + 1 + c2), f2 = wc([i2, [a3], s2]), p2 = t4.reshape(f2), d2 = o3.reshape([a3]), v2 = wc([[u2], l3, h]), m2 = p2.transpose(v2), g2 = Ec(m2, d2, r2.shape[n2]), y2 = yn(v2);
        return g2 = g2.transpose(y2);
      } };
    }).reshape(a2.outputShape);
  } });
  var Ec = Cn({ unsortedSegmentSum_: function(t3, e2, n2) {
    var r2 = ln(t3, "x", "unsortedSegmentSum"), o2 = ln(e2, "segmentIds", "unsortedSegmentSum", "int32");
    return g(E(n2), function() {
      return "numSegments must be of dtype int";
    }), Nt.runKernelFunc(function(t4, e3) {
      var a2 = t4.unsortedSegmentSum(r2, o2, n2);
      return e3([o2]), a2;
    }, { $x: r2 }, function(t4, e3) {
      var n3 = e3[0];
      return { $x: function() {
        return function(t5, e4) {
          for (var n4 = Xs(e4, zn(e4)), r3 = Cc(t5, n4), o3 = hc(e4, An(0, "int32")), a2 = r3.rank - o3.rank, i2 = 0; i2 < a2; ++i2)
            o3 = dr(o3, i2 + 1);
          o3 = Ms(o3, Bn(r3.shape, "bool"));
          var u2 = zn(r3);
          return Ws(o3, r3, u2);
        }(t4, n3);
      } };
    });
  } });
  var Rc = function(t3, e2, o2) {
    return n(this, void 0, void 0, function() {
      var n2, a2, i2, u2, s2, c2, l3, h, f2, p2, d2, v2, m2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            for (n2 = ln(t3, "tensor", "boolMask"), a2 = ln(e2, "mask", "boolMask", "bool"), i2 = null == o2 ? 0 : o2, u2 = a2.rank, s2 = n2.shape, g(u2 > 0, function() {
              return "mask cannot be scalar";
            }), y(s2.slice(i2, i2 + u2), a2.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c2 = 1, l3 = i2; l3 < i2 + u2; l3++)
              c2 *= s2[l3];
            return h = s2.slice(0, i2).concat([c2], s2.slice(i2 + u2)), f2 = n2.reshape(h), p2 = a2.reshape([-1]), [4, Us(p2)];
          case 1:
            return d2 = r2.sent(), v2 = d2.squeeze([1]), m2 = Cc(f2, v2, i2), t3 !== n2 && n2.dispose(), e2 !== a2 && a2.dispose(), v2.dispose(), f2.dispose(), p2.dispose(), d2.dispose(), [2, m2];
        }
      });
    });
  };
  function Ic(t3, e2, n2, r2, o2, a2, i2) {
    void 0 === a2 && (a2 = "NHWC"), g(t3.length === e2.rank, function() {
      return "Length of inShape (" + t3.length + ") and rank of dy (" + e2.rank + ") must match";
    });
    var u2 = t3, s2 = e2, c2 = false;
    3 === e2.rank && (c2 = true, s2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2]), u2 = [1, t3[0], t3[1], t3[2]]), g(4 === u2.length, function() {
      return "Error in conv2dDerInput: inShape must be length 4, but got length " + u2.length + ".";
    }), g(4 === s2.rank, function() {
      return "Error in conv2dDerInput: dy must be rank 4, but got rank " + s2.rank;
    }), g(4 === n2.rank, function() {
      return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n2.rank;
    });
    var l3 = "NHWC" === a2 ? u2[3] : u2[1], h = "NHWC" === a2 ? s2.shape[3] : s2.shape[1];
    g(l3 === n2.shape[2], function() {
      return "Error in conv2dDerInput: depth of input (" + l3 + ") must match input depth for filter " + n2.shape[2] + ".";
    }), g(h === n2.shape[3], function() {
      return "Error in conv2dDerInput: depth of output (" + h + ") must match output depth for filter " + n2.shape[3] + ".";
    }), null != i2 && g(E(o2), function() {
      return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + o2 + ".";
    });
    var f2 = ko(a2), p2 = go(u2, n2.shape, r2, 1, o2, i2, false, f2), d2 = Nt.runKernelFunc(function(t4, e3) {
      var r3 = t4.conv2dDerInput(s2, n2, p2);
      return e3([n2, s2]), r3;
    }, { dy4D: s2, filter: n2 }, function(t4, e3) {
      var n3 = e3[0], u3 = e3[1];
      return { dy4D: function() {
        return Dc(t4, n3, r2, o2, a2, 1, i2);
      }, filter: function() {
        return Nc(t4, u3, n3.shape, r2, o2, a2, i2);
      } };
    });
    return c2 ? d2.as3D(d2.shape[1], d2.shape[2], d2.shape[3]) : d2;
  }
  function kc(t3) {
    var e2 = function(t4) {
      return "number" == typeof t4 ? [t4, t4, t4] : 2 === t4.length ? [t4[0], t4[1], 1] : t4;
    }(t3), n2 = e2[0], r2 = e2[1], o2 = e2[2];
    return 1 === n2 && 1 === r2 && 1 === o2;
  }
  function Sc(t3, e2, n2, r2, o2) {
    g(t3.length === e2.rank, function() {
      return "Length of inShape (" + t3.length + ") and rank of dy (" + e2.rank + ") must match";
    });
    var a2 = t3, i2 = e2, u2 = false;
    4 === e2.rank && (u2 = true, i2 = e2.as5D(1, e2.shape[0], e2.shape[1], e2.shape[2], e2.shape[3]), a2 = [1, t3[0], t3[1], t3[2], t3[3]]);
    var s2 = a2[4], c2 = i2.shape[4];
    g(5 === a2.length, function() {
      return "Error in conv3dDerInput: inShape must be length 5, but got length " + a2.length + ".";
    }), g(5 === i2.rank, function() {
      return "Error in conv3dDerInput: dy must be rank 5, but got rank " + i2.rank;
    }), g(5 === n2.rank, function() {
      return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n2.rank;
    }), g(s2 === n2.shape[3], function() {
      return "Error in conv3dDerInput: depth of input (" + s2 + ") must match input depth for filter " + n2.shape[3] + ".";
    }), g(c2 === n2.shape[4], function() {
      return "Error in conv3dDerInput: depth of output (" + c2 + ") must match output depth for filter " + n2.shape[4] + ".";
    });
    var l3 = yo(a2, n2.shape, r2, 1, o2), h = Nt.runKernelFunc(function(t4) {
      return t4.conv3dDerInput(i2, n2, l3);
    }, { dy5D: i2 });
    return u2 ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  }
  var Ac = Cn({ conv1d_: function(t3, e2, n2, r2, o2, a2, i2) {
    void 0 === o2 && (o2 = "NWC"), void 0 === a2 && (a2 = 1);
    var u2 = ln(t3, "x", "conv1d"), s2 = ln(e2, "filter", "conv1d"), c2 = u2, l3 = false;
    2 === u2.rank && (l3 = true, c2 = u2.as3D(1, u2.shape[0], u2.shape[1])), g(3 === c2.rank, function() {
      return "Error in conv1d: input must be rank 3, but got rank " + c2.rank + ".";
    }), g(3 === s2.rank, function() {
      return "Error in conv1d: filter must be rank 3, but got rank " + s2.rank + ".";
    }), null != i2 && g(E(r2), function() {
      return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
    }), g(c2.shape[2] === s2.shape[1], function() {
      return "Error in conv1d: depth of input (" + c2.shape[2] + ") must match input depth for filter " + s2.shape[1] + ".";
    }), g(Io(n2, a2), function() {
      return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n2 + " and dilation '" + a2 + "'";
    }), g("NWC" === o2, function() {
      return "Error in conv1d: got dataFormat of " + o2 + " but only NWC is currently supported.";
    });
    var h = s2.as4D(1, s2.shape[0], s2.shape[1], s2.shape[2]), f2 = c2.as4D(c2.shape[0], 1, c2.shape[1], c2.shape[2]), p2 = Dc(f2, h, [1, n2], r2, "NHWC", [1, a2], i2);
    return l3 ? p2.as2D(p2.shape[2], p2.shape[3]) : p2.as3D(p2.shape[0], p2.shape[2], p2.shape[3]);
  } });
  var Dc = Cn({ conv2d_: function(t3, e2, n2, r2, o2, a2, i2) {
    void 0 === o2 && (o2 = "NHWC"), void 0 === a2 && (a2 = [1, 1]);
    var u2 = ln(t3, "x", "conv2d"), s2 = ln(e2, "filter", "conv2d"), c2 = u2, l3 = false;
    3 === u2.rank && (l3 = true, c2 = u2.as4D(1, u2.shape[0], u2.shape[1], u2.shape[2])), g(4 === c2.rank, function() {
      return "Error in conv2d: input must be rank 4, but got rank " + c2.rank + ".";
    }), g(4 === s2.rank, function() {
      return "Error in conv2d: filter must be rank 4, but got rank " + s2.rank + ".";
    }), null != i2 && g(E(r2), function() {
      return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
    });
    var h = "NHWC" === o2 ? c2.shape[3] : c2.shape[1];
    g(h === s2.shape[2], function() {
      return "Error in conv2d: depth of input (" + h + ") must match input depth for filter " + s2.shape[2] + ".";
    }), g(Io(n2, a2), function() {
      return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
    });
    var f2 = ko(o2), p2 = go(c2.shape, s2.shape, n2, a2, r2, i2, false, f2), d2 = Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.conv2d(c2, s2, p2);
      return e3([s2, c2]), n3;
    }, { x: c2, $filter: s2 }, function(t4, e3) {
      var i3 = e3, u3 = i3[0], s3 = i3[1];
      return g(Ro(a2), function() {
        return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a2 + "'";
      }), { x: function() {
        return Fc(s3.shape, t4, u3, n2, r2, o2);
      }, $filter: function() {
        return Nc(s3, t4, u3.shape, n2, r2, o2);
      } };
    });
    return l3 ? d2.as3D(d2.shape[1], d2.shape[2], d2.shape[3]) : d2;
  } });
  var Tc = Cn({ conv3d_: function(t3, e2, n2, r2, o2, a2) {
    void 0 === o2 && (o2 = "NDHWC"), void 0 === a2 && (a2 = [1, 1, 1]);
    var i2 = ln(t3, "x", "conv3d"), u2 = ln(e2, "filter", "conv3d"), s2 = i2, c2 = false;
    4 === i2.rank && (c2 = true, s2 = i2.as5D(1, i2.shape[0], i2.shape[1], i2.shape[2], i2.shape[3])), g(5 === s2.rank, function() {
      return "Error in conv3d: input must be rank 5, but got rank " + s2.rank + ".";
    }), g(5 === u2.rank, function() {
      return "Error in conv3d: filter must be rank 5, but got rank " + u2.rank + ".";
    }), g(s2.shape[4] === u2.shape[3], function() {
      return "Error in conv3d: depth of input (" + s2.shape[4] + ") must match input depth for filter " + u2.shape[3] + ".";
    }), g(function(t4, e3) {
      return kc(t4) || kc(e3);
    }(n2, a2), function() {
      return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
    }), g("NDHWC" === o2, function() {
      return "Error in conv3d: got dataFormat of " + o2 + " but only NDHWC is currently supported.";
    });
    var l3 = yo(s2.shape, u2.shape, n2, a2, r2), h = Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.conv3d(s2, u2, l3);
      return e3([s2, u2]), n3;
    }, { x: s2, $filter: u2 }, function(t4, e3) {
      g(kc(a2), function() {
        return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a2 + "'";
      });
      var o3 = e3[0], i3 = e3[1];
      return { x: function() {
        return Sc(o3.shape, t4, i3, n2, r2);
      }, $filter: function() {
        return function(t5, e4, n3, r3, o4) {
          var a3 = t5;
          4 === t5.rank && (a3 = t5.as5D(1, t5.shape[0], t5.shape[1], t5.shape[2], t5.shape[3]));
          var i4 = e4;
          4 === i4.rank && (i4 = e4.as5D(1, e4.shape[0], e4.shape[1], e4.shape[2], e4.shape[3])), g(5 === a3.rank, function() {
            return "Error in conv3dDerFilter: input must be rank 5, but got shape " + a3.shape + ".";
          }), g(5 === i4.rank, function() {
            return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + i4.shape + ".";
          }), g(5 === n3.length, function() {
            return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n3 + ".";
          }), g(a3.shape[4] === n3[3], function() {
            return "Error in conv3dDerFilter: depth of input " + a3.shape[4] + ") must match input depth in filter (" + n3[3] + ".";
          }), g(i4.shape[4] === n3[4], function() {
            return "Error in conv3dDerFilter: depth of dy (" + i4.shape[4] + ") must match output depth for filter (" + n3[4] + ").";
          });
          var u3 = yo(a3.shape, n3, r3, 1, o4);
          return Nt.runKernelFunc(function(t6) {
            return t6.conv3dDerFilter(a3, i4, u3);
          }, { x5D: a3, dy5D: i4 });
        }(o3, t4, i3.shape, n2, r2);
      } };
    });
    return c2 ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  } });
  var Nc = Cn({ conv2dDerFilter_: function(t3, e2, n2, r2, o2, a2, i2) {
    void 0 === a2 && (a2 = "NHWC");
    var u2 = t3;
    3 === t3.rank && (u2 = t3.as4D(1, t3.shape[0], t3.shape[1], t3.shape[2]));
    var s2 = e2;
    3 === s2.rank && (s2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2])), g(4 === u2.rank, function() {
      return "Error in conv2dDerFilter: input must be rank 4, but got shape " + u2.shape + ".";
    }), g(4 === s2.rank, function() {
      return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + s2.shape + ".";
    }), g(4 === n2.length, function() {
      return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n2 + ".";
    });
    var c2 = "NHWC" === a2 ? u2.shape[3] : u2.shape[1], l3 = "NHWC" === a2 ? s2.shape[3] : s2.shape[1];
    g(c2 === n2[2], function() {
      return "Error in conv2dDerFilter: depth of input " + c2 + ") must match input depth in filter (" + n2[2] + ".";
    }), g(l3 === n2[3], function() {
      return "Error in conv2dDerFilter: depth of dy (" + l3 + ") must match output depth for filter (" + n2[3] + ").";
    }), null != i2 && g(E(o2), function() {
      return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + o2 + ".";
    });
    var h = ko(a2), f2 = go(u2.shape, n2, r2, 1, o2, i2, false, h);
    return Nt.runKernelFunc(function(t4) {
      return t4.conv2dDerFilter(u2, s2, f2);
    }, { x4D: u2, dy4D: s2 });
  } });
  var Fc = Cn({ conv2dDerInput_: Ic });
  var Oc = Cn({ depthwiseConv2d_: function(t3, e2, n2, r2, o2, a2, i2) {
    void 0 === o2 && (o2 = "NHWC"), void 0 === a2 && (a2 = [1, 1]);
    var u2 = ln(t3, "x", "depthwiseConv2d"), s2 = ln(e2, "filter", "depthwiseConv2d"), c2 = u2, l3 = false;
    3 === u2.rank && (l3 = true, c2 = u2.as4D(1, u2.shape[0], u2.shape[1], u2.shape[2])), g(4 === c2.rank, function() {
      return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c2.rank + ".";
    }), g(4 === s2.rank, function() {
      return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + s2.rank + ".";
    }), g(c2.shape[3] === s2.shape[2], function() {
      return "Error in depthwiseConv2d: number of input channels (" + c2.shape[3] + ") must match the inChannels dimension in filter " + s2.shape[2] + ".";
    }), null == a2 && (a2 = [1, 1]), g(Io(n2, a2), function() {
      return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
    }), null != i2 && g(E(r2), function() {
      return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
    });
    var h = go(c2.shape, s2.shape, n2, a2, r2, i2, true), f2 = Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.depthwiseConv2D(c2, s2, h);
      return e3([c2, s2]), n3;
    }, { x: c2, $filter: s2 }, function(t4, e3) {
      g(Ro(a2), function() {
        return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + a2 + "'";
      });
      var n3 = e3[0], r3 = e3[1];
      return { x: function() {
        return _c(n3.shape, t4, r3, h);
      }, $filter: function() {
        return Mc(n3, t4, r3.shape, h);
      } };
    });
    return l3 ? f2.as3D(f2.shape[1], f2.shape[2], f2.shape[3]) : f2;
  } });
  var _c = Cn({ depthwiseConv2dDerInput_: function(t3, e2, n2, r2) {
    var o2 = e2, a2 = false;
    3 === e2.rank && (a2 = true, o2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2]));
    var i2 = Nt.runKernelFunc(function(t4) {
      return t4.depthwiseConv2DDerInput(o2, n2, r2);
    }, { dy4D: o2 });
    return a2 ? i2.as3D(i2.shape[1], i2.shape[2], i2.shape[3]) : i2;
  } });
  var Mc = Cn({ depthwiseConv2dDerFilter_: function(t3, e2, n2, r2) {
    var o2 = t3;
    3 === t3.rank && (o2 = t3.as4D(1, t3.shape[0], t3.shape[1], t3.shape[2]));
    var a2 = e2;
    return 3 === a2.rank && (a2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2])), Nt.runKernelFunc(function(t4) {
      return t4.depthwiseConv2DDerFilter(o2, a2, r2);
    }, { x4D: o2, dy4D: a2 });
  } });
  var Bc = Cn({ separableConv2d_: function(t3, e2, n2, r2, o2, a2, i2) {
    void 0 === a2 && (a2 = [1, 1]), void 0 === i2 && (i2 = "NHWC");
    var u2 = ln(t3, "x", "separableConv2d"), s2 = ln(e2, "depthwiseFilter", "separableConv2d"), c2 = ln(n2, "pointwiseFilter", "separableConv2d"), l3 = u2, h = false;
    if (3 === u2.rank && (h = true, l3 = u2.as4D(1, u2.shape[0], u2.shape[1], u2.shape[2])), "NCHW" === i2)
      throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    g(4 === l3.rank, function() {
      return "Error in separableConv2d: input must be rank 4, but got rank " + l3.rank + ".";
    }), g(4 === s2.rank, function() {
      return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + s2.rank + ".";
    }), g(4 === c2.rank, function() {
      return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + s2.rank + ".";
    }), g(1 === c2.shape[0], function() {
      return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c2.shape[0] + ".";
    }), g(1 === c2.shape[1], function() {
      return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c2.shape[1] + ".";
    });
    var f2 = s2.shape[2], p2 = s2.shape[3];
    g(c2.shape[2] === f2 * p2, function() {
      return "Error in separableConv2d: the third dimension of pointwise filter must be " + f2 * p2 + ", but got " + c2.shape[2] + ".";
    });
    var d2 = Oc(l3, s2, r2, o2, i2, a2), v2 = Dc(d2, c2, 1, "valid", i2);
    return h ? v2.as3D(v2.shape[1], v2.shape[2], v2.shape[3]) : v2;
  } });
  var Pc = Cn({ conv2dTranspose_: function(t3, e2, n2, r2, o2, a2) {
    return Ic(n2, ln(t3, "x", "conv2dTranspose"), ln(e2, "filter", "conv2dTranspose"), r2, o2, "NHWC", a2);
  } });
  var Lc = Cn({ conv3dTranspose_: function(t3, e2, n2, r2, o2) {
    return Sc(n2, ln(t3, "x", "conv3dTranspose"), ln(e2, "filter", "conv3dTranspose"), r2, o2);
  } });
  var Wc = Cn({ matMul_: function(t3, e2, n2, r2) {
    var o2;
    void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false);
    var a2 = ln(t3, "a", "matMul"), i2 = ln(e2, "b", "matMul");
    o2 = Rt(a2, i2), a2 = o2[0], i2 = o2[1];
    var u2 = n2 ? a2.shape[a2.rank - 2] : a2.shape[a2.rank - 1], s2 = r2 ? i2.shape[i2.rank - 1] : i2.shape[i2.rank - 2], c2 = n2 ? a2.shape[a2.rank - 1] : a2.shape[a2.rank - 2], l3 = r2 ? i2.shape[i2.rank - 2] : i2.shape[i2.rank - 1], h = a2.shape.slice(0, -2), f2 = i2.shape.slice(0, -2), p2 = w(h), d2 = w(f2);
    g(a2.rank >= 2 && i2.rank >= 2 && a2.rank === i2.rank, function() {
      return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + a2.rank + " and " + i2.rank + ".";
    }), g(C(h, f2), function() {
      return "Error in matMul: outer dimensions (" + h + ") and (" + f2 + ") of Tensors with shapes " + a2.shape + " and " + i2.shape + " must match.";
    }), g(u2 === s2, function() {
      return "Error in matMul: inner shapes (" + u2 + ") and (" + s2 + ") of Tensors with shapes " + a2.shape + " and " + i2.shape + " and transposeA=" + n2 + " and transposeB=" + r2 + " must match.";
    });
    var v2 = a2.shape.slice(0, -2).concat([c2, l3]), m2 = n2 ? a2.as3D(p2, u2, c2) : a2.as3D(p2, c2, u2), y2 = r2 ? i2.as3D(d2, l3, s2) : i2.as3D(d2, s2, l3), x2 = { transposeA: n2, transposeB: r2 };
    return Nt.runKernelFunc(function(t4, e3) {
      var o3 = t4.batchMatMul(m2, y2, n2, r2);
      return e3([m2, y2]), o3;
    }, { a: m2, b: y2 }, function(t4, e3) {
      var o3 = e3, a3 = o3[0], i3 = o3[1];
      return n2 || r2 ? !n2 && r2 ? { a: function() {
        return t4.matMul(i3, false, false);
      }, b: function() {
        return t4.matMul(a3, true, false);
      } } : n2 && !r2 ? { a: function() {
        return i3.matMul(t4, false, true);
      }, b: function() {
        return a3.matMul(t4, false, false);
      } } : { a: function() {
        return i3.matMul(t4, true, true);
      }, b: function() {
        return t4.matMul(a3, true, true);
      } } : { a: function() {
        return t4.matMul(i3, false, true);
      }, b: function() {
        return a3.matMul(t4, true, false);
      } };
    }, "BatchMatMul", x2).reshape(v2);
  } });
  var Uc = Cn({ dot_: function(t3, e2) {
    var n2 = ln(t3, "t1", "dot"), r2 = ln(e2, "t2", "dot");
    g(!(1 !== n2.rank && 2 !== n2.rank || 1 !== r2.rank && 2 !== r2.rank), function() {
      return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n2.rank + " and " + r2.rank + ".";
    });
    var o2 = 1 === n2.rank ? n2.size : n2.shape[1], a2 = 1 === r2.rank ? r2.size : r2.shape[0];
    return g(o2 === a2, function() {
      return "Error in dot: inner dimensions of inputs must match, but got " + o2 + " and " + a2 + ".";
    }), 1 === n2.rank && 1 === r2.rank ? n2.as2D(1, -1).matMul(r2.as2D(-1, 1)).asScalar() : 1 === n2.rank && 2 === r2.rank ? n2.as2D(1, -1).matMul(r2.as2D(r2.shape[0], r2.shape[1])).as1D() : 2 === n2.rank && 1 === r2.rank ? n2.matMul(r2.as2D(-1, 1)).as1D() : n2.matMul(r2.as2D(r2.shape[0], r2.shape[1]));
  } });
  var Vc = Cn({ outerProduct_: function(t3, e2) {
    var n2 = ln(t3, "v1", "outerProduct"), r2 = ln(e2, "v2", "outerProduct");
    return g(1 === n2.rank && 1 === r2.rank, function() {
      return "Error in outerProduct: inputs must be rank 1, but got ranks " + n2.rank + " and " + r2.rank + ".";
    }), n2.as2D(-1, 1).matMul(r2.as2D(1, -1));
  } });
  var zc = Cn({ reverse_: function(t3, e2) {
    var n2 = ln(t3, "x", "reverse");
    if (0 === n2.rank)
      return n2.clone();
    var r2 = D(e2, n2.shape);
    return Nt.runKernelFunc(function(t4) {
      return t4.reverse(n2, r2);
    }, { $x: n2 }, function(t4) {
      return { $x: function() {
        return t4.reverse(r2);
      } };
    }).reshapeAs(n2);
  } });
  var Gc = Cn({ reverse1d_: function(t3) {
    var e2 = ln(t3, "x", "reverse");
    return g(1 === e2.rank, function() {
      return "Error in reverse1D: x must be rank 1 but got rank " + e2.rank + ".";
    }), zc(e2, 0);
  } });
  var Hc = Cn({ reverse2d_: function(t3, e2) {
    var n2 = ln(t3, "x", "reverse");
    return g(2 === n2.rank, function() {
      return "Error in reverse2D: x must be rank 2 but got rank " + n2.rank + ".";
    }), zc(n2, e2);
  } });
  var qc = Cn({ reverse3d_: function(t3, e2) {
    var n2 = ln(t3, "x", "reverse");
    return g(3 === n2.rank, function() {
      return "Error in reverse3D: x must be rank 3 but got rank " + n2.rank + ".";
    }), zc(n2, e2);
  } });
  var Kc = Cn({ reverse4d_: function(t3, e2) {
    var n2 = ln(t3, "x", "reverse");
    return g(4 === n2.rank, function() {
      return "Error in reverse4D: x must be rank 4 but got rank " + n2.rank + ".";
    }), zc(n2, e2);
  } });
  function jc(t3, e2, n2, r2, o2, a2) {
    var i2 = ln(t3, "x", "maxPool"), u2 = i2, s2 = false;
    3 === i2.rank && (s2 = true, u2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), null == r2 && (r2 = [1, 1]), g(4 === u2.rank, function() {
      return "Error in maxPool: input must be rank 4 but got rank " + u2.rank + ".";
    }), g(Io(n2, r2), function() {
      return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + r2 + "'";
    }), null != a2 && g(E(o2), function() {
      return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + a2 + " but got pad " + o2 + ".";
    });
    var c2 = vo(u2.shape, e2, n2, r2, o2, a2), l3 = Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.maxPool(u2, c2);
      return e3([u2, n3]), n3;
    }, { x: u2 }, function(t4, a3) {
      var i3 = a3[0], u3 = a3[1];
      return { x: function() {
        return function(t5, e3, n3, r3, o3, a4, i4, u4) {
          var s3 = ln(t5, "dy", "maxPoolBackprop"), c3 = ln(e3, "input", "maxPoolBackprop"), l4 = ln(n3, "output", "maxPoolBackprop");
          g(c3.rank === s3.rank, function() {
            return "Rank of input (" + c3.rank + ") does not match rank of dy (" + s3.rank + ")";
          }), null == a4 && (a4 = [1, 1]), g(Io(o3, a4), function() {
            return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + o3 + " and dilations '" + a4 + "'";
          }), g(4 === s3.rank, function() {
            return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + s3.rank + ".";
          }), g(4 === c3.rank, function() {
            return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c3.rank + ".";
          }), null != u4 && g(E(i4), function() {
            return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + u4 + " but got pad " + i4 + ".";
          });
          var h = vo(c3.shape, r3, o3, a4, i4, u4);
          return Nt.runKernelFunc(function(t6) {
            return t6.maxPoolBackprop(s3, c3, l4, h);
          }, { $dy: s3, $input: c3 });
        }(t4, i3, u3, e2, n2, r2, o2);
      } };
    });
    return s2 ? l3.as3D(l3.shape[1], l3.shape[2], l3.shape[3]) : l3;
  }
  function Xc(t3, e2, n2, r2, o2, a2) {
    var i2 = ln(t3, "x", "avgPool", "float32");
    null == r2 && (r2 = [1, 1]), g(Io(n2, r2), function() {
      return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + r2 + "'";
    });
    var u2 = i2, s2 = false;
    3 === i2.rank && (s2 = true, u2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), g(4 === u2.rank, function() {
      return "Error in avgPool: x must be rank 4 but got rank " + u2.rank + ".";
    }), null != a2 && g(E(o2), function() {
      return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + a2 + " but got pad " + o2 + ".";
    });
    var c2 = vo(u2.shape, e2, n2, r2, o2, a2), l3 = Nt.runKernelFunc(function(t4) {
      return t4.avgPool(u2, c2);
    }, { x: u2 }, function(t4) {
      return { x: function() {
        return function(t5, e3, n3, r3, o3, a3) {
          var i3 = ln(t5, "dy", "avgPoolBackprop"), u3 = ln(e3, "input", "avgPoolBackprop");
          g(u3.rank === i3.rank, function() {
            return "Rank of input (" + u3.rank + ") does not match rank of dy (" + i3.rank + ")";
          }), null == o3 && (o3 = [1, 1]), g(Io(r3, o3), function() {
            return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r3 + " and dilations '" + o3 + "'";
          });
          var s3 = u3, c3 = i3, l4 = false;
          3 === u3.rank && (l4 = true, s3 = u3.as4D(1, u3.shape[0], u3.shape[1], u3.shape[2]), c3 = i3.as4D(1, i3.shape[0], i3.shape[1], i3.shape[2])), g(4 === c3.rank, function() {
            return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c3.rank + ".";
          }), g(4 === s3.rank, function() {
            return "Error in avgPoolBackprop: input must be rank 4 but got rank " + s3.rank + ".";
          });
          var h = vo(s3.shape, n3, r3, o3, a3), f2 = Nt.runKernelFunc(function(t6) {
            return t6.avgPoolBackprop(c3, s3, h);
          }, { dy4D: c3, input4D: s3 });
          return l4 ? f2.as3D(f2.shape[1], f2.shape[2], f2.shape[3]) : f2;
        }(t4, u2, e2, n2, r2, o2);
      } };
    });
    return l3 = l3.cast(i2.dtype), s2 ? l3.as3D(l3.shape[1], l3.shape[2], l3.shape[3]) : l3;
  }
  var $c = Cn({ maxPool_: function(t3, e2, n2, r2, o2) {
    return jc(t3, e2, n2, 1, r2, o2);
  } });
  var Yc = Cn({ avgPool_: function(t3, e2, n2, r2, o2) {
    return Xc(t3, e2, n2, 1, r2, o2);
  } });
  var Qc = Cn({ pool_: function(t3, e2, n2, r2, o2, a2) {
    null == o2 && (o2 = [1, 1]), null == a2 && (a2 = 1), 0 === r2 && (r2 = "valid");
    var i2 = ln(t3, "x", "maxPool"), u2 = i2, s2 = false;
    3 === i2.rank && (s2 = true, u2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), g(Io(a2, o2), function() {
      return "Error in pool: Either strides or dilations must be 1. Got strides " + a2 + " and dilations '" + o2 + "'";
    });
    var c2, l3 = vo(u2.shape, e2, a2, o2, r2), h = [l3.dilationHeight, l3.dilationWidth];
    c2 = "same" === r2 ? function(t4, e3) {
      var n3 = t4.map(function(t5, n4) {
        return t5 + (t5 - 1) * (e3[n4] - 1);
      }).map(function(t5) {
        return t5 - 1;
      }), r3 = n3.map(function(t5) {
        return Math.floor(t5 / 2);
      }), o3 = n3.map(function(t5, e4) {
        return t5 - r3[e4];
      });
      return n3.map(function(t5, e4) {
        return [r3[e4], o3[e4]];
      });
    }([l3.filterHeight, l3.filterWidth], h) : [[0, 0], [0, 0]];
    var f2 = 1 === h[0] && 1 === h[1], p2 = function(t4, e3, n3) {
      var r3 = n3.map(function(t5) {
        return t5[0];
      }), o3 = n3.map(function(t5) {
        return t5[1];
      }), a3 = t4.concat(r3, o3), i3 = e3.map(function(t5, e4) {
        return (t5 - a3[e4] % t5) % t5;
      }), u3 = o3.map(function(t5, e4) {
        return t5 + i3[e4];
      }), s3 = e3.map(function(t5, e4) {
        return [r3[e4], u3[e4]];
      }), c3 = e3.map(function(t5, e4) {
        return [0, i3[e4]];
      });
      return [s3, c3];
    }([l3.inHeight, l3.inWidth], h, c2), d2 = p2[0], v2 = p2[1], m2 = f2 ? r2 : "valid", y2 = f2 ? u2 : Ar(u2, h, d2), x2 = ("avg" === n2 ? function() {
      return Xc(y2, e2, a2, 1, m2);
    } : function() {
      return jc(y2, e2, a2, 1, m2);
    })(), b2 = f2 ? x2 : cr(x2, h, v2);
    return s2 ? b2.as3D(b2.shape[1], b2.shape[2], b2.shape[3]) : b2;
  } });
  var Jc = Cn({ maxPool3d_: function(t3, e2, n2, r2, o2, a2, i2) {
    void 0 === a2 && (a2 = "NDHWC");
    var u2 = ln(t3, "x", "maxPool3d"), s2 = u2, c2 = false;
    4 === u2.rank && (c2 = true, s2 = u2.as5D(1, u2.shape[0], u2.shape[1], u2.shape[2], u2.shape[3])), null == i2 && (i2 = [1, 1, 1]), g(5 === s2.rank, function() {
      return "Error in maxPool3d: x must be rank 5 but got rank " + s2.rank + ".";
    }), g("NDHWC" === a2, function() {
      return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + a2;
    }), g(Io(n2, i2), function() {
      return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + i2 + "'";
    }), null != o2 && g(E(r2), function() {
      return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + o2 + " but got pad " + r2 + ".";
    });
    var l3 = mo(s2.shape, e2, n2, i2, r2, o2, a2), h = Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.maxPool3d(s2, l3);
      return e3([s2, n3]), n3;
    }, { x: s2 }, function(t4, a3) {
      var u3 = a3[0], s3 = a3[1];
      return { x: function() {
        return function(t5, e3, n3, r3, o3, a4, i3, u4) {
          var s4 = ln(t5, "dy", "maxPool3dBackprop"), c3 = ln(e3, "input", "maxPool3dBackprop"), l4 = ln(n3, "output", "maxPool3dBackprop"), h2 = s4, f2 = c3, p2 = l4, d2 = false;
          4 === c3.rank && (d2 = true, h2 = s4.as5D(1, s4.shape[0], s4.shape[1], s4.shape[2], s4.shape[3]), f2 = c3.as5D(1, c3.shape[0], c3.shape[1], c3.shape[2], c3.shape[3]), p2 = l4.as5D(1, l4.shape[0], l4.shape[1], l4.shape[2], l4.shape[3])), g(5 === h2.rank, function() {
            return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h2.rank + ".";
          }), g(5 === f2.rank, function() {
            return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + f2.rank + ".";
          }), g(5 === p2.rank, function() {
            return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + p2.rank + ".";
          }), null == a4 && (a4 = [1, 1, 1]), g(Io(o3, a4), function() {
            return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + o3 + " and dilations '" + a4 + "'";
          }), null != u4 && g(E(i3), function() {
            return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + u4 + " but got pad " + i3 + ".";
          });
          var v2 = mo(f2.shape, r3, o3, a4, i3, u4), m2 = Nt.runKernelFunc(function(t6) {
            return t6.maxPool3dBackprop(h2, f2, p2, v2);
          }, { dy5D: h2, input5D: f2 });
          return d2 ? m2.as4D(m2.shape[1], m2.shape[2], m2.shape[3], m2.shape[4]) : m2;
        }(t4, u3, s3, e2, n2, i2, r2, o2);
      } };
    });
    return c2 ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  } });
  var Zc = Cn({ avgPool3d_: function(t3, e2, n2, r2, o2, a2, i2) {
    void 0 === a2 && (a2 = "NDHWC");
    var u2 = ln(t3, "x", "avgPool3d", "float32"), s2 = u2, c2 = false;
    4 === u2.rank && (c2 = true, s2 = u2.as5D(1, u2.shape[0], u2.shape[1], u2.shape[2], u2.shape[3])), null == i2 && (i2 = [1, 1, 1]), g(5 === s2.rank, function() {
      return "Error in avgPool3d: x must be rank 5 but got rank " + s2.rank + ".";
    }), g("NDHWC" === a2, function() {
      return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + a2;
    }), g(Io(n2, i2), function() {
      return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + i2 + "'";
    }), null != o2 && g(E(r2), function() {
      return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + o2 + " but got pad " + r2 + ".";
    });
    var l3 = mo(s2.shape, e2, n2, i2, r2, o2, a2), h = Nt.runKernelFunc(function(t4) {
      return t4.avgPool3d(s2, l3);
    }, { x: s2 }, function(t4) {
      return { x: function() {
        return function(t5, e3, n3, r3, o3, a3, i3) {
          var u3 = ln(t5, "dy", "avgPool3dBackprop"), s3 = ln(e3, "input", "avgPool3dBackprop"), c3 = u3, l4 = s3, h2 = false;
          4 === s3.rank && (h2 = true, c3 = u3.as5D(1, u3.shape[0], u3.shape[1], u3.shape[2], u3.shape[3]), l4 = s3.as5D(1, s3.shape[0], s3.shape[1], s3.shape[2], s3.shape[3])), g(5 === c3.rank, function() {
            return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c3.rank + ".";
          }), g(5 === l4.rank, function() {
            return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l4.rank + ".";
          }), null == o3 && (o3 = [1, 1, 1]), g(Io(r3, o3), function() {
            return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r3 + " and dilations '" + o3 + "'";
          }), null != i3 && g(E(a3), function() {
            return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + i3 + " but got pad " + a3 + ".";
          });
          var f2 = mo(l4.shape, n3, r3, o3, a3, i3), p2 = Nt.runKernelFunc(function(t6) {
            return t6.avgPool3dBackprop(c3, l4, f2);
          }, { dy5D: c3, input5D: l4 });
          return h2 ? p2.as4D(p2.shape[1], p2.shape[2], p2.shape[3], p2.shape[4]) : p2;
        }(t4, s2, e2, n2, i2, r2, o2);
      } };
    });
    return h = h.cast(s2.dtype), c2 ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  } });
  var tl = Cn({ slice_: function(t3, e2, n2) {
    var r2, o2, a2 = ln(t3, "x", "slice");
    if (0 === a2.rank)
      throw new Error("Slicing scalar is not possible");
    (r2 = "number" == typeof e2 ? [e2].concat(new Array(a2.rank - 1).fill(0)) : e2.length < a2.rank ? e2.concat(new Array(a2.rank - e2.length).fill(0)) : e2.slice()).forEach(function(t4) {
      g(-1 !== t4, function() {
        return "slice() does not support negative begin indexing.";
      });
    }), o2 = (o2 = null == n2 ? new Array(a2.rank).fill(-1) : "number" == typeof n2 ? [n2].concat(new Array(a2.rank - 1).fill(-1)) : n2.length < a2.rank ? n2.concat(new Array(a2.rank - n2.length).fill(-1)) : n2).map(function(t4, e3) {
      return t4 >= 0 ? t4 : (g(-1 === t4, function() {
        return "Negative size values should be exactly -1 but got " + t4 + " for the slice() size at index " + e3 + ".";
      }), a2.shape[e3] - r2[e3]);
    }), qr(a2, r2, o2);
    var i2 = a2.shape, u2 = { begin: r2, size: o2 };
    return Nt.runKernelFunc(function(t4) {
      return t4.slice(a2, r2, o2);
    }, { x: a2 }, function(t4) {
      for (var e3 = [], n3 = 0; n3 < t4.rank; n3++)
        e3.push([r2[n3], i2[n3] - r2[n3] - o2[n3]]);
      return { x: function() {
        return t4.pad(e3);
      } };
    }, "Slice", u2);
  } });
  var el = Cn({ slice1d_: function(t3, e2, n2) {
    var r2 = ln(t3, "x", "slice1d");
    return g(1 === r2.rank, function() {
      return "slice1d expects a rank-1 tensor, but got a rank-" + r2.rank + " tensor";
    }), tl(r2, [e2], [n2]);
  } });
  var nl = Cn({ slice2d_: function(t3, e2, n2) {
    var r2 = ln(t3, "x", "slice2d");
    return g(2 === r2.rank, function() {
      return "slice2d expects a rank-2 tensor, but got a rank-" + r2.rank + " tensor";
    }), tl(r2, e2, n2);
  } });
  var rl = Cn({ slice3d_: function(t3, e2, n2) {
    var r2 = ln(t3, "x", "slice3d");
    return g(3 === r2.rank, function() {
      return "slice3d expects a rank-3 tensor, but got a rank-" + r2.rank + " tensor";
    }), tl(r2, e2, n2);
  } });
  var ol = Cn({ slice4d_: function(t3, e2, n2) {
    var r2 = ln(t3, "x", "slice4d");
    return g(4 === r2.rank, function() {
      return "slice4d expects a rank-4 tensor, but got a rank-" + r2.rank + " tensor";
    }), tl(r2, e2, n2);
  } });
  function al(t3, e2, n2, r2, o2) {
    return e2.rank < n2.rank && (e2 = e2.reshape(vn(e2.shape, r2))), t3.rank < n2.rank && (t3 = t3.reshape(vn(t3.shape, r2))), { $x: function() {
      var r3 = t3.mul(n2.equal(e2).cast(t3.dtype));
      return null == o2 ? r3 : r3.transpose(o2);
    } };
  }
  var il = Cn({ all_: function(t3, e2, n2) {
    void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
    var r2 = ln(t3, "x", "all", "bool"), o2 = D(e2, r2.shape), a2 = o2, i2 = gn(a2, r2.rank);
    null != i2 && (r2 = r2.transpose(i2), a2 = xn(a2.length, r2.rank));
    var u2 = Nt.runKernelFunc(function(t4) {
      return t4.all(r2, a2);
    }, { $x: r2 });
    if (n2) {
      var s2 = vn(u2.shape, o2);
      return u2.reshape(s2);
    }
    return u2;
  } });
  var ul = Cn({ any_: function(t3, e2, n2) {
    void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
    var r2 = ln(t3, "x", "any", "bool"), o2 = D(e2, r2.shape), a2 = o2, i2 = gn(a2, r2.rank);
    null != i2 && (r2 = r2.transpose(i2), a2 = xn(a2.length, r2.rank));
    var u2 = Nt.runKernelFunc(function(t4) {
      return t4.any(r2, a2);
    }, { $x: r2 });
    if (n2) {
      var s2 = vn(u2.shape, o2);
      return u2.reshape(s2);
    }
    return u2;
  } });
  var sl = Cn({ argMax_: function(t3, e2) {
    void 0 === e2 && (e2 = 0);
    var n2 = ln(t3, "x", "argMax");
    null == e2 && (e2 = 0);
    var r2 = D(e2, n2.shape), o2 = gn(r2, n2.rank);
    return null != o2 && (n2 = n2.transpose(o2), r2 = xn(r2.length, n2.rank)), Nt.runKernelFunc(function(t4, e3) {
      var o3 = t4.argMax(n2, r2[0]);
      return e3([n2]), o3;
    }, { $x: n2 }, function(t4, e3) {
      var n3 = e3[0];
      return { $x: function() {
        return zn(n3);
      } };
    });
  } });
  var cl = Cn({ argMin_: function(t3, e2) {
    void 0 === e2 && (e2 = 0);
    var n2 = ln(t3, "x", "argMin");
    null == e2 && (e2 = 0);
    var r2 = D(e2, n2.shape), o2 = gn(r2, n2.rank);
    return null != o2 && (n2 = n2.transpose(o2), r2 = xn(r2.length, n2.rank)), Nt.runKernelFunc(function(t4, e3) {
      var o3 = t4.argMin(n2, r2[0]);
      return e3([n2]), o3;
    }, { $x: n2 }, function(t4, e3) {
      var n3 = e3[0];
      return { $x: function() {
        return zn(n3);
      } };
    });
  } });
  var ll = Cn({ logSumExp_: function(t3, e2, n2) {
    void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
    var r2 = ln(t3, "x", "logSumExp"), o2 = D(e2, r2.shape), a2 = r2.max(o2, true), i2 = r2.sub(a2).exp().sum(o2).log(), u2 = a2.reshape(i2.shape).add(i2);
    if (n2) {
      var s2 = vn(u2.shape, o2);
      return u2.reshape(s2);
    }
    return u2;
  } });
  var hl = Cn({ max_: function(t3, e2, n2) {
    void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
    var r2 = ln(t3, "x", "max"), o2 = r2, a2 = D(e2, r2.shape), i2 = a2, u2 = gn(i2, r2.rank);
    null != u2 && (r2 = r2.transpose(u2), i2 = xn(i2.length, r2.rank));
    var s2 = Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.max(r2, i2);
      return e3([o2, n3]), n3;
    }, { $x: r2 }, function(t4, e3) {
      return al(t4, e3[1], e3[0], a2, u2);
    });
    if (n2) {
      var c2 = vn(s2.shape, a2);
      s2 = s2.reshape(c2);
    }
    return s2;
  } });
  var fl = Cn({ mean_: function(t3, e2, n2) {
    void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
    var r2 = ln(t3, "x", "mean"), o2 = D(e2, r2.shape), a2 = w(dn(r2.shape, o2)[1]);
    return oo(function(t4) {
      var r3 = An(a2);
      return { value: (r3.dtype === t4.dtype ? t4 : t4.cast(r3.dtype)).div(r3).sum(e2, n2), gradFunc: function(e3) {
        var n3 = t4.shape.slice();
        return o2.forEach(function(t5) {
          n3[t5] = 1;
        }), e3.reshape(n3).mul(Bn(t4.shape, "float32")).div(a2);
      } };
    })(r2);
  } });
  var pl = Cn({ min_: function(t3, e2, n2) {
    void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
    var r2 = ln(t3, "x", "min"), o2 = r2, a2 = D(e2, r2.shape), i2 = a2, u2 = gn(i2, r2.rank);
    null != u2 && (r2 = r2.transpose(u2), i2 = xn(i2.length, r2.rank));
    var s2 = Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.min(r2, i2);
      return e3([o2, n3]), n3;
    }, { $x: r2 }, function(t4, e3) {
      return al(t4, e3[1], e3[0], a2, u2);
    });
    if (n2) {
      var c2 = vn(s2.shape, a2);
      s2 = s2.reshape(c2);
    }
    return s2;
  } });
  var dl = Cn({ moments_: function(t3, e2, n2) {
    void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
    var r2 = D(e2, (t3 = ln(t3, "x", "moments")).shape), o2 = t3.mean(r2, n2), a2 = o2.shape;
    n2 || (a2 = vn(o2.shape, r2));
    var i2 = t3.toFloat().sub(o2.reshape(a2)).square();
    return { mean: o2, variance: i2.mean(r2, n2) };
  } });
  var vl = Cn({ sum_: function(t3, e2, n2) {
    void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
    var r2 = ln(t3, "x", "sum");
    "bool" === r2.dtype && (r2 = r2.toInt());
    var o2 = D(e2, r2.shape);
    return oo(function(t4) {
      var e3 = gn(o2, t4.rank), r3 = o2, a2 = t4;
      null != e3 && (a2 = t4.transpose(e3), r3 = xn(r3.length, t4.rank));
      var i2 = Nt.runKernelFunc(function(t5) {
        return t5.sum(a2, r3);
      }, { permutedX: a2 });
      if (n2) {
        var u2 = vn(i2.shape, o2);
        i2 = i2.reshape(u2);
      }
      return { value: i2, gradFunc: function(e4) {
        var n3 = t4.shape.slice();
        return o2.forEach(function(t5) {
          n3[t5] = 1;
        }), e4.reshape(n3).mul(Bn(t4.shape, "float32"));
      } };
    })(r2);
  } });
  var ml = Cn({ prod_: function(t3, e2, n2) {
    void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
    var r2 = ln(t3, "x", "prod");
    "bool" === r2.dtype && (r2 = r2.toInt());
    var o2 = D(e2, r2.shape), a2 = gn(o2, r2.rank), i2 = o2, u2 = r2;
    null != a2 && (u2 = r2.transpose(a2), i2 = xn(i2.length, r2.rank));
    var s2 = Nt.runKernelFunc(function(t4) {
      return t4.prod(u2, i2);
    }, { permutedX: u2 });
    if (n2) {
      var c2 = vn(s2.shape, o2);
      s2 = s2.reshape(c2);
    }
    return s2;
  } });
  var gl = Cn({ elu_: function(t3) {
    var e2 = ln(t3, "x", "elu");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.elu(e2);
      return n2([r2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return Nt.runKernelFunc(function(e4) {
          return e4.eluDer(t4, n2);
        }, { dy: t4, y: n2 });
      } };
    });
  } });
  var yl = Cn({ leakyRelu_: function(t3, e2) {
    void 0 === e2 && (e2 = 0.2);
    var n2 = ln(t3, "x", "leakyRelu");
    return Xs(An(e2).mul(n2), n2);
  } });
  var xl = Cn({ prelu_: function(t3, e2) {
    var n2 = ln(t3, "x", "prelu"), r2 = ln(e2, "alpha", "prelu");
    return Nt.runKernelFunc(function(t4, e3) {
      var o2 = t4.prelu(n2, r2);
      return e3([n2, r2]), o2;
    }, { x: n2, alpha: r2 }, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1], o2 = n3.greater(0);
      return { x: function() {
        return Ws(o2, t4, t4.mul(r3));
      }, alpha: function() {
        var e4 = Ws(o2, zn(t4), t4.mul(n3)), a2 = fo(r3.shape, t4.shape);
        return a2.length > 0 && (e4 = e4.sum(a2)), e4.reshape(r3.shape);
      } };
    }, "Prelu");
  } });
  var bl = Cn({ relu_: function(t3) {
    var e2 = ln(t3, "x", "relu");
    return "bool" === e2.dtype ? e2.toInt() : Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.relu(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        return t4.mulStrict(n2.step().toFloat());
      } };
    });
  } });
  var wl = Cn({ relu6_: function(t3) {
    var e2 = ln(t3, "x", "relu6");
    return "bool" === e2.dtype ? e2.toInt() : Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.relu6(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0], r2 = n2.lessEqual(6).mul(n2.step());
      return { $x: function() {
        return t4.mulStrict(r2.toFloat());
      } };
    });
  } });
  var Cl = Cn({ selu_: function(t3) {
    var e2 = ln(t3, "x", "selu");
    return Nt.runKernelFunc(function(t4, n2) {
      var r2 = t4.selu(e2);
      return n2([e2]), r2;
    }, { $x: e2 }, function(t4, e3) {
      var n2 = e3[0];
      return { $x: function() {
        var e4 = n2.greater(An(0)), r2 = An(iu), o2 = An(uu), a2 = t4.mul(o2), i2 = t4.mul(r2).mul(n2.toFloat().exp());
        return Ws(e4, a2, i2);
      } };
    });
  } });
  var El = Cn({ transpose_: function(t3, e2) {
    var n2 = ln(t3, "x", "transpose");
    return null == e2 && (e2 = n2.shape.map(function(t4, e3) {
      return e3;
    }).reverse()), g(n2.rank === e2.length, function() {
      return "Error in transpose: rank of input " + n2.rank + " must match length of perm " + e2 + ".";
    }), e2.forEach(function(t4) {
      g(t4 >= 0 && t4 < n2.rank, function() {
        return "All entries in 'perm' must be between 0 and " + (n2.rank - 1) + " but got " + e2;
      });
    }), n2.rank <= 1 ? n2.clone() : Nt.runKernelFunc(function(t4) {
      return t4.transpose(n2, e2);
    }, { $x: n2 }, function(t4) {
      var n3 = yn(e2);
      return { $x: function() {
        return t4.transpose(n3);
      } };
    });
  } });
  var Rl = Cn({ localResponseNormalization_: function(t3, e2, n2, r2, o2) {
    void 0 === e2 && (e2 = 5), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 1), void 0 === o2 && (o2 = 0.5);
    var a2 = ln(t3, "x", "localResponseNormalization");
    g(4 === a2.rank || 3 === a2.rank, function() {
      return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + a2.rank + ".";
    }), g(E(e2), function() {
      return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e2 + ".";
    });
    var i2 = a2, u2 = false;
    3 === a2.rank && (u2 = true, i2 = a2.as4D(1, a2.shape[0], a2.shape[1], a2.shape[2]));
    var s2 = Nt.runKernelFunc(function(t4, a3) {
      var u3 = t4.localResponseNormalization4D(i2, e2, n2, r2, o2);
      return a3([i2, u3]), u3;
    }, { x4D: i2 }, function(t4, a3) {
      var i3 = a3[0], u3 = a3[1];
      return { x4D: function() {
        return Nt.runKernelFunc(function(a4) {
          return a4.LRNGrad(t4, i3, u3, e2, n2, r2, o2);
        }, {});
      } };
    });
    return u2 ? s2.as3D(s2.shape[1], s2.shape[2], s2.shape[3]) : s2;
  } });
  var Il = Cn({ norm_: function(t3, e2, n2, r2) {
    void 0 === e2 && (e2 = "euclidean"), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false);
    var o2 = function t4(e3, n3, r3) {
      if (void 0 === r3 && (r3 = null), 0 === e3.rank)
        return e3.abs();
      if (1 !== e3.rank && null === r3)
        return t4(e3.reshape([-1]), n3, r3);
      if (1 === e3.rank || "number" == typeof r3 || Array.isArray(r3) && 1 === r3.length) {
        if (1 === n3)
          return e3.abs().sum(r3);
        if (n3 === 1 / 0)
          return e3.abs().max(r3);
        if (n3 === -1 / 0)
          return e3.abs().min(r3);
        if ("euclidean" === n3 || 2 === n3)
          return e3.abs().pow(An(2, "int32")).sum(r3).sqrt();
        throw new Error("Error in norm: invalid ord value: " + n3);
      }
      if (Array.isArray(r3) && 2 === r3.length) {
        if (1 === n3)
          return e3.abs().sum(r3[0]).max(r3[1] - 1);
        if (n3 === 1 / 0)
          return e3.abs().sum(r3[1]).max(r3[0]);
        if (n3 === -1 / 0)
          return e3.abs().sum(r3[1]).min(r3[0]);
        if ("fro" === n3 || "euclidean" === n3)
          return e3.square().sum(r3).sqrt();
        throw new Error("Error in norm: invalid ord value: " + n3);
      }
      throw new Error("Error in norm: invalid axis: " + r3);
    }(t3 = ln(t3, "x", "norm"), e2, n2), a2 = o2.shape;
    if (r2) {
      var i2 = D(n2, t3.shape);
      a2 = vn(o2.shape, i2);
    }
    return o2.reshape(a2);
  } });
  var kl = Cn({ basicLSTMCell_: function(t3, e2, n2, r2, o2, a2) {
    var i2 = ln(t3, "forgetBias", "basicLSTMCell"), u2 = ln(e2, "lstmKernel", "basicLSTMCell"), s2 = ln(n2, "lstmBias", "basicLSTMCell"), c2 = ln(r2, "data", "basicLSTMCell"), l3 = ln(o2, "c", "basicLSTMCell"), h = ln(a2, "h", "basicLSTMCell"), f2 = c2.concat(h, 1).matMul(u2).add(s2), p2 = f2.shape[0], d2 = f2.shape[1] / 4, v2 = [p2, d2], m2 = f2.slice([0, 0], v2), g2 = f2.slice([0, d2], v2), y2 = f2.slice([0, 2 * d2], v2), x2 = f2.slice([0, 3 * d2], v2), b2 = m2.sigmoid().mulStrict(g2.tanh()).addStrict(l3.mulStrict(i2.add(y2).sigmoid())), w2 = b2.tanh().mulStrict(x2.sigmoid());
    return [b2, w2];
  } });
  var Sl = Cn({ multiRNNCell_: function(t3, e2, n2, r2) {
    for (var o2 = ln(e2, "data", "multiRNNCell"), a2 = hn(n2, "c", "multiRNNCell"), i2 = hn(r2, "h", "multiRNNCell"), u2 = o2, s2 = [], c2 = 0; c2 < t3.length; c2++) {
      var l3 = t3[c2](u2, a2[c2], i2[c2]);
      s2.push(l3[0]), s2.push(l3[1]), u2 = l3[1];
    }
    var h = [], f2 = [];
    for (c2 = 0; c2 < s2.length; c2 += 2)
      h.push(s2[c2]), f2.push(s2[c2 + 1]);
    return [h, f2];
  } });
  var Al = Cn({ movingAverage_: function(t3, e2, n2, r2, o2) {
    void 0 === o2 && (o2 = true);
    var a2 = ln(t3, "v", "movingAverage"), i2 = ln(e2, "x", "movingAverage"), u2 = ln(n2, "decay", "movingAverage");
    It(a2, i2), g(C(a2.shape, i2.shape), function() {
      return "Shape mismatch in v and x";
    });
    var s2 = An(1), c2 = s2.sub(u2), l3 = i2.sub(a2).mul(c2);
    if (o2) {
      g(null != r2, function() {
        return "When using zeroDebias: true, step is required.";
      });
      var h = ln(r2, "step", "movingAverage");
      l3 = l3.div(s2.sub(nc(u2, h)));
    }
    return a2.add(l3);
  } });
  var Dl = Cn({ stridedSlice_: function(t3, e2, n2, r2, o2, a2, i2, u2, s2) {
    if (void 0 === o2 && (o2 = 0), void 0 === a2 && (a2 = 0), void 0 === i2 && (i2 = 0), void 0 === u2 && (u2 = 0), void 0 === s2 && (s2 = 0), null == r2 && (r2 = new Array(e2.length)), 0 !== i2)
      throw new Error("ellipsis mask is not yet supported");
    var c2 = ln(t3, "x", "stridedSlice"), l3 = Kr(u2), h = c2.shape.slice();
    l3.forEach(function(t4) {
      e2[t4] = 0, n2[t4] = 1, h.splice(t4, 0, 1);
    }), c2 = c2.reshape(h);
    for (var f2 = 0; f2 < c2.rank; f2++)
      e2[f2] = Xr(o2, e2, r2, c2.shape, f2), n2[f2] = $r(a2, n2, r2, c2.shape, f2), r2[f2] = r2[f2] || 1;
    var p2 = Kr(s2);
    p2.forEach(function(t4) {
      n2[t4] = e2[t4] + 1, r2[t4] = 1;
    });
    var d2 = jr(e2, n2, r2), v2 = d2.filter(function(t4, e3) {
      return -1 === p2.indexOf(e3);
    });
    return r2.every(function(t4) {
      return 1 === t4;
    }) ? tl(c2, e2, d2).reshape(v2) : Nt.runKernelFunc(function(t4) {
      return t4.stridedSlice(c2, e2, n2, r2);
    }, { $x: c2 }).reshape(v2);
  } });
  var Tl = Cn({ topk_: function(t3, e2, n2) {
    void 0 === e2 && (e2 = 1), void 0 === n2 && (n2 = true);
    var r2 = ln(t3, "x", "topk");
    if (0 === r2.rank)
      throw new Error("topk() expects the input to be of rank 1 or higher");
    var o2 = r2.shape[r2.shape.length - 1];
    if (e2 > o2)
      throw new Error("'k' passed to topk() must be <= the last dimension (" + o2 + ") but got " + e2);
    var a2 = Nt.runKernelFunc(function(t4) {
      return t4.topk(r2, e2, n2);
    }, { $x: r2 });
    return { values: a2[0], indices: a2[1] };
  } });
  var Nl = Cn({ scatterND_: function(t3, e2, n2) {
    var r2 = ln(t3, "indices", "scatterND", "int32"), o2 = ln(e2, "updates", "scatterND");
    return Gr(o2, r2, n2), Nt.runKernelFunc(function(t4) {
      return t4.scatterND(r2, o2, n2);
    }, { $indices: r2, $updates: o2 });
  } });
  var Fl = Cn({ fft_: function(t3) {
    g("complex64" === t3.dtype, function() {
      return "The dtype for tf.spectral.fft() must be complex64 but got " + t3.dtype + ".";
    });
    var e2 = t3.shape[t3.shape.length - 1], n2 = t3.size / e2, r2 = t3.as2D(n2, e2);
    return Nt.runKernelFunc(function(t4) {
      return t4.fft(r2);
    }, { input: t3 }).reshape(t3.shape);
  } });
  var Ol = Cn({ ifft_: function(t3) {
    g("complex64" === t3.dtype, function() {
      return "The dtype for tf.spectral.ifft() must be complex64 but got " + t3.dtype + ".";
    });
    var e2 = t3.shape[t3.shape.length - 1], n2 = t3.size / e2, r2 = t3.as2D(n2, e2);
    return Nt.runKernelFunc(function(t4) {
      return t4.ifft(r2);
    }, { input: t3 }).reshape(t3.shape);
  } });
  var _l = Cn({ rfft_: function(t3, e2) {
    g("float32" === t3.dtype, function() {
      return "The dtype for rfft() must be real value but got " + t3.dtype;
    });
    var n2, r2 = t3.shape[t3.shape.length - 1], o2 = t3.size / r2;
    if (null != e2 && e2 < r2) {
      var a2 = t3.shape.map(function(t4) {
        return 0;
      }), i2 = t3.shape.map(function(t4) {
        return t4;
      });
      i2[t3.shape.length - 1] = e2, n2 = t3.slice(a2, i2), r2 = e2;
    } else if (null != e2 && e2 > r2) {
      var u2 = t3.shape.map(function(t4) {
        return t4;
      });
      u2[t3.shape.length - 1] = e2 - r2, n2 = t3.concat(Pn(u2), t3.shape.length - 1), r2 = e2;
    } else
      n2 = t3;
    var s2 = n2.zerosLike(), c2 = En(n2, s2).as2D(o2, r2), l3 = Fl(c2), h = Math.floor(r2 / 2) + 1, f2 = Rn(l3), p2 = In(l3), d2 = f2.split([h, r2 - h], f2.shape.length - 1), v2 = p2.split([h, r2 - h], p2.shape.length - 1), m2 = n2.shape.slice();
    return m2[n2.shape.length - 1] = h, En(d2[0], v2[0]).reshape(m2);
  } });
  var Ml = Cn({ irfft_: function(t3) {
    var e2 = t3.shape[t3.shape.length - 1], n2 = t3.size / e2;
    if (e2 <= 2) {
      var r2 = t3.as2D(n2, e2), o2 = Ol(r2);
      return Rn(o2);
    }
    var a2 = [n2, 2 * (e2 - 1)], i2 = Rn(t3).as2D(n2, e2), u2 = In(t3).as2D(n2, e2), s2 = i2.slice([0, 1], [n2, e2 - 2]).reverse(1), c2 = u2.slice([0, 1], [n2, e2 - 2]).reverse(1).mul(An(-1)), l3 = i2.concat(s2, 1), h = u2.concat(c2, 1);
    return r2 = En(l3, h).as2D(a2[0], a2[1]), o2 = Ol(r2), Rn(o2);
  } });
  var Bl = Object.freeze({ fft: Fl, ifft: Ol, rfft: _l, irfft: Ml });
  var Pl = Cn({ sparseToDense_: function(t3, e2, n2, r2) {
    void 0 === r2 && (r2 = 0);
    var o2 = ln(t3, "sparseIndices", "sparseToDense", "int32"), a2 = ln(e2, "sparseValues", "sparseToDense"), i2 = ln(r2, "defaultValue", "sparseToDense", a2.dtype);
    return function(t4, e3, n3, r3) {
      if ("int32" !== t4.dtype)
        throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t4.dtype + ".");
      if (t4.rank > 2)
        throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t4.shape + ".");
      var o3 = t4.rank > 0 ? t4.shape[0] : 1, a3 = t4.rank > 1 ? t4.shape[1] : 1;
      if (n3.length !== a3)
        throw new Error("outputShape has incorrect number of elements:, " + n3.length + ", should be: " + a3 + ".");
      var i3 = e3.size;
      if (0 !== e3.rank && (1 !== e3.rank || i3 !== o3))
        throw new Error("sparseValues has incorrect shape " + e3.shape + ", should be [] or [" + o3 + "]");
      if (e3.dtype !== r3.dtype)
        throw new Error("sparseValues.dtype must match defaultValues.dtype");
    }(o2, a2, n2, i2), Nt.runKernelFunc(function(t4) {
      return t4.sparseToDense(o2, a2, n2, i2);
    }, { $sparseIndices: o2, $sparseValues: a2, $defaultValue: i2 });
  } });
  var Ll = Cn({ gatherND_: function(t3, e2) {
    var n2 = ln(e2, "indices", "gatherND", "int32"), r2 = ln(t3, "x", "gatherND");
    return Nt.runKernelFunc(function(t4) {
      return t4.gatherND(r2, n2);
    }, { $x: r2, $indices: n2 });
  } });
  var Wl = Cn({ diag_: function(t3) {
    var e2 = ln(t3, "x", "diag").flatten(), n2 = t3.shape.concat(t3.shape);
    return Nt.runKernelFunc(function(t4) {
      return t4.diag(e2);
    }, { $x: e2 }).reshape(n2);
  } });
  var Ul = Cn({ dropout_: function(t3, e2, n2, r2) {
    var o2 = ln(t3, "x", "dropout");
    if (g("float32" === o2.dtype, function() {
      return "x has to be a floating point tensor since it's going to be scaled, but got a " + o2.dtype + " tensor instead.";
    }), g(e2 >= 0 && e2 < 1, function() {
      return "rate must be a float in the range [0, 1), but got " + e2 + ".";
    }), 0 === e2)
      return t3 instanceof dt ? o2.clone() : o2;
    var a2 = function(t4, e3) {
      if (null == e3)
        return t4.shape.slice();
      if (C(t4.shape, e3))
        return e3;
      if (t4.shape.length === e3.length) {
        for (var n3 = [], r3 = 0; r3 < t4.shape.length; r3++)
          null == e3[r3] && null != t4.shape[r3] ? n3.push(t4.shape[r3]) : n3.push(e3[r3]);
        return n3;
      }
      return e3;
    }(o2, n2), i2 = 1 - e2, u2 = kr(a2, 0, 1, "float32", r2).add(i2).floor().div(i2);
    return o2.mul(u2);
  } });
  function Vl(t3, e2, n2) {
    for (var r2 = 1 - t3 % 2, o2 = new Float32Array(t3), a2 = 0; a2 < t3; ++a2) {
      var i2 = 2 * Math.PI * a2 / (t3 + r2 - 1);
      o2[a2] = e2 - n2 * Math.cos(i2);
    }
    return Dn(o2, "float32");
  }
  var zl = Cn({ hannWindow_: function(t3) {
    return Vl(t3, 0.5, 0.5);
  } });
  var Gl = Cn({ hammingWindow_: function(t3) {
    return Vl(t3, 0.54, 0.46);
  } });
  var Hl = Cn({ frame_: function(t3, e2, n2, r2, o2) {
    void 0 === r2 && (r2 = false), void 0 === o2 && (o2 = 0);
    for (var a2 = 0, i2 = []; a2 + e2 <= t3.size; )
      i2.push(tl(t3, a2, e2)), a2 += n2;
    if (r2)
      for (; a2 < t3.size; ) {
        var u2 = a2 + e2 - t3.size, s2 = Gn([tl(t3, a2, e2 - u2), Ln([u2], o2)]);
        i2.push(s2), a2 += n2;
      }
    return 0 === i2.length ? Tn([], [0, e2]) : Gn(i2).as2D(i2.length, e2);
  } });
  var ql = Cn({ stft_: function(t3, e2, n2, r2, o2) {
    var a2;
    void 0 === o2 && (o2 = zl), null == r2 && (a2 = e2, r2 = Math.floor(Math.pow(2, Math.ceil(Math.log(a2) / Math.log(2)))));
    for (var i2 = Hl(t3, e2, n2), u2 = tc(i2, o2(e2)), s2 = [], c2 = 0; c2 < i2.shape[0]; c2++)
      s2.push(_l(u2.slice([c2, 0], [1, e2]), r2));
    return Gn(s2);
  } });
  var Kl = Object.freeze({ hannWindow: zl, hammingWindow: Gl, frame: Hl, stft: ql });
  var jl;
  var Xl = function(t3, e2, o2) {
    return void 0 === o2 && (o2 = 1), n(this, void 0, void 0, function() {
      var n2, a2, i2, u2, s2, c2, l3, h, f2, p2, d2, v2, m2, x2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return n2 = ln(t3, "predictions", "inTopK"), a2 = ln(e2, "targets", "inTopK"), g(n2.rank > 1, function() {
              return "inTopK() expects the predictions to be of rank 2 or higher, but got " + n2.rank;
            }), g(n2.rank - 1 === a2.rank, function() {
              return "predictions rank should be 1 larger than targets rank, but got predictions rank " + n2.rank + " and targets rank " + a2.rank;
            }), y(n2.shape.slice(0, n2.shape.length - 1), a2.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), i2 = n2.shape[n2.shape.length - 1], g(o2 > 0 && o2 <= i2, function() {
              return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + i2 + "), but got " + o2;
            }), [4, n2.data()];
          case 1:
            return u2 = r2.sent(), [4, a2.data()];
          case 2:
            for (s2 = r2.sent(), c2 = [u2.length / i2, i2], h = c2[1], f2 = N("bool", l3 = c2[0]), p2 = 0; p2 < l3; p2++) {
              for (d2 = p2 * h, v2 = u2.subarray(d2, d2 + h), m2 = [], x2 = 0; x2 < v2.length; x2++)
                m2.push({ value: v2[x2], index: x2 });
              for (m2.sort(function(t4, e3) {
                return e3.value - t4.value;
              }), f2[p2] = 0, x2 = 0; x2 < o2; x2++)
                if (m2[x2].index === s2[p2]) {
                  f2[p2] = 1;
                  break;
                }
            }
            return t3 !== n2 && n2.dispose(), e2 !== a2 && a2.dispose(), [2, kn(f2, a2.shape, "bool")];
        }
      });
    });
  };
  !function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.MEAN = 1] = "MEAN", t3[t3.SUM = 2] = "SUM", t3[t3.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
  }(jl || (jl = {}));
  var $l = Cn({ absoluteDifference_: function(t3, e2, n2, r2) {
    void 0 === r2 && (r2 = jl.SUM_BY_NONZERO_WEIGHTS);
    var o2 = ln(t3, "labels", "absoluteDifference"), a2 = ln(e2, "predictions", "absoluteDifference"), i2 = null;
    null != n2 && (i2 = ln(n2, "weights", "absoluteDifference")), y(o2.shape, a2.shape, "Error in absoluteDifference: ");
    var u2 = o2.sub(a2).abs();
    return Yl(u2, i2, r2);
  } });
  var Yl = Cn({ computeWeightedLoss_: function(t3, e2, n2) {
    void 0 === n2 && (n2 = jl.SUM_BY_NONZERO_WEIGHTS);
    var r2 = ln(t3, "losses", "computeWeightedLoss"), o2 = null;
    null != e2 && (o2 = ln(e2, "weights", "computeWeightedLoss"));
    var a2 = null == o2 ? r2 : r2.mul(o2);
    if (n2 === jl.NONE)
      return a2;
    if (n2 === jl.SUM)
      return a2.sum();
    if (n2 === jl.MEAN) {
      if (null == o2)
        return a2.mean();
      var i2 = r2.size / o2.size, u2 = a2.sum().div(o2.sum());
      return i2 > 1 ? u2.div(An(i2)) : u2;
    }
    if (n2 === jl.SUM_BY_NONZERO_WEIGHTS) {
      if (null == o2)
        return a2.sum().div(An(r2.size));
      var s2 = o2.mul(Bn(r2.shape)).notEqual(An(0)).sum().toFloat();
      return a2.sum().div(s2);
    }
    throw Error("Unknown reduction: " + n2);
  } });
  var Ql = Cn({ cosineDistance_: function(t3, e2, n2, r2, o2) {
    void 0 === o2 && (o2 = jl.SUM_BY_NONZERO_WEIGHTS);
    var a2 = ln(t3, "labels", "cosineDistance"), i2 = ln(e2, "predictions", "cosineDistance"), u2 = null;
    null != r2 && (u2 = ln(r2, "weights", "cosineDistance")), y(a2.shape, i2.shape, "Error in cosineDistance: ");
    var s2 = An(1).sub(a2.mul(i2).sum(n2, true));
    return Yl(s2, u2, o2);
  } });
  var Jl = Cn({ hingeLoss_: function(t3, e2, n2, r2) {
    void 0 === r2 && (r2 = jl.SUM_BY_NONZERO_WEIGHTS);
    var o2 = ln(t3, "labels", "hingeLoss"), a2 = ln(e2, "predictions", "hingeLoss"), i2 = null;
    null != n2 && (i2 = ln(n2, "weights", "hingeLoss")), y(o2.shape, a2.shape, "Error in hingeLoss: ");
    var u2 = An(1);
    o2 = An(2).mul(o2).sub(u2);
    var s2 = u2.sub(o2.mul(a2)).relu();
    return Yl(s2, i2, r2);
  } });
  var Zl = Cn({ huberLoss_: function(t3, e2, n2, r2, o2) {
    void 0 === r2 && (r2 = 1), void 0 === o2 && (o2 = jl.SUM_BY_NONZERO_WEIGHTS);
    var a2 = ln(t3, "labels", "huberLoss"), i2 = ln(e2, "predictions", "huberLoss"), u2 = null;
    null != n2 && (u2 = ln(n2, "weights", "huberLoss")), y(a2.shape, i2.shape, "Error in huberLoss: ");
    var s2 = An(r2), c2 = i2.sub(a2).abs(), l3 = Ys(c2, s2), h = c2.sub(l3), f2 = An(0.5).mul(l3.square()).add(s2.mul(h));
    return Yl(f2, u2, o2);
  } });
  var th = Cn({ logLoss_: function(t3, e2, n2, r2, o2) {
    void 0 === r2 && (r2 = 1e-7), void 0 === o2 && (o2 = jl.SUM_BY_NONZERO_WEIGHTS);
    var a2 = ln(t3, "labels", "logLoss"), i2 = ln(e2, "predictions", "logLoss"), u2 = null;
    null != n2 && (u2 = ln(n2, "weights", "logLoss")), y(a2.shape, i2.shape, "Error in logLoss: ");
    var s2 = An(1), c2 = An(r2), l3 = a2.mul(i2.add(c2).log()).neg().sub(s2.sub(a2).mul(s2.sub(i2).add(c2).log()));
    return Yl(l3, u2, o2);
  } });
  var eh = Cn({ meanSquaredError_: function(t3, e2, n2, r2) {
    void 0 === r2 && (r2 = jl.SUM_BY_NONZERO_WEIGHTS);
    var o2 = ln(t3, "labels", "meanSquaredError"), a2 = ln(e2, "predictions", "meanSquaredError"), i2 = null;
    null != n2 && (i2 = ln(n2, "weights", "meanSquaredError")), y(o2.shape, a2.shape, "Error in meanSquaredError: ");
    var u2 = o2.squaredDifference(a2);
    return Yl(u2, i2, r2);
  } });
  var nh = Cn({ sigmoidCrossEntropy_: function(t3, e2, n2, r2, o2) {
    void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = jl.SUM_BY_NONZERO_WEIGHTS);
    var a2 = ln(t3, "multiClassLabels", "sigmoidCrossEntropy"), i2 = ln(e2, "logits", "sigmoidCrossEntropy"), u2 = null;
    if (null != n2 && (u2 = ln(n2, "weights", "sigmoidCrossEntropy")), y(a2.shape, i2.shape, "Error in sigmoidCrossEntropy: "), r2 > 0) {
      var s2 = An(r2), c2 = An(1), l3 = An(0.5);
      a2 = a2.mul(c2.sub(s2)).add(l3.mul(s2));
    }
    var h = function(t4, e3) {
      var n3 = ln(t4, "labels", "sigmoidCrossEntropyWithLogits"), r3 = ln(e3, "logits", "sigmoidCrossEntropyWithLogits");
      y(n3.shape, r3.shape, "Error in sigmoidCrossEntropyWithLogits: ");
      var o3 = r3.relu(), a3 = r3.mul(n3), i3 = r3.abs().neg().exp().log1p();
      return o3.sub(a3).add(i3);
    }(a2, i2);
    return Yl(h, u2, o2);
  } });
  var rh = Cn({ softmaxCrossEntropy_: function(t3, e2, n2, r2, o2) {
    void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = jl.SUM_BY_NONZERO_WEIGHTS);
    var a2 = ln(t3, "onehotLabels", "softmaxCrossEntropy"), i2 = ln(e2, "logits", "softmaxCrossEntropy"), u2 = null;
    if (null != n2 && (u2 = ln(n2, "weights", "softmaxCrossEntropy")), y(a2.shape, i2.shape, "Error in softmaxCrossEntropy: "), r2 > 0) {
      var s2 = An(r2), c2 = An(1), l3 = An(a2.shape[1]);
      a2 = a2.mul(c2.sub(s2)).add(s2.div(l3));
    }
    var h = function(t4, e3, n3) {
      if (void 0 === n3 && (n3 = -1), -1 === n3 && (n3 = e3.rank - 1), n3 !== e3.rank - 1)
        throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e3.rank + " and dim was " + n3);
      return oo(function(t5, e4, r3) {
        var o3 = e4.logSumExp([n3], true), a3 = e4.toFloat().sub(o3);
        return r3([t5, a3]), { value: a3.mul(t5).neg().sum([n3]), gradFunc: function(t6, e5) {
          var r4 = e5[0], o4 = e5[1], a4 = vn(t6.shape, [n3]);
          return [t6.reshape(a4).mul(r4.toFloat().sub(o4.exp())), t6.reshape(a4).mul(o4.exp().sub(r4.toFloat()))];
        } };
      })(t4, e3);
    }(a2, i2);
    return Yl(h, u2, o2);
  } });
  var oh = Object.freeze({ get Reduction() {
    return jl;
  }, absoluteDifference: $l, computeWeightedLoss: Yl, cosineDistance: Ql, hingeLoss: Jl, huberLoss: Zl, logLoss: th, meanSquaredError: eh, sigmoidCrossEntropy: nh, softmaxCrossEntropy: rh });
  function ah(t3, e2) {
    return void 0 === e2 && (e2 = false), Nt.tidy(function() {
      if (2 !== t3.shape.length)
        throw new Error("qr2d() requires a 2D Tensor, but got a " + t3.shape.length + "D Tensor.");
      for (var n2 = t3.shape[0], r2 = t3.shape[1], o2 = vr(n2), a2 = t3.clone(), i2 = Tn([[1]], [1, 1]), u2 = i2.clone(), s2 = n2 >= r2 ? r2 : n2, c2 = function(t4) {
        var e3, s3 = a2, c3 = u2, l4 = o2;
        e3 = Nt.tidy(function() {
          var e4 = a2.slice([t4, t4], [n2 - t4, 1]), s4 = e4.norm(), c4 = a2.slice([t4, t4], [1, 1]), l5 = Tn([[-1]]).where(c4.greater(0), Tn([[1]])), h = c4.sub(l5.mul(s4)), f2 = e4.div(h);
          u2 = 1 === f2.shape[0] ? i2.clone() : i2.concat(f2.slice([1, 0], [f2.shape[0] - 1, f2.shape[1]]), 0);
          var p2 = l5.matMul(h).div(s4).neg(), d2 = a2.slice([t4, 0], [n2 - t4, r2]), v2 = p2.mul(u2);
          if (0 === t4)
            a2 = d2.sub(v2.matMul(u2.transpose().matMul(d2)));
          else {
            var m2 = d2.sub(v2.matMul(u2.transpose().matMul(d2)));
            a2 = a2.slice([0, 0], [t4, r2]).concat(m2, 0);
          }
          var g2 = o2.slice([0, t4], [n2, o2.shape[1] - t4]);
          if (0 === t4)
            o2 = g2.sub(g2.matMul(u2).matMul(v2.transpose()));
          else {
            var y2 = g2.sub(g2.matMul(u2).matMul(v2.transpose()));
            o2 = o2.slice([0, 0], [n2, t4]).concat(y2, 1);
          }
          return [u2, a2, o2];
        }), u2 = e3[0], a2 = e3[1], o2 = e3[2], Xe([s3, c3, l4]);
      }, l3 = 0; l3 < s2; ++l3)
        c2(l3);
      return !e2 && n2 > r2 && (o2 = o2.slice([0, 0], [n2, r2]), a2 = a2.slice([0, 0], [r2, r2])), [o2, a2];
    });
  }
  var ih = Cn({ gramSchmidt_: function(t3) {
    var e2;
    if (Array.isArray(t3)) {
      e2 = false, g(null != t3 && t3.length > 0, function() {
        return "Gram-Schmidt process: input must not be null, undefined, or empty";
      });
      for (var n2 = t3[0].shape[0], r2 = function(e3) {
        g(t3[e3].shape[0] === n2, function() {
          return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t3[e3].shape[0] + " vs. " + n2 + ")";
        });
      }, o2 = 1; o2 < t3.length; ++o2)
        r2(o2);
    } else
      e2 = true, t3 = Xn(t3, t3.shape[0], 0).map(function(t4) {
        return Dr(t4, [0]);
      });
    g(t3.length <= t3[0].shape[0], function() {
      return "Gram-Schmidt: Number of vectors (" + t3.length + ") exceeds number of dimensions (" + t3[0].shape[0] + ").";
    });
    var a2 = [], i2 = t3, u2 = function(t4) {
      a2.push(Nt.tidy(function() {
        var e3 = i2[t4];
        if (t4 > 0)
          for (var n3 = 0; n3 < t4; ++n3) {
            var r3 = vl(a2[n3].mulStrict(e3)).mul(a2[n3]);
            e3 = e3.sub(r3);
          }
        return e3.div(Il(e3, "euclidean"));
      }));
    };
    for (o2 = 0; o2 < t3.length; ++o2)
      u2(o2);
    return e2 ? Tr(a2, 0) : a2;
  } });
  var uh = Cn({ qr_: function(t3, e2) {
    if (void 0 === e2 && (e2 = false), t3.rank < 2)
      throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t3.rank);
    if (2 === t3.rank)
      return ah(t3, e2);
    var n2 = t3.shape.slice(0, t3.shape.length - 2).reduce(function(t4, e3) {
      return t4 * e3;
    }), r2 = Or(t3.reshape([n2, t3.shape[t3.shape.length - 2], t3.shape[t3.shape.length - 1]]), 0), o2 = [], a2 = [];
    return r2.forEach(function(t4) {
      var n3 = ah(t4, e2), r3 = n3[0], i2 = n3[1];
      o2.push(r3), a2.push(i2);
    }), [Tr(o2, 0).reshape(t3.shape), Tr(a2, 0).reshape(t3.shape)];
  } });
  var sh = Object.freeze({ gramSchmidt: ih, qr: uh });
  function ch(t3, e2, n2, r2, o2) {
    null == r2 && (r2 = 0.5), null == o2 && (o2 = Number.NEGATIVE_INFINITY);
    var a2 = t3.shape[0];
    return n2 = Math.min(n2, a2), g(0 <= r2 && r2 <= 1, function() {
      return "iouThreshold must be in [0, 1], but was '" + r2 + "'";
    }), g(2 === t3.rank, function() {
      return "boxes must be a 2D tensor, but was of rank '" + t3.rank + "'";
    }), g(4 === t3.shape[1], function() {
      return "boxes must have 4 columns, but 2nd dimension was " + t3.shape[1];
    }), g(1 === e2.rank, function() {
      return "scores must be a 1D tensor";
    }), g(e2.shape[0] === a2, function() {
      return "scores has incompatible shape with boxes. Expected " + a2 + ", but was " + e2.shape[0];
    }), { maxOutputSize: n2, iouThreshold: r2, scoreThreshold: o2 };
  }
  var lh = Cn({ resizeBilinear_: function(t3, e2, n2) {
    void 0 === n2 && (n2 = false);
    var r2 = ln(t3, "images", "resizeBilinear");
    g(3 === r2.rank || 4 === r2.rank, function() {
      return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r2.rank + ".";
    }), g(2 === e2.length, function() {
      return "Error in resizeBilinear: new shape must 2D, but got shape " + e2 + ".";
    });
    var o2 = r2, a2 = false;
    3 === r2.rank && (a2 = true, o2 = r2.as4D(1, r2.shape[0], r2.shape[1], r2.shape[2]));
    var i2 = e2[0], u2 = e2[1], s2 = Nt.runKernelFunc(function(t4, e3) {
      return e3([o2]), t4.resizeBilinear(o2, i2, u2, n2);
    }, { batchImages: o2 }, function(t4, e3) {
      return { batchImages: function() {
        return Nt.runKernelFunc(function(r3) {
          return r3.resizeBilinearBackprop(t4, e3[0], n2);
        }, {});
      } };
    });
    return a2 ? s2.as3D(s2.shape[1], s2.shape[2], s2.shape[3]) : s2;
  } });
  var hh = Cn({ resizeNearestNeighbor_: function(t3, e2, n2) {
    void 0 === n2 && (n2 = false);
    var r2 = ln(t3, "images", "resizeNearestNeighbor");
    g(3 === r2.rank || 4 === r2.rank, function() {
      return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r2.rank + ".";
    }), g(2 === e2.length, function() {
      return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e2 + ".";
    }), g("float32" === r2.dtype || "int32" === r2.dtype, function() {
      return "`images` must have `int32` or `float32` as dtype";
    });
    var o2 = r2, a2 = false;
    3 === r2.rank && (a2 = true, o2 = r2.as4D(1, r2.shape[0], r2.shape[1], r2.shape[2]));
    var i2 = e2[0], u2 = e2[1], s2 = Nt.runKernelFunc(function(t4, e3) {
      return e3([o2]), t4.resizeNearestNeighbor(o2, i2, u2, n2);
    }, { batchImages: o2 }, function(t4, e3) {
      return { batchImages: function() {
        return Nt.runKernelFunc(function(r3) {
          return r3.resizeNearestNeighborBackprop(t4, e3[0], n2);
        }, {});
      } };
    });
    return a2 ? s2.as3D(s2.shape[1], s2.shape[2], s2.shape[3]) : s2;
  } });
  var fh = Cn({ nonMaxSuppression_: function(t3, e2, n2, r2, o2) {
    void 0 === r2 && (r2 = 0.5), void 0 === o2 && (o2 = Number.NEGATIVE_INFINITY);
    var a2 = ln(t3, "boxes", "nonMaxSuppression"), i2 = ln(e2, "scores", "nonMaxSuppression"), u2 = ch(a2, i2, n2, r2, o2);
    return n2 = u2.maxOutputSize, r2 = u2.iouThreshold, o2 = u2.scoreThreshold, Nt.runKernelFunc(function(t4) {
      return t4.nonMaxSuppression(a2, i2, n2, r2, o2);
    }, { $boxes: a2 });
  } });
  var ph = function(t3, e2, o2, a2, i2) {
    return void 0 === a2 && (a2 = 0.5), void 0 === i2 && (i2 = Number.NEGATIVE_INFINITY), n(this, void 0, void 0, function() {
      var n2, u2, s2, c2, l3, h, f2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return n2 = ln(t3, "boxes", "nonMaxSuppressionAsync"), u2 = ln(e2, "scores", "nonMaxSuppressionAsync"), s2 = ch(n2, u2, o2, a2, i2), o2 = s2.maxOutputSize, a2 = s2.iouThreshold, i2 = s2.scoreThreshold, [4, Promise.all([n2.data(), u2.data()])];
          case 1:
            return c2 = r2.sent(), l3 = c2[0], h = c2[1], f2 = Mo(l3, h, o2, a2, i2), n2 !== t3 && n2.dispose(), u2 !== e2 && u2.dispose(), [2, f2];
        }
      });
    });
  };
  var dh = Cn({ cropAndResize_: function(t3, e2, n2, r2, o2, a2) {
    var i2 = ln(t3, "image", "cropAndResize", "float32"), u2 = ln(e2, "boxes", "cropAndResize", "float32"), s2 = ln(n2, "boxInd", "cropAndResize", "int32");
    o2 = o2 || "bilinear", a2 = a2 || 0;
    var c2 = u2.shape[0];
    return g(4 === i2.rank, function() {
      return "Error in cropAndResize: image must be rank 4,but got rank " + i2.rank + ".";
    }), g(2 === u2.rank && 4 === u2.shape[1], function() {
      return "Error in cropAndResize: boxes must be have size [" + c2 + ",4] but had shape " + u2.shape + ".";
    }), g(1 === s2.rank && s2.shape[0] === c2, function() {
      return "Error in cropAndResize: boxInd must be have size [" + c2 + "] but had shape " + u2.shape + ".";
    }), g(2 === r2.length, function() {
      return "Error in cropAndResize: cropSize must be of length 2, but got length " + r2.length + ".";
    }), g(r2[0] >= 1 && r2[1] >= 1, function() {
      return "cropSize must be atleast [1,1], but was " + r2;
    }), g("bilinear" === o2 || "nearest" === o2, function() {
      return "method must be bilinear or nearest, but was " + o2;
    }), Nt.runKernelFunc(function(t4, e3) {
      return t4.cropAndResize(i2, u2, s2, r2, o2, a2);
    }, { $image: i2, $boxes: u2 });
  } });
  var vh = Object.freeze({ resizeBilinear: lh, resizeNearestNeighbor: hh, nonMaxSuppression: fh, nonMaxSuppressionAsync: ph, cropAndResize: dh });
  var mh = function(t3, e2) {
    return !(t3 > 0) && ("linear" === e2 || "relu" === e2);
  };
  var gh = function(t3, e2, n2) {
    if (null == n2 || "linear" === n2)
      return t3;
    if ("relu" === n2)
      return t3.mul(e2.step());
    throw new Error("Gradient for activation " + n2 + " has not been implemented yet.");
  };
  var yh = function(t3, e2) {
    var n2 = e2, r2 = fo(t3.shape, e2.shape);
    return r2.length > 0 && (n2 = n2.sum(r2)), n2.reshape(t3.shape);
  };
  var xh = function(t3, e2, n2) {
    if ("linear" === e2)
      return t3;
    if ("relu" === e2)
      return bl(t3);
    if ("elu" === e2)
      return gl(t3);
    if ("relu6" === e2)
      return wl(t3);
    if ("prelu" === e2)
      return xl(t3, n2);
    throw new Error("Unknown fused activation " + e2 + ".");
  };
  var bh = Cn({ matMul_: function(t3) {
    var e2, n2 = t3.a, r2 = t3.b, o2 = t3.transposeA, a2 = void 0 !== o2 && o2, i2 = t3.transposeB, u2 = void 0 !== i2 && i2, s2 = t3.bias, c2 = t3.activation, l3 = void 0 === c2 ? "linear" : c2, h = t3.preluActivationWeights;
    if (false === mh(Nt.state.gradientDepth, l3)) {
      var f2 = Wc(n2, r2, a2, u2);
      return null != s2 && (f2 = Vs(f2, s2)), xh(f2, l3, h);
    }
    var p2 = ln(n2, "a", "fused matMul"), d2 = ln(r2, "b", "fused matMul");
    e2 = Rt(p2, d2), p2 = e2[0], d2 = e2[1];
    var v2 = a2 ? p2.shape[p2.rank - 2] : p2.shape[p2.rank - 1], m2 = u2 ? d2.shape[d2.rank - 1] : d2.shape[d2.rank - 2], y2 = a2 ? p2.shape[p2.rank - 1] : p2.shape[p2.rank - 2], x2 = u2 ? d2.shape[d2.rank - 2] : d2.shape[d2.rank - 1], b2 = p2.shape.slice(0, -2), E3 = d2.shape.slice(0, -2), R3 = w(b2), I3 = w(E3);
    g(p2.rank >= 2 && d2.rank >= 2 && p2.rank === d2.rank, function() {
      return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + p2.rank + " and " + d2.rank + ".";
    }), g(C(b2, E3), function() {
      return "Error in fused matMul: outer dimensions (" + b2 + ") and (" + E3 + ") of Tensors with shapes " + p2.shape + " and " + d2.shape + " must match.";
    }), g(v2 === m2, function() {
      return "Error in fused matMul: inner shapes (" + v2 + ") and (" + m2 + ") of Tensors with shapes " + p2.shape + " and " + d2.shape + " and transposeA=" + a2 + " and transposeB=" + u2 + " must match.";
    });
    var k4, S3, A2 = p2.shape.slice(0, -2).concat([y2, x2]), D3 = a2 ? p2.as3D(R3, v2, y2) : p2.as3D(R3, y2, v2), T2 = u2 ? d2.as3D(I3, x2, m2) : d2.as3D(I3, m2, x2);
    null != s2 && po(A2, (k4 = Rt(k4 = ln(s2, "bias", "fused matMul"), p2)[0]).shape), null != h && (S3 = ln(h, "prelu weights", "fused matMul"));
    var N3 = { $a: D3, $b: T2 };
    return null != s2 && (N3.$bias = k4), null != h && (N3.$preluActivationWeights = S3), Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.fusedBatchMatMul({ a: D3, b: T2, transposeA: a2, transposeB: u2, bias: k4, activation: l3, preluActivationWeights: S3 });
      return e3([D3, T2, n3]), n3;
    }, N3, function(t4, e3) {
      var n3 = e3[0], r3 = e3[1], o3 = e3[2], i3 = gh(t4, o3, l3), c3 = {};
      return null != s2 && (c3 = { $bias: function() {
        return yh(k4, i3);
      } }), a2 || u2 ? !a2 && u2 ? Object.assign({ $a: function() {
        return i3.matMul(r3, false, false);
      }, $b: function() {
        return i3.matMul(n3, true, false);
      } }, c3) : a2 && !u2 ? Object.assign({ $a: function() {
        return r3.matMul(i3, false, true);
      }, $b: function() {
        return n3.matMul(i3, false, false);
      } }, c3) : Object.assign({ $a: function() {
        return r3.matMul(i3, true, true);
      }, $b: function() {
        return i3.matMul(n3, true, true);
      } }, c3) : Object.assign({ $a: function() {
        return i3.matMul(r3, false, true);
      }, $b: function() {
        return n3.matMul(i3, true, false);
      } }, c3);
    }).reshape(A2);
  } });
  var wh = Cn({ conv2d_: function(t3) {
    var e2 = t3.x, n2 = t3.filter, r2 = t3.strides, o2 = t3.pad, a2 = t3.dataFormat, i2 = void 0 === a2 ? "NHWC" : a2, u2 = t3.dilations, s2 = void 0 === u2 ? [1, 1] : u2, c2 = t3.dimRoundingMode, l3 = t3.bias, h = t3.activation, f2 = void 0 === h ? "linear" : h, p2 = t3.preluActivationWeights;
    if (f2 = f2 || "linear", false === mh(Nt.state.gradientDepth, f2)) {
      var d2 = Dc(e2, n2, r2, o2, i2, s2, c2);
      return null != l3 && (d2 = Vs(d2, l3)), xh(d2, f2, p2);
    }
    var v2 = ln(e2, "x", "conv2d"), m2 = ln(n2, "filter", "conv2d"), y2 = v2, x2 = false;
    3 === v2.rank && (x2 = true, y2 = v2.as4D(1, v2.shape[0], v2.shape[1], v2.shape[2])), g(4 === y2.rank, function() {
      return "Error in fused conv2d: input must be rank 4, but got rank " + y2.rank + ".";
    }), g(4 === m2.rank, function() {
      return "Error in fused conv2d: filter must be rank 4, but got rank " + m2.rank + ".";
    }), null != c2 && g(E(o2), function() {
      return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c2 + " but got pad " + o2 + ".";
    }), g(y2.shape[3] === m2.shape[2], function() {
      return "Error in conv2d: depth of input (" + y2.shape[3] + ") must match input depth for filter " + m2.shape[2] + ".";
    }), g(Io(r2, s2), function() {
      return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r2 + " and dilations '" + s2 + "'";
    }), g("NHWC" === i2, function() {
      return "Error in conv2d: got dataFormat of " + i2 + " but only NHWC is currently supported.";
    });
    var b2, w2, C3 = go(y2.shape, m2.shape, r2, s2, o2, c2);
    null != l3 && (b2 = Rt(b2 = ln(l3, "bias", "fused conv2d"), v2)[0], po(C3.outShape, b2.shape)), null != p2 && (w2 = ln(p2, "prelu weights", "fused conv2d"));
    var R3 = { x: y2, $filter: m2 };
    null != l3 && (R3.$bias = b2), null != p2 && (R3.$preluActivationWeights = w2);
    var I3 = Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.fusedConv2d({ input: y2, filter: m2, convInfo: C3, bias: b2, activation: f2, preluActivationWeights: w2 });
      return e3([m2, y2, n3]), n3;
    }, R3, function(t4, e3) {
      var n3 = e3, a3 = n3[0], i3 = n3[1], u3 = n3[2], c3 = gh(t4, u3, f2);
      g(Ro(s2), function() {
        return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + s2 + "'";
      });
      var h2 = {};
      return null != l3 && (h2 = { $bias: function() {
        return yh(b2, c3);
      } }), Object.assign({ x: function() {
        return Fc(i3.shape, c3, a3, r2, o2);
      }, $filter: function() {
        return Nc(i3, c3, a3.shape, r2, o2);
      } }, h2);
    });
    return x2 ? I3.as3D(I3.shape[1], I3.shape[2], I3.shape[3]) : I3;
  } });
  var Ch = Cn({ depthwiseConv2d_: function(t3) {
    var e2 = t3.x, n2 = t3.filter, r2 = t3.strides, o2 = t3.pad, a2 = t3.dataFormat, i2 = void 0 === a2 ? "NHWC" : a2, u2 = t3.dilations, s2 = void 0 === u2 ? [1, 1] : u2, c2 = t3.dimRoundingMode, l3 = t3.bias, h = t3.activation, f2 = void 0 === h ? "linear" : h, p2 = t3.preluActivationWeights;
    if (false === mh(Nt.state.gradientDepth, f2)) {
      var d2 = Oc(e2, n2, r2, o2, i2, s2, c2);
      return null != l3 && (d2 = Vs(d2, l3)), xh(d2, f2, p2);
    }
    var v2 = ln(e2, "x", "depthwiseConv2d"), m2 = ln(n2, "filter", "depthwiseConv2d"), y2 = v2, x2 = false;
    3 === v2.rank && (x2 = true, y2 = v2.as4D(1, v2.shape[0], v2.shape[1], v2.shape[2])), g(4 === y2.rank, function() {
      return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + y2.rank + ".";
    }), g(4 === m2.rank, function() {
      return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + m2.rank + ".";
    }), g(y2.shape[3] === m2.shape[2], function() {
      return "Error in fused depthwiseConv2d: number of input channels (" + y2.shape[3] + ") must match the inChannels dimension in filter " + m2.shape[2] + ".";
    }), null == s2 && (s2 = [1, 1]), g(Io(r2, s2), function() {
      return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r2 + " and dilations '" + s2 + "'";
    }), null != c2 && g(E(o2), function() {
      return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c2 + " but got pad " + o2 + ".";
    });
    var b2, w2, C3 = go(y2.shape, m2.shape, r2, s2, o2, c2, true);
    null != l3 && (b2 = Rt(b2 = ln(l3, "bias", "fused conv2d"), v2)[0], po(C3.outShape, b2.shape)), null != p2 && (w2 = ln(p2, "prelu weights", "fused depthwiseConv2d"));
    var R3 = { x: y2, $filter: m2 };
    null != l3 && (R3.$bias = b2), null != p2 && (R3.$preluActivationWeights = w2);
    var I3 = Nt.runKernelFunc(function(t4, e3) {
      var n3 = t4.fusedDepthwiseConv2D({ input: y2, filter: m2, convInfo: C3, bias: b2, activation: f2, preluActivationWeights: w2 });
      return e3([y2, m2, n3]), n3;
    }, R3, function(t4, e3) {
      g(Ro(s2), function() {
        return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + s2 + "'";
      });
      var n3 = e3[0], r3 = e3[1], o3 = e3[2], a3 = gh(t4, o3, f2), i3 = {};
      return null != l3 && (i3 = { $bias: function() {
        return yh(b2, a3);
      } }), Object.assign({ x: function() {
        return _c(n3.shape, a3, r3, C3);
      }, $filter: function() {
        return Mc(n3, a3, r3.shape, C3);
      } }, i3);
    });
    return x2 ? I3.as3D(I3.shape[1], I3.shape[2], I3.shape[3]) : I3;
  } });
  var Eh = Object.freeze({ matMul: bh, conv2d: wh, depthwiseConv2d: Ch });
  var Rh = Object.freeze({ image: vh, linalg: sh, losses: oh, spectral: Bl, fused: Eh, signal: Kl, square: Uu, conv1d: Ac, conv2d: Dc, conv3d: Tc, depthwiseConv2d: Oc, separableConv2d: Bc, conv2dTranspose: Pc, conv3dTranspose: Lc, op: Cn, batchNormalization2d: Ss, batchNormalization3d: As, batchNormalization4d: Ds, batchNormalization: Ts, batchNorm: Ns, batchNorm2d: Fs, batchNorm3d: Os, batchNorm4d: _s, booleanMaskAsync: Rc, complex: En, real: Rn, imag: In, concat: Gn, concat1d: Hn, concat2d: qn, concat3d: Kn, concat4d: jn, split: Xn, matMul: Wc, dot: Uc, outerProduct: Vc, reverse: zc, reverse1d: Gc, reverse2d: Hc, reverse3d: qc, reverse4d: Kc, maxPool: $c, avgPool: Yc, pool: Qc, maxPool3d: Jc, avgPool3d: Zc, slice: tl, slice1d: el, slice2d: nl, slice3d: rl, slice4d: ol, abs: Vu, acos: zu, acosh: Gu, asin: Hu, asinh: qu, atan: Ku, atanh: ju, ceil: Xu, clipByValue: $u, cos: Yu, cosh: Qu, erf: Ju, exp: Zu, expm1: ts, floor: es, log: ns, log1p: rs, logSigmoid: os, neg: as, reciprocal: is, round: us, rsqrt: ss, sigmoid: cs, sign: ls, isNaN: hs, isInf: fs, isFinite: ps, sin: ds, sinh: vs, softplus: ms, sqrt: gs, step: ys, tan: xs, tanh: bs, all: il, any: ul, argMax: sl, argMin: cl, logSumExp: ll, max: hl, mean: fl, min: pl, moments: dl, sum: vl, prod: ml, equal: sc, equalStrict: cc, greater: lc, greaterEqual: hc, greaterEqualStrict: fc, greaterStrict: pc, less: dc, lessEqual: vc, lessEqualStrict: mc, lessStrict: gc, notEqual: yc, notEqualStrict: xc, add: Vs, addN: zs, addStrict: Gs, atan2: Hs, div: qs, divStrict: Ks, floorDiv: js, maximum: Xs, maximumStrict: $s, minimum: Ys, minimumStrict: Qs, mod: Js, modStrict: Zs, mul: tc, mulStrict: ec, pow: nc, powStrict: rc, squaredDifference: oc, squaredDifferenceStrict: ac, sub: ic, subStrict: uc, elu: gl, leakyRelu: yl, prelu: xl, relu: bl, relu6: wl, selu: Cl, logicalAnd: Ms, logicalNot: Bs, logicalOr: Ps, logicalXor: Ls, where: Ws, whereAsync: Us, buffer: ur, print: sr, batchToSpaceND: cr, cast: lr, clone: hr, cumsum: fr, depthToSpace: pr, expandDims: dr, eye: vr, multinomial: mr, oneHot: gr, pad: yr, pad1d: xr, pad2d: br, pad3d: wr, pad4d: Cr, rand: Er, randomNormal: Rr, randomGamma: Ir, randomUniform: kr, reshape: Sr, spaceToBatchND: Ar, squeeze: Dr, stack: Tr, tile: Nr, truncatedNormal: Fr, unstack: Or, setdiff1dAsync: _r, fill: Ln, linspace: Wn, ones: Bn, range: Un, scalar: An, tensor: kn, tensor1d: Dn, tensor2d: Tn, tensor3d: Nn, tensor4d: Fn, tensor5d: On, tensor6d: _n, variable: Mn, zeros: Pn, onesLike: Vn, zerosLike: zn, transpose: El, softmax: io, logSoftmax: uo, localResponseNormalization: Rl, norm: Il, gather: Cc, unsortedSegmentSum: Ec, basicLSTMCell: kl, multiRNNCell: Sl, movingAverage: Al, stridedSlice: Dl, topk: Tl, scatterND: Nl, fft: Fl, ifft: Ol, rfft: _l, irfft: Ml, sparseToDense: Pl, gatherND: Ll, diag: Wl, dropout: Ul, hannWindow: zl, hammingWindow: Gl, frame: Hl, stft: ql, inTopKAsync: Xl });
  function Ih(t3, e2) {
    Array.isArray(t3) || (t3 = [t3]), t3.forEach(function(t4) {
      null != t4 && g("complex64" !== t4.dtype, function() {
        return e2 + " does not support complex64 tensors.";
      });
    });
  }
  function kh(t3, e2, n2, r2) {
    if ("linear" === n2)
      return t3.linear(e2);
    if ("relu" === n2)
      return t3.relu(e2);
    if ("elu" === n2)
      return t3.elu(e2);
    if ("relu6" === n2)
      return t3.relu6(e2);
    if ("prelu" === n2)
      return t3.prelu(e2, r2);
    throw new Error("Activation " + n2 + " has not been implemented for the CPU backend.");
  }
  var Sh = function(t3) {
    function o2() {
      var e2 = t3.call(this) || this;
      if (e2.blockSize = 48, e2.firstUse = true, a().get("IS_BROWSER")) {
        var n2 = "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(300, 150) : "undefined" != typeof document ? document.createElement("canvas") : null;
        null !== n2 && (e2.fromPixels2DContext = n2.getContext("2d"));
      }
      return e2.data = new so(e2, Nt), e2;
    }
    return e(o2, t3), o2.prototype.write = function(t4, e2, n2) {
      this.firstUse && (this.firstUse = false, a().get("IS_NODE") && un("\n============================\nHi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================\n"));
      var r2 = {};
      return this.data.set(r2, { values: t4, dtype: n2 }), r2;
    }, o2.prototype.move = function(t4, e2, n2, r2) {
      this.data.set(t4, { values: e2, dtype: r2 });
    }, o2.prototype.numDataIds = function() {
      return this.data.numDataIds();
    }, o2.prototype.fromPixels = function(t4, e2) {
      if (null == t4)
        throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
      var n2, r2, o3 = t4.data instanceof Uint8Array, i2 = "undefined" != typeof ImageData && t4 instanceof ImageData, u2 = "undefined" != typeof HTMLVideoElement && t4 instanceof HTMLVideoElement, s2 = "undefined" != typeof HTMLImageElement && t4 instanceof HTMLImageElement, c2 = u2 ? [t4.videoWidth, t4.videoHeight] : [t4.width, t4.height], l3 = c2[0], h = c2[1];
      if (a().get("IS_NODE") && null == t4.getContext)
        throw new Error("When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package");
      if (null != t4.getContext)
        n2 = t4.getContext("2d").getImageData(0, 0, l3, h).data;
      else if (i2 || o3)
        n2 = t4.data;
      else {
        if (!s2 && !u2)
          throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData or {data: Uint32Array, width: number, height: number}, but was " + t4.constructor.name);
        if (null == this.fromPixels2DContext)
          throw new Error("Can't read pixels from HTMLImageElement outside the browser.");
        this.fromPixels2DContext.canvas.width = l3, this.fromPixels2DContext.canvas.height = h, this.fromPixels2DContext.drawImage(t4, 0, 0, l3, h), n2 = this.fromPixels2DContext.getImageData(0, 0, l3, h).data;
      }
      if (4 === e2)
        r2 = new Int32Array(n2);
      else {
        var f2 = l3 * h;
        r2 = new Int32Array(f2 * e2);
        for (var p2 = 0; p2 < f2; p2++)
          for (var d2 = 0; d2 < e2; ++d2)
            r2[p2 * e2 + d2] = n2[4 * p2 + d2];
      }
      return Nn(r2, [h, l3, e2], "int32");
    }, o2.prototype.read = function(t4) {
      return n(this, void 0, void 0, function() {
        return r(this, function(e2) {
          return [2, this.readSync(t4)];
        });
      });
    }, o2.prototype.readSync = function(t4) {
      var e2 = this.data.get(t4), n2 = e2.dtype, r2 = e2.complexTensors;
      return "complex64" === n2 ? No(this.readSync(r2.real.dataId), this.readSync(r2.imag.dataId)) : this.data.get(t4).values;
    }, o2.prototype.bufferSync = function(t4) {
      var e2 = this.readSync(t4.dataId), n2 = e2;
      if ("string" === t4.dtype)
        try {
          n2 = e2.map(function(t5) {
            return Z(t5);
          });
        } catch (t5) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
      return ur(t4.shape, t4.dtype, n2);
    }, o2.prototype.makeOutput = function(t4, e2, n2) {
      var r2 = this.write(t4, e2, n2);
      return Nt.makeTensorFromDataId(r2, e2, n2, this);
    }, o2.prototype.disposeData = function(t4) {
      if (this.data.has(t4)) {
        var e2 = this.data.get(t4).complexTensors;
        null != e2 && (e2.real.dispose(), e2.imag.dispose()), this.data.delete(t4);
      }
    }, o2.prototype.time = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2;
        return r(this, function(n2) {
          return e2 = Y(), t4(), [2, { kernelMs: Y() - e2 }];
        });
      });
    }, o2.prototype.memory = function() {
      return { unreliable: true, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."] };
    }, o2.prototype.complex = function(t4, e2) {
      var n2 = this.makeOutput(null, t4.shape, "complex64");
      return this.data.get(n2.dataId).complexTensors = { real: Nt.keep(t4.clone()), imag: Nt.keep(e2.clone()) }, n2;
    }, o2.prototype.real = function(t4) {
      return this.data.get(t4.dataId).complexTensors.real.clone();
    }, o2.prototype.imag = function(t4) {
      return this.data.get(t4.dataId).complexTensors.imag.clone();
    }, o2.prototype.slice = function(t4, e2, n2) {
      if (Ih(t4, "slice"), Yr(t4.shape, e2, n2)) {
        var r2 = Qr(e2, t4.strides), o3 = w(n2);
        return kn(this.readSync(t4.dataId).subarray(r2, r2 + o3), n2, t4.dtype);
      }
      for (var a2 = ur(n2, t4.dtype), i2 = this.bufferSync(t4), u2 = 0; u2 < a2.size; ++u2) {
        var s2 = a2.indexToLoc(u2).map(function(t5, n3) {
          return t5 + e2[n3];
        });
        a2.values[u2] = i2.get.apply(i2, s2);
      }
      return a2.toTensor();
    }, o2.prototype.stridedSlice = function(t4, e2, n2, r2) {
      Ih(t4, "stridedSlice");
      var o3 = jr(e2, n2, r2);
      if (o3.some(function(t5) {
        return 0 === t5;
      }))
        return kn([], o3);
      for (var a2 = ur(o3, t4.dtype), i2 = this.bufferSync(t4), u2 = 0; u2 < a2.size; u2++) {
        for (var s2 = a2.indexToLoc(u2), c2 = new Array(s2.length), l3 = 0; l3 < c2.length; l3++)
          c2[l3] = s2[l3] * r2[l3] + e2[l3];
        a2.set.apply(a2, [i2.get.apply(i2, c2)].concat(s2));
      }
      return a2.toTensor();
    }, o2.prototype.diag = function(t4) {
      for (var e2 = this.readSync(t4.dataId), n2 = ur([t4.size, t4.size], t4.dtype), r2 = n2.values, o3 = 0; o3 < e2.length; o3++)
        r2[o3 * t4.size + o3] = e2[o3];
      return n2.toTensor();
    }, o2.prototype.unstack = function(t4, e2) {
      for (var n2 = t4.shape[e2], r2 = new Array(t4.rank - 1), o3 = 0, a2 = 0; a2 < t4.rank; a2++)
        a2 !== e2 && (r2[o3++] = t4.shape[a2]);
      var i2 = new Array(t4.rank).fill(0), u2 = t4.shape.slice();
      u2[e2] = 1;
      var s2 = new Array(n2);
      for (a2 = 0; a2 < s2.length; a2++)
        i2[e2] = a2, s2[a2] = this.slice(t4, i2, u2).reshape(r2);
      return s2;
    }, o2.prototype.reverse = function(t4, e2) {
      Ih(t4, "reverse");
      for (var n2 = ur(t4.shape, t4.dtype), r2 = this.bufferSync(t4), o3 = function(o4) {
        var a3 = n2.indexToLoc(o4), i2 = a3.slice();
        e2.forEach(function(e3) {
          return i2[e3] = t4.shape[e3] - 1 - i2[e3];
        }), n2.set.apply(n2, [r2.get.apply(r2, i2)].concat(a3));
      }, a2 = 0; a2 < n2.size; a2++)
        o3(a2);
      return n2.toTensor();
    }, o2.prototype.concat = function(t4, e2) {
      var n2 = this;
      if ("complex64" === t4[0].dtype) {
        var r2 = t4.map(function(t5) {
          return Rn(t5);
        }), o3 = t4.map(function(t5) {
          return In(t5);
        });
        return En(this.concat(r2, e2), this.concat(o3, e2));
      }
      var a2 = t4.map(function(t5) {
        var n3 = w(t5.shape.slice(e2));
        return t5.as2D(-1, n3);
      }), i2 = wn(a2.map(function(t5) {
        return t5.shape;
      }), 1), u2 = ur(i2, t4[0].dtype).values;
      if (1 === a2[0].shape[0]) {
        var s2 = 0;
        a2.forEach(function(t5) {
          u2.set(n2.readSync(t5.dataId), s2), s2 += t5.size;
        });
      } else {
        var c2 = 0;
        a2.forEach(function(t5) {
          for (var e3 = n2.readSync(t5.dataId), r3 = 0, o4 = 0; o4 < t5.shape[0]; ++o4)
            for (var a3 = o4 * i2[1] + c2, s3 = 0; s3 < t5.shape[1]; ++s3)
              u2[a3 + s3] = e3[r3++];
          c2 += t5.shape[1];
        });
      }
      var l3 = wn(t4.map(function(t5) {
        return t5.shape;
      }), e2);
      return kn(u2, l3, t4[0].dtype);
    }, o2.prototype.neg = function(t4) {
      return Ih(t4, "neg"), this.multiply(An(-1), t4);
    }, o2.prototype.add = function(t4, e2) {
      return "complex64" === t4.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t4.cast("complex64"), e2.cast("complex64"), function(t5, e3, n2, r2) {
        return { real: t5 + n2, imag: e3 + r2 };
      }) : this.broadcastedBinaryOp(t4, e2, Ct(t4.dtype, e2.dtype), function(t5, e3) {
        return t5 + e3;
      });
    }, o2.prototype.addN = function(t4) {
      var e2 = this;
      Ih(t4, "addN");
      for (var n2 = t4.map(function(t5) {
        return e2.readSync(t5.dataId);
      }), r2 = ur(t4[0].shape, t4[0].dtype), o3 = r2.values, a2 = 0; a2 < t4.length; a2++)
        for (var i2 = n2[a2], u2 = 0; u2 < o3.length; u2++)
          o3[u2] += i2[u2];
      return r2.toTensor();
    }, o2.prototype.subtract = function(t4, e2) {
      return "complex64" === t4.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t4.cast("complex64"), e2.cast("complex64"), function(t5, e3, n2, r2) {
        return { real: t5 - n2, imag: e3 - r2 };
      }) : this.broadcastedBinaryOp(t4, e2, Ct(t4.dtype, e2.dtype), function(t5, e3) {
        return t5 - e3;
      });
    }, o2.prototype.pow = function(t4, e2) {
      return Ih([t4, e2], "pow"), this.broadcastedBinaryOp(t4, e2, t4.dtype, function(t5, e3) {
        return Math.pow(t5, e3);
      });
    }, o2.prototype.batchMatMul = function(t4, e2, n2, r2) {
      Ih([t4, e2], "matMul");
      for (var o3 = n2 ? t4.shape[1] : t4.shape[2], a2 = n2 ? t4.shape[2] : t4.shape[1], i2 = r2 ? e2.shape[1] : e2.shape[2], u2 = t4.shape[0], s2 = this.readSync(t4.dataId), c2 = this.readSync(e2.dataId), l3 = n2 ? [t4.strides[0], 1, t4.strides[1]] : [t4.strides[0], t4.strides[1], 1], h = l3[0], f2 = l3[1], p2 = l3[2], d2 = r2 ? [1, e2.strides[1], e2.strides[0]] : [e2.strides[1], 1, e2.strides[0]], v2 = d2[0], m2 = d2[1], g2 = d2[2], y2 = a2 * i2, x2 = ur([u2, a2, i2], t4.dtype), b2 = x2.values, w2 = this.blockSize, C3 = 0; C3 < u2; C3++)
        for (var E3 = 0; E3 < a2; E3 += w2)
          for (var R3 = 0; R3 < i2; R3 += w2)
            for (var I3 = 0; I3 < o3; I3 += w2)
              for (var k4 = Math.min(E3 + w2, a2), S3 = Math.min(R3 + w2, i2), A2 = Math.min(I3 + w2, o3), D3 = E3; D3 < k4; D3++)
                for (var T2 = R3; T2 < S3; T2++) {
                  for (var N3 = 0, F3 = I3; F3 < A2; F3++)
                    N3 += s2[C3 * h + D3 * f2 + F3 * p2] * c2[F3 * v2 + T2 * m2 + C3 * g2];
                  b2[C3 * y2 + (D3 * i2 + T2)] += N3;
                }
      return x2.toTensor();
    }, o2.prototype.fusedBatchMatMul = function(t4) {
      var e2 = t4.a, n2 = t4.b, r2 = t4.transposeA, o3 = t4.transposeB, a2 = t4.bias, i2 = t4.activation, u2 = t4.preluActivationWeights, s2 = this.batchMatMul(e2, n2, r2, o3);
      return a2 && (s2 = this.add(s2, a2)), i2 && (s2 = kh(this, s2, i2, u2)), s2;
    }, o2.prototype.multiply = function(t4, e2) {
      return "complex64" === t4.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t4.cast("complex64"), e2.cast("complex64"), function(t5, e3, n2, r2) {
        return { real: t5 * n2 - e3 * r2, imag: t5 * r2 + e3 * n2 };
      }) : this.broadcastedBinaryOp(t4, e2, Ct(t4.dtype, e2.dtype), function(t5, e3) {
        return t5 * e3;
      });
    }, o2.prototype.realDivide = function(t4, e2) {
      Ih([t4, e2], "realDivide");
      return this.broadcastedBinaryOp(t4, e2, "float32", function(t5, e3) {
        return t5 / e3;
      });
    }, o2.prototype.floorDiv = function(t4, e2) {
      Ih([t4, e2], "floorDiv");
      return this.broadcastedBinaryOp(t4, e2, "int32", function(t5, e3) {
        return Math.floor(t5 / e3);
      });
    }, o2.prototype.sum = function(t4, e2) {
      Ih(t4, "sum"), mn("sum", e2, t4.rank);
      for (var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, Ct(t4.dtype, "int32")), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t4.dataId), c2 = 0; c2 < u2.length; ++c2) {
        for (var l3 = c2 * i2, h = 0, f2 = 0; f2 < i2; ++f2)
          h += s2[l3 + f2];
        u2[c2] = h;
      }
      return a2;
    }, o2.prototype.prod = function(t4, e2) {
      Ih(t4, "sum");
      for (var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, Ct(t4.dtype, "int32")), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t4.dataId), c2 = 0; c2 < u2.length; ++c2) {
        for (var l3 = c2 * i2, h = 1, f2 = 0; f2 < i2; ++f2)
          h *= s2[l3 + f2];
        u2[c2] = h;
      }
      return a2;
    }, o2.prototype.unsortedSegmentSum = function(t4, e2, n2) {
      Ih(t4, "unsortedSegmentSum");
      for (var r2 = [], o3 = t4.rank - e2.rank, a2 = 0; a2 < o3; ++a2)
        e2 = e2.expandDims(a2 + 1);
      for (a2 = 0; a2 < n2; ++a2) {
        var i2 = An(a2, "int32"), u2 = sc(i2, e2).asType("float32").mul(t4).sum(0);
        r2.push(u2);
      }
      return Tr(r2);
    }, o2.prototype.argMin = function(t4, e2) {
      Ih(t4, "argMin");
      var n2 = [e2];
      mn("argMin", n2, t4.rank);
      for (var r2 = dn(t4.shape, n2), o3 = r2[0], a2 = r2[1], i2 = Pn(o3, "int32"), u2 = w(a2), s2 = this.readSync(i2.dataId), c2 = this.readSync(t4.dataId), l3 = 0; l3 < s2.length; ++l3) {
        for (var h = l3 * u2, f2 = c2[h], p2 = 0, d2 = 0; d2 < u2; ++d2) {
          var v2 = c2[h + d2];
          v2 < f2 && (f2 = v2, p2 = d2);
        }
        s2[l3] = p2;
      }
      return i2;
    }, o2.prototype.argMax = function(t4, e2) {
      Ih(t4, "argMax");
      var n2 = [e2];
      mn("argMax", n2, t4.rank);
      for (var r2 = dn(t4.shape, n2), o3 = r2[0], a2 = r2[1], i2 = Pn(o3, "int32"), u2 = w(a2), s2 = this.readSync(i2.dataId), c2 = this.readSync(t4.dataId), l3 = 0; l3 < s2.length; ++l3) {
        for (var h = l3 * u2, f2 = c2[h], p2 = 0, d2 = 0; d2 < u2; ++d2) {
          var v2 = c2[h + d2];
          v2 > f2 && (f2 = v2, p2 = d2);
        }
        s2[l3] = p2;
      }
      return i2;
    }, o2.prototype.cumsum = function(t4, e2, n2, r2) {
      if (Ih(t4, "cumsum"), e2 !== t4.rank - 1)
        throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t4.rank - 1) + " but got axis=" + e2);
      for (var o3 = Ct(t4.dtype, "int32"), a2 = Pn(t4.shape, o3), i2 = this.readSync(a2.dataId), u2 = this.readSync(t4.dataId), s2 = t4.shape[t4.rank - 1], c2 = r2 ? function(t5, e3) {
        return t5 + s2 - e3 - 1;
      } : function(t5, e3) {
        return t5 + e3;
      }, l3 = 0; l3 < u2.length; l3 += s2)
        for (var h = 0; h < s2; h++) {
          var f2 = c2(l3, h);
          if (0 === h)
            i2[f2] = n2 ? 0 : u2[f2];
          else {
            var p2 = c2(l3, h - 1);
            i2[f2] = n2 ? u2[p2] + i2[p2] : u2[f2] + i2[p2];
          }
        }
      return a2;
    }, o2.prototype.equal = function(t4, e2) {
      return Ih([t4, e2], "equal"), this.broadcastedBinaryOp(t4, e2, "bool", function(t5, e3) {
        return t5 === e3 ? 1 : 0;
      });
    }, o2.prototype.notEqual = function(t4, e2) {
      return Ih([t4, e2], "notEqual"), this.broadcastedBinaryOp(t4, e2, "bool", function(t5, e3) {
        return t5 !== e3 ? 1 : 0;
      });
    }, o2.prototype.less = function(t4, e2) {
      return Ih([t4, e2], "less"), this.broadcastedBinaryOp(t4, e2, "bool", function(t5, e3) {
        return t5 < e3 ? 1 : 0;
      });
    }, o2.prototype.lessEqual = function(t4, e2) {
      return Ih([t4, e2], "lessEqual"), this.broadcastedBinaryOp(t4, e2, "bool", function(t5, e3) {
        return t5 <= e3 ? 1 : 0;
      });
    }, o2.prototype.greater = function(t4, e2) {
      return Ih([t4, e2], "greater"), this.broadcastedBinaryOp(t4, e2, "bool", function(t5, e3) {
        return t5 > e3 ? 1 : 0;
      });
    }, o2.prototype.greaterEqual = function(t4, e2) {
      return Ih([t4, e2], "greaterEqual"), this.broadcastedBinaryOp(t4, e2, "bool", function(t5, e3) {
        return t5 >= e3 ? 1 : 0;
      });
    }, o2.prototype.logicalNot = function(t4) {
      Ih(t4, "logicalNot");
      for (var e2 = this.readSync(t4.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
        n2[r2] = e2[r2] ? 0 : 1;
      return this.makeOutput(n2, t4.shape, "bool");
    }, o2.prototype.logicalAnd = function(t4, e2) {
      return Ih([t4, e2], "logicalAnd"), this.broadcastedBinaryOp(t4, e2, "bool", function(t5, e3) {
        return t5 && e3;
      });
    }, o2.prototype.logicalOr = function(t4, e2) {
      return Ih([t4, e2], "logicalOr"), this.broadcastedBinaryOp(t4, e2, "bool", function(t5, e3) {
        return t5 || e3;
      });
    }, o2.prototype.select = function(t4, e2, n2) {
      Ih([t4, e2, n2], "select");
      for (var r2 = this.readSync(t4.dataId), o3 = this.readSync(e2.dataId), a2 = this.readSync(n2.dataId), i2 = Pn(e2.shape, Ct(e2.dtype, n2.dtype)), u2 = this.readSync(i2.dataId), s2 = 0, c2 = 0 === t4.rank || t4.rank > 1 || 1 === e2.rank ? 1 : w(e2.shape.slice(1)), l3 = 0; l3 < r2.length; l3++)
        for (var h = 0; h < c2; h++)
          1 === r2[l3] ? u2[s2++] = o3[l3] : u2[s2++] = a2[l3];
      return i2;
    }, o2.prototype.where = function(t4) {
      Ih([t4], "where");
      var e2 = this.readSync(t4.dataId);
      return Uo(t4.shape, e2);
    }, o2.prototype.topk = function(t4, e2, n2) {
      return Ih(t4, "topk"), Wo(this.readSync(t4.dataId), t4.shape, t4.dtype, e2);
    }, o2.prototype.min = function(t4, e2) {
      Ih(t4, "min"), mn("min", e2, t4.rank);
      for (var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t4.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t4.dataId), c2 = 0; c2 < u2.length; ++c2) {
        for (var l3 = c2 * i2, h = s2[l3], f2 = 0; f2 < i2; ++f2) {
          var p2 = s2[l3 + f2];
          p2 < h && (h = p2);
        }
        u2[c2] = h;
      }
      return a2;
    }, o2.prototype.minimum = function(t4, e2) {
      return Ih([t4, e2], "minimum"), this.broadcastedBinaryOp(t4, e2, t4.dtype, function(t5, e3) {
        return Math.min(t5, e3);
      });
    }, o2.prototype.mod = function(t4, e2) {
      return Ih([t4, e2], "mod"), this.broadcastedBinaryOp(t4, e2, t4.dtype, function(t5, e3) {
        var n2 = t5 % e3;
        return t5 < 0 && e3 < 0 || t5 >= 0 && e3 >= 0 ? n2 : (n2 + e3) % e3;
      });
    }, o2.prototype.max = function(t4, e2) {
      Ih(t4, "max"), mn("max", e2, t4.rank);
      for (var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t4.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t4.dataId), c2 = 0; c2 < u2.length; ++c2) {
        for (var l3 = c2 * i2, h = s2[l3], f2 = 0; f2 < i2; ++f2) {
          var p2 = s2[l3 + f2];
          p2 > h && (h = p2);
        }
        u2[c2] = h;
      }
      return a2;
    }, o2.prototype.maximum = function(t4, e2) {
      return Ih([t4, e2], "maximum"), this.broadcastedBinaryOp(t4, e2, t4.dtype, function(t5, e3) {
        return Math.max(t5, e3);
      });
    }, o2.prototype.all = function(t4, e2) {
      Ih(t4, "all"), mn("all", e2, t4.rank);
      for (var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t4.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t4.dataId), c2 = 0; c2 < u2.length; ++c2) {
        for (var l3 = c2 * i2, h = s2[l3], f2 = 0; f2 < i2; ++f2) {
          var p2 = s2[l3 + f2];
          h = h && p2;
        }
        u2[c2] = h;
      }
      return a2;
    }, o2.prototype.any = function(t4, e2) {
      Ih(t4, "any"), mn("any", e2, t4.rank);
      for (var n2 = dn(t4.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t4.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t4.dataId), c2 = 0; c2 < u2.length; ++c2) {
        for (var l3 = c2 * i2, h = s2[l3], f2 = 0; f2 < i2; ++f2) {
          var p2 = s2[l3 + f2];
          h = h || p2;
        }
        u2[c2] = h;
      }
      return a2;
    }, o2.prototype.squaredDifference = function(t4, e2) {
      return Ih([t4, e2], "squaredDifference"), this.broadcastedBinaryOp(t4, e2, t4.dtype, function(t5, e3) {
        var n2 = t5 - e3;
        return n2 * n2;
      });
    }, o2.prototype.ceil = function(t4) {
      Ih(t4, "ceil");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
        n2[r2] = Math.ceil(e2[r2]);
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.floor = function(t4) {
      Ih(t4, "floor");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
        n2[r2] = Math.floor(e2[r2]);
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.sign = function(t4) {
      Ih(t4, "x");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
        e2[r2] < 0 ? n2[r2] = -1 : e2[r2] > 0 ? n2[r2] = 1 : n2[r2] = 0;
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.isNaN = function(t4) {
      Ih(t4, "x");
      for (var e2 = this.readSync(t4.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
        Number.isNaN(e2[r2]) && (n2[r2] = 1);
      return this.makeOutput(n2, t4.shape, "bool");
    }, o2.prototype.isInf = function(t4) {
      Ih(t4, "x");
      for (var e2 = this.readSync(t4.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
        Math.abs(e2[r2]) === 1 / 0 && (n2[r2] = 1);
      return this.makeOutput(n2, t4.shape, "bool");
    }, o2.prototype.isFinite = function(t4) {
      Ih(t4, "x");
      for (var e2 = this.readSync(t4.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
        Number.isFinite(e2[r2]) && (n2[r2] = 1);
      return this.makeOutput(n2, t4.shape, "bool");
    }, o2.prototype.round = function(t4) {
      Ih(t4, "round");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
        var o3 = Math.floor(e2[r2]);
        e2[r2] - o3 < 0.5 ? n2[r2] = Math.floor(e2[r2]) : e2[r2] - o3 > 0.5 ? n2[r2] = Math.ceil(e2[r2]) : n2[r2] = o3 % 2 == 0 ? o3 : o3 + 1;
      }
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.exp = function(t4) {
      Ih(t4, "exp");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
        n2[r2] = Math.exp(e2[r2]);
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.expm1 = function(t4) {
      Ih(t4, "expm1");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
        n2[r2] = Math.expm1(e2[r2]);
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.log = function(t4) {
      Ih(t4, "log");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
        var o3 = e2[r2];
        n2[r2] = Math.log(o3);
      }
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.log1p = function(t4) {
      Ih(t4, "log1p");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
        var o3 = e2[r2];
        n2[r2] = Math.log1p(o3);
      }
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.sqrt = function(t4) {
      Ih(t4, "sqrt");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
        var o3 = e2[r2];
        n2[r2] = Math.sqrt(o3);
      }
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.rsqrt = function(t4) {
      Ih(t4, "rsqrt");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
        var o3 = e2[r2];
        n2[r2] = 1 / Math.sqrt(o3);
      }
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.reciprocal = function(t4) {
      Ih(t4, "reciprocal");
      for (var e2 = this.readSync(t4.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
        n2[r2] = 1 / e2[r2];
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.linear = function(t4) {
      return t4;
    }, o2.prototype.relu = function(t4) {
      Ih(t4, "relu");
      for (var e2 = Pn(t4.shape, t4.dtype), n2 = this.readSync(e2.dataId), r2 = this.readSync(t4.dataId), o3 = 0; o3 < r2.length; ++o3)
        n2[o3] = Math.max(0, r2[o3]);
      return e2;
    }, o2.prototype.relu6 = function(t4) {
      Ih(t4, "relu");
      for (var e2 = Pn(t4.shape, t4.dtype), n2 = this.readSync(e2.dataId), r2 = this.readSync(t4.dataId), o3 = 0; o3 < r2.length; ++o3)
        n2[o3] = Math.min(Math.max(0, r2[o3]), 6);
      return e2;
    }, o2.prototype.prelu = function(t4, e2) {
      return Ih([t4, e2], "prelu"), this.broadcastedBinaryOp(t4, e2, t4.dtype, function(t5, e3) {
        return t5 < 0 ? e3 * t5 : t5;
      });
    }, o2.prototype.elu = function(t4) {
      Ih(t4, "elu");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2) {
        var o3 = n2[r2];
        e2[r2] = o3 >= 0 ? o3 : Math.exp(o3) - 1;
      }
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.eluDer = function(t4, e2) {
      Ih([t4, e2], "eluDer");
      for (var n2 = new Float32Array(e2.size), r2 = this.readSync(e2.dataId), o3 = this.readSync(t4.dataId), a2 = 0; a2 < r2.length; ++a2) {
        var i2 = r2[a2];
        n2[a2] = i2 >= 1 ? o3[a2] : o3[a2] * (i2 + 1);
      }
      return this.makeOutput(n2, e2.shape, "float32");
    }, o2.prototype.selu = function(t4) {
      Ih(t4, "selu");
      for (var e2 = iu, n2 = uu, r2 = new Float32Array(t4.size), o3 = this.readSync(t4.dataId), a2 = 0; a2 < o3.length; ++a2) {
        var i2 = o3[a2];
        r2[a2] = i2 >= 0 ? n2 * i2 : e2 * (Math.exp(i2) - 1);
      }
      return this.makeOutput(r2, t4.shape, "float32");
    }, o2.prototype.clip = function(t4, e2, n2) {
      Ih(t4, "clip");
      for (var r2 = new Float32Array(t4.size), o3 = this.readSync(t4.dataId), a2 = 0; a2 < o3.length; ++a2) {
        var i2 = o3[a2];
        r2[a2] = i2 > n2 ? n2 : i2 < e2 ? e2 : i2;
      }
      return this.makeOutput(r2, t4.shape, "float32");
    }, o2.prototype.abs = function(t4) {
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.abs(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.complexAbs = function(t4) {
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < t4.size; ++r2) {
        var o3 = n2[2 * r2], a2 = n2[2 * r2 + 1];
        e2[r2] = Math.hypot(o3, a2);
      }
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.int = function(t4) {
      Ih(t4, "int");
      for (var e2 = new Int32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = n2[r2];
      return this.makeOutput(e2, t4.shape, "int32");
    }, o2.prototype.sigmoid = function(t4) {
      Ih(t4, "sigmoid");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = 1 / (1 + Math.exp(-n2[r2]));
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.softplus = function(t4) {
      Ih(t4, "softplus");
      for (var e2 = Math.log(11920928955078125e-23) + 2, n2 = new Float32Array(t4.size), r2 = this.readSync(t4.dataId), o3 = 0; o3 < r2.length; ++o3) {
        var a2 = r2[o3] > -e2, i2 = r2[o3] < e2, u2 = Math.exp(r2[o3]), s2 = void 0;
        s2 = i2 ? u2 : a2 ? r2[o3] : Math.log(1 + u2), n2[o3] = s2;
      }
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.sin = function(t4) {
      Ih(t4, "sin");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.sin(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.cos = function(t4) {
      Ih(t4, "cos");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.cos(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.tan = function(t4) {
      Ih(t4, "tan");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.tan(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.asin = function(t4) {
      Ih(t4, "asin");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.asin(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.acos = function(t4) {
      Ih(t4, "acos");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.acos(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.atan = function(t4) {
      Ih(t4, "atan");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.atan(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.atan2 = function(t4, e2) {
      return Ih([t4, e2], "atan2"), this.broadcastedBinaryOp(t4, e2, t4.dtype, function(t5, e3) {
        return Math.atan2(t5, e3);
      });
    }, o2.prototype.sinh = function(t4) {
      Ih(t4, "sinh");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.sinh(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.cosh = function(t4) {
      Ih(t4, "cosh");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.cosh(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.tanh = function(t4) {
      Ih(t4, "tanh");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = R(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.asinh = function(t4) {
      Ih(t4, "asinh");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.asinh(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.acosh = function(t4) {
      Ih(t4, "acosh");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.acosh(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.atanh = function(t4) {
      Ih(t4, "atanh");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2)
        e2[r2] = Math.atanh(n2[r2]);
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.erf = function(t4) {
      Ih(t4, "erf");
      for (var e2 = new Float32Array(t4.size), n2 = this.readSync(t4.dataId), r2 = 0; r2 < n2.length; ++r2) {
        var o3 = Math.sign(n2[r2]), a2 = Math.abs(n2[r2]), i2 = 1 / (1 + 0.3275911 * a2);
        e2[r2] = o3 * (1 - ((((1.061405429 * i2 - 1.453152027) * i2 + 1.421413741) * i2 - 0.284496736) * i2 + 0.254829592) * i2 * Math.exp(-a2 * a2));
      }
      return this.makeOutput(e2, t4.shape, "float32");
    }, o2.prototype.step = function(t4, e2) {
      void 0 === e2 && (e2 = 0), Ih(t4, "step");
      for (var n2 = new Float32Array(t4.size), r2 = this.readSync(t4.dataId), o3 = 0; o3 < r2.length; ++o3) {
        var a2 = r2[o3];
        isNaN(a2) ? n2[o3] = NaN : n2[o3] = a2 > 0 ? 1 : e2;
      }
      return this.makeOutput(n2, t4.shape, "float32");
    }, o2.prototype.fusedConv2d = function(t4) {
      var e2 = t4.input, n2 = t4.filter, r2 = t4.convInfo, o3 = t4.bias, a2 = t4.activation, i2 = t4.preluActivationWeights, u2 = this.conv2d(e2, n2, r2);
      return o3 && (u2 = this.add(u2, o3)), a2 && (u2 = kh(this, u2, a2, i2)), u2;
    }, o2.prototype.conv2d = function(t4, e2, n2) {
      Ih([t4, e2], "conv2d");
      for (var r2 = n2.filterHeight, o3 = n2.filterWidth, a2 = n2.dilationHeight, i2 = n2.dilationWidth, u2 = n2.padInfo.left, s2 = n2.padInfo.top, c2 = "channelsLast" === n2.dataFormat, l3 = ur(n2.outShape, t4.dtype), h = t4.strides[0], f2 = c2 ? t4.strides[1] : t4.strides[2], p2 = c2 ? t4.strides[2] : 1, d2 = c2 ? 1 : t4.strides[1], v2 = l3.strides[0], m2 = c2 ? l3.strides[1] : l3.strides[2], g2 = c2 ? l3.strides[2] : 1, y2 = c2 ? 1 : l3.strides[1], x2 = this.readSync(t4.dataId), b2 = this.readSync(e2.dataId), w2 = l3.values, C3 = 0; C3 < n2.batchSize; ++C3)
        for (var E3 = C3 * h, R3 = C3 * v2, I3 = 0; I3 < n2.outHeight; ++I3)
          for (var k4 = R3 + I3 * m2, S3 = I3 * n2.strideHeight - s2, A2 = 0; A2 < r2; A2++) {
            var D3 = S3 + A2 * a2;
            if (!(D3 < 0 || D3 >= n2.inHeight))
              for (var T2 = A2 * e2.strides[0], N3 = E3 + D3 * f2, F3 = 0; F3 < n2.outWidth; ++F3)
                for (var O3 = k4 + F3 * g2, _3 = F3 * n2.strideWidth - u2, M2 = 0; M2 < o3; M2++) {
                  var B3 = _3 + M2 * i2;
                  if (!(B3 < 0 || B3 >= n2.inWidth))
                    for (var P3 = N3 + B3 * p2, L3 = T2 + M2 * e2.strides[1], W3 = 0; W3 < n2.inChannels; ++W3) {
                      for (var U3 = x2[P3 + W3 * d2], V3 = 0; V3 < n2.outChannels; ++V3)
                        w2[O3 + V3 * y2] += U3 * b2[L3 + V3];
                      L3 += n2.outChannels;
                    }
                }
          }
      return l3.toTensor();
    }, o2.prototype.conv3d = function(t4, e2, n2) {
      for (var r2 = n2.filterDepth, o3 = n2.filterHeight, a2 = n2.filterWidth, i2 = n2.dilationDepth, u2 = n2.dilationHeight, s2 = n2.dilationWidth, c2 = n2.padInfo.front, l3 = n2.padInfo.left, h = n2.padInfo.top, f2 = ur(n2.outShape, t4.dtype), p2 = this.readSync(t4.dataId), d2 = this.readSync(e2.dataId), v2 = f2.values, m2 = 0; m2 < n2.batchSize; ++m2)
        for (var g2 = m2 * t4.strides[0], y2 = m2 * f2.strides[0], x2 = 0; x2 < n2.outDepth; ++x2)
          for (var b2 = y2 + x2 * f2.strides[1], w2 = x2 * n2.strideDepth - c2, C3 = 0; C3 < r2; C3++) {
            var E3 = w2 + C3 * i2;
            if (!(E3 < 0 || E3 >= n2.inDepth))
              for (var R3 = C3 * e2.strides[0], I3 = g2 + E3 * t4.strides[1], k4 = 0; k4 < n2.outHeight; ++k4)
                for (var S3 = b2 + k4 * f2.strides[2], A2 = k4 * n2.strideHeight - h, D3 = 0; D3 < o3; D3++) {
                  var T2 = A2 + D3 * u2;
                  if (!(T2 < 0 || T2 >= n2.inHeight))
                    for (var N3 = R3 + D3 * e2.strides[1], F3 = I3 + T2 * t4.strides[2], O3 = 0; O3 < n2.outWidth; ++O3)
                      for (var _3 = S3 + O3 * n2.outChannels, M2 = O3 * n2.strideWidth - l3, B3 = 0; B3 < a2; B3++) {
                        var P3 = M2 + B3 * s2;
                        if (!(P3 < 0 || P3 >= n2.inWidth))
                          for (var L3 = N3 + B3 * e2.strides[2], W3 = F3 + P3 * n2.inChannels, U3 = L3, V3 = 0; V3 < n2.inChannels; ++V3) {
                            for (var z3 = p2[W3 + V3], G3 = 0; G3 < n2.outChannels; ++G3)
                              v2[_3 + G3] += z3 * d2[U3 + G3];
                            U3 += n2.outChannels;
                          }
                      }
                }
          }
      return f2.toTensor();
    }, o2.prototype.conv2dDerInput = function(t4, e2, n2) {
      Ih([t4, e2], "conv2dDerInput");
      for (var r2 = ur(n2.inShape, "float32"), o3 = r2.values, a2 = this.readSync(t4.dataId), i2 = this.readSync(e2.dataId), u2 = e2.strides, s2 = u2[0], c2 = u2[1], l3 = u2[2], h = n2.batchSize, f2 = n2.filterHeight, p2 = n2.filterWidth, d2 = n2.inChannels, v2 = n2.inHeight, m2 = n2.inWidth, g2 = n2.outChannels, y2 = n2.outHeight, x2 = n2.outWidth, b2 = n2.strideHeight, w2 = n2.strideWidth, C3 = n2.dataFormat, E3 = f2 - 1 - n2.padInfo.top, R3 = p2 - 1 - n2.padInfo.left, I3 = "channelsLast" === C3, k4 = r2.strides[0], S3 = I3 ? r2.strides[1] : r2.strides[2], A2 = I3 ? r2.strides[2] : 1, D3 = I3 ? 1 : r2.strides[1], T2 = t4.strides[0], N3 = I3 ? t4.strides[1] : t4.strides[2], F3 = I3 ? t4.strides[2] : 1, O3 = I3 ? 1 : t4.strides[1], _3 = 0; _3 < h; ++_3)
        for (var M2 = 0; M2 < d2; ++M2)
          for (var B3 = 0; B3 < v2; ++B3)
            for (var P3 = B3 - E3, L3 = Math.max(0, Math.ceil(P3 / b2)), W3 = Math.min(y2, (f2 + P3) / b2), U3 = 0; U3 < m2; ++U3) {
              for (var V3 = U3 - R3, z3 = Math.max(0, Math.ceil(V3 / w2)), G3 = Math.min(x2, (p2 + V3) / w2), H3 = 0, q3 = L3; q3 < W3; ++q3)
                for (var K3 = q3 * b2 - P3, j3 = z3; j3 < G3; ++j3)
                  for (var X3 = T2 * _3 + N3 * q3 + F3 * j3, $3 = s2 * (f2 - 1 - K3) + c2 * (p2 - 1 - (j3 * w2 - V3)) + l3 * M2, Y3 = 0; Y3 < g2; ++Y3) {
                    H3 += a2[X3 + O3 * Y3] * i2[$3 + Y3];
                  }
              o3[k4 * _3 + S3 * B3 + A2 * U3 + D3 * M2] = H3;
            }
      return r2.toTensor();
    }, o2.prototype.conv3dDerInput = function(t4, e2, n2) {
      for (var r2 = ur(n2.inShape, "float32"), o3 = r2.values, a2 = r2.strides, i2 = a2[0], u2 = a2[1], s2 = a2[2], c2 = a2[3], l3 = this.readSync(t4.dataId), h = t4.strides, f2 = h[0], p2 = h[1], d2 = h[2], v2 = h[3], m2 = this.readSync(e2.dataId), g2 = e2.strides, y2 = g2[0], x2 = g2[1], b2 = g2[2], w2 = g2[3], C3 = n2.batchSize, E3 = n2.filterDepth, R3 = n2.filterHeight, I3 = n2.filterWidth, k4 = n2.inChannels, S3 = n2.inDepth, A2 = n2.inHeight, D3 = n2.inWidth, T2 = n2.outChannels, N3 = n2.outDepth, F3 = n2.outHeight, O3 = n2.outWidth, _3 = n2.strideDepth, M2 = n2.strideHeight, B3 = n2.strideWidth, P3 = E3 - 1 - n2.padInfo.front, L3 = R3 - 1 - n2.padInfo.top, W3 = I3 - 1 - n2.padInfo.left, U3 = 0; U3 < C3; ++U3)
        for (var V3 = 0; V3 < k4; ++V3)
          for (var z3 = 0; z3 < S3; ++z3)
            for (var G3 = z3 - P3, H3 = Math.max(0, Math.ceil(G3 / _3)), q3 = Math.min(N3, (E3 + G3) / _3), K3 = 0; K3 < A2; ++K3)
              for (var j3 = K3 - L3, X3 = Math.max(0, Math.ceil(j3 / M2)), $3 = Math.min(F3, (R3 + j3) / M2), Y3 = 0; Y3 < D3; ++Y3) {
                for (var Q3 = Y3 - W3, J3 = Math.max(0, Math.ceil(Q3 / B3)), Z3 = Math.min(O3, (I3 + Q3) / B3), tt3 = 0, et3 = H3; et3 < q3; ++et3)
                  for (var nt3 = et3 * _3 - G3, rt3 = X3; rt3 < $3; ++rt3)
                    for (var ot3 = rt3 * M2 - j3, at3 = J3; at3 < Z3; ++at3)
                      for (var it3 = f2 * U3 + p2 * et3 + d2 * rt3 + v2 * at3, ut3 = y2 * (E3 - 1 - nt3) + x2 * (R3 - 1 - ot3) + b2 * (I3 - 1 - (at3 * B3 - Q3)) + w2 * V3, st3 = 0; st3 < T2; ++st3) {
                        tt3 += l3[it3 + st3] * m2[ut3 + st3];
                      }
                o3[i2 * U3 + u2 * z3 + s2 * K3 + c2 * Y3 + V3] = tt3;
              }
      return r2.toTensor();
    }, o2.prototype.conv2dDerFilter = function(t4, e2, n2) {
      Ih([t4, e2], "conv2dDerFilter");
      for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, u2 = "channelsLast" === n2.dataFormat, s2 = ur(n2.filterShape, "float32"), c2 = n2.padInfo.left, l3 = n2.padInfo.top, h = this.bufferSync(t4), f2 = this.bufferSync(e2), p2 = 0; p2 < a2; ++p2)
        for (var d2 = Math.max(0, Math.ceil((l3 - p2) / r2)), v2 = Math.min(n2.outHeight, (n2.inHeight + l3 - p2) / r2), m2 = 0; m2 < i2; ++m2)
          for (var g2 = Math.max(0, Math.ceil((c2 - m2) / o3)), y2 = Math.min(n2.outWidth, (n2.inWidth + c2 - m2) / o3), x2 = 0; x2 < n2.inChannels; ++x2)
            for (var b2 = 0; b2 < n2.outChannels; ++b2) {
              for (var w2 = 0, C3 = 0; C3 < n2.batchSize; ++C3)
                for (var E3 = d2; E3 < v2; ++E3)
                  for (var R3 = p2 + E3 * r2 - l3, I3 = g2; I3 < y2; ++I3) {
                    var k4 = m2 + I3 * o3 - c2;
                    w2 += u2 ? h.get(C3, R3, k4, x2) * f2.get(C3, E3, I3, b2) : h.get(C3, x2, R3, k4) * f2.get(C3, b2, E3, I3);
                  }
              s2.set(w2, p2, m2, x2, b2);
            }
      return s2.toTensor();
    }, o2.prototype.conv3dDerFilter = function(t4, e2, n2) {
      for (var r2 = n2.strideDepth, o3 = n2.strideHeight, a2 = n2.strideWidth, i2 = n2.filterDepth, u2 = n2.filterHeight, s2 = n2.filterWidth, c2 = ur(n2.filterShape, "float32"), l3 = c2.values, h = c2.strides, f2 = h[0], p2 = h[1], d2 = h[2], v2 = h[3], m2 = this.readSync(e2.dataId), g2 = e2.strides, y2 = g2[0], x2 = g2[1], b2 = g2[2], w2 = g2[3], C3 = this.readSync(t4.dataId), E3 = t4.strides, R3 = E3[0], I3 = E3[1], k4 = E3[2], S3 = E3[3], A2 = n2.padInfo.front, D3 = n2.padInfo.left, T2 = n2.padInfo.top, N3 = 0; N3 < i2; ++N3)
        for (var F3 = Math.max(0, Math.ceil((A2 - N3) / r2)), O3 = Math.min(n2.outDepth, (n2.inDepth + A2 - N3) / r2), _3 = N3 * f2, M2 = 0; M2 < u2; ++M2)
          for (var B3 = Math.max(0, Math.ceil((T2 - M2) / o3)), P3 = Math.min(n2.outHeight, (n2.inHeight + T2 - M2) / o3), L3 = M2 * p2 + _3, W3 = 0; W3 < s2; ++W3)
            for (var U3 = Math.max(0, Math.ceil((D3 - W3) / a2)), V3 = Math.min(n2.outWidth, (n2.inWidth + D3 - W3) / a2), z3 = W3 * d2 + L3, G3 = 0; G3 < n2.inChannels; ++G3)
              for (var H3 = G3 * v2 + z3, q3 = 0; q3 < n2.outChannels; ++q3) {
                for (var K3 = 0, j3 = 0; j3 < n2.batchSize; ++j3)
                  for (var X3 = j3 * R3, $3 = j3 * y2, Y3 = F3; Y3 < O3; ++Y3)
                    for (var Q3 = (N3 + Y3 * r2 - A2) * I3 + X3, J3 = Y3 * x2 + $3, Z3 = B3; Z3 < P3; ++Z3)
                      for (var tt3 = (M2 + Z3 * o3 - T2) * k4 + Q3, et3 = Z3 * b2 + J3, nt3 = U3; nt3 < V3; ++nt3) {
                        var rt3 = nt3 * w2 + et3;
                        K3 += C3[(W3 + nt3 * a2 - D3) * S3 + tt3 + G3] * m2[rt3 + q3];
                      }
                l3[H3 + q3] = K3;
              }
      return c2.toTensor();
    }, o2.prototype.fusedDepthwiseConv2D = function(t4) {
      var e2 = t4.input, n2 = t4.filter, r2 = t4.convInfo, o3 = t4.bias, a2 = t4.activation, i2 = t4.preluActivationWeights, u2 = this.depthwiseConv2D(e2, n2, r2);
      return o3 && (u2 = this.add(u2, o3)), a2 && (u2 = kh(this, u2, a2, i2)), u2;
    }, o2.prototype.depthwiseConv2D = function(t4, e2, n2) {
      Ih([t4, e2], "depthwiseConv2D");
      for (var r2 = n2.filterHeight, o3 = n2.filterWidth, a2 = n2.dilationHeight, i2 = n2.dilationWidth, u2 = n2.padInfo.left, s2 = n2.padInfo.top, c2 = n2.outChannels / n2.inChannels, l3 = ur(n2.outShape, t4.dtype), h = this.readSync(t4.dataId), f2 = this.readSync(e2.dataId), p2 = l3.values, d2 = 0; d2 < n2.batchSize; ++d2)
        for (var v2 = d2 * t4.strides[0], m2 = d2 * l3.strides[0], g2 = 0; g2 < n2.outHeight; ++g2)
          for (var y2 = m2 + g2 * l3.strides[1], x2 = g2 * n2.strideHeight - u2, b2 = 0; b2 < r2; ++b2) {
            var w2 = x2 + b2 * a2;
            if (!(w2 < 0 || w2 >= n2.inHeight))
              for (var C3 = b2 * e2.strides[0], E3 = v2 + w2 * t4.strides[1], R3 = 0; R3 < n2.outWidth; ++R3)
                for (var I3 = y2 + R3 * l3.strides[2], k4 = R3 * n2.strideWidth - s2, S3 = 0; S3 < o3; ++S3) {
                  var A2 = k4 + S3 * i2;
                  if (!(A2 < 0 || A2 >= n2.inWidth))
                    for (var D3 = C3 + S3 * e2.strides[1], T2 = E3 + A2 * n2.inChannels, N3 = I3, F3 = D3, O3 = 0; O3 < n2.inChannels; ++O3) {
                      for (var _3 = h[T2 + O3], M2 = 0; M2 < c2; ++M2)
                        p2[N3 + M2] += _3 * f2[F3 + M2];
                      N3 += c2, F3 += c2;
                    }
                }
          }
      return l3.toTensor();
    }, o2.prototype.depthwiseConv2DDerInput = function(t4, e2, n2) {
      Ih([t4, e2], "depthwiseConv2DDerInput");
      for (var r2 = ur(n2.inShape, "float32"), o3 = r2.values, a2 = r2.strides, i2 = a2[0], u2 = a2[1], s2 = a2[2], c2 = this.readSync(t4.dataId), l3 = t4.strides, h = l3[0], f2 = l3[1], p2 = l3[2], d2 = this.readSync(e2.dataId), v2 = e2.strides, m2 = v2[0], g2 = v2[1], y2 = v2[2], x2 = n2.batchSize, b2 = n2.filterHeight, w2 = n2.filterWidth, C3 = n2.inChannels, E3 = n2.inHeight, R3 = n2.inWidth, I3 = n2.outChannels, k4 = n2.outHeight, S3 = n2.outWidth, A2 = n2.strideHeight, D3 = n2.strideWidth, T2 = b2 - 1 - n2.padInfo.top, N3 = w2 - 1 - n2.padInfo.left, F3 = I3 / C3, O3 = 0; O3 < x2; ++O3)
        for (var _3 = 0; _3 < C3; ++_3)
          for (var M2 = 0; M2 < E3; ++M2)
            for (var B3 = M2 - T2, P3 = Math.max(0, Math.ceil(B3 / A2)), L3 = Math.min(k4, (b2 + B3) / A2), W3 = 0; W3 < R3; ++W3) {
              for (var U3 = W3 - N3, V3 = Math.max(0, Math.ceil(U3 / D3)), z3 = Math.min(S3, (w2 + U3) / D3), G3 = 0, H3 = P3; H3 < L3; ++H3)
                for (var q3 = H3 * A2 - B3, K3 = V3; K3 < z3; ++K3)
                  for (var j3 = h * O3 + f2 * H3 + p2 * K3, X3 = m2 * (b2 - 1 - q3) + g2 * (w2 - 1 - (K3 * D3 - U3)) + y2 * _3, $3 = 0; $3 < F3; ++$3) {
                    G3 += c2[j3 + (_3 * F3 + $3)] * d2[X3 + $3];
                  }
              o3[i2 * O3 + u2 * M2 + s2 * W3 + _3] = G3;
            }
      return r2.toTensor();
    }, o2.prototype.depthwiseConv2DDerFilter = function(t4, e2, n2) {
      Ih([t4, e2], "depthwiseConv2DDerFilter");
      for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, u2 = ur(n2.filterShape, "float32"), s2 = n2.padInfo.left, c2 = n2.padInfo.top, l3 = n2.outChannels / n2.inChannels, h = this.bufferSync(t4), f2 = this.bufferSync(e2), p2 = 0; p2 < a2; ++p2)
        for (var d2 = Math.max(0, Math.ceil((c2 - p2) / r2)), v2 = Math.min(n2.outHeight, (n2.inHeight + c2 - p2) / r2), m2 = 0; m2 < i2; ++m2)
          for (var g2 = Math.max(0, Math.ceil((s2 - m2) / o3)), y2 = Math.min(n2.outWidth, (n2.inWidth + s2 - m2) / o3), x2 = 0; x2 < n2.outChannels; ++x2) {
            for (var b2 = Math.trunc(x2 / l3), w2 = x2 % l3, C3 = 0, E3 = 0; E3 < n2.batchSize; ++E3)
              for (var R3 = d2; R3 < v2; ++R3)
                for (var I3 = p2 + R3 * r2 - c2, k4 = g2; k4 < y2; ++k4) {
                  var S3 = m2 + k4 * o3 - s2;
                  C3 += h.get(E3, I3, S3, b2) * f2.get(E3, R3, k4, x2);
                }
            u2.set(C3, p2, m2, b2, w2);
          }
      return u2.toTensor();
    }, o2.prototype.tile = function(t4, e2) {
      return Ih(t4, "tile"), Lo(this.bufferSync(t4), e2);
    }, o2.prototype.pad = function(t4, e2, n2) {
      Ih(t4, "pad");
      var r2 = e2.map(function(e3, n3) {
        return e3[0] + t4.shape[n3] + e3[1];
      }), o3 = e2.map(function(t5) {
        return t5[0];
      }), a2 = this.bufferSync(t4), i2 = ur(r2, t4.dtype);
      0 !== n2 && i2.values.fill(n2);
      for (var u2 = 0; u2 < t4.size; u2++) {
        var s2 = a2.indexToLoc(u2), c2 = s2.map(function(t5, e3) {
          return t5 + o3[e3];
        });
        i2.set.apply(i2, [a2.get.apply(a2, s2)].concat(c2));
      }
      return i2.toTensor();
    }, o2.prototype.transpose = function(t4, e2) {
      Ih(t4, "transpose");
      for (var n2 = new Array(t4.rank), r2 = 0; r2 < n2.length; r2++)
        n2[r2] = t4.shape[e2[r2]];
      var o3 = this.readSync(t4.dataId), a2 = ur(n2, t4.dtype), i2 = this.bufferSync(t4);
      for (r2 = 0; r2 < t4.size; ++r2) {
        for (var u2 = i2.indexToLoc(r2), s2 = new Array(u2.length), c2 = 0; c2 < s2.length; c2++)
          s2[c2] = u2[e2[c2]];
        var l3 = a2.locToIndex(s2);
        a2.values[l3] = o3[r2];
      }
      return a2.toTensor();
    }, o2.prototype.gather = function(t4, e2, n2) {
      Ih([t4, e2], "gather");
      var r2 = t4.shape.slice(), o3 = this.readSync(e2.dataId);
      r2[n2] = o3.length;
      for (var a2 = ur(r2, t4.dtype), i2 = this.bufferSync(t4), u2 = 0; u2 < a2.size; ++u2) {
        var s2 = a2.indexToLoc(u2), c2 = s2.slice();
        c2[n2] = o3[s2[n2]];
        var l3 = i2.locToIndex(c2);
        a2.values[u2] = i2.values[l3];
      }
      return a2.toTensor();
    }, o2.prototype.batchToSpaceND = function(t4, e2, n2) {
      Ih([t4], "batchToSpaceND");
      var r2 = e2.reduce(function(t5, e3) {
        return t5 * e3;
      }), o3 = Mr(t4.shape, e2, r2), a2 = Br(o3.length, e2.length), i2 = Pr(t4.shape, e2, r2), u2 = Lr(n2, e2.length), s2 = Wr(i2, n2, e2.length);
      return t4.reshape(o3).transpose(a2).reshape(i2).slice(u2, s2);
    }, o2.prototype.spaceToBatchND = function(t4, e2, n2) {
      Ih([t4], "spaceToBatchND");
      var r2 = e2.reduce(function(t5, e3) {
        return t5 * e3;
      }), o3 = [[0, 0]];
      o3.push.apply(o3, n2);
      for (var a2 = 1 + e2.length; a2 < t4.shape.length; ++a2)
        o3.push([0, 0]);
      var i2 = t4.pad(o3), u2 = Mr(i2.shape, e2, r2, false), s2 = Br(u2.length, e2.length, false), c2 = Pr(i2.shape, e2, r2, false);
      return i2.reshape(u2).transpose(s2).reshape(c2);
    }, o2.prototype.pool = function(t4, e2, n2) {
      Ih(t4, "pool");
      for (var r2 = e2.strideHeight, o3 = e2.strideWidth, a2 = e2.dilationHeight, i2 = e2.dilationWidth, u2 = e2.effectiveFilterHeight, s2 = e2.effectiveFilterWidth, c2 = e2.padInfo.top, l3 = e2.padInfo.left, h = "max" === n2 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, f2 = this.readSync(t4.dataId), p2 = ur(e2.outShape, t4.dtype), d2 = p2.values, v2 = e2.outShape[1] * e2.outShape[2] * e2.outShape[3], m2 = e2.outShape[2] * e2.outShape[3], g2 = e2.outShape[3], y2 = 0; y2 < e2.batchSize; ++y2)
        for (var x2 = y2 * v2, b2 = y2 * t4.strides[0], w2 = 0; w2 < e2.inChannels; ++w2)
          for (var C3 = 0; C3 < e2.outHeight; ++C3)
            for (var E3 = C3 * r2 - c2, R3 = Math.max(0, E3), I3 = Math.min(e2.inHeight, u2 + E3), k4 = x2 + C3 * m2, S3 = 0; S3 < e2.outWidth; ++S3) {
              for (var A2 = S3 * o3 - l3, D3 = Math.max(0, A2), T2 = Math.min(e2.inWidth, s2 + A2), N3 = h, F3 = 0, O3 = 0, _3 = R3; _3 < I3; _3 += a2) {
                for (var M2 = b2 + _3 * t4.strides[1], B3 = D3; B3 < T2; B3 += i2) {
                  var P3 = f2[M2 + B3 * t4.strides[2] + w2];
                  "max" === n2 && P3 > N3 ? N3 = P3 : "avg" === n2 && (F3 += P3, O3++);
                }
                if (isNaN(N3))
                  break;
              }
              d2[k4 + S3 * g2 + w2] = "avg" === n2 ? F3 / O3 : N3;
            }
      return p2.toTensor();
    }, o2.prototype.maxPool = function(t4, e2) {
      return this.pool(t4, e2, "max");
    }, o2.prototype.maxPoolPositions = function(t4, e2) {
      for (var n2 = ur(e2.outShape, "int32"), r2 = e2.strideHeight, o3 = e2.strideWidth, a2 = e2.dilationHeight, i2 = e2.dilationWidth, u2 = e2.effectiveFilterHeight, s2 = e2.effectiveFilterWidth, c2 = e2.padInfo.top, l3 = e2.padInfo.left, h = this.bufferSync(t4), f2 = 0; f2 < e2.batchSize; ++f2)
        for (var p2 = 0; p2 < e2.inChannels; ++p2)
          for (var d2 = 0; d2 < e2.outHeight; ++d2) {
            for (var v2 = d2 * r2 - c2, m2 = v2; m2 < 0; )
              m2 += a2;
            for (var g2 = Math.min(e2.inHeight, u2 + v2), y2 = 0; y2 < e2.outWidth; ++y2) {
              for (var x2 = y2 * o3 - l3, b2 = x2; b2 < 0; )
                b2 += i2;
              for (var w2 = Math.min(e2.inWidth, s2 + x2), C3 = Number.NEGATIVE_INFINITY, E3 = -1, R3 = m2; R3 < g2; R3 += a2)
                for (var I3 = R3 - v2, k4 = b2; k4 < w2; k4 += i2) {
                  var S3 = k4 - x2, A2 = h.get(f2, R3, k4, p2);
                  A2 > C3 && (C3 = A2, E3 = I3 * s2 + S3);
                }
              n2.set(E3, f2, d2, y2, p2);
            }
          }
      return n2.toTensor();
    }, o2.prototype.maxPoolBackprop = function(t4, e2, n2, r2) {
      Ih([e2, n2], "maxPoolBackprop");
      for (var o3 = this.maxPoolPositions(e2, r2), a2 = r2.strideHeight, i2 = r2.strideWidth, u2 = r2.dilationHeight, s2 = r2.dilationWidth, c2 = r2.effectiveFilterHeight, l3 = r2.effectiveFilterWidth, h = l3 - 1 - r2.padInfo.left, f2 = c2 - 1 - r2.padInfo.top, p2 = ur(e2.shape, "float32"), d2 = this.bufferSync(o3), v2 = this.bufferSync(t4), m2 = 0; m2 < r2.batchSize; ++m2)
        for (var g2 = 0; g2 < r2.inChannels; ++g2)
          for (var y2 = 0; y2 < r2.inHeight; ++y2)
            for (var x2 = 0; x2 < r2.inWidth; ++x2) {
              for (var b2 = y2 - f2, w2 = x2 - h, C3 = 0, E3 = 0; E3 < c2; E3 += u2) {
                var R3 = (b2 + E3) / a2;
                if (!(R3 < 0 || R3 >= r2.outHeight || Math.floor(R3) !== R3))
                  for (var I3 = 0; I3 < l3; I3 += s2) {
                    var k4 = (w2 + I3) / i2;
                    if (!(k4 < 0 || k4 >= r2.outWidth || Math.floor(k4) !== k4)) {
                      var S3 = c2 * l3 - 1 - d2.get(m2, R3, k4, g2) === E3 * l3 + I3 ? 1 : 0;
                      if (0 !== S3)
                        C3 += v2.get(m2, R3, k4, g2) * S3;
                    }
                  }
              }
              p2.set(C3, m2, y2, x2, g2);
            }
      return p2.toTensor();
    }, o2.prototype.avgPoolBackprop = function(t4, e2, n2) {
      Ih([t4, e2], "avgPoolBackprop");
      for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, u2 = n2.dilationHeight, s2 = n2.dilationWidth, c2 = n2.effectiveFilterHeight, l3 = n2.effectiveFilterWidth, h = l3 - 1 - n2.padInfo.left, f2 = c2 - 1 - n2.padInfo.top, p2 = ur(e2.shape, "float32"), d2 = 1 / (a2 * i2), v2 = this.bufferSync(t4), m2 = 0; m2 < n2.batchSize; ++m2)
        for (var g2 = 0; g2 < n2.inChannels; ++g2)
          for (var y2 = 0; y2 < n2.inHeight; ++y2)
            for (var x2 = 0; x2 < n2.inWidth; ++x2) {
              for (var b2 = y2 - f2, w2 = x2 - h, C3 = 0, E3 = 0; E3 < c2; E3 += u2) {
                var R3 = (b2 + E3) / r2;
                if (!(R3 < 0 || R3 >= n2.outHeight || Math.floor(R3) !== R3))
                  for (var I3 = 0; I3 < l3; I3 += s2) {
                    var k4 = (w2 + I3) / o3;
                    if (!(k4 < 0 || k4 >= n2.outWidth || Math.floor(k4) !== k4))
                      C3 += v2.get(m2, R3, k4, g2);
                  }
              }
              p2.set(C3 * d2, m2, y2, x2, g2);
            }
      return p2.toTensor();
    }, o2.prototype.pool3d = function(t4, e2, n2) {
      Ih(t4, "pool3d");
      for (var r2 = e2.strideDepth, o3 = e2.strideHeight, a2 = e2.strideWidth, i2 = e2.dilationDepth, u2 = e2.dilationHeight, s2 = e2.dilationWidth, c2 = e2.effectiveFilterDepth, l3 = e2.effectiveFilterHeight, h = e2.effectiveFilterWidth, f2 = e2.padInfo.front, p2 = e2.padInfo.top, d2 = e2.padInfo.left, v2 = "max" === n2 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m2 = this.readSync(t4.dataId), g2 = ur(e2.outShape, t4.dtype), y2 = g2.values, x2 = e2.outShape[1] * e2.outShape[2] * e2.outShape[3] * e2.outShape[4], b2 = e2.outShape[2] * e2.outShape[3] * e2.outShape[4], w2 = e2.outShape[3] * e2.outShape[4], C3 = e2.outShape[4], E3 = 0; E3 < e2.batchSize; ++E3)
        for (var R3 = E3 * x2, I3 = E3 * t4.strides[0], k4 = 0; k4 < e2.inChannels; ++k4)
          for (var S3 = 0; S3 < e2.outDepth; ++S3) {
            for (var A2 = S3 * r2 - f2, D3 = A2; D3 < 0; )
              D3 += i2;
            for (var T2 = Math.min(e2.inDepth, c2 + A2), N3 = R3 + S3 * b2, F3 = 0; F3 < e2.outHeight; ++F3) {
              for (var O3 = F3 * o3 - p2, _3 = O3; _3 < 0; )
                _3 += u2;
              for (var M2 = Math.min(e2.inHeight, l3 + O3), B3 = N3 + F3 * w2, P3 = 0; P3 < e2.outWidth; ++P3) {
                for (var L3 = P3 * a2 - d2, W3 = L3; W3 < 0; )
                  W3 += s2;
                for (var U3 = Math.min(e2.inWidth, h + L3), V3 = B3 + P3 * C3, z3 = v2, G3 = 0, H3 = 0, q3 = D3; q3 < T2; q3 += i2) {
                  for (var K3 = I3 + q3 * t4.strides[1], j3 = _3; j3 < M2; j3 += u2) {
                    for (var X3 = K3 + j3 * t4.strides[2], $3 = W3; $3 < U3; $3 += s2) {
                      var Y3 = m2[X3 + $3 * t4.strides[3] + k4];
                      if ("max" === n2 && Y3 > z3 ? z3 = Y3 : "avg" === n2 && (G3 += Y3, H3++), isNaN(z3))
                        break;
                    }
                    if (isNaN(z3))
                      break;
                  }
                  if (isNaN(z3))
                    break;
                }
                y2[V3 + k4] = "avg" === n2 ? G3 / H3 : z3;
              }
            }
          }
      return g2.toTensor();
    }, o2.prototype.avgPool3d = function(t4, e2) {
      return Ih(t4, "avgPool3d"), this.pool3d(t4, e2, "avg").toFloat();
    }, o2.prototype.avgPool3dBackprop = function(t4, e2, n2) {
      Ih([t4, e2], "avgPool3dBackprop");
      for (var r2 = n2.strideDepth, o3 = n2.strideHeight, a2 = n2.strideWidth, i2 = n2.filterDepth, u2 = n2.filterHeight, s2 = n2.filterWidth, c2 = n2.dilationDepth, l3 = n2.dilationHeight, h = n2.dilationWidth, f2 = n2.effectiveFilterDepth, p2 = n2.effectiveFilterHeight, d2 = n2.effectiveFilterWidth, v2 = f2 - 1 - n2.padInfo.front, m2 = d2 - 1 - n2.padInfo.left, g2 = p2 - 1 - n2.padInfo.top, y2 = ur(e2.shape, "float32"), x2 = 1 / (i2 * u2 * s2), b2 = this.bufferSync(t4), w2 = 0; w2 < n2.batchSize; ++w2)
        for (var C3 = 0; C3 < n2.inChannels; ++C3)
          for (var E3 = 0; E3 < n2.inDepth; ++E3)
            for (var R3 = 0; R3 < n2.inHeight; ++R3)
              for (var I3 = 0; I3 < n2.inWidth; ++I3) {
                for (var k4 = E3 - v2, S3 = R3 - g2, A2 = I3 - m2, D3 = 0, T2 = 0; T2 < f2; T2 += c2) {
                  var N3 = (k4 + T2) / r2;
                  if (!(N3 < 0 || N3 >= n2.outDepth || Math.floor(N3) !== N3))
                    for (var F3 = 0; F3 < p2; F3 += l3) {
                      var O3 = (S3 + F3) / o3;
                      if (!(O3 < 0 || O3 >= n2.outHeight || Math.floor(O3) !== O3))
                        for (var _3 = 0; _3 < d2; _3 += h) {
                          var M2 = (A2 + _3) / a2;
                          if (!(M2 < 0 || M2 >= n2.outWidth || Math.floor(M2) !== M2))
                            D3 += b2.get(w2, N3, O3, M2, C3);
                        }
                    }
                }
                y2.set(D3 * x2, w2, E3, R3, I3, C3);
              }
      return y2.toTensor();
    }, o2.prototype.maxPool3d = function(t4, e2) {
      return Ih(t4, "maxPool3d"), this.pool3d(t4, e2, "max").toFloat();
    }, o2.prototype.maxPool3dPositions = function(t4, e2) {
      for (var n2 = ur(e2.outShape, "int32"), r2 = e2.strideDepth, o3 = e2.strideHeight, a2 = e2.strideWidth, i2 = e2.dilationDepth, u2 = e2.dilationHeight, s2 = e2.dilationWidth, c2 = e2.effectiveFilterDepth, l3 = e2.effectiveFilterHeight, h = e2.effectiveFilterWidth, f2 = e2.padInfo.front, p2 = e2.padInfo.top, d2 = e2.padInfo.left, v2 = this.bufferSync(t4), m2 = 0; m2 < e2.batchSize; ++m2)
        for (var g2 = 0; g2 < e2.inChannels; ++g2)
          for (var y2 = 0; y2 < e2.outDepth; ++y2) {
            for (var x2 = y2 * r2 - f2, b2 = x2; b2 < 0; )
              b2 += i2;
            for (var w2 = Math.min(e2.inDepth, c2 + x2), C3 = 0; C3 < e2.outHeight; ++C3) {
              for (var E3 = C3 * o3 - p2, R3 = E3; R3 < 0; )
                R3 += u2;
              for (var I3 = Math.min(e2.inHeight, l3 + E3), k4 = 0; k4 < e2.outWidth; ++k4) {
                for (var S3 = k4 * a2 - d2, A2 = S3; A2 < 0; )
                  A2 += s2;
                for (var D3 = Math.min(e2.inWidth, h + S3), T2 = Number.NEGATIVE_INFINITY, N3 = -1, F3 = b2; F3 < w2; F3 += i2)
                  for (var O3 = F3 - x2, _3 = R3; _3 < I3; _3 += u2)
                    for (var M2 = _3 - E3, B3 = A2; B3 < D3; B3 += s2) {
                      var P3 = B3 - S3, L3 = v2.get(m2, F3, _3, B3, g2);
                      L3 >= T2 && (T2 = L3, N3 = O3 * l3 * h + M2 * l3 + P3);
                    }
                n2.set(N3, m2, y2, C3, k4, g2);
              }
            }
          }
      return n2.toTensor();
    }, o2.prototype.maxPool3dBackprop = function(t4, e2, n2, r2) {
      Ih([e2, n2], "maxPool3dBackprop");
      for (var o3 = this.maxPool3dPositions(e2, r2), a2 = r2.strideDepth, i2 = r2.strideHeight, u2 = r2.strideWidth, s2 = r2.dilationDepth, c2 = r2.dilationHeight, l3 = r2.dilationWidth, h = r2.effectiveFilterDepth, f2 = r2.effectiveFilterHeight, p2 = r2.effectiveFilterWidth, d2 = h - 1 - r2.padInfo.front, v2 = p2 - 1 - r2.padInfo.left, m2 = f2 - 1 - r2.padInfo.top, g2 = ur(e2.shape, "float32"), y2 = this.bufferSync(o3), x2 = this.bufferSync(t4), b2 = 0; b2 < r2.batchSize; ++b2)
        for (var w2 = 0; w2 < r2.inChannels; ++w2)
          for (var C3 = 0; C3 < r2.inDepth; ++C3)
            for (var E3 = 0; E3 < r2.inHeight; ++E3)
              for (var R3 = 0; R3 < r2.inWidth; ++R3) {
                for (var I3 = C3 - d2, k4 = E3 - m2, S3 = R3 - v2, A2 = 0, D3 = 0; D3 < h; D3 += s2) {
                  var T2 = (I3 + D3) / a2;
                  if (!(T2 < 0 || T2 >= r2.outDepth || Math.floor(T2) !== T2))
                    for (var N3 = 0; N3 < f2; N3 += c2) {
                      var F3 = (k4 + N3) / i2;
                      if (!(F3 < 0 || F3 >= r2.outHeight || Math.floor(F3) !== F3))
                        for (var O3 = 0; O3 < p2; O3 += l3) {
                          var _3 = (S3 + O3) / u2;
                          if (!(_3 < 0 || _3 >= r2.outWidth || Math.floor(_3) !== _3)) {
                            var M2 = h * f2 * p2 - 1 - y2.get(b2, T2, F3, _3, w2) === D3 * f2 * p2 + N3 * p2 + O3 ? 1 : 0;
                            if (0 !== M2)
                              A2 += x2.get(b2, T2, F3, _3, w2) * M2;
                          }
                        }
                    }
                }
                g2.set(A2, b2, C3, E3, R3, w2);
              }
      return g2.toTensor();
    }, o2.prototype.cast = function(t4, e2) {
      return So(t4, e2, this);
    }, o2.prototype.reshape = function(t4, e2) {
      return Ao(t4, e2);
    }, o2.prototype.avgPool = function(t4, e2) {
      return Ih(t4, "avgPool"), this.pool(t4, e2, "avg").toFloat();
    }, o2.prototype.resizeBilinear = function(t4, e2, n2, r2) {
      Ih(t4, "resizeBilinear");
      for (var o3 = t4.shape, a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3], c2 = this.readSync(t4.dataId), l3 = new Float32Array(w([a2, e2, n2, s2])), h = [r2 && e2 > 1 ? i2 - 1 : i2, r2 && n2 > 1 ? u2 - 1 : u2], f2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], p2 = 0, d2 = h[0] / f2[0], v2 = h[1] / f2[1], m2 = 0; m2 < a2; m2++)
        for (var g2 = 0; g2 < e2; g2++)
          for (var y2 = d2 * g2, x2 = Math.floor(y2), b2 = y2 - x2, C3 = Math.min(i2 - 1, Math.ceil(y2)), E3 = m2 * t4.strides[0] + x2 * t4.strides[1], R3 = m2 * t4.strides[0] + C3 * t4.strides[1], I3 = 0; I3 < n2; I3++)
            for (var k4 = v2 * I3, S3 = Math.floor(k4), A2 = k4 - S3, D3 = Math.min(u2 - 1, Math.ceil(k4)), T2 = E3 + S3 * t4.strides[2], N3 = R3 + S3 * t4.strides[2], F3 = E3 + +D3 * t4.strides[2], O3 = R3 + D3 * t4.strides[2], _3 = 0; _3 < s2; _3++) {
              var M2 = c2[T2 + _3], B3 = c2[N3 + _3], P3 = M2 + (c2[F3 + _3] - M2) * A2, L3 = P3 + (B3 + (c2[O3 + _3] - B3) * A2 - P3) * b2;
              l3[p2++] = L3;
            }
      return kn(l3, [a2, e2, n2, s2]);
    }, o2.prototype.resizeBilinearBackprop = function(t4, e2, n2) {
      Ih([t4, e2], "resizeBilinearBackprop");
      for (var r2 = e2.shape, o3 = r2[0], a2 = r2[1], i2 = r2[2], u2 = r2[3], s2 = t4.shape, c2 = s2[1], l3 = s2[2], h = new Float32Array(o3 * a2 * i2 * u2), f2 = [n2 && c2 > 1 ? a2 - 1 : a2, n2 && l3 > 1 ? i2 - 1 : i2], p2 = [n2 && c2 > 1 ? c2 - 1 : c2, n2 && l3 > 1 ? l3 - 1 : l3], d2 = f2[0] / p2[0], v2 = f2[1] / p2[1], m2 = this.readSync(t4.dataId), g2 = 0, y2 = 0; y2 < o3; y2++)
        for (var x2 = y2 * e2.strides[0], b2 = 0; b2 < c2; b2++)
          for (var w2 = b2 * d2, C3 = Math.floor(w2), E3 = Math.min(Math.ceil(w2), a2 - 1), R3 = x2 + C3 * e2.strides[1], I3 = x2 + E3 * e2.strides[1], k4 = w2 - C3, S3 = 1 - k4, A2 = 0; A2 < l3; A2++)
            for (var D3 = A2 * v2, T2 = Math.floor(D3), N3 = Math.min(Math.ceil(D3), i2 - 1), F3 = D3 - T2, O3 = 1 - F3, _3 = R3 + T2 * e2.strides[2], M2 = R3 + N3 * e2.strides[2], B3 = I3 + T2 * e2.strides[2], P3 = I3 + N3 * e2.strides[2], L3 = S3 * O3, W3 = S3 * F3, U3 = k4 * O3, V3 = k4 * F3, z3 = 0; z3 < u2; z3++) {
              var G3 = m2[g2++];
              h[_3 + z3] += G3 * L3, h[M2 + z3] += G3 * W3, h[B3 + z3] += G3 * U3, h[P3 + z3] += G3 * V3;
            }
      return Fn(h, [o3, i2, a2, u2], e2.dtype);
    }, o2.prototype.resizeNearestNeighbor = function(t4, e2, n2, r2) {
      Ih(t4, "resizeNearestNeighbor");
      for (var o3 = t4.shape, a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3], c2 = this.readSync(t4.dataId), l3 = new Float32Array(a2 * e2 * n2 * s2), h = [r2 && e2 > 1 ? i2 - 1 : i2, r2 && n2 > 1 ? u2 - 1 : u2], f2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], p2 = h[0] / f2[0], d2 = h[1] / f2[1], v2 = 0, m2 = 0; m2 < a2; m2++)
        for (var g2 = m2 * t4.strides[0], y2 = 0; y2 < e2; y2++)
          for (var x2 = p2 * y2, b2 = g2 + Math.min(i2 - 1, r2 ? Math.round(x2) : Math.floor(x2)) * t4.strides[1], w2 = 0; w2 < n2; w2++)
            for (var C3 = d2 * w2, E3 = b2 + Math.min(u2 - 1, r2 ? Math.round(C3) : Math.floor(C3)) * t4.strides[2], R3 = 0; R3 < s2; R3++) {
              var I3 = c2[E3 + R3];
              l3[v2++] = I3;
            }
      return kn(l3, [a2, e2, n2, s2], t4.dtype);
    }, o2.prototype.resizeNearestNeighborBackprop = function(t4, e2, n2) {
      Ih([t4, e2], "resizeNearestNeighborBackprop");
      for (var r2 = e2.shape, o3 = r2[0], a2 = r2[1], i2 = r2[2], u2 = r2[3], s2 = t4.shape, c2 = s2[1], l3 = s2[2], h = new Float32Array(o3 * a2 * i2 * u2), f2 = this.readSync(t4.dataId), p2 = [n2 && c2 > 1 ? a2 - 1 : a2, n2 && l3 > 1 ? i2 - 1 : i2], d2 = [n2 && c2 > 1 ? c2 - 1 : c2, n2 && l3 > 1 ? l3 - 1 : l3], v2 = p2[0] / d2[0], m2 = p2[1] / d2[1], g2 = 1 / v2, y2 = 1 / m2, x2 = 2 * Math.ceil(g2) + 2, b2 = 2 * Math.ceil(y2) + 2, w2 = 0; w2 < o3; w2++)
        for (var C3 = w2 * e2.strides[0], E3 = 0; E3 < a2; E3++)
          for (var R3 = C3 + E3 * e2.strides[1], I3 = Math.floor(E3 * g2), k4 = Math.floor(I3 - x2 / 2), S3 = 0; S3 < i2; S3++)
            for (var A2 = R3 + S3 * e2.strides[2], D3 = Math.floor(S3 * y2), T2 = Math.floor(D3 - b2 / 2), N3 = 0; N3 < u2; N3++) {
              for (var F3 = 0, O3 = 0; O3 < x2; O3++) {
                var _3 = O3 + k4;
                if (!(_3 < 0 || _3 >= c2)) {
                  var M2 = C3 + _3 * t4.strides[1], B3 = _3 * v2;
                  if (E3 === Math.min(a2 - 1, n2 ? Math.round(B3) : Math.floor(B3)))
                    for (var P3 = 0; P3 < b2; P3++) {
                      var L3 = P3 + T2;
                      if (!(L3 < 0 || L3 >= l3)) {
                        var W3 = M2 + L3 * t4.strides[2], U3 = L3 * m2;
                        S3 === Math.min(i2 - 1, n2 ? Math.round(U3) : Math.floor(U3)) && (F3 += f2[W3 + N3]);
                      }
                    }
                }
              }
              h[A2 + N3] = F3;
            }
      return Fn(h, e2.shape, e2.dtype);
    }, o2.prototype.batchNormalization = function(t4, e2, n2, r2, o3, a2) {
      Ih([t4, e2, n2, o3, a2], "batchNorm");
      for (var i2 = this.readSync(t4.dataId), u2 = this.readSync(e2.dataId), s2 = this.readSync(n2.dataId), c2 = o3 ? this.readSync(o3.dataId) : new Float32Array([1]), l3 = a2 ? this.readSync(a2.dataId) : new Float32Array([0]), h = new Float32Array(i2.length), f2 = l3.length, p2 = c2.length, d2 = s2.length, v2 = u2.length, m2 = 0, g2 = 0, y2 = 0, x2 = 0, b2 = 0; b2 < i2.length; ++b2)
        h[b2] = l3[m2++] + (i2[b2] - u2[g2++]) * c2[y2++] / Math.sqrt(s2[x2++] + r2), m2 >= f2 && (m2 = 0), g2 >= v2 && (g2 = 0), y2 >= p2 && (y2 = 0), x2 >= d2 && (x2 = 0);
      return Fn(h, t4.shape);
    }, o2.prototype.localResponseNormalization4D = function(t4, e2, n2, r2, o3) {
      Ih(t4, "localResponseNormalization4D");
      var a2 = t4.shape[3], i2 = a2 - 1, u2 = this.readSync(t4.dataId), s2 = t4.size, c2 = new Float32Array(s2);
      function l3(t5) {
        for (var n3 = t5 % a2, r3 = t5 - n3 + Math.max(0, n3 - e2), o4 = t5 - n3 + Math.min(n3 + e2, i2), s3 = 0; r3 <= o4; r3++) {
          var c3 = u2[r3];
          s3 += c3 * c3;
        }
        return s3;
      }
      for (var h = 0; h < s2; h++) {
        var f2 = l3(h), p2 = u2[h] * Math.pow(n2 + r2 * f2, -o3);
        c2[h] = p2;
      }
      return Fn(c2, t4.shape);
    }, o2.prototype.LRNGrad = function(t4, e2, n2, r2, o3, a2, i2) {
      Ih(t4, "LRNGrad");
      for (var u2 = t4.shape[3], s2 = this.readSync(t4.dataId), c2 = this.readSync(e2.dataId), l3 = this.readSync(n2.dataId), h = new Float32Array(t4.size), f2 = t4.size, p2 = 0; p2 < f2; p2++) {
        for (var d2 = p2 % u2, v2 = p2 - d2 + Math.max(0, d2 - r2), m2 = p2 - d2 + Math.min(u2, d2 + r2 + 1), g2 = 0, y2 = v2; y2 < m2; y2++)
          g2 += Math.pow(c2[y2], 2);
        g2 = a2 * g2 + o3;
        for (y2 = v2; y2 < m2; y2++) {
          var x2 = -2 * a2 * i2 * c2[y2] * l3[p2] / g2;
          p2 === y2 && (x2 += Math.pow(g2, -i2)), x2 *= s2[p2], h[y2] += x2;
        }
      }
      return Fn(h, t4.shape);
    }, o2.prototype.multinomial = function(t4, e2, n2, r2) {
      Ih(t4, "multinomial");
      for (var o3 = e2 ? t4 : io(t4), a2 = o3.shape[0], i2 = o3.shape[1], u2 = Pn([a2, n2], "int32"), s2 = this.readSync(u2.dataId), c2 = this.readSync(o3.dataId), l3 = 0; l3 < a2; ++l3) {
        var h = l3 * i2, f2 = new Float32Array(i2 - 1);
        f2[0] = c2[h];
        for (var p2 = 1; p2 < f2.length; ++p2)
          f2[p2] = f2[p2 - 1] + c2[h + p2];
        for (var d2 = rr(r2.toString()), v2 = l3 * n2, m2 = 0; m2 < n2; ++m2) {
          var g2 = d2();
          s2[v2 + m2] = f2.length;
          for (var y2 = 0; y2 < f2.length; y2++)
            if (g2 < f2[y2]) {
              s2[v2 + m2] = y2;
              break;
            }
        }
      }
      return u2;
    }, o2.prototype.oneHot = function(t4, e2, n2, r2) {
      Ih(t4, "oneHot");
      var o3 = new Float32Array(t4.size * e2);
      o3.fill(r2);
      for (var a2 = this.readSync(t4.dataId), i2 = 0; i2 < t4.size; ++i2)
        a2[i2] >= 0 && a2[i2] < e2 && (o3[i2 * e2 + a2[i2]] = n2);
      return Tn(o3, [t4.size, e2], "int32");
    }, o2.prototype.nonMaxSuppression = function(t4, e2, n2, r2, o3) {
      return Ih(t4, "nonMaxSuppression"), Mo(this.readSync(t4.dataId), this.readSync(e2.dataId), n2, r2, o3);
    }, o2.prototype.fft = function(t4) {
      return this.fftBatch(t4, false);
    }, o2.prototype.ifft = function(t4) {
      return this.fftBatch(t4, true);
    }, o2.prototype.fftBatch = function(t4, e2) {
      for (var n2 = t4.shape[0], r2 = t4.shape[1], o3 = ur(t4.shape, "float32"), a2 = ur(t4.shape, "float32"), i2 = Rn(t4).as2D(n2, r2), u2 = In(t4).as2D(n2, r2), s2 = 0; s2 < n2; s2++)
        for (var c2 = i2.slice([s2, 0], [1, r2]), l3 = u2.slice([s2, 0], [1, r2]), h = En(c2, l3), f2 = this.readSync(this.fftImpl(h, e2).dataId), p2 = 0; p2 < r2; p2++) {
          var d2 = Fo(f2, p2);
          o3.values[s2 * r2 + p2] = d2.real, a2.values[s2 * r2 + p2] = d2.imag;
        }
      return En(o3.toTensor(), a2.toTensor()).as2D(n2, r2);
    }, o2.prototype.fftImpl = function(t4, e2) {
      var n2 = t4.as1D(), r2 = n2.size;
      if (this.isExponentOf2(r2)) {
        var o3 = this.fftRadix2(n2, r2, e2).as2D(t4.shape[0], t4.shape[1]);
        return e2 && (o3 = En(Rn(o3).div(An(r2)), In(o3).div(An(r2)))), o3;
      }
      var a2 = this.readSync(t4.dataId), i2 = function(t5) {
        for (var e3 = new Float32Array(t5.length / 2), n3 = new Float32Array(t5.length / 2), r3 = 0; r3 < t5.length; r3 += 2)
          e3[r3 / 2] = t5[r3], n3[r3 / 2] = t5[r3 + 1];
        return { real: e3, imag: n3 };
      }(this.fourierTransformByMatmul(a2, r2, e2));
      return En(i2.real, i2.imag).as2D(t4.shape[0], t4.shape[1]);
    }, o2.prototype.isExponentOf2 = function(t4) {
      return 0 == (t4 & t4 - 1);
    }, o2.prototype.fftRadix2 = function(t4, e2, n2) {
      if (1 === e2)
        return t4;
      var r2 = this.readSync(t4.dataId), o3 = e2 / 2, a2 = function(t5) {
        for (var e3 = Math.ceil(t5.length / 4), n3 = new Float32Array(e3), r3 = new Float32Array(e3), o4 = 0; o4 < t5.length; o4 += 4)
          n3[Math.floor(o4 / 4)] = t5[o4], r3[Math.floor(o4 / 4)] = t5[o4 + 1];
        return { real: n3, imag: r3 };
      }(r2), i2 = En(a2.real, a2.imag).as1D(), u2 = function(t5) {
        for (var e3 = Math.floor(t5.length / 4), n3 = new Float32Array(e3), r3 = new Float32Array(e3), o4 = 2; o4 < t5.length; o4 += 4)
          n3[Math.floor(o4 / 4)] = t5[o4], r3[Math.floor(o4 / 4)] = t5[o4 + 1];
        return { real: n3, imag: r3 };
      }(r2), s2 = En(u2.real, u2.imag).as1D();
      i2 = this.fftRadix2(i2, o3, n2), s2 = this.fftRadix2(s2, o3, n2);
      var c2 = function(t5, e3) {
        for (var n3 = new Float32Array(t5 / 2), r3 = new Float32Array(t5 / 2), o4 = 0; o4 < Math.ceil(t5 / 2); o4++) {
          var a3 = (e3 ? 2 : -2) * Math.PI * (o4 / t5);
          n3[o4] = Math.cos(a3), r3[o4] = Math.sin(a3);
        }
        return { real: n3, imag: r3 };
      }(e2, n2), l3 = En(c2.real, c2.imag).mul(s2), h = i2.add(l3), f2 = i2.sub(l3), p2 = Rn(h).concat(Rn(f2)), d2 = In(h).concat(In(f2));
      return En(p2, d2).as1D();
    }, o2.prototype.fourierTransformByMatmul = function(t4, e2, n2) {
      for (var r2 = new Float32Array(2 * e2), o3 = 0; o3 < e2; o3++) {
        for (var a2 = 0, i2 = 0, u2 = 0; u2 < e2; u2++) {
          var s2 = _o(o3 * u2, e2, n2), c2 = Fo(t4, u2);
          a2 += c2.real * s2.real - c2.imag * s2.imag, i2 += c2.real * s2.imag + c2.imag * s2.real;
        }
        n2 && (a2 /= e2, i2 /= e2), Oo(r2, a2, i2, o3);
      }
      return r2;
    }, o2.prototype.depthToSpace = function(t4, e2, n2) {
      g("NHWC" === n2, function() {
        return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n2;
      }), g(e2 > 1, function() {
        return "blockSize should be > 1 for depthToSpace, but was: " + e2;
      });
      for (var r2 = t4.shape[0], o3 = t4.shape[1], a2 = t4.shape[2], i2 = t4.shape[3], u2 = o3 * e2, s2 = a2 * e2, c2 = i2 / (e2 * e2), l3 = this.readSync(t4.dataId), h = new Float32Array(r2 * u2 * s2 * c2), f2 = 0, p2 = 0; p2 < r2; ++p2)
        for (var d2 = 0; d2 < u2; ++d2)
          for (var v2 = Math.floor(d2 / e2), m2 = d2 % e2, y2 = 0; y2 < s2; ++y2)
            for (var x2 = Math.floor(y2 / e2), b2 = (m2 * e2 + y2 % e2) * c2, w2 = 0; w2 < c2; ++w2) {
              var C3 = w2 + b2 + i2 * (x2 + a2 * (v2 + o3 * p2));
              h[f2++] = l3[C3];
            }
      return Fn(h, [r2, u2, s2, c2]);
    }, o2.prototype.broadcastedBinaryOp = function(t4, e2, n2, r2) {
      var o3 = po(t4.shape, e2.shape), a2 = ur(o3, n2), i2 = this.readSync(t4.dataId), u2 = this.readSync(e2.dataId), s2 = ho(t4.shape, o3), c2 = ho(e2.shape, o3), l3 = a2.values;
      if (s2.length + c2.length === 0)
        for (var h = 0; h < l3.length; ++h)
          l3[h] = r2(i2[h % i2.length], u2[h % u2.length]);
      else {
        var f2 = this.bufferSync(t4), p2 = this.bufferSync(e2), d2 = function(n3) {
          var o4 = a2.indexToLoc(n3), h2 = o4.slice(-t4.rank);
          s2.forEach(function(t5) {
            return h2[t5] = 0;
          });
          var d3 = f2.locToIndex(h2), v2 = o4.slice(-e2.rank);
          c2.forEach(function(t5) {
            return v2[t5] = 0;
          });
          var m2 = p2.locToIndex(v2);
          l3[n3] = r2(i2[d3], u2[m2]);
        };
        for (h = 0; h < l3.length; ++h)
          d2(h);
      }
      return a2.toTensor();
    }, o2.prototype.broadcastedBinaryComplexOp = function(t4, e2, n2) {
      var r2 = po(t4.shape, e2.shape), o3 = ur(r2, "float32"), a2 = ur(r2, "float32"), i2 = this.readSync(t4.dataId), u2 = this.readSync(e2.dataId), s2 = ho(t4.shape, r2), c2 = ho(e2.shape, r2), l3 = o3.values, h = a2.values;
      if (s2.length + c2.length === 0)
        for (var f2 = 0; f2 < l3.length; f2++) {
          var p2 = f2 % i2.length, d2 = f2 % u2.length, v2 = n2(i2[2 * p2], i2[2 * p2 + 1], u2[2 * d2], u2[2 * d2 + 1]);
          l3[f2] = v2.real, h[f2] = v2.imag;
        }
      else {
        var m2 = this.bufferSync(this.data.get(t4.dataId).complexTensors.real), g2 = this.bufferSync(this.data.get(e2.dataId).complexTensors.real), y2 = function(r3) {
          var a3 = o3.indexToLoc(r3), f3 = a3.slice(-t4.rank);
          s2.forEach(function(t5) {
            return f3[t5] = 0;
          });
          var p3 = m2.locToIndex(f3), d3 = a3.slice(-e2.rank);
          c2.forEach(function(t5) {
            return d3[t5] = 0;
          });
          var v3 = g2.locToIndex(d3), y3 = n2(i2[2 * p3], i2[2 * p3 + 1], u2[2 * v3], u2[2 * v3 + 1]);
          l3[r3] = y3.real, h[r3] = y3.imag;
        };
        for (f2 = 0; f2 < l3.length; f2++)
          y2(f2);
      }
      return this.complex(o3.toTensor(), a2.toTensor());
    }, o2.prototype.split = function(t4, e2, n2) {
      return Po(t4, e2, n2);
    }, o2.prototype.dispose = function() {
    }, o2.prototype.floatPrecision = function() {
      return 32;
    }, o2.prototype.epsilon = function() {
      return 1e-7;
    }, o2.prototype.cropAndResize = function(t4, e2, n2, r2, o3, a2) {
      for (var i2 = t4.shape, u2 = i2[0], s2 = i2[1], c2 = i2[2], l3 = i2[3], h = e2.shape[0], f2 = r2[0], p2 = r2[1], d2 = ur([h, f2, p2, l3], t4.dtype), v2 = this.readSync(e2.dataId), m2 = this.readSync(n2.dataId), g2 = this.readSync(t4.dataId), y2 = t4.strides, x2 = d2.strides, b2 = 0; b2 < h; b2++) {
        var w2 = 4 * b2, C3 = v2[w2], E3 = v2[w2 + 1], R3 = v2[w2 + 2], I3 = v2[w2 + 3], k4 = m2[b2];
        if (!(k4 >= u2))
          for (var S3 = f2 > 1 ? (R3 - C3) * (s2 - 1) / (f2 - 1) : 0, A2 = p2 > 1 ? (I3 - E3) * (c2 - 1) / (p2 - 1) : 0, D3 = 0; D3 < f2; D3++) {
            var T2 = f2 > 1 ? C3 * (s2 - 1) + D3 * S3 : 0.5 * (C3 + R3) * (s2 - 1);
            if (T2 < 0 || T2 > s2 - 1)
              for (var N3 = 0; N3 < p2; N3++)
                for (var F3 = 0; F3 < l3; F3++) {
                  var O3 = F3 + N3 * x2[2] + D3 * x2[1] + b2 * x2[0];
                  d2.values[O3] = a2;
                }
            else if ("bilinear" === o3) {
              var _3 = Math.floor(T2), M2 = Math.ceil(T2), B3 = T2 - _3;
              for (N3 = 0; N3 < p2; N3++) {
                if ((q3 = p2 > 1 ? E3 * (c2 - 1) + N3 * A2 : 0.5 * (E3 + I3) * (c2 - 1)) < 0 || q3 > c2 - 1)
                  for (F3 = 0; F3 < l3; F3++) {
                    O3 = F3 + N3 * x2[2] + D3 * x2[1] + b2 * x2[0];
                    d2.values[O3] = a2;
                  }
                else {
                  var P3 = Math.floor(q3), L3 = Math.ceil(q3), W3 = q3 - P3;
                  for (F3 = 0; F3 < l3; F3++) {
                    var U3 = g2[O3 = F3 + P3 * y2[2] + _3 * y2[1] + k4 * y2[0]], V3 = g2[O3 = F3 + L3 * y2[2] + _3 * y2[1] + k4 * y2[0]], z3 = g2[O3 = F3 + P3 * y2[2] + M2 * y2[1] + k4 * y2[0]], G3 = U3 + (V3 - U3) * W3, H3 = z3 + (g2[O3 = F3 + L3 * y2[2] + M2 * y2[1] + k4 * y2[0]] - z3) * W3;
                    O3 = F3 + N3 * x2[2] + D3 * x2[1] + b2 * x2[0], d2.values[O3] = G3 + (H3 - G3) * B3;
                  }
                }
              }
            } else
              for (N3 = 0; N3 < p2; ++N3) {
                var q3;
                if ((q3 = p2 > 1 ? E3 * (c2 - 1) + N3 * A2 : 0.5 * (E3 + I3) * (c2 - 1)) < 0 || q3 > c2 - 1)
                  for (F3 = 0; F3 < l3; F3++) {
                    O3 = F3 + N3 * x2[2] + D3 * x2[1] + b2 * x2[0];
                    d2.values[O3] = a2;
                  }
                else {
                  var K3 = Math.round(q3), j3 = Math.round(T2);
                  for (F3 = 0; F3 < l3; F3++) {
                    var X3 = F3 + K3 * y2[2] + j3 * y2[1] + k4 * y2[0], $3 = F3 + N3 * x2[2] + D3 * x2[1] + b2 * x2[0];
                    d2.values[$3] = g2[X3];
                  }
                }
              }
          }
      }
      return d2.toTensor();
    }, o2.prototype.sparseToDense = function(t4, e2, n2, r2) {
      var o3 = Hr(0, t4, n2), a2 = o3.sliceRank, i2 = o3.numUpdates, u2 = o3.sliceSize, s2 = o3.strides, c2 = o3.outputSize;
      return this.scatter(t4, e2, n2, c2, u2, i2, a2, s2, r2, false);
    }, o2.prototype.gatherND = function(t4, e2) {
      var n2 = e2.shape, r2 = n2[n2.length - 1], o3 = Ur(t4, e2), a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3];
      if (0 === i2)
        return kn([], a2, t4.dtype);
      for (var c2 = new lt([i2, u2], t4.dtype), l3 = this.readSync(e2.dataId), h = this.readSync(t4.dataId), f2 = 0; f2 < i2; f2++) {
        for (var p2 = [], d2 = 0, v2 = 0; v2 < r2; v2++) {
          var m2 = l3[f2 * r2 + v2];
          d2 += m2 * s2[v2], p2.push(m2);
        }
        if (d2 < 0 || d2 >= t4.size / u2)
          throw new Error("Invalid indices: " + p2 + " does not index into " + t4.shape);
        for (var g2 = 0; g2 < u2; g2++)
          c2.values[f2 * u2 + g2] = h[d2 * u2 + g2];
      }
      return c2.toTensor().reshape(a2);
    }, o2.prototype.scatterND = function(t4, e2, n2) {
      var r2 = Hr(0, t4, n2), o3 = r2.sliceRank, a2 = r2.numUpdates, i2 = r2.sliceSize, u2 = r2.strides, s2 = r2.outputSize, c2 = An(0);
      return this.scatter(t4, e2, n2, s2, i2, a2, o3, u2, c2, true);
    }, o2.prototype.fill = function(t4, e2, n2) {
      var r2 = F(n2 = n2 || z(e2), w(t4));
      return r2.fill(e2), Nt.makeTensor(r2, t4, n2, this);
    }, o2.prototype.onesLike = function(t4) {
      if ("string" === t4.dtype)
        throw new Error("onesLike is not supported for string tensors");
      return this.fill(t4.shape, 1, t4.dtype);
    }, o2.prototype.zerosLike = function(t4) {
      var e2 = F(t4.dtype, w(t4.shape));
      return this.makeOutput(e2, t4.shape, t4.dtype);
    }, o2.prototype.linspace = function(t4, e2, n2) {
      return Do(t4, e2, n2);
    }, o2.prototype.scatter = function(t4, e2, n2, r2, o3, a2, i2, u2, s2, c2) {
      var l3 = [r2 / o3, o3], h = this.readSync(t4.dataId), f2 = this.readSync(e2.dataId);
      if (0 === r2)
        return kn([], n2, e2.dtype);
      var p2 = new lt(l3, e2.dtype);
      p2.values.fill(this.readSync(s2.dataId)[0]);
      for (var d2 = 0; d2 < a2; d2++) {
        for (var v2 = [], m2 = 0, g2 = 0; g2 < i2; g2++) {
          var y2 = h[d2 * i2 + g2];
          v2.push(y2), m2 += y2 * u2[g2];
        }
        if (m2 < 0 || m2 >= r2 / o3)
          throw new Error("Invalid indices: " + v2 + " does not index into " + n2);
        for (var x2 = 0; x2 < o3; x2++)
          c2 ? p2.values[m2 * o3 + x2] += f2[d2 * o3 + x2] : p2.values[m2 * o3 + x2] = 0 === e2.rank ? f2[0] : f2[d2 * o3 + x2];
      }
      return p2.toTensor().reshape(n2);
    }, o2;
  }(co);
  Nt.registerBackend("cpu", function() {
    return new Sh();
  }, 1), l({ kernelName: "Square", backendName: "cpu", kernelFunc: function(t3) {
    var e2 = t3.inputs, n2 = t3.backend, r2 = e2.x, o2 = n2;
    Ih(r2, "square");
    for (var a2 = o2.data.get(r2.dataId).values, i2 = new Float32Array(a2.length), u2 = 0; u2 < a2.length; ++u2) {
      var s2 = a2[u2];
      i2[u2] = s2 * s2;
    }
    return { dataId: o2.write(i2, r2.shape, r2.dtype), shape: r2.shape, dtype: r2.dtype };
  } }), l({ kernelName: "Square", backendName: "webgl", kernelFunc: function(t3) {
    var e2 = t3.inputs, n2 = t3.backend, r2 = e2.x, o2 = n2, a2 = new su(r2.shape, "return x * x;");
    return o2.runWebGLProgram(a2, [r2], r2.dtype);
  } });
  var Ah = function() {
    function t3() {
    }
    return t3.prototype.fetch = function(t4, e2) {
      return fetch(t4, e2);
    }, t3.prototype.now = function() {
      return performance.now();
    }, t3.prototype.encode = function(t4, e2) {
      if ("utf-8" !== e2 && "utf8" !== e2)
        throw new Error("Browser's encoder only supports utf-8, but got " + e2);
      return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t4);
    }, t3.prototype.decode = function(t4, e2) {
      return new TextDecoder(e2).decode(t4);
    }, t3;
  }();
  a().get("IS_BROWSER") && a().setPlatform("browser", new Ah());
  var Dh;
  var Th = function() {
    return require_browser();
  };
  var Nh = function() {
    function t3() {
      this.util = require_util(), this.textEncoder = new this.util.TextEncoder();
    }
    return t3.prototype.fetch = function(t4, e2) {
      return null != a().global.fetch ? a().global.fetch(t4, e2) : (null == Dh && (Dh = Th()), Dh(t4, e2));
    }, t3.prototype.now = function() {
      var t4 = process.hrtime();
      return 1e3 * t4[0] + t4[1] / 1e6;
    }, t3.prototype.encode = function(t4, e2) {
      if ("utf-8" !== e2 && "utf8" !== e2)
        throw new Error("Node built-in encoder only supports utf-8, but got " + e2);
      return this.textEncoder.encode(t4);
    }, t3.prototype.decode = function(t4, e2) {
      return 0 === t4.length ? "" : new this.util.TextDecoder(e2).decode(t4);
    }, t3;
  }();
  a().get("IS_NODE") && a().setPlatform("node", new Nh());
  var Fh = { float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1 };
  var Oh = 4;
  function _h(t3, e2) {
    for (var n2 = {}, r2 = 0, o2 = function(e3) {
      var o3 = e3.name, a3 = e3.dtype, i3 = e3.shape, u2 = w(i3), s2 = void 0;
      if ("quantization" in e3) {
        var c2 = e3.quantization;
        if ("uint8" !== c2.dtype && "uint16" !== c2.dtype)
          throw new Error("Weight " + e3.name + " has unknown quantization dtype " + c2.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
        var l3 = Fh[c2.dtype], h = t3.slice(r2, r2 + u2 * l3), f2 = "uint8" === c2.dtype ? new Uint8Array(h) : new Uint16Array(h);
        if ("float32" === a3)
          s2 = Float32Array.from(f2, function(t4) {
            return t4 * c2.scale + c2.min;
          });
        else {
          if ("int32" !== a3)
            throw new Error("Unsupported dtype in weight '" + o3 + "': " + a3);
          s2 = Int32Array.from(f2, function(t4) {
            return Math.round(t4 * c2.scale + c2.min);
          });
        }
        r2 += u2 * l3;
      } else if ("string" === a3) {
        var p2 = w(e3.shape);
        s2 = [];
        for (var d2 = 0; d2 < p2; d2++) {
          var v2 = new Uint32Array(t3.slice(r2, r2 + Oh))[0];
          r2 += Oh;
          var m2 = new Uint8Array(t3.slice(r2, r2 + v2));
          s2.push(m2), r2 += v2;
        }
      } else {
        var g2 = Fh[a3];
        h = t3.slice(r2, r2 + u2 * g2);
        if ("float32" === a3)
          s2 = new Float32Array(h);
        else if ("int32" === a3)
          s2 = new Int32Array(h);
        else {
          if ("bool" !== a3)
            throw new Error("Unsupported dtype in weight '" + o3 + "': " + a3);
          s2 = new Uint8Array(h);
        }
        r2 += u2 * g2;
      }
      n2[o3] = kn(s2, i3, a3);
    }, a2 = 0, i2 = e2; a2 < i2.length; a2++) {
      o2(i2[a2]);
    }
    return n2;
  }
  function Mh(t3) {
    if (null === t3)
      throw new Error("Invalid input value: " + JSON.stringify(t3));
    var e2 = 0, n2 = [];
    t3.forEach(function(t4) {
      if (e2 += t4.byteLength, n2.push(t4.byteLength === t4.buffer.byteLength ? t4 : new t4.constructor(t4)), !(t4 instanceof Float32Array || t4 instanceof Int32Array || t4 instanceof Uint8Array))
        throw new Error("Unsupported TypedArray subtype: " + t4.constructor.name);
    });
    var r2 = new Uint8Array(e2), o2 = 0;
    return n2.forEach(function(t4) {
      r2.set(new Uint8Array(t4.buffer), o2), o2 += t4.byteLength;
    }), r2.buffer;
  }
  var Bh = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
  function Ph(t3) {
    return Bh ? Buffer.byteLength(t3) : new Blob([t3]).size;
  }
  function Lh(t3) {
    var e2 = 0;
    t3.forEach(function(t4) {
      e2 += t4.byteLength;
    });
    var n2 = new Uint8Array(e2), r2 = 0;
    return t3.forEach(function(t4) {
      n2.set(new Uint8Array(t4), r2), r2 += t4.byteLength;
    }), n2.buffer;
  }
  function Wh(t3) {
    for (t3 = t3.trim(); t3.endsWith("/"); )
      t3 = t3.slice(0, t3.length - 1);
    var e2 = t3.split("/");
    return e2[e2.length - 1];
  }
  function Uh(t3) {
    if (t3.modelTopology instanceof ArrayBuffer)
      throw new Error("Expected JSON model topology, received ArrayBuffer.");
    return { dateSaved: /* @__PURE__ */ new Date(), modelTopologyType: "JSON", modelTopologyBytes: null == t3.modelTopology ? 0 : Ph(JSON.stringify(t3.modelTopology)), weightSpecsBytes: null == t3.weightSpecs ? 0 : Ph(JSON.stringify(t3.weightSpecs)), weightDataBytes: null == t3.weightData ? 0 : t3.weightData.byteLength };
  }
  var Vh = function() {
    function t3() {
      this.saveRouters = [], this.loadRouters = [];
    }
    return t3.getInstance = function() {
      return null == t3.instance && (t3.instance = new t3()), t3.instance;
    }, t3.registerSaveRouter = function(e2) {
      t3.getInstance().saveRouters.push(e2);
    }, t3.registerLoadRouter = function(e2) {
      t3.getInstance().loadRouters.push(e2);
    }, t3.getSaveHandlers = function(e2) {
      return t3.getHandlers(e2, "save");
    }, t3.getLoadHandlers = function(e2, n2) {
      return t3.getHandlers(e2, "load", n2);
    }, t3.getHandlers = function(e2, n2, r2) {
      var o2 = [];
      return ("load" === n2 ? t3.getInstance().loadRouters : t3.getInstance().saveRouters).forEach(function(t4) {
        var n3 = t4(e2, r2);
        null !== n3 && o2.push(n3);
      }), o2;
    }, t3;
  }();
  var zh = "://";
  var Gh = function() {
    function t3() {
      this.managers = {};
    }
    return t3.getInstance = function() {
      return null == t3.instance && (t3.instance = new t3()), t3.instance;
    }, t3.registerManager = function(e2, n2) {
      g(null != e2, function() {
        return "scheme must not be undefined or null.";
      }), e2.endsWith(zh) && (e2 = e2.slice(0, e2.indexOf(zh))), g(e2.length > 0, function() {
        return "scheme must not be an empty string.";
      });
      var r2 = t3.getInstance();
      g(null == r2.managers[e2], function() {
        return "A model store manager is already registered for scheme '" + e2 + "'.";
      }), r2.managers[e2] = n2;
    }, t3.getManager = function(t4) {
      var e2 = this.getInstance().managers[t4];
      if (null == e2)
        throw new Error("Cannot find model manager for scheme '" + t4 + "'");
      return e2;
    }, t3.getSchemes = function() {
      return Object.keys(this.getInstance().managers);
    }, t3;
  }();
  function Hh(t3) {
    if (-1 === t3.indexOf(zh))
      throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + Gh.getSchemes().join(","));
    return { scheme: t3.split(zh)[0], path: t3.split(zh)[1] };
  }
  function qh(t3, e2, o2) {
    return void 0 === o2 && (o2 = false), n(this, void 0, void 0, function() {
      var n2, a2, i2, u2, s2, c2, l3, h, f2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return g(t3 !== e2, function() {
              return "Old path and new path are the same: '" + t3 + "'";
            }), g((n2 = Vh.getLoadHandlers(t3)).length > 0, function() {
              return "Copying failed because no load handler is found for source URL " + t3 + ".";
            }), g(n2.length < 2, function() {
              return "Copying failed because more than one (" + n2.length + ") load handlers for source URL " + t3 + ".";
            }), a2 = n2[0], g((i2 = Vh.getSaveHandlers(e2)).length > 0, function() {
              return "Copying failed because no save handler is found for destination URL " + e2 + ".";
            }), g(i2.length < 2, function() {
              return "Copying failed because more than one (" + n2.length + ") save handlers for destination URL " + e2 + ".";
            }), u2 = i2[0], s2 = Hh(t3).scheme, c2 = Hh(t3).path, l3 = s2 === Hh(t3).scheme, [4, a2.load()];
          case 1:
            return h = r2.sent(), o2 && l3 ? [4, Gh.getManager(s2).removeModel(c2)] : [3, 3];
          case 2:
            r2.sent(), r2.label = 3;
          case 3:
            return [4, u2.save(h)];
          case 4:
            return f2 = r2.sent(), !o2 || l3 ? [3, 6] : [4, Gh.getManager(s2).removeModel(c2)];
          case 5:
            r2.sent(), r2.label = 6;
          case 6:
            return [2, f2.modelArtifactsInfo];
        }
      });
    });
  }
  var Kh = "models_store";
  var jh = "model_info_store";
  function Xh() {
    if (!a().getBool("IS_BROWSER"))
      throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    var t3 = window, e2 = t3.indexedDB || t3.mozIndexedDB || t3.webkitIndexedDB || t3.msIndexedDB || t3.shimIndexedDB;
    if (null == e2)
      throw new Error("The current browser does not appear to support IndexedDB.");
    return e2;
  }
  function $h(t3) {
    var e2 = t3.result;
    e2.createObjectStore(Kh, { keyPath: "modelPath" }), e2.createObjectStore(jh, { keyPath: "modelPath" });
  }
  var Yh = function() {
    function t3(t4) {
      if (this.indexedDB = Xh(), null == t4 || !t4)
        throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
      this.modelPath = t4;
    }
    return t3.prototype.save = function(t4) {
      return n(this, void 0, void 0, function() {
        return r(this, function(e2) {
          if (t4.modelTopology instanceof ArrayBuffer)
            throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
          return [2, this.databaseAction(this.modelPath, t4)];
        });
      });
    }, t3.prototype.load = function() {
      return n(this, void 0, void 0, function() {
        return r(this, function(t4) {
          return [2, this.databaseAction(this.modelPath)];
        });
      });
    }, t3.prototype.databaseAction = function(t4, e2) {
      var n2 = this;
      return new Promise(function(t5, r2) {
        var o2 = n2.indexedDB.open("tensorflowjs", 1);
        o2.onupgradeneeded = function() {
          return $h(o2);
        }, o2.onsuccess = function() {
          var a2 = o2.result;
          if (null == e2) {
            var i2 = a2.transaction(Kh, "readonly"), u2 = i2.objectStore(Kh).get(n2.modelPath);
            u2.onsuccess = function() {
              if (null == u2.result)
                return a2.close(), r2(new Error("Cannot find model with path '" + n2.modelPath + "' in IndexedDB."));
              t5(u2.result.modelArtifacts);
            }, u2.onerror = function(t6) {
              return a2.close(), r2(u2.error);
            }, i2.oncomplete = function() {
              return a2.close();
            };
          } else {
            var s2, c2 = Uh(e2), l3 = a2.transaction(jh, "readwrite"), h = l3.objectStore(jh), f2 = h.put({ modelPath: n2.modelPath, modelArtifactsInfo: c2 });
            f2.onsuccess = function() {
              var o3 = (s2 = a2.transaction(Kh, "readwrite")).objectStore(Kh).put({ modelPath: n2.modelPath, modelArtifacts: e2, modelArtifactsInfo: c2 });
              o3.onsuccess = function() {
                return t5({ modelArtifactsInfo: c2 });
              }, o3.onerror = function(t6) {
                var e3 = (h = l3.objectStore(jh)).delete(n2.modelPath);
                e3.onsuccess = function() {
                  return a2.close(), r2(o3.error);
                }, e3.onerror = function(t7) {
                  return a2.close(), r2(o3.error);
                };
              };
            }, f2.onerror = function(t6) {
              return a2.close(), r2(f2.error);
            }, l3.oncomplete = function() {
              null == s2 ? a2.close() : s2.oncomplete = function() {
                return a2.close();
              };
            };
          }
        }, o2.onerror = function(t6) {
          return r2(o2.error);
        };
      });
    }, t3.URL_SCHEME = "indexeddb://", t3;
  }();
  var Qh = function(t3) {
    return a().getBool("IS_BROWSER") && !Array.isArray(t3) && t3.startsWith(Yh.URL_SCHEME) ? (e2 = t3.slice(Yh.URL_SCHEME.length), new Yh(e2)) : null;
    var e2;
  };
  Vh.registerSaveRouter(Qh), Vh.registerLoadRouter(Qh);
  var Jh = function() {
    function t3() {
      this.indexedDB = Xh();
    }
    return t3.prototype.listModels = function() {
      return n(this, void 0, void 0, function() {
        var t4 = this;
        return r(this, function(e2) {
          return [2, new Promise(function(e3, n2) {
            var r2 = t4.indexedDB.open("tensorflowjs", 1);
            r2.onupgradeneeded = function() {
              return $h(r2);
            }, r2.onsuccess = function() {
              var t5 = r2.result, o2 = t5.transaction(jh, "readonly"), a2 = o2.objectStore(jh).getAll();
              a2.onsuccess = function() {
                for (var t6 = {}, n3 = 0, r3 = a2.result; n3 < r3.length; n3++) {
                  var o3 = r3[n3];
                  t6[o3.modelPath] = o3.modelArtifactsInfo;
                }
                e3(t6);
              }, a2.onerror = function(e4) {
                return t5.close(), n2(a2.error);
              }, o2.oncomplete = function() {
                return t5.close();
              };
            }, r2.onerror = function(t5) {
              return n2(r2.error);
            };
          })];
        });
      });
    }, t3.prototype.removeModel = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2 = this;
        return r(this, function(n2) {
          var r2;
          return t4 = (r2 = t4).startsWith(Yh.URL_SCHEME) ? r2.slice(Yh.URL_SCHEME.length) : r2, [2, new Promise(function(n3, r3) {
            var o2 = e2.indexedDB.open("tensorflowjs", 1);
            o2.onupgradeneeded = function() {
              return $h(o2);
            }, o2.onsuccess = function() {
              var e3, a2 = o2.result, i2 = a2.transaction(jh, "readwrite"), u2 = i2.objectStore(jh), s2 = u2.get(t4);
              s2.onsuccess = function() {
                if (null == s2.result)
                  return a2.close(), r3(new Error("Cannot find model with path '" + t4 + "' in IndexedDB."));
                var o3 = u2.delete(t4), i3 = function() {
                  var o4 = (e3 = a2.transaction(Kh, "readwrite")).objectStore(Kh).delete(t4);
                  o4.onsuccess = function() {
                    return n3(s2.result.modelArtifactsInfo);
                  }, o4.onerror = function(t5) {
                    return r3(s2.error);
                  };
                };
                o3.onsuccess = i3, o3.onerror = function(t5) {
                  return i3(), a2.close(), r3(s2.error);
                };
              }, s2.onerror = function(t5) {
                return a2.close(), r3(s2.error);
              }, i2.oncomplete = function() {
                null == e3 ? a2.close() : e3.oncomplete = function() {
                  return a2.close();
                };
              };
            }, o2.onerror = function(t5) {
              return r3(o2.error);
            };
          })];
        });
      });
    }, t3;
  }();
  if (a().getBool("IS_BROWSER"))
    try {
      Gh.registerManager(Yh.URL_SCHEME, new Jh());
    } catch (t3) {
    }
  var Zh = "/";
  var tf2 = "tensorflowjs_models";
  var ef = "info";
  var nf = "model_topology";
  var rf = "weight_specs";
  var of = "weight_data";
  var af = "model_metadata";
  function uf(t3) {
    return { info: [tf2, t3, ef].join(Zh), topology: [tf2, t3, nf].join(Zh), weightSpecs: [tf2, t3, rf].join(Zh), weightData: [tf2, t3, of].join(Zh), modelMetadata: [tf2, t3, af].join(Zh) };
  }
  function sf(t3) {
    var e2 = t3.split(Zh);
    if (e2.length < 3)
      throw new Error("Invalid key format: " + t3);
    return e2.slice(1, e2.length - 1).join(Zh);
  }
  var cf = function() {
    function t3(t4) {
      if (!a().getBool("IS_BROWSER") || void 0 === window.localStorage)
        throw new Error("The current environment does not support local storage.");
      if (this.LS = window.localStorage, null == t4 || !t4)
        throw new Error("For local storage, modelPath must not be null, undefined or empty.");
      this.modelPath = t4, this.keys = uf(this.modelPath);
    }
    return t3.prototype.save = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2, o2;
        return r(this, function(r2) {
          if (t4.modelTopology instanceof ArrayBuffer)
            throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
          e2 = JSON.stringify(t4.modelTopology), n2 = JSON.stringify(t4.weightSpecs), o2 = Uh(t4);
          try {
            return this.LS.setItem(this.keys.info, JSON.stringify(o2)), this.LS.setItem(this.keys.topology, e2), this.LS.setItem(this.keys.weightSpecs, n2), this.LS.setItem(this.keys.weightData, (a2 = t4.weightData, Bh ? Buffer.from(a2).toString("base64") : btoa(String.fromCharCode.apply(null, new Uint8Array(a2))))), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({ format: t4.format, generatedBy: t4.generatedBy, convertedBy: t4.convertedBy })), [2, { modelArtifactsInfo: o2 }];
          } catch (t5) {
            throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + o2.modelTopologyBytes + ", weightSpecsBytes=" + o2.weightSpecsBytes + ", weightDataBytes=" + o2.weightDataBytes + ".");
          }
          var a2;
          return [2];
        });
      });
    }, t3.prototype.load = function() {
      return n(this, void 0, void 0, function() {
        var t4, e2, n2, o2, a2, i2, u2;
        return r(this, function(r2) {
          if (null == (t4 = JSON.parse(this.LS.getItem(this.keys.info))))
            throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
          if ("JSON" !== t4.modelTopologyType)
            throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
          if (e2 = {}, null == (n2 = JSON.parse(this.LS.getItem(this.keys.topology))))
            throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
          if (e2.modelTopology = n2, null == (o2 = JSON.parse(this.LS.getItem(this.keys.weightSpecs))))
            throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
          if (e2.weightSpecs = o2, null != (a2 = this.LS.getItem(this.keys.modelMetadata)) && (i2 = JSON.parse(a2), e2.format = i2.format, e2.generatedBy = i2.generatedBy, e2.convertedBy = i2.convertedBy), null == (u2 = this.LS.getItem(this.keys.weightData)))
            throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
          return e2.weightData = function(t5) {
            if (Bh) {
              var e3 = Buffer.from(t5, "base64");
              return e3.buffer.slice(e3.byteOffset, e3.byteOffset + e3.byteLength);
            }
            for (var n3 = atob(t5), r3 = new Uint8Array(n3.length), o3 = 0; o3 < n3.length; ++o3)
              r3.set([n3.charCodeAt(o3)], o3);
            return r3.buffer;
          }(u2), [2, e2];
        });
      });
    }, t3.URL_SCHEME = "localstorage://", t3;
  }();
  var lf = function(t3) {
    return a().getBool("IS_BROWSER") && !Array.isArray(t3) && t3.startsWith(cf.URL_SCHEME) ? (e2 = t3.slice(cf.URL_SCHEME.length), new cf(e2)) : null;
    var e2;
  };
  Vh.registerSaveRouter(lf), Vh.registerLoadRouter(lf);
  var hf = function() {
    function t3() {
      g(a().getBool("IS_BROWSER"), function() {
        return "Current environment is not a web browser";
      }), g(void 0 !== window.localStorage, function() {
        return "Current browser does not appear to support localStorage";
      }), this.LS = window.localStorage;
    }
    return t3.prototype.listModels = function() {
      return n(this, void 0, void 0, function() {
        var t4, e2, n2, o2, a2, i2;
        return r(this, function(r2) {
          for (t4 = {}, e2 = tf2 + Zh, n2 = Zh + ef, o2 = 0; o2 < this.LS.length; ++o2)
            (a2 = this.LS.key(o2)).startsWith(e2) && a2.endsWith(n2) && (i2 = sf(a2), t4[i2] = JSON.parse(this.LS.getItem(a2)));
          return [2, t4];
        });
      });
    }, t3.prototype.removeModel = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2;
        return r(this, function(r2) {
          var o2;
          if (t4 = (o2 = t4).startsWith(cf.URL_SCHEME) ? o2.slice(cf.URL_SCHEME.length) : o2, e2 = uf(t4), null == this.LS.getItem(e2.info))
            throw new Error("Cannot find model at path '" + t4 + "'");
          return n2 = JSON.parse(this.LS.getItem(e2.info)), this.LS.removeItem(e2.info), this.LS.removeItem(e2.topology), this.LS.removeItem(e2.weightSpecs), this.LS.removeItem(e2.weightData), [2, n2];
        });
      });
    }, t3;
  }();
  if (a().getBool("IS_BROWSER"))
    try {
      Gh.registerManager(cf.URL_SCHEME, new hf());
    } catch (t3) {
    }
  var ff = "model";
  var pf = ".json";
  var df = ".weights.bin";
  function vf(t3) {
    return new Promise(function(t4) {
      return setTimeout(t4);
    }).then(t3);
  }
  var mf = function() {
    function t3(e2) {
      if (!a().getBool("IS_BROWSER"))
        throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
      e2.startsWith(t3.URL_SCHEME) && (e2 = e2.slice(t3.URL_SCHEME.length)), null != e2 && 0 !== e2.length || (e2 = ff), this.modelTopologyFileName = e2 + pf, this.weightDataFileName = e2 + df;
    }
    return t3.prototype.save = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2, o2, a2, i2, u2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              if ("undefined" == typeof document)
                throw new Error("Browser downloads are not supported in this environment since `document` is not present");
              if (e2 = window.URL.createObjectURL(new Blob([t4.weightData], { type: "application/octet-stream" })), !(t4.modelTopology instanceof ArrayBuffer))
                return [3, 1];
              throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
            case 1:
              return n2 = [{ paths: ["./" + this.weightDataFileName], weights: t4.weightSpecs }], o2 = { modelTopology: t4.modelTopology, format: t4.format, generatedBy: t4.generatedBy, convertedBy: t4.convertedBy, weightsManifest: n2 }, a2 = window.URL.createObjectURL(new Blob([JSON.stringify(o2)], { type: "application/json" })), (i2 = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, i2.href = a2, [4, vf(function() {
                return i2.dispatchEvent(new MouseEvent("click"));
              })];
            case 2:
              return r2.sent(), null == t4.weightData ? [3, 4] : ((u2 = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, u2.href = e2, [4, vf(function() {
                return u2.dispatchEvent(new MouseEvent("click"));
              })]);
            case 3:
              r2.sent(), r2.label = 4;
            case 4:
              return [2, { modelArtifactsInfo: Uh(t4) }];
          }
        });
      });
    }, t3.URL_SCHEME = "downloads://", t3;
  }();
  var gf = function() {
    function t3(t4) {
      if (null == t4 || t4.length < 1)
        throw new Error("When calling browserFiles, at least 1 file is required, but received " + t4);
      this.files = t4;
    }
    return t3.prototype.load = function() {
      return n(this, void 0, void 0, function() {
        var t4, e2, n2 = this;
        return r(this, function(r2) {
          return t4 = this.files[0], e2 = this.files.slice(1), [2, new Promise(function(r3, o2) {
            var a2 = new FileReader();
            a2.onload = function(a3) {
              var i2 = JSON.parse(a3.target.result), u2 = i2.modelTopology;
              if (null != u2) {
                0 === e2.length && r3({ modelTopology: u2 });
                var s2 = i2.weightsManifest;
                if (null != s2) {
                  var c2;
                  try {
                    c2 = n2.checkManifestAndWeightFiles(s2, e2);
                  } catch (t5) {
                    return void o2(t5);
                  }
                  var l3 = [], h = [], f2 = [];
                  s2.forEach(function(t5) {
                    t5.paths.forEach(function(t6) {
                      h.push(t6), f2.push(null);
                    }), l3.push.apply(l3, t5.weights);
                  }), s2.forEach(function(t5) {
                    t5.paths.forEach(function(t6) {
                      var e3 = new FileReader();
                      e3.onload = function(e4) {
                        var n3 = e4.target.result, o3 = h.indexOf(t6);
                        f2[o3] = n3, -1 === f2.indexOf(null) && r3({ modelTopology: u2, weightSpecs: l3, weightData: Lh(f2) });
                      }, e3.onerror = function(e4) {
                        return o2("Failed to weights data from file of path '" + t6 + "'.");
                      }, e3.readAsArrayBuffer(c2[t6]);
                    });
                  });
                } else
                  o2(new Error("weightManifest field is missing from file " + t4.name));
              } else
                o2(new Error("modelTopology field is missing from file " + t4.name));
            }, a2.onerror = function(e3) {
              return o2("Failed to read model topology and weights manifest JSON from file '" + t4.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
            }, a2.readAsText(t4);
          })];
        });
      });
    }, t3.prototype.checkManifestAndWeightFiles = function(t4, e2) {
      for (var n2 = [], r2 = e2.map(function(t5) {
        return Wh(t5.name);
      }), o2 = {}, a2 = 0, i2 = t4; a2 < i2.length; a2++) {
        i2[a2].paths.forEach(function(t5) {
          var a3 = Wh(t5);
          if (-1 !== n2.indexOf(a3))
            throw new Error("Duplicate file basename found in weights manifest: '" + a3 + "'");
          if (n2.push(a3), -1 === r2.indexOf(a3))
            throw new Error("Weight file with basename '" + a3 + "' is not provided.");
          o2[t5] = e2[r2.indexOf(a3)];
        });
      }
      if (n2.length !== e2.length)
        throw new Error("Mismatch in the number of files in weights manifest (" + n2.length + ") and the number of weight files provided (" + e2.length + ").");
      return o2;
    }, t3;
  }();
  function yf(t3, e2, n2, r2) {
    !function(t4) {
      g(null != t4 && Array.isArray(t4) && t4.length > 0, function() {
        return "promises must be a none empty array";
      });
    }(t3), function(t4, e3) {
      g(t4 >= 0 && t4 <= 1, function() {
        return "Progress fraction must be in range [0, 1], but got startFraction " + t4;
      }), g(e3 >= 0 && e3 <= 1, function() {
        return "Progress fraction must be in range [0, 1], but got endFraction " + e3;
      }), g(e3 >= t4, function() {
        return "startFraction must be no more than endFraction, but got startFraction " + t4 + " and endFraction " + e3;
      });
    }(n2 = null == n2 ? 0 : n2, r2 = null == r2 ? 1 : r2);
    var o2 = 0;
    return Promise.all(t3.map(function(a2) {
      return a2.then(function(a3) {
        var i2 = n2 + ++o2 / t3.length * (r2 - n2);
        return e2(i2), a3;
      }), a2;
    }));
  }
  function xf(t3, e2) {
    return n(this, void 0, void 0, function() {
      var n2, o2, i2, u2, s2, c2, l3, h, f2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return null == e2 && (e2 = {}), n2 = null == e2.fetchFunc ? a().platform.fetch : e2.fetchFunc, o2 = t3.map(function(t4) {
              return n2(t4, e2.requestInit, { isBinary: true });
            }), i2 = 0, u2 = 0.5, null != e2.onProgress ? [3, 2] : [4, Promise.all(o2)];
          case 1:
            return s2 = r2.sent(), [3, 4];
          case 2:
            return [4, yf(o2, e2.onProgress, i2, u2)];
          case 3:
            s2 = r2.sent(), r2.label = 4;
          case 4:
            return c2 = s2.map(function(t4) {
              return t4.arrayBuffer();
            }), l3 = 0.5, h = 1, null != e2.onProgress ? [3, 6] : [4, Promise.all(c2)];
          case 5:
            return f2 = r2.sent(), [3, 8];
          case 6:
            return [4, yf(c2, e2.onProgress, l3, h)];
          case 7:
            f2 = r2.sent(), r2.label = 8;
          case 8:
            return [2, f2];
        }
      });
    });
  }
  function bf(t3) {
    var e2 = this;
    return function(o2, a2, i2) {
      return void 0 === a2 && (a2 = ""), n(e2, void 0, void 0, function() {
        var e3, n2, u2, s2, c2, l3, h, f2, p2, d2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              if (e3 = o2.map(function() {
                return false;
              }), n2 = {}, u2 = null != i2 ? i2.map(function() {
                return false;
              }) : [], s2 = [], o2.forEach(function(t4, r3) {
                var o3 = 0;
                t4.weights.forEach(function(t5) {
                  var a3 = "quantization" in t5 ? t5.quantization.dtype : t5.dtype, c3 = Fh[a3] * w(t5.shape), l4 = function() {
                    e3[r3] = true, null == n2[r3] && (n2[r3] = []), n2[r3].push({ manifestEntry: t5, groupOffset: o3, sizeBytes: c3 });
                  };
                  null != i2 ? i2.forEach(function(e4, n3) {
                    e4 === t5.name && (l4(), u2[n3] = true);
                  }) : l4(), s2.push(t5.name), o3 += c3;
                });
              }), !u2.every(function(t4) {
                return t4;
              }))
                throw c2 = i2.filter(function(t4, e4) {
                  return !u2[e4];
                }), new Error("Could not find weights in manifest with names: " + c2.join(", ") + ". \nManifest JSON has weights with names: " + s2.join(", ") + ".");
              return l3 = e3.reduce(function(t4, e4, n3) {
                return e4 && t4.push(n3), t4;
              }, []), h = [], l3.forEach(function(t4) {
                o2[t4].paths.forEach(function(t5) {
                  var e4 = a2 + (a2.endsWith("/") ? "" : "/") + t5;
                  h.push(e4);
                });
              }), [4, t3(h)];
            case 1:
              return f2 = r2.sent(), p2 = {}, d2 = 0, l3.forEach(function(t4) {
                for (var e4 = o2[t4].paths.length, r3 = 0, a3 = 0; a3 < e4; a3++)
                  r3 += f2[d2 + a3].byteLength;
                for (var i3 = new ArrayBuffer(r3), u3 = new Uint8Array(i3), s3 = 0, c3 = 0; c3 < e4; c3++) {
                  var l4 = new Uint8Array(f2[d2 + c3]);
                  u3.set(l4, s3), s3 += l4.byteLength;
                }
                n2[t4].forEach(function(t5) {
                  var e5 = _h(i3.slice(t5.groupOffset, t5.groupOffset + t5.sizeBytes), [t5.manifestEntry]);
                  for (var n3 in e5)
                    p2[n3] = e5[n3];
                }), d2 += e4;
              }), [2, p2];
          }
        });
      });
    };
  }
  Vh.registerSaveRouter(function(t3) {
    return a().getBool("IS_BROWSER") && !Array.isArray(t3) && t3.startsWith(mf.URL_SCHEME) ? (e2 = t3.slice(mf.URL_SCHEME.length), void 0 === e2 && (e2 = "model"), new mf(e2)) : null;
    var e2;
  });
  var wf = function() {
    function t3(t4, e2) {
      if (this.DEFAULT_METHOD = "POST", null == e2 && (e2 = {}), this.weightPathPrefix = e2.weightPathPrefix, this.onProgress = e2.onProgress, null != e2.fetchFunc ? (g("function" == typeof e2.fetchFunc, function() {
        return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
      }), this.fetch = e2.fetchFunc) : this.fetch = a().platform.fetch, g(null != t4 && t4.length > 0, function() {
        return "URL path for http must not be null, undefined or empty.";
      }), Array.isArray(t4) && g(2 === t4.length, function() {
        return "URL paths for http must have a length of 2, (actual length is " + t4.length + ").";
      }), this.path = t4, null != e2.requestInit && null != e2.requestInit.body)
        throw new Error("requestInit is expected to have no pre-existing body, but has one.");
      this.requestInit = e2.requestInit || {};
    }
    return t3.prototype.save = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2, o2, a2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              if (t4.modelTopology instanceof ArrayBuffer)
                throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
              return (e2 = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit)).body = new FormData(), n2 = [{ paths: ["./model.weights.bin"], weights: t4.weightSpecs }], o2 = { modelTopology: t4.modelTopology, format: t4.format, generatedBy: t4.generatedBy, convertedBy: t4.convertedBy, userDefinedMetadata: t4.userDefinedMetadata, weightsManifest: n2 }, e2.body.append("model.json", new Blob([JSON.stringify(o2)], { type: "application/json" }), "model.json"), null != t4.weightData && e2.body.append("model.weights.bin", new Blob([t4.weightData], { type: "application/octet-stream" }), "model.weights.bin"), [4, this.fetch(this.path, e2)];
            case 1:
              if ((a2 = r2.sent()).ok)
                return [2, { modelArtifactsInfo: Uh(t4), responses: [a2] }];
              throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + a2.status + ".");
          }
        });
      });
    }, t3.prototype.load = function() {
      return n(this, void 0, void 0, function() {
        var t4, e2, n2, o2, a2, i2, u2, s2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              return [4, this.fetch(this.path, this.requestInit)];
            case 1:
              if (!(t4 = r2.sent()).ok)
                throw new Error("Request to " + this.path + " failed with status code " + t4.status + ". Please verify this URL points to the model JSON of the model to load.");
              r2.label = 2;
            case 2:
              return r2.trys.push([2, 4, , 5]), [4, t4.json()];
            case 3:
              return e2 = r2.sent(), [3, 5];
            case 4:
              throw r2.sent(), n2 = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n2 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n2 += " Please make sure the server is serving valid JSON for this request.", new Error(n2);
            case 5:
              if (o2 = e2.modelTopology, a2 = e2.weightsManifest, null == o2 && null == a2)
                throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
              return null == a2 ? [3, 7] : [4, this.loadWeights(a2)];
            case 6:
              s2 = r2.sent(), i2 = s2[0], u2 = s2[1], r2.label = 7;
            case 7:
              return [2, { modelTopology: o2, weightSpecs: i2, weightData: u2 }];
          }
        });
      });
    }, t3.prototype.loadWeights = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2, o2, a2, i2, u2, s2, c2, l3, h, f2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              for (e2 = Array.isArray(this.path) ? this.path[1] : this.path, n2 = function(t5) {
                var e3 = t5.lastIndexOf("/"), n3 = t5.lastIndexOf("?"), r3 = t5.substring(0, e3), o3 = n3 > e3 ? t5.substring(n3) : "";
                return [r3 + "/", o3];
              }(e2), o2 = n2[0], a2 = n2[1], i2 = this.weightPathPrefix || o2, u2 = [], s2 = 0, c2 = t4; s2 < c2.length; s2++)
                l3 = c2[s2], u2.push.apply(u2, l3.weights);
              return h = [], t4.forEach(function(t5) {
                t5.paths.forEach(function(t6) {
                  h.push(i2 + t6 + a2);
                });
              }), [4, xf(h, { requestInit: this.requestInit, fetchFunc: this.fetch, onProgress: this.onProgress })];
            case 1:
              return f2 = r2.sent(), [2, [u2, Lh(f2)]];
          }
        });
      });
    }, t3.URL_SCHEME_REGEX = /^https?:\/\//, t3;
  }();
  function Cf(t3) {
    return null != t3.match(wf.URL_SCHEME_REGEX);
  }
  var Ef = function(t3, e2) {
    if ("undefined" == typeof fetch)
      return null;
    return (Array.isArray(t3) ? t3.every(function(t4) {
      return Cf(t4);
    }) : Cf(t3)) ? Rf(t3, { onProgress: e2 }) : null;
  };
  function Rf(t3, e2) {
    return new wf(t3, e2);
  }
  Vh.registerSaveRouter(Ef), Vh.registerLoadRouter(Ef);
  var If = function() {
    function t3(t4) {
      this.modelArtifacts = t4;
    }
    return t3.prototype.load = function() {
      return n(this, void 0, void 0, function() {
        return r(this, function(t4) {
          return [2, this.modelArtifacts];
        });
      });
    }, t3;
  }();
  var kf = function() {
    function t3(t4) {
      this.saveHandler = t4;
    }
    return t3.prototype.save = function(t4) {
      return n(this, void 0, void 0, function() {
        return r(this, function(e2) {
          return [2, this.saveHandler(t4)];
        });
      });
    }, t3;
  }();
  var Sf = Object.freeze({ browserFiles: function(t3) {
    return new gf(t3);
  }, browserHTTPRequest: function(t3, e2) {
    return Rf(t3, e2);
  }, concatenateArrayBuffers: Lh, decodeWeights: _h, encodeWeights: function(t3, e2) {
    return n(this, void 0, void 0, function() {
      var o2, a2, i2, u2, s2, c2 = this;
      return r(this, function(l3) {
        switch (l3.label) {
          case 0:
            for (o2 = [], a2 = [], i2 = Array.isArray(t3) ? t3.map(function(t4) {
              return t4.name;
            }) : Object.keys(t3), u2 = function(u3) {
              var s3 = i2[u3], l4 = Array.isArray(t3) ? t3[u3].tensor : t3[s3];
              if ("float32" !== l4.dtype && "int32" !== l4.dtype && "bool" !== l4.dtype && "string" !== l4.dtype)
                throw new Error("Unsupported dtype in weight '" + s3 + "': " + l4.dtype);
              var h = { name: s3, shape: l4.shape, dtype: l4.dtype };
              if ("string" === l4.dtype) {
                var f2 = new Promise(function(t4) {
                  return n(c2, void 0, void 0, function() {
                    var e3, n2, o3, a3, i3, u4, s4;
                    return r(this, function(r2) {
                      switch (r2.label) {
                        case 0:
                          return [4, l4.bytes()];
                        case 1:
                          for (e3 = r2.sent(), n2 = e3.reduce(function(t5, e4) {
                            return t5 + e4.length;
                          }, 0) + Oh * e3.length, o3 = new Uint8Array(n2), a3 = 0, i3 = 0; i3 < e3.length; i3++)
                            u4 = e3[i3], s4 = new Uint8Array(new Uint32Array([u4.length]).buffer), o3.set(s4, a3), a3 += Oh, o3.set(u4, a3), a3 += u4.length;
                          return t4(o3), [2];
                      }
                    });
                  });
                });
                a2.push(f2);
              } else
                a2.push(l4.data());
              null != e2 && (h.group = e2), o2.push(h);
            }, s2 = 0; s2 < i2.length; ++s2)
              u2(s2);
            return [4, Promise.all(a2)];
          case 1:
            return [2, { data: Mh(l3.sent()), specs: o2 }];
        }
      });
    });
  }, fromMemory: function(t3, e2, n2, r2) {
    return 1 === arguments.length ? null != t3.modelTopology || null != t3.weightSpecs ? new If(t3) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new If({ modelTopology: t3 })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new If({ modelTopology: t3, weightSpecs: e2, weightData: n2, trainingConfig: r2 }));
  }, getLoadHandlers: function(t3, e2) {
    return Vh.getLoadHandlers(t3, e2);
  }, getModelArtifactsInfoForJSON: Uh, getSaveHandlers: function(t3) {
    return Vh.getSaveHandlers(t3);
  }, http: Rf, isHTTPScheme: Cf, loadWeights: function(t3, e2, o2, a2) {
    return void 0 === e2 && (e2 = ""), n(this, void 0, void 0, function() {
      return r(this, function(n2) {
        return [2, bf(function(t4) {
          return xf(t4, { requestInit: a2 });
        })(t3, e2, o2)];
      });
    });
  }, registerLoadRouter: function(t3) {
    return Vh.registerLoadRouter(t3);
  }, registerSaveRouter: function(t3) {
    return Vh.registerSaveRouter(t3);
  }, weightsLoaderFactory: bf, withSaveHandler: function(t3) {
    return new kf(t3);
  }, copyModel: function(t3, e2) {
    return n(this, void 0, void 0, function() {
      return r(this, function(n2) {
        return [2, qh(t3, e2, false)];
      });
    });
  }, listModels: function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2, o2, a2, i2, u2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            t3 = Gh.getSchemes(), e2 = {}, n2 = 0, o2 = t3, r2.label = 1;
          case 1:
            return n2 < o2.length ? (a2 = o2[n2], [4, Gh.getManager(a2).listModels()]) : [3, 4];
          case 2:
            for (u2 in i2 = r2.sent())
              e2[a2 + zh + u2] = i2[u2];
            r2.label = 3;
          case 3:
            return n2++, [3, 1];
          case 4:
            return [2, e2];
        }
      });
    });
  }, moveModel: function(t3, e2) {
    return n(this, void 0, void 0, function() {
      return r(this, function(n2) {
        return [2, qh(t3, e2, true)];
      });
    });
  }, removeModel: function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        return e2 = Hh(t3), [2, Gh.getManager(e2.scheme).removeModel(e2.path)];
      });
    });
  } });
  var Af = Cn({ confusionMatrix_: function(t3, e2, n2) {
    var r2 = ln(t3, "labels", "confusionMatrix"), o2 = ln(e2, "predictions", "confusionMatrix");
    g(null == n2 || n2 > 0 && Number.isInteger(n2), function() {
      return "If provided, numClasses must be a positive integer, but got " + n2;
    }), g(1 === r2.rank, function() {
      return "Expected the rank of labels to be 1, but got " + r2.rank;
    }), g(1 === o2.rank, function() {
      return "Expected the rank of predictions to be 1, but got " + o2.rank;
    }), g(r2.shape[0] === o2.shape[0], function() {
      return "Mismatch in the number of examples: " + r2.shape[0] + " vs. " + o2.shape[0] + ". Labels and predictions should have the same number of elements.";
    }), g(n2 > 0 && Number.isInteger(n2), function() {
      return "numClasses is required to be a positive integer, but got " + n2;
    });
    var a2 = gr(r2.asType("int32"), n2), i2 = gr(o2.asType("int32"), n2);
    return a2.transpose().matMul(i2).asType("int32");
  } });
  var Df = Object.freeze({ confusionMatrix: Af });
  var Tf = Cn({ fromPixels_: function(t3, e2) {
    if (void 0 === e2 && (e2 = 3), e2 > 4)
      throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
    var n2 = "undefined" != typeof HTMLVideoElement && t3 instanceof HTMLVideoElement;
    if (n2 && n2 && t3.readyState < 2)
      throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
    return Nt.fromPixels(t3, e2);
  } });
  var Nf = Object.freeze({ toPixels: function(t3, e2) {
    return n(this, void 0, void 0, function() {
      var n2, o2, a2, i2, u2, s2, c2, l3, h, f2, p2, d2, v2, m2, g2, y2, x2, b2, w2, C3, E3, R3, I3;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (n2 = ln(t3, "img", "toPixels"), t3 instanceof dt || (n2 = n2.toInt()), 2 !== n2.rank && 3 !== n2.rank)
              throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n2.rank + ".");
            if (o2 = n2.shape.slice(0, 2), a2 = o2[0], i2 = o2[1], (u2 = 2 === n2.rank ? 1 : n2.shape[2]) > 4 || 2 === u2)
              throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + u2);
            return [4, n2.data()];
          case 1:
            return s2 = r2.sent(), c2 = n2.min(), l3 = n2.max(), [4, Promise.all([c2.data(), l3.data()])];
          case 2:
            if (h = r2.sent(), f2 = h[0], p2 = h[1], d2 = f2[0], v2 = p2[0], c2.dispose(), l3.dispose(), "float32" === n2.dtype) {
              if (d2 < 0 || v2 > 1)
                throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + d2 + " - " + v2 + "].");
            } else {
              if ("int32" !== n2.dtype)
                throw new Error("Unsupported type for toPixels: " + n2.dtype + ". Please use float32 or int32 tensors.");
              if (d2 < 0 || v2 > 255)
                throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + d2 + " - " + v2 + "].");
            }
            for (m2 = "float32" === n2.dtype ? 255 : 1, g2 = new Uint8ClampedArray(i2 * a2 * 4), y2 = 0; y2 < a2 * i2; ++y2)
              x2 = void 0, b2 = void 0, w2 = void 0, C3 = void 0, 1 === u2 ? (x2 = s2[y2] * m2, b2 = s2[y2] * m2, w2 = s2[y2] * m2, C3 = 255) : 3 === u2 ? (x2 = s2[3 * y2] * m2, b2 = s2[3 * y2 + 1] * m2, w2 = s2[3 * y2 + 2] * m2, C3 = 255) : 4 === u2 && (x2 = s2[4 * y2] * m2, b2 = s2[4 * y2 + 1] * m2, w2 = s2[4 * y2 + 2] * m2, C3 = s2[4 * y2 + 3] * m2), g2[0 + (E3 = 4 * y2)] = Math.round(x2), g2[E3 + 1] = Math.round(b2), g2[E3 + 2] = Math.round(w2), g2[E3 + 3] = Math.round(C3);
            return null != e2 && (e2.width = i2, e2.height = a2, R3 = e2.getContext("2d"), I3 = new ImageData(g2, i2, a2), R3.putImageData(I3, 0, 0)), n2 !== t3 && n2.dispose(), [2, g2];
        }
      });
    });
  }, fromPixels: Tf });
  var Ff = function() {
    function t3() {
    }
    return t3.prototype.getClassName = function() {
      return this.constructor.className;
    }, t3.fromConfig = function(t4, e2) {
      return new t4(e2);
    }, t3;
  }();
  var Of = function() {
    function t3() {
      this.classNameMap = {};
    }
    return t3.getMap = function() {
      return null == t3.instance && (t3.instance = new t3()), t3.instance;
    }, t3.register = function(e2) {
      t3.getMap().classNameMap[e2.className] = [e2, e2.fromConfig];
    }, t3;
  }();
  function _f(t3) {
    g(null != t3.className, function() {
      return "Class being registered does not have the static className property defined.";
    }), g("string" == typeof t3.className, function() {
      return "className is required to be a string, but got type " + typeof t3.className;
    }), g(t3.className.length > 0, function() {
      return "Class being registered has an empty-string as its className, which is disallowed.";
    }), Of.register(t3);
  }
  var Mf = Object.freeze({ Serializable: Ff, SerializationMap: Of, registerClass: _f });
  var Bf = 1e-3;
  var Pf = 0.1;
  function Lf() {
    return 32 === Nt.backend.floatPrecision() ? Bf : Pf;
  }
  function Wf(t3, e2, n2) {
    var r2 = true;
    if ((B(t3) || B(e2)) && (r2 = false), B(t3) && B(e2) && (r2 = true), r2) {
      var o2 = t3.constructor.name, a2 = e2.constructor.name;
      if (o2 !== a2)
        throw new Error("Arrays are of different type. Actual: " + o2 + ". Expected: " + a2);
    }
    if (Array.isArray(t3) && Array.isArray(e2)) {
      var i2 = sn(t3), u2 = sn(e2);
      if (!C(i2, u2))
        throw new Error("Arrays have different shapes. Actual: [" + i2 + "]. Expected: [" + u2 + "]");
    }
    var s2 = B(t3) ? t3 : b(t3), c2 = B(e2) ? e2 : b(e2);
    if (s2.length !== c2.length)
      throw new Error("Arrays have different lengths actual: " + s2.length + " vs expected: " + c2.length + ".\nActual:   " + s2 + ".\nExpected: " + c2 + ".");
    for (var l3 = 0; l3 < c2.length; ++l3) {
      var h = s2[l3], f2 = c2[l3];
      if (!n2(h, f2))
        throw new Error("Arrays differ: actual[" + l3 + "] = " + h + ", expected[" + l3 + "] = " + f2 + ".\nActual:   " + s2 + ".\nExpected: " + c2 + ".");
    }
  }
  function Uf(t3, e2, n2) {
    return !isFinite(t3) && !isFinite(e2) || !(isNaN(t3) || isNaN(e2) || Math.abs(t3 - e2) > n2);
  }
  var Vf = Object.freeze({ TEST_EPSILON_FLOAT16: Pf, expectArraysClose: function(t3, e2, n2) {
    return null == n2 && (n2 = Lf()), Wf(t3, e2, function(t4, e3) {
      return Uf(t4, e3, n2);
    });
  }, testEpsilon: Lf, expectPromiseToFail: function(t3, e2) {
    t3().then(function() {
      return e2.fail();
    }, function() {
      return e2();
    });
  }, expectArraysEqual: function(t3, e2) {
    var n2 = "string" == typeof e2 || "number" == typeof e2 || "boolean" == typeof e2 ? [e2] : e2;
    return W(t3) || W(t3[0]) || W(e2) || W(e2[0]) ? Wf(t3, n2, function(t4, e3) {
      return t4 == e3;
    }) : Wf(t3, e2, function(t4, e3) {
      return Uf(t4, e3, 0);
    });
  }, expectNumbersClose: function(t3, e2, n2) {
    if (null == n2 && (n2 = Lf()), !Uf(t3, e2, n2))
      throw new Error("Numbers differ: actual === " + t3 + ", expected === " + e2);
  }, expectValuesInRange: function(t3, e2, n2) {
    for (var r2 = 0; r2 < t3.length; r2++)
      if (t3[r2] < e2 || t3[r2] > n2)
        throw new Error("Value out of range:" + t3[r2] + " low: " + e2 + ", high: " + n2);
  }, expectArrayBuffersEqual: function(t3, e2) {
    expect(new Float32Array(t3)).toEqual(new Float32Array(e2));
  } });
  var Gf = Object.freeze({ gpgpu_util: wi, webgl_util: Pe, forceHalfFloat: function() {
    a().set("WEBGL_FORCE_F16_TEXTURES", true);
  }, MathBackendWebGL: Wu, setWebGLContext: Wt, GPGPUContext: Ci });
  var Hf = function(t3) {
    function o2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return e(o2, t3), o2.prototype.minimize = function(t4, e2, n2) {
      void 0 === e2 && (e2 = false);
      var r2 = this.computeGradients(t4, n2), o3 = r2.value, a2 = r2.grads;
      if (null != n2) {
        var i2 = n2.map(function(t5) {
          return { name: t5.name, tensor: a2[t5.name] };
        });
        this.applyGradients(i2);
      } else
        this.applyGradients(a2);
      return Xe(a2), e2 ? o3 : (o3.dispose(), null);
    }, Object.defineProperty(o2.prototype, "iterations", { get: function() {
      return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
    }, enumerable: true, configurable: true }), o2.prototype.incrementIterations = function() {
      this.iterations_ = this.iterations + 1;
    }, o2.prototype.computeGradients = function(t4, e2) {
      return ro(t4, e2);
    }, o2.prototype.dispose = function() {
      null != this.iterations_ && Xe(this.iterations_);
    }, o2.prototype.saveIterations = function() {
      return n(this, void 0, void 0, function() {
        return r(this, function(t4) {
          return null == this.iterations_ && (this.iterations_ = 0), [2, { name: "iter", tensor: An(this.iterations_, "int32") }];
        });
      });
    }, o2.prototype.getWeights = function() {
      return n(this, void 0, void 0, function() {
        return r(this, function(t4) {
          throw new Error("getWeights() is not implemented for this optimizer yet.");
        });
      });
    }, o2.prototype.setWeights = function(t4) {
      return n(this, void 0, void 0, function() {
        return r(this, function(t5) {
          throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
        });
      });
    }, o2.prototype.extractIterations = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2;
        return r(this, function(n2) {
          switch (n2.label) {
            case 0:
              return e2 = this, [4, t4[0].tensor.data()];
            case 1:
              return e2.iterations_ = n2.sent()[0], [2, t4.slice(1)];
          }
        });
      });
    }, o2;
  }(Ff);
  Object.defineProperty(Hf, Symbol.hasInstance, { value: function(t3) {
    return null != t3.minimize && null != t3.computeGradients && null != t3.applyGradients;
  } });
  var qf = function(t3) {
    function o2(e2, n2, r2) {
      void 0 === r2 && (r2 = null);
      var o3 = t3.call(this) || this;
      return o3.learningRate = e2, o3.rho = n2, o3.epsilon = r2, o3.accumulatedGrads = [], o3.accumulatedUpdates = [], null == r2 && (o3.epsilon = Nt.backend.epsilon()), o3;
    }
    return e(o2, t3), o2.prototype.applyGradients = function(t4) {
      var e2 = this;
      (Array.isArray(t4) ? t4.map(function(t5) {
        return t5.name;
      }) : Object.keys(t4)).forEach(function(n2, r2) {
        var o3 = Nt.registeredVariables[n2];
        null == e2.accumulatedGrads[r2] && (e2.accumulatedGrads[r2] = { originalName: n2 + "/accum_grad", variable: je(function() {
          return zn(o3).variable(false);
        }) }), null == e2.accumulatedUpdates[r2] && (e2.accumulatedUpdates[r2] = { originalName: n2 + "/accum_var", variable: je(function() {
          return zn(o3).variable(false);
        }) });
        var a2 = Array.isArray(t4) ? t4[r2].tensor : t4[n2];
        if (null != a2) {
          var i2 = e2.accumulatedGrads[r2].variable, u2 = e2.accumulatedUpdates[r2].variable;
          je(function() {
            var t5 = i2.mul(e2.rho).add(a2.square().mul(1 - e2.rho)), n3 = u2.add(e2.epsilon).sqrt().div(i2.add(e2.epsilon).sqrt()).mul(a2), r3 = u2.mul(e2.rho).add(n3.square().mul(1 - e2.rho));
            i2.assign(t5), u2.assign(r3);
            var s2 = n3.mul(-e2.learningRate).add(o3);
            o3.assign(s2);
          });
        }
      }), this.incrementIterations();
    }, o2.prototype.dispose = function() {
      null != this.accumulatedUpdates && (Xe(this.accumulatedGrads.map(function(t4) {
        return t4.variable;
      })), Xe(this.accumulatedUpdates.map(function(t4) {
        return t4.variable;
      })));
    }, o2.prototype.getWeights = function() {
      return n(this, void 0, void 0, function() {
        var t4;
        return r(this, function(e2) {
          switch (e2.label) {
            case 0:
              return t4 = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];
            case 1:
              return [2, [e2.sent()].concat(t4.map(function(t5) {
                return { name: t5.originalName, tensor: t5.variable };
              }))];
          }
        });
      });
    }, o2.prototype.setWeights = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2;
        return r(this, function(n2) {
          switch (n2.label) {
            case 0:
              return [4, this.extractIterations(t4)];
            case 1:
              return t4 = n2.sent(), e2 = t4.length / 2, false, this.accumulatedGrads = t4.slice(0, e2).map(function(t5) {
                return { originalName: t5.name, variable: t5.tensor.variable(false) };
              }), this.accumulatedUpdates = t4.slice(e2, 2 * e2).map(function(t5) {
                return { originalName: t5.name, variable: t5.tensor.variable(false) };
              }), [2];
          }
        });
      });
    }, o2.prototype.getConfig = function() {
      return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };
    }, o2.fromConfig = function(t4, e2) {
      return new t4(e2.learningRate, e2.rho, e2.epsilon);
    }, o2.className = "Adadelta", o2;
  }(Hf);
  _f(qf);
  var Kf = function(t3) {
    function o2(e2, n2) {
      void 0 === n2 && (n2 = 0.1);
      var r2 = t3.call(this) || this;
      return r2.learningRate = e2, r2.initialAccumulatorValue = n2, r2.accumulatedGrads = [], r2;
    }
    return e(o2, t3), o2.prototype.applyGradients = function(t4) {
      var e2 = this;
      (Array.isArray(t4) ? t4.map(function(t5) {
        return t5.name;
      }) : Object.keys(t4)).forEach(function(n2, r2) {
        var o3 = Nt.registeredVariables[n2];
        if (null == e2.accumulatedGrads[r2]) {
          e2.accumulatedGrads[r2] = { originalName: n2 + "/accumulator", variable: je(function() {
            return Ln(o3.shape, e2.initialAccumulatorValue).variable(false);
          }) };
        }
        var a2 = Array.isArray(t4) ? t4[r2].tensor : t4[n2];
        if (null != a2) {
          var i2 = e2.accumulatedGrads[r2].variable;
          je(function() {
            var t5 = i2.add(a2.square());
            i2.assign(t5);
            var n3 = a2.div(t5.add(Nt.backend.epsilon()).sqrt()).mul(-e2.learningRate).add(o3);
            o3.assign(n3);
          });
        }
      }), this.incrementIterations();
    }, o2.prototype.dispose = function() {
      null != this.accumulatedGrads && Xe(this.accumulatedGrads.map(function(t4) {
        return t4.variable;
      }));
    }, o2.prototype.getWeights = function() {
      return n(this, void 0, void 0, function() {
        return r(this, function(t4) {
          switch (t4.label) {
            case 0:
              return [4, this.saveIterations()];
            case 1:
              return [2, [t4.sent()].concat(this.accumulatedGrads.map(function(t5) {
                return { name: t5.originalName, tensor: t5.variable };
              }))];
          }
        });
      });
    }, o2.prototype.setWeights = function(t4) {
      return n(this, void 0, void 0, function() {
        return r(this, function(e2) {
          switch (e2.label) {
            case 0:
              return [4, this.extractIterations(t4)];
            case 1:
              return t4 = e2.sent(), false, this.accumulatedGrads = t4.map(function(t5) {
                return { originalName: t5.name, variable: t5.tensor.variable(false) };
              }), [2];
          }
        });
      });
    }, o2.prototype.getConfig = function() {
      return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };
    }, o2.fromConfig = function(t4, e2) {
      return new t4(e2.learningRate, e2.initialAccumulatorValue);
    }, o2.className = "Adagrad", o2;
  }(Hf);
  _f(Kf);
  var jf = function(t3) {
    function o2(e2, n2, r2, o3) {
      void 0 === o3 && (o3 = null);
      var a2 = t3.call(this) || this;
      return a2.learningRate = e2, a2.beta1 = n2, a2.beta2 = r2, a2.epsilon = o3, a2.accumulatedFirstMoment = [], a2.accumulatedSecondMoment = [], je(function() {
        a2.accBeta1 = An(n2).variable(), a2.accBeta2 = An(r2).variable();
      }), null == o3 && (a2.epsilon = Nt.backend.epsilon()), a2;
    }
    return e(o2, t3), o2.prototype.applyGradients = function(t4) {
      var e2 = this, n2 = Array.isArray(t4) ? t4.map(function(t5) {
        return t5.name;
      }) : Object.keys(t4);
      je(function() {
        var r2 = ic(1, e2.accBeta1), o3 = ic(1, e2.accBeta2);
        n2.forEach(function(n3, a2) {
          var i2 = Nt.registeredVariables[n3];
          null == e2.accumulatedFirstMoment[a2] && (e2.accumulatedFirstMoment[a2] = { originalName: n3 + "/m", variable: je(function() {
            return zn(i2).variable(false);
          }) }), null == e2.accumulatedSecondMoment[a2] && (e2.accumulatedSecondMoment[a2] = { originalName: n3 + "/v", variable: je(function() {
            return zn(i2).variable(false);
          }) });
          var u2 = Array.isArray(t4) ? t4[a2].tensor : t4[n3];
          if (null != u2) {
            var s2 = e2.accumulatedFirstMoment[a2].variable, c2 = e2.accumulatedSecondMoment[a2].variable, l3 = s2.mul(e2.beta1).add(u2.mul(1 - e2.beta1)), h = c2.mul(e2.beta2).add(u2.square().mul(1 - e2.beta2)), f2 = l3.div(r2), p2 = h.div(o3);
            s2.assign(l3), c2.assign(h);
            var d2 = f2.div(p2.sqrt().add(e2.epsilon)).mul(-e2.learningRate).add(i2);
            i2.assign(d2);
          }
        }), e2.accBeta1.assign(e2.accBeta1.mul(e2.beta1)), e2.accBeta2.assign(e2.accBeta2.mul(e2.beta2));
      }), this.incrementIterations();
    }, o2.prototype.dispose = function() {
      this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Xe(this.accumulatedFirstMoment.map(function(t4) {
        return t4.variable;
      })), null != this.accumulatedSecondMoment && Xe(this.accumulatedSecondMoment.map(function(t4) {
        return t4.variable;
      }));
    }, o2.prototype.getWeights = function() {
      return n(this, void 0, void 0, function() {
        var t4;
        return r(this, function(e2) {
          switch (e2.label) {
            case 0:
              return t4 = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];
            case 1:
              return [2, [e2.sent()].concat(t4.map(function(t5) {
                return { name: t5.originalName, tensor: t5.variable };
              }))];
          }
        });
      });
    }, o2.prototype.setWeights = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2, n2 = this;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              return [4, this.extractIterations(t4)];
            case 1:
              return t4 = r2.sent(), je(function() {
                n2.accBeta1.assign(nc(n2.beta1, n2.iterations_ + 1)), n2.accBeta2.assign(nc(n2.beta2, n2.iterations_ + 1));
              }), e2 = t4.length / 2, false, this.accumulatedFirstMoment = t4.slice(0, e2).map(function(t5) {
                return { originalName: t5.name, variable: t5.tensor.variable(false) };
              }), this.accumulatedSecondMoment = t4.slice(e2, 2 * e2).map(function(t5) {
                return { originalName: t5.name, variable: t5.tensor.variable(false) };
              }), [2];
          }
        });
      });
    }, o2.prototype.getConfig = function() {
      return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };
    }, o2.fromConfig = function(t4, e2) {
      return new t4(e2.learningRate, e2.beta1, e2.beta2, e2.epsilon);
    }, o2.className = "Adam", o2;
  }(Hf);
  _f(jf);
  var Xf = function(t3) {
    function o2(e2, n2, r2, o3, a2) {
      void 0 === o3 && (o3 = null), void 0 === a2 && (a2 = 0);
      var i2 = t3.call(this) || this;
      return i2.learningRate = e2, i2.beta1 = n2, i2.beta2 = r2, i2.epsilon = o3, i2.decay = a2, i2.accumulatedFirstMoment = [], i2.accumulatedWeightedInfNorm = [], je(function() {
        i2.iteration = An(0).variable(), i2.accBeta1 = An(n2).variable();
      }), null == o3 && (i2.epsilon = Nt.backend.epsilon()), i2;
    }
    return e(o2, t3), o2.prototype.applyGradients = function(t4) {
      var e2 = this, n2 = Array.isArray(t4) ? t4.map(function(t5) {
        return t5.name;
      }) : Object.keys(t4);
      je(function() {
        var r2 = ic(1, e2.accBeta1), o3 = qs(-e2.learningRate, e2.iteration.mul(e2.decay).add(1));
        n2.forEach(function(n3, a2) {
          var i2 = Nt.registeredVariables[n3];
          null == e2.accumulatedFirstMoment[a2] && (e2.accumulatedFirstMoment[a2] = { originalName: n3 + "/m", variable: zn(i2).variable(false) }), null == e2.accumulatedWeightedInfNorm[a2] && (e2.accumulatedWeightedInfNorm[a2] = { originalName: n3 + "/v", variable: zn(i2).variable(false) });
          var u2 = Array.isArray(t4) ? t4[a2].tensor : t4[n3];
          if (null != u2) {
            var s2 = e2.accumulatedFirstMoment[a2].variable, c2 = e2.accumulatedWeightedInfNorm[a2].variable, l3 = s2.mul(e2.beta1).add(u2.mul(1 - e2.beta1)), h = c2.mul(e2.beta2), f2 = u2.abs(), p2 = h.maximum(f2);
            s2.assign(l3), c2.assign(p2);
            var d2 = o3.div(r2).mul(l3.div(p2.add(e2.epsilon))).add(i2);
            i2.assign(d2);
          }
        }), e2.iteration.assign(e2.iteration.add(1)), e2.accBeta1.assign(e2.accBeta1.mul(e2.beta1));
      }), this.incrementIterations();
    }, o2.prototype.dispose = function() {
      this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Xe(this.accumulatedFirstMoment.map(function(t4) {
        return t4.variable;
      })), null != this.accumulatedWeightedInfNorm && Xe(this.accumulatedWeightedInfNorm.map(function(t4) {
        return t4.variable;
      }));
    }, o2.prototype.getWeights = function() {
      return n(this, void 0, void 0, function() {
        return r(this, function(t4) {
          throw new Error("getWeights() is not implemented for Adamax yet.");
        });
      });
    }, o2.prototype.setWeights = function(t4) {
      return n(this, void 0, void 0, function() {
        return r(this, function(t5) {
          throw new Error("setWeights() is not implemented for Adamax yet.");
        });
      });
    }, o2.prototype.getConfig = function() {
      return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay };
    }, o2.fromConfig = function(t4, e2) {
      return new t4(e2.learningRate, e2.beta1, e2.beta2, e2.epsilon, e2.decay);
    }, o2.className = "Adamax", o2;
  }(Hf);
  _f(Xf);
  var $f = function(t3) {
    function o2(e2) {
      var n2 = t3.call(this) || this;
      return n2.learningRate = e2, n2.setLearningRate(e2), n2;
    }
    return e(o2, t3), o2.prototype.applyGradients = function(t4) {
      var e2 = this;
      (Array.isArray(t4) ? t4.map(function(t5) {
        return t5.name;
      }) : Object.keys(t4)).forEach(function(n2, r2) {
        var o3 = Array.isArray(t4) ? t4[r2].tensor : t4[n2];
        if (null != o3) {
          var a2 = Nt.registeredVariables[n2];
          je(function() {
            var t5 = e2.c.mul(o3).add(a2);
            a2.assign(t5);
          });
        }
      }), this.incrementIterations();
    }, o2.prototype.setLearningRate = function(t4) {
      this.learningRate = t4, null != this.c && this.c.dispose(), this.c = $e(An(-t4));
    }, o2.prototype.dispose = function() {
      this.c.dispose();
    }, o2.prototype.getWeights = function() {
      return n(this, void 0, void 0, function() {
        return r(this, function(t4) {
          switch (t4.label) {
            case 0:
              return [4, this.saveIterations()];
            case 1:
              return [2, [t4.sent()]];
          }
        });
      });
    }, o2.prototype.setWeights = function(t4) {
      return n(this, void 0, void 0, function() {
        return r(this, function(e2) {
          switch (e2.label) {
            case 0:
              return [4, this.extractIterations(t4)];
            case 1:
              if (0 !== (t4 = e2.sent()).length)
                throw new Error("SGD optimizer does not have settable weights.");
              return [2];
          }
        });
      });
    }, o2.prototype.getConfig = function() {
      return { learningRate: this.learningRate };
    }, o2.fromConfig = function(t4, e2) {
      return new t4(e2.learningRate);
    }, o2.className = "SGD", o2;
  }(Hf);
  _f($f);
  var Yf = function(t3) {
    function o2(e2, n2, r2) {
      void 0 === r2 && (r2 = false);
      var o3 = t3.call(this, e2) || this;
      return o3.learningRate = e2, o3.momentum = n2, o3.useNesterov = r2, o3.accumulations = [], o3.m = An(o3.momentum), o3;
    }
    return e(o2, t3), o2.prototype.applyGradients = function(t4) {
      var e2 = this;
      (Array.isArray(t4) ? t4.map(function(t5) {
        return t5.name;
      }) : Object.keys(t4)).forEach(function(n2, r2) {
        var o3 = Nt.registeredVariables[n2];
        if (null == e2.accumulations[r2]) {
          e2.accumulations[r2] = { originalName: n2 + "/momentum", variable: je(function() {
            return zn(o3).variable(false);
          }) };
        }
        var a2 = e2.accumulations[r2].variable, i2 = Array.isArray(t4) ? t4[r2].tensor : t4[n2];
        null != i2 && je(function() {
          var t5, n3 = e2.m.mul(a2).add(i2);
          t5 = e2.useNesterov ? e2.c.mul(i2.add(n3.mul(e2.m))).add(o3) : e2.c.mul(n3).add(o3), a2.assign(n3), o3.assign(t5);
        });
      }), this.incrementIterations();
    }, o2.prototype.dispose = function() {
      this.m.dispose(), null != this.accumulations && Xe(this.accumulations.map(function(t4) {
        return t4.variable;
      }));
    }, o2.prototype.setMomentum = function(t4) {
      this.momentum = t4;
    }, o2.prototype.getWeights = function() {
      return n(this, void 0, void 0, function() {
        return r(this, function(t4) {
          switch (t4.label) {
            case 0:
              return [4, this.saveIterations()];
            case 1:
              return [2, [t4.sent()].concat(this.accumulations.map(function(t5) {
                return { name: t5.originalName, tensor: t5.variable };
              }))];
          }
        });
      });
    }, o2.prototype.setWeights = function(t4) {
      return n(this, void 0, void 0, function() {
        return r(this, function(e2) {
          switch (e2.label) {
            case 0:
              return [4, this.extractIterations(t4)];
            case 1:
              return t4 = e2.sent(), false, this.accumulations = t4.map(function(t5) {
                return { originalName: t5.name, variable: t5.tensor.variable(false) };
              }), [2];
          }
        });
      });
    }, o2.prototype.getConfig = function() {
      return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };
    }, o2.fromConfig = function(t4, e2) {
      return new t4(e2.learningRate, e2.momentum, e2.useNesterov);
    }, o2.className = "Momentum", o2;
  }($f);
  _f(Yf);
  var Qf = function(t3) {
    function o2(e2, n2, r2, o3, a2) {
      void 0 === n2 && (n2 = 0.9), void 0 === r2 && (r2 = 0), void 0 === o3 && (o3 = null), void 0 === a2 && (a2 = false);
      var i2 = t3.call(this) || this;
      return i2.learningRate = e2, i2.decay = n2, i2.momentum = r2, i2.epsilon = o3, i2.accumulatedMeanSquares = [], i2.accumulatedMoments = [], i2.accumulatedMeanGrads = [], i2.centered = a2, null == o3 && (i2.epsilon = Nt.backend.epsilon()), i2;
    }
    return e(o2, t3), o2.prototype.applyGradients = function(t4) {
      var e2 = this;
      (Array.isArray(t4) ? t4.map(function(t5) {
        return t5.name;
      }) : Object.keys(t4)).forEach(function(n2, r2) {
        var o3 = Nt.registeredVariables[n2];
        null == e2.accumulatedMeanSquares[r2] && (e2.accumulatedMeanSquares[r2] = { originalName: n2 + "/rms", variable: je(function() {
          return zn(o3).variable(false);
        }) }), null == e2.accumulatedMoments[r2] && (e2.accumulatedMoments[r2] = { originalName: n2 + "/momentum", variable: je(function() {
          return zn(o3).variable(false);
        }) }), null == e2.accumulatedMeanGrads[r2] && e2.centered && (e2.accumulatedMeanGrads[r2] = { originalName: n2 + "/mg", variable: je(function() {
          return zn(o3).variable(false);
        }) });
        var a2 = Array.isArray(t4) ? t4[r2].tensor : t4[n2];
        if (null != a2) {
          var i2 = e2.accumulatedMeanSquares[r2].variable, u2 = e2.accumulatedMoments[r2].variable;
          je(function() {
            var t5 = i2.mul(e2.decay).add(a2.square().mul(1 - e2.decay));
            if (e2.centered) {
              var n3 = e2.accumulatedMeanGrads[r2].variable, s2 = n3.mul(e2.decay).add(a2.mul(1 - e2.decay)), c2 = u2.mul(e2.momentum).add(a2.mul(e2.learningRate).div(t5.sub(s2.square().add(e2.epsilon)).sqrt()));
              i2.assign(t5), n3.assign(s2), u2.assign(c2);
              var l3 = o3.sub(c2);
              o3.assign(l3);
            } else {
              var h = i2.mul(e2.decay).add(a2.square().mul(1 - e2.decay));
              c2 = u2.mul(e2.momentum).add(a2.mul(e2.learningRate).div(h.add(e2.epsilon).sqrt()));
              i2.assign(h), u2.assign(c2);
              l3 = o3.sub(c2);
              o3.assign(l3);
            }
          });
        }
      }), this.incrementIterations();
    }, o2.prototype.dispose = function() {
      null != this.accumulatedMeanSquares && Xe(this.accumulatedMeanSquares.map(function(t4) {
        return t4.variable;
      })), null != this.accumulatedMeanGrads && this.centered && Xe(this.accumulatedMeanGrads.map(function(t4) {
        return t4.variable;
      })), null != this.accumulatedMoments && Xe(this.accumulatedMoments.map(function(t4) {
        return t4.variable;
      }));
    }, o2.prototype.getWeights = function() {
      return n(this, void 0, void 0, function() {
        var t4;
        return r(this, function(e2) {
          switch (e2.label) {
            case 0:
              return t4 = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t4.push.apply(t4, this.accumulatedMeanGrads), [4, this.saveIterations()];
            case 1:
              return [2, [e2.sent()].concat(t4.map(function(t5) {
                return { name: t5.originalName, tensor: t5.variable };
              }))];
          }
        });
      });
    }, o2.prototype.setWeights = function(t4) {
      return n(this, void 0, void 0, function() {
        var e2;
        return r(this, function(n2) {
          switch (n2.label) {
            case 0:
              return [4, this.extractIterations(t4)];
            case 1:
              return t4 = n2.sent(), e2 = this.centered ? t4.length / 3 : t4.length / 2, false, this.accumulatedMeanSquares = t4.slice(0, e2).map(function(t5) {
                return { originalName: t5.name, variable: t5.tensor.variable(false) };
              }), this.accumulatedMoments = t4.slice(e2, 2 * e2).map(function(t5) {
                return { originalName: t5.name, variable: t5.tensor.variable(false) };
              }), this.centered && (this.accumulatedMeanGrads = t4.slice(2 * e2, 3 * e2).map(function(t5) {
                return { originalName: t5.name, variable: t5.tensor.variable(false) };
              })), [2];
          }
        });
      });
    }, o2.prototype.getConfig = function() {
      return { learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered };
    }, o2.fromConfig = function(t4, e2) {
      return new t4(e2.learningRate, e2.decay, e2.momentum, e2.epsilon, e2.centered);
    }, o2.className = "RMSProp", o2;
  }(Hf);
  _f(Qf);
  var Jf = function() {
    function t3() {
    }
    return t3.sgd = function(t4) {
      return new $f(t4);
    }, t3.momentum = function(t4, e2, n2) {
      return void 0 === n2 && (n2 = false), new Yf(t4, e2, n2);
    }, t3.rmsprop = function(t4, e2, n2, r2, o2) {
      return void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0), void 0 === r2 && (r2 = null), void 0 === o2 && (o2 = false), new Qf(t4, e2, n2, r2, o2);
    }, t3.adam = function(t4, e2, n2, r2) {
      return void 0 === t4 && (t4 = 1e-3), void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0.999), void 0 === r2 && (r2 = null), new jf(t4, e2, n2, r2);
    }, t3.adadelta = function(t4, e2, n2) {
      return void 0 === t4 && (t4 = 1e-3), void 0 === e2 && (e2 = 0.95), void 0 === n2 && (n2 = null), new qf(t4, e2, n2);
    }, t3.adamax = function(t4, e2, n2, r2, o2) {
      return void 0 === t4 && (t4 = 2e-3), void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0.999), void 0 === r2 && (r2 = null), void 0 === o2 && (o2 = 0), new Xf(t4, e2, n2, r2, o2);
    }, t3.adagrad = function(t4, e2) {
      return void 0 === e2 && (e2 = 0.1), new Kf(t4, e2);
    }, t3;
  }();
  var Zf = { sgd: Jf.sgd, momentum: Jf.momentum, adadelta: Jf.adadelta, adagrad: Jf.adagrad, rmsprop: Jf.rmsprop, adamax: Jf.adamax, adam: Jf.adam };
  var tp = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function(t3) {
    return t3();
  };
  function ep() {
    return new Promise(function(t3) {
      return tp(function() {
        return t3();
      });
    });
  }
  ft = Rh;

  // node_modules/@tensorflow/tfjs/node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js
  var extendStatics = function(e2, t3) {
    return (extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t4) {
      e3.__proto__ = t4;
    } || function(e3, t4) {
      for (var n2 in t4)
        t4.hasOwnProperty(n2) && (e3[n2] = t4[n2]);
    })(e2, t3);
  };
  function __extends(e2, t3) {
    function n2() {
      this.constructor = e2;
    }
    extendStatics(e2, t3), e2.prototype = null === t3 ? Object.create(t3) : (n2.prototype = t3.prototype, new n2());
  }
  var _epsilon;
  var __assign = function() {
    return (__assign = Object.assign || function(e2) {
      for (var t3, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
        for (var i2 in t3 = arguments[n2])
          Object.prototype.hasOwnProperty.call(t3, i2) && (e2[i2] = t3[i2]);
      return e2;
    }).apply(this, arguments);
  };
  function __awaiter(e2, t3, n2, r2) {
    return new (n2 || (n2 = Promise))(function(i2, a2) {
      function o2(e3) {
        try {
          l3(r2.next(e3));
        } catch (e4) {
          a2(e4);
        }
      }
      function s2(e3) {
        try {
          l3(r2.throw(e3));
        } catch (e4) {
          a2(e4);
        }
      }
      function l3(e3) {
        e3.done ? i2(e3.value) : new n2(function(t4) {
          t4(e3.value);
        }).then(o2, s2);
      }
      l3((r2 = r2.apply(e2, t3 || [])).next());
    });
  }
  function __generator(e2, t3) {
    var n2, r2, i2, a2, o2 = { label: 0, sent: function() {
      if (1 & i2[0])
        throw i2[1];
      return i2[1];
    }, trys: [], ops: [] };
    return a2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (a2[Symbol.iterator] = function() {
      return this;
    }), a2;
    function s2(a3) {
      return function(s3) {
        return function(a4) {
          if (n2)
            throw new TypeError("Generator is already executing.");
          for (; o2; )
            try {
              if (n2 = 1, r2 && (i2 = 2 & a4[0] ? r2.return : a4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, a4[1])).done)
                return i2;
              switch (r2 = 0, i2 && (a4 = [2 & a4[0], i2.value]), a4[0]) {
                case 0:
                case 1:
                  i2 = a4;
                  break;
                case 4:
                  return o2.label++, { value: a4[1], done: false };
                case 5:
                  o2.label++, r2 = a4[1], a4 = [0];
                  continue;
                case 7:
                  a4 = o2.ops.pop(), o2.trys.pop();
                  continue;
                default:
                  if (!(i2 = (i2 = o2.trys).length > 0 && i2[i2.length - 1]) && (6 === a4[0] || 2 === a4[0])) {
                    o2 = 0;
                    continue;
                  }
                  if (3 === a4[0] && (!i2 || a4[1] > i2[0] && a4[1] < i2[3])) {
                    o2.label = a4[1];
                    break;
                  }
                  if (6 === a4[0] && o2.label < i2[1]) {
                    o2.label = i2[1], i2 = a4;
                    break;
                  }
                  if (i2 && o2.label < i2[2]) {
                    o2.label = i2[2], o2.ops.push(a4);
                    break;
                  }
                  i2[2] && o2.ops.pop(), o2.trys.pop();
                  continue;
              }
              a4 = t3.call(e2, o2);
            } catch (e3) {
              a4 = [6, e3], r2 = 0;
            } finally {
              n2 = i2 = 0;
            }
          if (5 & a4[0])
            throw a4[1];
          return { value: a4[0] ? a4[1] : void 0, done: true };
        }([a3, s3]);
      };
    }
  }
  function epsilon() {
    return null == _epsilon && (_epsilon = on().epsilon()), _epsilon;
  }
  function imageDataFormat() {
    return "channelsLast";
  }
  var AttributeError = function(e2) {
    function t3(n2) {
      var r2 = e2.call(this, n2) || this;
      return Object.setPrototypeOf(r2, t3.prototype), r2;
    }
    return __extends(t3, e2), t3;
  }(Error);
  var RuntimeError = function(e2) {
    function t3(n2) {
      var r2 = e2.call(this, n2) || this;
      return Object.setPrototypeOf(r2, t3.prototype), r2;
    }
    return __extends(t3, e2), t3;
  }(Error);
  var ValueError = function(e2) {
    function t3(n2) {
      var r2 = e2.call(this, n2) || this;
      return Object.setPrototypeOf(r2, t3.prototype), r2;
    }
    return __extends(t3, e2), t3;
  }(Error);
  var NotImplementedError = function(e2) {
    function t3(n2) {
      var r2 = e2.call(this, n2) || this;
      return Object.setPrototypeOf(r2, t3.prototype), r2;
    }
    return __extends(t3, e2), t3;
  }(Error);
  var AssertionError = function(e2) {
    function t3(n2) {
      var r2 = e2.call(this, n2) || this;
      return Object.setPrototypeOf(r2, t3.prototype), r2;
    }
    return __extends(t3, e2), t3;
  }(Error);
  var IndexError = function(e2) {
    function t3(n2) {
      var r2 = e2.call(this, n2) || this;
      return Object.setPrototypeOf(r2, t3.prototype), r2;
    }
    return __extends(t3, e2), t3;
  }(Error);
  function pyListRepeat(e2, t3) {
    if (Array.isArray(e2)) {
      for (var n2 = [], r2 = 0; r2 < t3; r2++)
        n2 = n2.concat(e2);
      return n2;
    }
    return (n2 = new Array(t3)).fill(e2), n2;
  }
  function assert(e2, t3) {
    if (!e2)
      throw new AssertionError(t3);
  }
  function count(e2, t3) {
    for (var n2 = 0, r2 = 0, i2 = e2; r2 < i2.length; r2++) {
      i2[r2] === t3 && n2++;
    }
    return n2;
  }
  function singletonOrArray(e2) {
    return 1 === e2.length ? e2[0] : e2;
  }
  function toList(e2) {
    return Array.isArray(e2) ? e2 : [e2];
  }
  function toSnakeCase(e2) {
    var t3 = e2.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
    return "_" !== t3[0] ? t3 : "private" + t3;
  }
  function toCamelCase(e2) {
    return e2.length <= 1 ? e2 : -1 === e2.indexOf("_") ? e2 : e2.replace(/[_]+(\w|$)/g, function(e3, t3) {
      return t3.toUpperCase();
    });
  }
  var _GLOBAL_CUSTOM_OBJECTS = {};
  function serializeKerasObject(e2) {
    if (null === e2 || void 0 === e2)
      return null;
    var t3 = {};
    return t3.className = e2.getClassName(), t3.config = e2.getConfig(), t3;
  }
  function convertNDArrayScalarsInConfig(e2) {
    if (null != e2 && "object" == typeof e2)
      if (Array.isArray(e2))
        e2.forEach(function(e3) {
          return convertNDArrayScalarsInConfig(e3);
        });
      else
        for (var t3 = 0, n2 = Object.keys(e2); t3 < n2.length; t3++) {
          var r2 = n2[t3], i2 = e2[r2];
          null != i2 && "object" == typeof i2 && (Array.isArray(i2) || "ndarray" !== i2.type || "number" != typeof i2.value ? convertNDArrayScalarsInConfig(i2) : e2[r2] = i2.value);
        }
  }
  function deserializeKerasObject(e2, t3, n2, r2, i2) {
    var a2, o2, s2;
    if (void 0 === t3 && (t3 = {}), void 0 === n2 && (n2 = {}), void 0 === r2 && (r2 = "object"), void 0 === i2 && (i2 = false), "string" == typeof e2) {
      var l3 = e2, u2 = void 0;
      if (l3 in n2)
        u2 = n2[l3];
      else if (l3 in _GLOBAL_CUSTOM_OBJECTS)
        u2 = _GLOBAL_CUSTOM_OBJECTS[l3];
      else if (null == (u2 = t3[l3]))
        throw new ValueError("Unknown " + r2 + ": " + e2 + ". This may be due to one of the following reasons:\n1. The " + r2 + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r2 + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
      return u2;
    }
    var c2 = e2;
    if (null == c2.className || null == c2.config)
      throw new ValueError(r2 + ": Improper config format: " + JSON.stringify(c2) + ".\n'className' and 'config' must set.");
    var p2 = c2.className, h = void 0, d2 = void 0;
    if (p2 in n2 ? (h = (a2 = n2[p2])[0], d2 = a2[1]) : p2 in _GLOBAL_CUSTOM_OBJECTS ? (h = (o2 = _GLOBAL_CUSTOM_OBJECTS.className)[0], d2 = o2[1]) : p2 in t3 && (h = (s2 = t3[p2])[0], d2 = s2[1]), null == h)
      throw new ValueError("Unknown " + r2 + ": " + p2 + ". This may be due to one of the following reasons:\n1. The " + r2 + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r2 + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
    if (null != d2) {
      for (var f2 = {}, g2 = 0, m2 = Object.keys(_GLOBAL_CUSTOM_OBJECTS); g2 < m2.length; g2++) {
        f2[S3 = m2[g2]] = _GLOBAL_CUSTOM_OBJECTS[S3];
      }
      for (var y2 = 0, v2 = Object.keys(n2); y2 < v2.length; y2++) {
        f2[S3 = v2[y2]] = n2[S3];
      }
      c2.config.customObjects = f2;
      for (var b2 = __assign({}, _GLOBAL_CUSTOM_OBJECTS), w2 = 0, z3 = Object.keys(n2); w2 < z3.length; w2++) {
        var S3 = z3[w2];
        _GLOBAL_CUSTOM_OBJECTS[S3] = n2[S3];
      }
      convertNDArrayScalarsInConfig(c2.config);
      var A2 = d2(h, c2.config, n2, i2);
      return _GLOBAL_CUSTOM_OBJECTS = __assign({}, b2), A2;
    }
    b2 = __assign({}, _GLOBAL_CUSTOM_OBJECTS);
    for (var _3 = 0, I3 = Object.keys(n2); _3 < I3.length; _3++) {
      S3 = I3[_3];
      _GLOBAL_CUSTOM_OBJECTS[S3] = n2[S3];
    }
    A2 = new h(c2.config);
    return _GLOBAL_CUSTOM_OBJECTS = __assign({}, b2), A2;
  }
  function numberCompare(e2, t3) {
    return e2 < t3 ? -1 : e2 > t3 ? 1 : 0;
  }
  function reverseNumberCompare(e2, t3) {
    return -1 * numberCompare(e2, t3);
  }
  function unique(e2) {
    if (null == e2)
      return e2;
    for (var t3 = [], n2 = 0, r2 = e2; n2 < r2.length; n2++) {
      var i2 = r2[n2];
      -1 === t3.indexOf(i2) && t3.push(i2);
    }
    return t3;
  }
  function isObjectEmpty(e2) {
    if (null == e2)
      throw new ValueError("Invalid value in obj: " + JSON.stringify(e2));
    for (var t3 in e2)
      if (e2.hasOwnProperty(t3))
        return false;
    return true;
  }
  function checkStringTypeUnionValue(e2, t3, n2) {
    if (null != n2 && e2.indexOf(n2) < 0)
      throw new ValueError(n2 + " is not a valid " + t3 + ".  Valid values are " + e2 + " or null/undefined.");
  }
  function checkArrayTypeAndLength(e2, t3, n2, r2) {
    return void 0 === n2 && (n2 = 0), void 0 === r2 && (r2 = 1 / 0), assert(n2 >= 0), assert(r2 >= n2), Array.isArray(e2) && e2.length >= n2 && e2.length <= r2 && e2.every(function(e3) {
      return typeof e3 === t3;
    });
  }
  function assertPositiveInteger(e2, t3) {
    Array.isArray(e2) ? (tt.assert(e2.length > 0, function() {
      return t3 + " is unexpectedly an empty array.";
    }), e2.forEach(function(e3, n2) {
      return assertPositiveInteger(e3, "element " + (n2 + 1) + " of " + t3);
    })) : tt.assert(Number.isInteger(e2) && e2 > 0, function() {
      return "Expected " + t3 + " to be a positive integer, but got " + formatAsFriendlyString(e2) + ".";
    });
  }
  function formatAsFriendlyString(e2) {
    return null === e2 ? "null" : Array.isArray(e2) ? "[" + e2.map(function(e3) {
      return formatAsFriendlyString(e3);
    }).join(",") + "]" : "string" == typeof e2 ? '"' + e2 + '"' : "" + e2;
  }
  function debounce(e2, t3) {
    var n2, r2 = tt.now();
    return function() {
      for (var i2 = [], a2 = 0; a2 < arguments.length; a2++)
        i2[a2] = arguments[a2];
      var o2 = tt.now();
      return o2 - r2 < t3 ? n2 : (r2 = o2, n2 = e2.apply(void 0, i2));
    };
  }
  function mapActivationToFusedKernel(e2) {
    return "relu" === e2 ? "relu" : "linear" === e2 ? "linear" : "elu" === e2 ? "elu" : null;
  }
  function calcL2Norms(e2, t3) {
    return je(function() {
      return gs(vl(ec(e2, e2), t3, true));
    });
  }
  var Constraint = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.getConfig = function() {
      return {};
    }, t3;
  }(Mf.Serializable);
  var MaxNorm = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      return n2.defaultMaxValue = 2, n2.defaultAxis = 0, n2.maxValue = null != t4.maxValue ? t4.maxValue : n2.defaultMaxValue, n2.axis = null != t4.axis ? t4.axis : n2.defaultAxis, n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      var t4 = this;
      return je(function() {
        var n2 = calcL2Norms(e3, t4.axis), r2 = $u(n2, 0, t4.maxValue);
        return tc(e3, qs(r2, Vs(epsilon(), n2)));
      });
    }, t3.prototype.getConfig = function() {
      return { maxValue: this.maxValue, axis: this.axis };
    }, t3.className = "MaxNorm", t3;
  }(Constraint);
  Mf.registerClass(MaxNorm);
  var UnitNorm = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      return n2.defaultAxis = 0, n2.axis = null != t4.axis ? t4.axis : n2.defaultAxis, n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      var t4 = this;
      return je(function() {
        return qs(e3, Vs(epsilon(), calcL2Norms(e3, t4.axis)));
      });
    }, t3.prototype.getConfig = function() {
      return { axis: this.axis };
    }, t3.className = "UnitNorm", t3;
  }(Constraint);
  Mf.registerClass(UnitNorm);
  var NonNeg = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      return bl(e3);
    }, t3.className = "NonNeg", t3;
  }(Constraint);
  Mf.registerClass(NonNeg);
  var MinMaxNorm = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      return n2.defaultMinValue = 0, n2.defaultMaxValue = 1, n2.defaultRate = 1, n2.defaultAxis = 0, n2.minValue = null != t4.minValue ? t4.minValue : n2.defaultMinValue, n2.maxValue = null != t4.maxValue ? t4.maxValue : n2.defaultMaxValue, n2.rate = null != t4.rate ? t4.rate : n2.defaultRate, n2.axis = null != t4.axis ? t4.axis : n2.defaultAxis, n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      var t4 = this;
      return je(function() {
        var n2 = calcL2Norms(e3, t4.axis), r2 = Vs(tc(t4.rate, $u(n2, t4.minValue, t4.maxValue)), tc(1 - t4.rate, n2));
        return tc(e3, qs(r2, Vs(epsilon(), n2)));
      });
    }, t3.prototype.getConfig = function() {
      return { minValue: this.minValue, maxValue: this.maxValue, rate: this.rate, axis: this.axis };
    }, t3.className = "MinMaxNorm", t3;
  }(Constraint);
  Mf.registerClass(MinMaxNorm);
  var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = { maxNorm: "MaxNorm", minMaxNorm: "MinMaxNorm", nonNeg: "NonNeg", unitNorm: "UnitNorm" };
  function serializeConstraint(e2) {
    return serializeKerasObject(e2);
  }
  function deserializeConstraint(e2, t3) {
    return void 0 === t3 && (t3 = {}), deserializeKerasObject(e2, Mf.SerializationMap.getMap().classNameMap, t3, "constraint");
  }
  function getConstraint(e2) {
    return null == e2 ? null : "string" == typeof e2 ? deserializeConstraint({ className: e2 in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ? CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[e2] : e2, config: {} }) : e2 instanceof Constraint ? e2 : deserializeConstraint(e2);
  }
  function maxNorm(e2) {
    return new MaxNorm(e2);
  }
  function unitNorm(e2) {
    return new UnitNorm(e2);
  }
  function nonNeg() {
    return new NonNeg();
  }
  function minMaxNorm(e2) {
    return new MinMaxNorm(e2);
  }
  var exports_constraints = Object.freeze({ maxNorm, unitNorm, nonNeg, minMaxNorm });
  var VALID_DATA_FORMAT_VALUES = ["channelsFirst", "channelsLast"];
  var VALID_PADDING_MODE_VALUES = ["valid", "same", "causal"];
  var VALID_POOL_MODE_VALUES = ["max", "avg"];
  var VALID_BIDIRECTIONAL_MERGE_MODES = ["sum", "mul", "concat", "ave"];
  var nameMap = /* @__PURE__ */ new Map();
  function checkDataFormat(e2) {
    checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, "DataFormat", e2);
  }
  function checkPaddingMode(e2) {
    checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, "PaddingMode", e2);
  }
  function checkPoolMode(e2) {
    checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, "PoolMode", e2);
  }
  var _nameScopeStack = [];
  var _nameScopeDivider = "/";
  function nameScope(e2, t3) {
    _nameScopeStack.push(e2);
    try {
      var n2 = t3();
      return _nameScopeStack.pop(), n2;
    } catch (e3) {
      throw _nameScopeStack.pop(), e3;
    }
  }
  function currentNameScopePrefix() {
    return 0 === _nameScopeStack.length ? "" : _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
  }
  function getScopedTensorName(e2) {
    if (!isValidTensorName(e2))
      throw new Error("Not a valid tensor name: '" + e2 + "'");
    return currentNameScopePrefix() + e2;
  }
  function getUniqueTensorName(e2) {
    if (!isValidTensorName(e2))
      throw new Error("Not a valid tensor name: '" + e2 + "'");
    nameMap.has(e2) || nameMap.set(e2, 0);
    var t3 = nameMap.get(e2);
    if (nameMap.set(e2, nameMap.get(e2) + 1), t3 > 0) {
      var n2 = e2 + "_" + t3;
      return nameMap.set(n2, 1), n2;
    }
    return e2;
  }
  var tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
  function isValidTensorName(e2) {
    return !!e2.match(tensorNameRegex);
  }
  function isInteger(e2) {
    return e2 === parseInt(e2.toString(), 10);
  }
  function arrayProd(e2, t3, n2) {
    null == t3 && (t3 = 0), null == n2 && (n2 = e2.length);
    for (var r2 = 1, i2 = t3; i2 < n2; ++i2)
      r2 *= e2[i2];
    return r2;
  }
  function toArray1D(e2) {
    return e2 = Array.isArray(e2) ? new Float32Array(e2) : e2, Dn(e2);
  }
  function min$1(e2) {
    return pl(toArray1D(e2)).dataSync()[0];
  }
  function max$1(e2) {
    return hl(toArray1D(e2)).dataSync()[0];
  }
  function range(e2, t3) {
    if (t3 < e2)
      throw new ValueError("end (" + t3 + ") < begin (" + e2 + ") is forbidden.");
    for (var n2 = [], r2 = e2; r2 < t3; ++r2)
      n2.push(r2);
    return n2;
  }
  function cast$1(e2, t3) {
    return e2.asType(t3);
  }
  function expandDims$1(e2, t3) {
    void 0 === t3 && (t3 = -1);
    var n2 = e2.shape.slice();
    return t3 < 0 && (t3 = n2.length + t3 + 1), n2.splice(t3, 0, 1), e2.reshape(n2);
  }
  function repeat(e2, t3) {
    return je(function() {
      if (2 !== e2.shape.length)
        throw new ValueError("repeat() expects a rank-2 tensor, but received a rank-" + e2.shape.length + " tensor.");
      return tile$1(expandDims$1(e2, 1), [1, t3, 1]);
    });
  }
  function flatten(e2) {
    var t3 = [arrayProd(e2.shape)];
    return e2.reshape(t3);
  }
  function batchFlatten(e2) {
    if (e2.rank <= 1)
      throw new ValueError("batchFlatten requires a minimum rank of 2. Got rank: " + e2.rank + ".");
    var t3 = [e2.shape[0], arrayProd(e2.shape, 1)];
    return e2.reshape(t3);
  }
  function sliceAlongFirstAxis(e2, t3, n2) {
    return je(function() {
      switch (e2.rank) {
        case 1:
          return el(e2, t3, n2);
        case 2:
          return nl(e2, [t3, 0], [n2, e2.shape[1]]);
        case 3:
          return rl(e2, [t3, 0, 0], [n2, e2.shape[1], e2.shape[2]]);
        case 4:
          return ol(e2, [t3, 0, 0, 0], [n2, e2.shape[1], e2.shape[2], e2.shape[3]]);
        case 5:
          return tl(e2, [t3, 0, 0, 0, 0], [n2, e2.shape[1], e2.shape[2], e2.shape[3], e2.shape[4]]);
        case 6:
          return tl(e2, [t3, 0, 0, 0, 0, 0], [n2, e2.shape[1], e2.shape[2], e2.shape[3], e2.shape[4], e2.shape[5]]);
        default:
          throw new ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: " + e2.rank);
      }
    });
  }
  function sliceAlongLastAxis(e2, t3, n2) {
    return je(function() {
      switch (e2.rank) {
        case 1:
          return el(e2, t3, n2);
        case 2:
          return nl(e2, [0, t3], [e2.shape[0], n2]);
        case 3:
          return rl(e2, [0, 0, t3], [e2.shape[0], e2.shape[1], n2]);
        case 4:
          return ol(e2, [0, 0, 0, t3], [e2.shape[0], e2.shape[1], e2.shape[2], n2]);
        default:
          throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " + e2.rank);
      }
    });
  }
  function sliceAlongAxis(e2, t3, n2, r2) {
    return je(function() {
      switch (e2.rank) {
        case 1:
          return el(e2, t3, n2);
        case 2:
          switch (r2) {
            case 1:
              return sliceAlongFirstAxis(e2, t3, n2);
            case 2:
              return sliceAlongLastAxis(e2, t3, n2);
            default:
              throw new ValueError("The axis is not within the rank of the tensor " + r2);
          }
        case 3:
          switch (r2) {
            case 1:
              return sliceAlongFirstAxis(e2, t3, n2);
            case 2:
              return rl(e2, [0, t3, 0], [e2.shape[0], n2, e2.shape[2]]);
            case 3:
              return sliceAlongLastAxis(e2, t3, n2);
            default:
              throw new ValueError("The axis is not within the rank of the tensor " + r2);
          }
        case 4:
          switch (r2) {
            case 1:
              return sliceAlongFirstAxis(e2, t3, n2);
            case 2:
              return ol(e2, [0, t3, 0, 0], [e2.shape[0], n2, e2.shape[2], e2.shape[3]]);
            case 3:
              return ol(e2, [0, 0, t3, 0], [e2.shape[0], e2.shape[1], n2, e2.shape[3]]);
            case 4:
              return sliceAlongLastAxis(e2, t3, n2);
            default:
              throw new ValueError("The axis is not within the rank of the tensor " + r2);
          }
        default:
          throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " + e2.rank);
      }
    });
  }
  function concatenate(e2, t3) {
    var n2;
    return void 0 === t3 && (t3 = -1), t3 < 0 && (t3 = 0 !== (n2 = e2[0].rank) ? n2 : 0), t3 === e2[0].rank && (t3 = -1), Gn(e2, t3);
  }
  function concatAlongFirstAxis(e2, t3) {
    switch (e2.rank) {
      case 1:
        return Hn([e2, t3]);
      case 2:
        return qn([e2, t3], 0);
      case 3:
        return Kn([e2, t3], 0);
      case 4:
        return jn([e2, t3], 0);
      default:
        throw new ValueError("concatAlongFirstAxis() received an unsupported tensor rank: " + e2.rank);
    }
  }
  function tile$1(e2, t3) {
    if (Array.isArray(t3) || (t3 = [t3]), e2.rank !== t3.length)
      throw new ValueError("The length of input n (" + t3.length + ") does not match the number of dimensions in input x (" + e2.rank + ")");
    return Nr(e2, t3);
  }
  function randomNormal$1(e2, t3, n2, r2, i2) {
    return void 0 === t3 && (t3 = 0), void 0 === n2 && (n2 = 1), Rr(e2, t3, n2, r2, i2);
  }
  function dot(e2, t3, n2, r2) {
    if (e2.rank < 2 || t3.rank < 2)
      throw new NotImplementedError("dot requires both inputs to be rank >= 2 but got x shape = " + e2.shape + " and y shape = " + t3.shape);
    if (t3.rank >= 3 && e2.shape.slice(-1)[0] !== (c2 = t3.shape.slice(-2)[0]))
      throw new NotImplementedError("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = " + e2.shape + " and  y shape = " + t3.shape);
    if (2 === e2.rank && 2 === t3.rank) {
      var i2 = false, a2 = false;
      return Eh.matMul({ a: e2, b: t3, transposeA: i2, transposeB: a2, bias: r2 ? reshapeBias(e2.rank, r2, imageDataFormat()) : null, activation: n2 });
    }
    var o2 = e2.shape.slice(), s2 = o2.pop();
    e2 = e2.reshape([-1, s2]);
    var l3 = t3.shape.slice(), u2 = l3.pop(), c2 = l3.pop(), p2 = l3.concat([u2]), h = Array.from({ length: t3.rank }, function(e3, n3) {
      return 0 === n3 ? t3.rank - 2 : n3 <= t3.rank - 2 ? n3 - 1 : n3;
    });
    t3 = t3.transpose(h).reshape([c2, -1]);
    var d2 = o2.concat(p2);
    i2 = false, a2 = false;
    return Eh.matMul({ a: e2, b: t3, transposeA: i2, transposeB: a2, bias: r2 ? reshapeBias(e2.rank, r2, imageDataFormat()) : null, activation: n2 }).reshape(d2);
  }
  function gather$1(e2, t3, n2) {
    return je(function() {
      return t3 = Array.isArray(t3) ? Dn(t3, "int32") : t3.toInt(), Cc(e2, t3, n2);
    });
  }
  function square(e2) {
    return ec(e2, e2);
  }
  function reshapeBias(e2, t3, n2) {
    var r2 = t3.shape;
    if (1 !== t3.rank && t3.rank !== e2)
      throw new ValueError("Unexpected bias dimensions: " + t3.rank + "; expected it to be 1 or " + e2);
    if (5 === e2) {
      if ("channelsFirst" === n2)
        return 1 === r2.length ? t3.reshape([1, r2[0], 1, 1, 1]) : t3.reshape([1, r2[3], r2[0], r2[1], r2[2]]);
      if ("channelsLast" === n2)
        return 1 === r2.length ? t3.reshape([1, 1, 1, 1, r2[0]]) : t3.reshape([1].concat(r2));
    } else if (4 === e2) {
      if ("channelsFirst" === n2)
        return 1 === r2.length ? t3.reshape([1, r2[0], 1, 1]) : t3.reshape([1, r2[2], r2[0], r2[1]]);
      if ("channelsLast" === n2)
        return 1 === r2.length ? t3.reshape([1, 1, 1, r2[0]]) : t3.reshape([1].concat(r2));
    } else if (3 === e2) {
      if ("channelsFirst" === n2)
        return 1 === r2.length ? t3.reshape([1, r2[0], 1]) : t3.reshape([1, r2[1], r2[0]]);
      if ("channelsLast" === n2)
        return 1 === r2.length ? t3.reshape([1, 1, r2[0]]) : t3.reshape([1].concat(r2));
    } else if (e2 < 3)
      return t3;
    throw new ValueError("Unsupported input rank by biasAdd: " + t3.rank);
  }
  function biasAdd(e2, t3, n2) {
    return je(function() {
      return null == n2 && (n2 = imageDataFormat()), checkDataFormat(n2), e2.add(reshapeBias(e2.rank, t3, n2));
    });
  }
  function elu$1(e2, t3) {
    if (void 0 === t3 && (t3 = 1), 1 !== t3)
      throw new NotImplementedError("Support for alpha values other than 1 (" + t3 + ") is not implemented yet.");
    return gl(e2);
  }
  function softsign(e2) {
    return je(function() {
      return qs(e2, Vu(e2).add(1));
    });
  }
  function dropout$1(e2, t3, n2, r2) {
    return je(function() {
      return Ul(e2, t3, n2, r2);
    });
  }
  function hardSigmoid(e2) {
    return je(function() {
      var t3 = Vs(0.5, tc(0.2, e2));
      return $u(t3, 0, 1);
    });
  }
  function inTrainPhase(e2, t3, n2) {
    return void 0 === n2 && (n2 = false), n2 ? e2() : t3();
  }
  var VALID_FAN_MODE_VALUES = ["fanIn", "fanOut", "fanAvg"];
  var VALID_DISTRIBUTION_VALUES = ["normal", "uniform", "truncatedNormal"];
  function checkFanMode(e2) {
    checkStringTypeUnionValue(VALID_FAN_MODE_VALUES, "FanMode", e2);
  }
  function checkDistribution(e2) {
    checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES, "Distribution", e2);
  }
  var Initializer = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.fromConfigUsesCustomObjects = function() {
      return false;
    }, t3.prototype.getConfig = function() {
      return {};
    }, t3;
  }(Mf.Serializable);
  var Zeros = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      return Pn(e3, t4);
    }, t3.className = "Zeros", t3;
  }(Initializer);
  Mf.registerClass(Zeros);
  var Ones = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      return Bn(e3, t4);
    }, t3.className = "Ones", t3;
  }(Initializer);
  Mf.registerClass(Ones);
  var Constant = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      if ("object" != typeof t4)
        throw new ValueError("Expected argument of type ConstantConfig but got " + t4);
      if (void 0 === t4.value)
        throw new ValueError("config must have value set but got " + t4);
      return n2.value = t4.value, n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      var n2 = this;
      return je(function() {
        return tc(An(n2.value), Bn(e3, t4));
      });
    }, t3.prototype.getConfig = function() {
      return { value: this.value };
    }, t3.className = "Constant", t3;
  }(Initializer);
  Mf.registerClass(Constant);
  var RandomUniform = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      return n2.DEFAULT_MINVAL = -0.05, n2.DEFAULT_MAXVAL = 0.05, n2.minval = t4.minval || n2.DEFAULT_MINVAL, n2.maxval = t4.maxval || n2.DEFAULT_MAXVAL, n2.seed = t4.seed, n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      return kr(e3, this.minval, this.maxval, t4);
    }, t3.prototype.getConfig = function() {
      return { minval: this.minval, maxval: this.maxval, seed: this.seed };
    }, t3.className = "RandomUniform", t3;
  }(Initializer);
  Mf.registerClass(RandomUniform);
  var RandomNormal = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      return n2.DEFAULT_MEAN = 0, n2.DEFAULT_STDDEV = 0.05, n2.mean = t4.mean || n2.DEFAULT_MEAN, n2.stddev = t4.stddev || n2.DEFAULT_STDDEV, n2.seed = t4.seed, n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      if ("float32" !== (t4 = t4 || "float32") && "int32" !== t4)
        throw new NotImplementedError("randomNormal does not support dType " + t4 + ".");
      return randomNormal$1(e3, this.mean, this.stddev, t4, this.seed);
    }, t3.prototype.getConfig = function() {
      return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    }, t3.className = "RandomNormal", t3;
  }(Initializer);
  Mf.registerClass(RandomNormal);
  var TruncatedNormal = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      return n2.DEFAULT_MEAN = 0, n2.DEFAULT_STDDEV = 0.05, n2.mean = t4.mean || n2.DEFAULT_MEAN, n2.stddev = t4.stddev || n2.DEFAULT_STDDEV, n2.seed = t4.seed, n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      if ("float32" !== (t4 = t4 || "float32") && "int32" !== t4)
        throw new NotImplementedError("truncatedNormal does not support dType " + t4 + ".");
      return Fr(e3, this.mean, this.stddev, t4, this.seed);
    }, t3.prototype.getConfig = function() {
      return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    }, t3.className = "TruncatedNormal", t3;
  }(Initializer);
  Mf.registerClass(TruncatedNormal);
  var Identity = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      return n2.gain = null != t4.gain ? t4.gain : 1, n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      var n2 = this;
      return je(function() {
        if (2 !== e3.length || e3[0] !== e3[1])
          throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");
        return tc(n2.gain, vr(e3[0]));
      });
    }, t3.prototype.getConfig = function() {
      return { gain: this.gain };
    }, t3.className = "Identity", t3;
  }(Initializer);
  function computeFans(e2, t3) {
    var n2, r2;
    if (void 0 === t3 && (t3 = "channelsLast"), checkDataFormat(t3), 2 === e2.length)
      n2 = e2[0], r2 = e2[1];
    else if (-1 !== [3, 4, 5].indexOf(e2.length)) {
      if ("channelsFirst" === t3) {
        var i2 = arrayProd(e2, 2);
        n2 = e2[1] * i2, r2 = e2[0] * i2;
      } else if ("channelsLast" === t3) {
        i2 = arrayProd(e2, 0, e2.length - 2);
        n2 = e2[e2.length - 2] * i2, r2 = e2[e2.length - 1] * i2;
      }
    } else {
      var a2 = arrayProd(e2);
      n2 = Math.sqrt(a2), r2 = Math.sqrt(a2);
    }
    return [n2, r2];
  }
  Mf.registerClass(Identity);
  var VarianceScaling = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      if (t4.scale < 0)
        throw new ValueError("scale must be a positive float. Got: " + t4.scale);
      return n2.scale = null == t4.scale ? 1 : t4.scale, n2.mode = null == t4.mode ? "fanIn" : t4.mode, checkFanMode(n2.mode), n2.distribution = null == t4.distribution ? "normal" : t4.distribution, checkDistribution(n2.distribution), n2.seed = t4.seed, n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      var n2 = computeFans(e3), r2 = n2[0], i2 = n2[1], a2 = this.scale;
      if ("fanIn" === this.mode ? a2 /= Math.max(1, r2) : "fanOut" === this.mode ? a2 /= Math.max(1, i2) : a2 /= Math.max(1, (r2 + i2) / 2), "normal" === this.distribution) {
        var o2 = Math.sqrt(a2);
        if ("float32" !== (t4 = t4 || "float32") && "int32" !== t4)
          throw new NotImplementedError(this.getClassName() + " does not support dType " + t4 + ".");
        return Fr(e3, 0, o2, t4, this.seed);
      }
      var s2 = Math.sqrt(3 * a2);
      return kr(e3, -s2, s2, t4);
    }, t3.prototype.getConfig = function() {
      return { scale: this.scale, mode: this.mode, distribution: this.distribution, seed: this.seed };
    }, t3.className = "VarianceScaling", t3;
  }(Initializer);
  Mf.registerClass(VarianceScaling);
  var GlorotUniform = function(e2) {
    function t3(t4) {
      return e2.call(this, { scale: 1, mode: "fanAvg", distribution: "uniform", seed: null == t4 ? null : t4.seed }) || this;
    }
    return __extends(t3, e2), t3.prototype.getClassName = function() {
      return VarianceScaling.className;
    }, t3.className = "GlorotUniform", t3;
  }(VarianceScaling);
  Mf.registerClass(GlorotUniform);
  var GlorotNormal = function(e2) {
    function t3(t4) {
      return e2.call(this, { scale: 1, mode: "fanAvg", distribution: "normal", seed: null == t4 ? null : t4.seed }) || this;
    }
    return __extends(t3, e2), t3.prototype.getClassName = function() {
      return VarianceScaling.className;
    }, t3.className = "GlorotNormal", t3;
  }(VarianceScaling);
  Mf.registerClass(GlorotNormal);
  var HeNormal = function(e2) {
    function t3(t4) {
      return e2.call(this, { scale: 2, mode: "fanIn", distribution: "normal", seed: null == t4 ? null : t4.seed }) || this;
    }
    return __extends(t3, e2), t3.prototype.getClassName = function() {
      return VarianceScaling.className;
    }, t3.className = "HeNormal", t3;
  }(VarianceScaling);
  Mf.registerClass(HeNormal);
  var HeUniform = function(e2) {
    function t3(t4) {
      return e2.call(this, { scale: 2, mode: "fanIn", distribution: "uniform", seed: null == t4 ? null : t4.seed }) || this;
    }
    return __extends(t3, e2), t3.prototype.getClassName = function() {
      return VarianceScaling.className;
    }, t3.className = "HeUniform", t3;
  }(VarianceScaling);
  Mf.registerClass(HeUniform);
  var LeCunNormal = function(e2) {
    function t3(t4) {
      return e2.call(this, { scale: 1, mode: "fanIn", distribution: "normal", seed: null == t4 ? null : t4.seed }) || this;
    }
    return __extends(t3, e2), t3.prototype.getClassName = function() {
      return VarianceScaling.className;
    }, t3.className = "LeCunNormal", t3;
  }(VarianceScaling);
  Mf.registerClass(LeCunNormal);
  var LeCunUniform = function(e2) {
    function t3(t4) {
      return e2.call(this, { scale: 1, mode: "fanIn", distribution: "uniform", seed: null == t4 ? null : t4.seed }) || this;
    }
    return __extends(t3, e2), t3.prototype.getClassName = function() {
      return VarianceScaling.className;
    }, t3.className = "LeCunNormal", t3;
  }(VarianceScaling);
  Mf.registerClass(LeCunUniform);
  var Orthogonal = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      if (n2.DEFAULT_GAIN = 1, n2.gain = null == t4.gain ? n2.DEFAULT_GAIN : t4.gain, n2.seed = t4.seed, null != n2.seed)
        throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");
      return n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      var n2 = this;
      return je(function() {
        if (2 !== e3.length)
          throw new NotImplementedError("The Orthogonal Initializer does not support non-2D shapes yet.");
        e3[0] * e3[1] > 2e3 && console.warn("Orthogonal initializer is being called on a matrix with more than 2000 (" + e3[0] * e3[1] + ") elements: Slowness may result.");
        var t5 = randomNormal$1(e3[0] > e3[1] ? [e3[1], e3[0]] : e3, 0, 1, "float32"), r2 = sh.gramSchmidt(t5);
        return e3[0] > e3[1] && (r2 = r2.transpose()), tc(n2.gain, r2);
      });
    }, t3.prototype.getConfig = function() {
      return { gain: this.gain, seed: this.seed };
    }, t3.className = "Orthogonal", t3;
  }(Initializer);
  Mf.registerClass(Orthogonal);
  var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = { constant: "Constant", glorotNormal: "GlorotNormal", glorotUniform: "GlorotUniform", heNormal: "HeNormal", heUniform: "HeUniform", identity: "Identity", leCunNormal: "LeCunNormal", leCunUniform: "LeCunUniform", ones: "Ones", orthogonal: "Orthogonal", randomNormal: "RandomNormal", randomUniform: "RandomUniform", truncatedNormal: "TruncatedNormal", varianceScaling: "VarianceScaling", zeros: "Zeros" };
  function deserializeInitializer(e2, t3) {
    return void 0 === t3 && (t3 = {}), deserializeKerasObject(e2, Mf.SerializationMap.getMap().classNameMap, t3, "initializer");
  }
  function serializeInitializer(e2) {
    return serializeKerasObject(e2);
  }
  function getInitializer(e2) {
    if ("string" == typeof e2) {
      var t3 = e2 in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e2] : e2;
      if ("GlorotNormal" === t3)
        return new GlorotNormal();
      if ("GlorotUniform" === t3)
        return new GlorotUniform();
      if ("HeNormal" === t3)
        return new HeNormal();
      if ("HeUniform" === t3)
        return new HeUniform();
      if ("LeCunNormal" === t3)
        return new LeCunNormal();
      if ("LeCunUniform" === t3)
        return new LeCunUniform();
      var n2 = {};
      return n2.className = t3, n2.config = {}, deserializeInitializer(n2);
    }
    return e2 instanceof Initializer ? e2 : deserializeInitializer(e2);
  }
  function zeros$1() {
    return new Zeros();
  }
  function ones$1() {
    return new Ones();
  }
  function constant(e2) {
    return new Constant(e2);
  }
  function randomUniform$1(e2) {
    return new RandomUniform(e2);
  }
  function randomNormal$2(e2) {
    return new RandomNormal(e2);
  }
  function truncatedNormal$1(e2) {
    return new TruncatedNormal(e2);
  }
  function identity(e2) {
    return new Identity(e2);
  }
  function varianceScaling(e2) {
    return new VarianceScaling(e2);
  }
  function glorotUniform(e2) {
    return new GlorotUniform(e2);
  }
  function glorotNormal(e2) {
    return new GlorotNormal(e2);
  }
  function heNormal(e2) {
    return new HeNormal(e2);
  }
  function heUniform(e2) {
    return new HeUniform(e2);
  }
  function leCunNormal(e2) {
    return new LeCunNormal(e2);
  }
  function leCunUniform(e2) {
    return new LeCunUniform(e2);
  }
  function orthogonal(e2) {
    return new Orthogonal(e2);
  }
  var exports_initializers = Object.freeze({ zeros: zeros$1, ones: ones$1, constant, randomUniform: randomUniform$1, randomNormal: randomNormal$2, truncatedNormal: truncatedNormal$1, identity, varianceScaling, glorotUniform, glorotNormal, heNormal, heUniform, leCunNormal, leCunUniform, orthogonal });
  var _nextUniqueTensorId = 0;
  function getNextUniqueTensorId() {
    return _nextUniqueTensorId++;
  }
  var _uidPrefixes = {};
  function getUid(e2) {
    return void 0 === e2 && (e2 = ""), e2 in _uidPrefixes || (_uidPrefixes[e2] = 0), _uidPrefixes[e2] += 1, e2 + _uidPrefixes[e2].toString();
  }
  function isArrayOfShapes(e2) {
    return Array.isArray(e2) && Array.isArray(e2[0]);
  }
  function normalizeShapeList(e2) {
    return 0 === e2.length ? [] : Array.isArray(e2[0]) ? e2 : [e2];
  }
  function getExactlyOneTensor(e2) {
    var t3;
    if (Array.isArray(e2)) {
      if (1 !== e2.length)
        throw new ValueError("Expected Tensor length to be 1; got " + e2.length);
      t3 = e2[0];
    } else
      t3 = e2;
    return t3;
  }
  function getExactlyOneShape(e2) {
    if (Array.isArray(e2) && Array.isArray(e2[0])) {
      if (1 === e2.length)
        return (e2 = e2)[0];
      throw new ValueError("Expected exactly 1 Shape; got " + e2.length);
    }
    return e2;
  }
  function countParamsInWeights(e2) {
    for (var t3 = 0, n2 = 0, r2 = e2; n2 < r2.length; n2++) {
      var i2 = r2[n2];
      0 === i2.shape.length ? t3 += 1 : t3 += i2.shape.reduce(function(e3, t4) {
        return e3 * t4;
      });
    }
    return t3;
  }
  var DEFAULT_VARIABLE_NAME_PREFIX = "Variable";
  var LayerVariable = function() {
    function e2(e3, t3, n2, r2, i2) {
      void 0 === t3 && (t3 = "float32"), void 0 === n2 && (n2 = DEFAULT_VARIABLE_NAME_PREFIX), void 0 === r2 && (r2 = true), void 0 === i2 && (i2 = null), this.dtype = null == t3 ? "float32" : t3, this.shape = e3.shape, this.id = getNextUniqueTensorId(), n2 = null == n2 ? DEFAULT_VARIABLE_NAME_PREFIX : n2, this.originalName = getScopedTensorName(n2), this.name = getUniqueTensorName(this.originalName), this.trainable_ = r2, this.constraint = i2, this.val = Mn(e3, this.trainable_, this.name, this.dtype);
    }
    return e2.prototype.read = function() {
      return this.assertNotDisposed(), this.val;
    }, e2.prototype.write = function(e3) {
      return this.assertNotDisposed(), checkShapesMatch(this.val, e3), this.val.id !== e3.id && (this.val.assign(e3), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this;
    }, e2.prototype.dispose = function() {
      this.assertNotDisposed(), this.val.dispose();
    }, e2.prototype.assertNotDisposed = function() {
      if (this.val.isDisposed)
        throw new Error("LayersVariable " + this.name + " is already disposed.");
    }, Object.defineProperty(e2.prototype, "trainable", { get: function() {
      return this.trainable_;
    }, set: function(e3) {
      this.trainable_ = e3, this.val.trainable = e3;
    }, enumerable: true, configurable: true }), e2;
  }();
  function checkShapesMatch(e2, t3) {
    if (e2.shape.toString() !== t3.shape.toString())
      throw new Error("Shape mismatch: " + JSON.stringify(e2.shape) + " vs. " + JSON.stringify(t3.shape));
  }
  function batchGetValue(e2) {
    return e2.map(function(e3) {
      return e3.read();
    });
  }
  function batchSetValue(e2) {
    e2.forEach(function(e3) {
      e3[0].write(e3[1]);
    });
  }
  var InputSpec = function() {
    return function(e2) {
      this.dtype = e2.dtype, this.shape = e2.shape, null != e2.shape ? this.ndim = e2.shape.length : this.ndim = e2.ndim, this.maxNDim = e2.maxNDim, this.minNDim = e2.minNDim, this.axes = e2.axes || {};
    };
  }();
  var SymbolicTensor = function() {
    return function(e2, t3, n2, r2, i2, a2, o2) {
      this.dtype = e2, this.shape = t3, this.sourceLayer = n2, this.inputs = r2, this.callArgs = i2, this.outputTensorIndex = o2, this.id = getNextUniqueTensorId(), null != a2 && (this.originalName = getScopedTensorName(a2), this.name = getUniqueTensorName(this.originalName)), this.rank = t3.length;
    };
  }();
  var _nextNodeID = 0;
  var Node = function() {
    function e2(e3, t3) {
      this.callArgs = t3, this.id = _nextNodeID++, this.outboundLayer = e3.outboundLayer, this.inboundLayers = e3.inboundLayers, this.nodeIndices = e3.nodeIndices, this.tensorIndices = e3.tensorIndices, this.inputTensors = e3.inputTensors, this.outputTensors = e3.outputTensors, this.inputMasks = e3.inputMasks, this.outputMasks = e3.outputMasks, this.inputShapes = e3.inputShapes, this.outputShapes = e3.outputShapes;
      for (var n2 = 0, r2 = e3.inboundLayers; n2 < r2.length; n2++) {
        var i2 = r2[n2];
        null != i2 && i2.outboundNodes.push(this);
      }
      e3.outboundLayer.inboundNodes.push(this);
    }
    return e2.prototype.getConfig = function() {
      for (var e3 = [], t3 = 0, n2 = this.inboundLayers; t3 < n2.length; t3++) {
        var r2 = n2[t3];
        null != r2 ? e3.push(r2.name) : e3.push(null);
      }
      return { outboundLayer: this.outboundLayer ? this.outboundLayer.name : null, inboundLayers: e3, nodeIndices: this.nodeIndices, tensorIndices: this.tensorIndices };
    }, e2;
  }();
  var _nextLayerID = 0;
  var Layer = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      n2._callHook = null, n2._addedWeightNames = [], n2._stateful = false, n2.id = _nextLayerID++, n2.activityRegularizer = null, n2.inputSpec = null, n2.supportsMasking = false, n2._trainableWeights = [], n2._nonTrainableWeights = [], n2._losses = [], n2._updates = [], n2._built = false, n2.inboundNodes = [], n2.outboundNodes = [];
      var r2 = t4.name;
      if (!r2) {
        var i2 = n2.getClassName();
        r2 = toSnakeCase(i2) + "_" + getUid(i2);
      }
      if (n2.name = r2, n2.trainable_ = null == t4.trainable || t4.trainable, null != t4.inputShape || null != t4.batchInputShape) {
        var a2 = void 0;
        if (null != t4.batchInputShape)
          a2 = t4.batchInputShape;
        else if (null != t4.inputShape) {
          var o2 = null;
          null != t4.batchSize && (o2 = t4.batchSize), a2 = [o2].concat(t4.inputShape);
        }
        n2.batchInputShape = a2;
        var s2 = t4.dtype;
        null == s2 && (s2 = t4.inputDType), null == s2 && (s2 = "float32"), n2.dtype = s2;
      }
      return null != t4.weights ? n2.initialWeights = t4.weights : n2.initialWeights = null, n2._refCount = null, n2.fastWeightInitDuringBuild = false, n2;
    }
    return __extends(t3, e2), t3.nodeKey = function(e3, t4) {
      return e3.name + "_ib-" + t4.toString();
    }, t3.prototype.getNodeAtIndex = function(e3, t4) {
      if (0 === this.inboundNodes.length)
        throw new RuntimeError("The layer has never been called and thus has no defined " + t4 + ".");
      if (this.inboundNodes.length <= e3)
        throw new ValueError("Asked to get " + t4 + " at node " + e3 + ", but the layer has only " + this.inboundNodes.length + " inbound nodes.");
      return this.inboundNodes[e3];
    }, t3.prototype.getInputAt = function(e3) {
      return singletonOrArray(this.getNodeAtIndex(e3, "input").inputTensors);
    }, t3.prototype.getOutputAt = function(e3) {
      return singletonOrArray(this.getNodeAtIndex(e3, "output").outputTensors);
    }, Object.defineProperty(t3.prototype, "input", { get: function() {
      if (this.inboundNodes.length > 1)
        throw new AttributeError("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');
      if (0 === this.inboundNodes.length)
        throw new AttributeError("Layer " + this.name + " is not connected, no input to return.");
      return singletonOrArray(this.getNodeAtIndex(0, "input").inputTensors);
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "output", { get: function() {
      if (0 === this.inboundNodes.length)
        throw new AttributeError("Layer " + this.name + " has no inbound nodes.");
      if (this.inboundNodes.length > 1)
        throw new AttributeError("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');
      return singletonOrArray(this.getNodeAtIndex(0, "output").outputTensors);
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "losses", { get: function() {
      return this._losses;
    }, enumerable: true, configurable: true }), t3.prototype.calculateLosses = function() {
      return this.losses.map(function(e3) {
        return e3();
      });
    }, Object.defineProperty(t3.prototype, "updates", { get: function() {
      return this._updates;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "built", { get: function() {
      return this._built;
    }, set: function(e3) {
      this._built = e3;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "trainable", { get: function() {
      return this.trainable_;
    }, set: function(e3) {
      this._trainableWeights.forEach(function(t4) {
        return t4.trainable = e3;
      }), this.trainable_ = e3;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "trainableWeights", { get: function() {
      return this.trainable_ ? this._trainableWeights.filter(function(e3) {
        return e3.trainable;
      }) : [];
    }, set: function(e3) {
      this._trainableWeights = e3;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "nonTrainableWeights", { get: function() {
      return this.trainable ? this._trainableWeights.filter(function(e3) {
        return !e3.trainable;
      }).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
    }, set: function(e3) {
      this._nonTrainableWeights = e3;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "weights", { get: function() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "stateful", { get: function() {
      return this._stateful;
    }, enumerable: true, configurable: true }), t3.prototype.resetStates = function() {
      if (!this.stateful)
        throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
    }, t3.prototype.assertInputCompatibility = function(e3) {
      if (e3 = toList(e3), null != this.inputSpec && 0 !== this.inputSpec.length) {
        var t4 = toList(this.inputSpec);
        if (e3.length !== t4.length)
          throw new ValueError("Layer " + this.name + " expects " + t4.length + " inputs, but it received " + e3.length + " input tensors. Input received: " + e3);
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2], i2 = t4[n2];
          if (null != i2) {
            var a2 = r2.rank;
            if (null != i2.ndim && a2 !== i2.ndim)
              throw new ValueError("Input " + n2 + " is incompatible with layer " + this.name + ": expected ndim=" + i2.ndim + ", found ndim=" + a2);
            if (null != i2.maxNDim && a2 > i2.maxNDim)
              throw new ValueError("Input " + n2 + " is incompatible with layer " + this.name + ": expected max_ndim=" + i2.maxNDim + ", found ndim=" + a2);
            if (null != i2.minNDim && a2 < i2.minNDim)
              throw new ValueError("Input " + n2 + " is incompatible with layer " + this.name + ": expected min_ndim=" + i2.minNDim + ", found ndim=" + a2 + ".");
            if (null != i2.dtype && r2.dtype !== i2.dtype)
              throw new ValueError("Input " + n2 + " is incompatible with layer " + this.name + " : expected dtype=" + i2.dtype + ", found dtype=" + r2.dtype + ".");
            if (i2.axes) {
              var o2 = r2.shape;
              for (var s2 in i2.axes) {
                var l3 = Number(s2), u2 = i2.axes[s2], c2 = l3 >= 0 ? o2[l3] : o2[o2.length + l3];
                if (null != u2 && -1 === [u2, null].indexOf(c2))
                  throw new ValueError("Input " + n2 + " is incompatible with layer " + this.name + ": expected axis " + l3 + " of input shape to have value " + u2 + " but got shape " + o2 + ".");
              }
            }
            if (null != i2.shape)
              for (var p2 = 0; p2 < i2.shape.length; ++p2) {
                var h = i2.shape[p2], d2 = r2.shape[p2];
                if (null != h && null != d2 && h !== d2)
                  throw new ValueError("Input " + n2 + " is incompatible with layer " + this.name + ": expected shape=" + i2.shape + ", found shape=" + r2.shape + ".");
              }
          }
        }
      }
    }, t3.prototype.call = function(e3, t4) {
      return e3;
    }, t3.prototype.invokeCallHook = function(e3, t4) {
      null != this._callHook && this._callHook(e3, t4);
    }, t3.prototype.setCallHook = function(e3) {
      this._callHook = e3;
    }, t3.prototype.clearCallHook = function() {
      this._callHook = null;
    }, t3.prototype.apply = function(e3, t4) {
      var n2 = this;
      t4 = t4 || {}, this.assertNotDisposed();
      for (var r2 = toList(e3), i2 = true, a2 = 0, o2 = r2; a2 < o2.length; a2++) {
        if (!(o2[a2] instanceof SymbolicTensor)) {
          i2 = false;
          break;
        }
      }
      for (var s2 = true, l3 = 0, u2 = r2; l3 < u2.length; l3++) {
        if (u2[l3] instanceof SymbolicTensor) {
          s2 = false;
          break;
        }
      }
      if (i2 === s2)
        throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");
      return nameScope(this.name, function() {
        if (!n2.built) {
          n2.assertInputCompatibility(e3);
          for (var i3 = [], a3 = 0, o3 = toList(e3); a3 < o3.length; a3++) {
            var l4 = o3[a3];
            i3.push(l4.shape);
          }
          n2.build(singletonOrArray(i3)), n2.built = true, n2.initialWeights && n2.setWeights(n2.initialWeights), null === n2._refCount && s2 && (n2._refCount = 1);
        }
        if (n2.assertInputCompatibility(e3), s2) {
          for (var u3 = [], c2 = 0, p2 = toList(g2 = n2.call(e3, t4)); c2 < p2.length; c2++) {
            var h = p2[c2];
            -1 !== r2.indexOf(h) && (h = h.clone()), u3.push(h);
          }
          if (g2 = singletonOrArray(u3), null != n2.activityRegularizer)
            throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          return g2;
        }
        var d2 = collectInputShape(e3), f2 = n2.computeOutputShape(d2), g2 = void 0, m2 = guessOutputDType(e3);
        if (n2.warnOnIncompatibleInputShape(Array.isArray(e3) ? d2[0] : d2), g2 = null != f2 && f2.length > 0 && Array.isArray(f2[0]) ? f2.map(function(r3, i4) {
          return new SymbolicTensor(m2, r3, n2, toList(e3), t4, n2.name, i4);
        }) : new SymbolicTensor(m2, f2, n2, toList(e3), t4, n2.name), n2.addInboundNode(e3, g2, null, null, d2, f2, t4), n2._refCount++, null != n2.activityRegularizer)
          throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return g2;
      });
    }, t3.prototype.warnOnIncompatibleInputShape = function(e3) {
      if (null != this.batchInputShape)
        if (e3.length !== this.batchInputShape.length)
          console.warn("The rank of the input tensor provided (shape: " + JSON.stringify(e3) + ") does not match that of the batchInputShape (" + JSON.stringify(this.batchInputShape) + ") of the layer " + this.name);
        else {
          var t4 = false;
          this.batchInputShape.forEach(function(n2, r2) {
            null != n2 && null != e3[r2] && e3[r2] !== n2 && (t4 = true);
          }), t4 && console.warn("The shape of the input tensor (" + JSON.stringify(e3) + ") does not match the expectation of layer " + this.name + ": " + JSON.stringify(this.batchInputShape));
        }
    }, Object.defineProperty(t3.prototype, "outputShape", { get: function() {
      if (null == this.inboundNodes || 0 === this.inboundNodes.length)
        throw new AttributeError("The layer " + this.name + " has never been called and thus has no defined output shape.");
      for (var e3 = [], t4 = 0, n2 = this.inboundNodes; t4 < n2.length; t4++) {
        var r2 = n2[t4], i2 = JSON.stringify(r2.outputShapes);
        -1 === e3.indexOf(i2) && e3.push(i2);
      }
      if (1 === e3.length) {
        var a2 = this.inboundNodes[0].outputShapes;
        return Array.isArray(a2) && Array.isArray(a2[0]) && 1 === a2.length ? a2[0] : a2;
      }
      throw new AttributeError("The layer " + this.name + ' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.');
    }, enumerable: true, configurable: true }), t3.prototype.countParams = function() {
      if (!this.built)
        throw new RuntimeError("You tried to call countParams() on " + this.name + ", but the layer is not built yet. Build it first by calling build(batchInputShape).");
      return countParamsInWeights(this.weights);
    }, t3.prototype.build = function(e3) {
      this.built = true;
    }, t3.prototype.getWeights = function(e3) {
      return void 0 === e3 && (e3 = false), batchGetValue(e3 ? this.trainableWeights : this.weights);
    }, t3.prototype.setWeights = function(e3) {
      var t4 = this;
      je(function() {
        var n2 = t4.weights;
        if (n2.length !== e3.length)
          throw new ValueError('You called setWeights(weights) on layer "' + t4.name + '" with a weight list of length ' + e3.length + ", but the layer was expecting " + n2.length + " weights. Provided weights: " + e3 + "...");
        if (0 !== n2.length) {
          for (var r2 = [], i2 = batchGetValue(n2), a2 = 0; a2 < i2.length; ++a2) {
            var o2 = i2[a2], s2 = n2[a2], l3 = e3[a2];
            if (!tt.arraysEqual(o2.shape, l3.shape))
              throw new ValueError("Layer weight shape " + o2.shape + " not compatible with provided weight shape " + l3.shape);
            r2.push([s2, l3]);
          }
          batchSetValue(r2);
        }
      });
    }, t3.prototype.addWeight = function(e3, t4, n2, r2, i2, a2, o2) {
      if (-1 !== this._addedWeightNames.indexOf(e3))
        throw new ValueError("Duplicate weight name " + e3 + " for layer " + this.name);
      this._addedWeightNames.push(e3), null == n2 && (n2 = "float32"), this.fastWeightInitDuringBuild && (r2 = getInitializer("zeros"));
      var s2 = r2.apply(t4, n2), l3 = new LayerVariable(s2, n2, e3, a2, o2);
      return s2.dispose(), null != i2 && this.addLoss(function() {
        return i2.apply(l3.read());
      }), null == a2 && (a2 = true), a2 ? this._trainableWeights.push(l3) : this._nonTrainableWeights.push(l3), l3;
    }, t3.prototype.setFastWeightInitDuringBuild = function(e3) {
      this.fastWeightInitDuringBuild = e3;
    }, t3.prototype.addLoss = function(e3) {
      var t4;
      null == e3 || Array.isArray(e3) && 0 === e3.length || (e3 = toList(e3), void 0 !== this._losses && null !== this._losses && (t4 = this.losses).push.apply(t4, e3));
    }, t3.prototype.computeOutputShape = function(e3) {
      return e3;
    }, t3.prototype.computeMask = function(e3, t4) {
      var n2 = this;
      if (!this.supportsMasking) {
        if (null != t4) {
          if (!Array.isArray(t4))
            throw new TypeError("Layer " + this.name + " does not support masking, but was passed an inputMask.");
          t4.forEach(function(e4) {
            if (null != e4)
              throw new TypeError("Layer " + n2.name + " does not support masking, but was passed an inputMask.");
          });
        }
        return null;
      }
      return t4;
    }, t3.prototype.addInboundNode = function(e3, t4, n2, r2, i2, a2, o2) {
      void 0 === o2 && (o2 = null);
      var s2 = toList(e3);
      t4 = toList(t4), n2 = toList(n2), r2 = toList(r2), i2 = normalizeShapeList(i2), a2 = normalizeShapeList(a2);
      for (var l3 = [], u2 = [], c2 = [], p2 = 0, h = s2; p2 < h.length; p2++) {
        var d2 = h[p2];
        l3.push(d2.sourceLayer), u2.push(d2.nodeIndex), c2.push(d2.tensorIndex);
      }
      new Node({ outboundLayer: this, inboundLayers: l3, nodeIndices: u2, tensorIndices: c2, inputTensors: s2, outputTensors: t4, inputMasks: n2, outputMasks: r2, inputShapes: i2, outputShapes: a2 }, o2);
      for (var f2 = 0; f2 < t4.length; f2++)
        t4[f2].sourceLayer = this, t4[f2].nodeIndex = this.inboundNodes.length - 1, t4[f2].tensorIndex = f2;
    }, t3.prototype.getConfig = function() {
      var e3 = { name: this.name, trainable: this.trainable };
      return null != this.batchInputShape && (e3.batchInputShape = this.batchInputShape), null != this.dtype && (e3.dtype = this.dtype), e3;
    }, t3.prototype.disposeWeights = function() {
      return this.weights.forEach(function(e3) {
        return e3.dispose();
      }), this.weights.length;
    }, t3.prototype.assertNotDisposed = function() {
      if (0 === this._refCount)
        throw new Error("Layer '" + this.name + "' is already disposed.");
    }, t3.prototype.dispose = function() {
      if (!this.built)
        throw new Error("Cannot dispose Layer " + this.name + " because it has not been built yet.");
      if (null === this._refCount)
        throw new Error("Cannot dispose Layer " + this.name + " because it has not been used yet.");
      this.assertNotDisposed();
      var e3 = 0;
      return 0 == --this._refCount && (e3 = this.disposeWeights()), { refCountAfterDispose: this._refCount, numDisposedVariables: e3 };
    }, t3;
  }(Mf.Serializable);
  function collectInputShape(e2) {
    for (var t3 = [], n2 = 0, r2 = e2 = toList(e2); n2 < r2.length; n2++) {
      var i2 = r2[n2];
      t3.push(i2.shape);
    }
    return singletonOrArray(t3);
  }
  function guessOutputDType(e2) {
    return "float32";
  }
  function getSourceInputs(e2, t3, n2) {
    if ((null == t3 || null != n2 && n2 > 0) && (t3 = e2.sourceLayer, n2 = e2.nodeIndex), 0 === t3.inboundNodes.length)
      return [e2];
    var r2 = t3.inboundNodes[n2];
    if (0 === r2.inboundLayers.length)
      return r2.inputTensors;
    for (var i2 = [], a2 = 0; a2 < r2.inboundLayers.length; a2++)
      for (var o2 = 0, s2 = getSourceInputs(r2.inputTensors[a2], r2.inboundLayers[a2], r2.nodeIndices[a2]); o2 < s2.length; o2++) {
        var l3 = s2[o2];
        -1 === i2.indexOf(l3) && i2.push(l3);
      }
    return i2;
  }
  var ModelLoggingVerbosity;
  var InputLayer = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, { dtype: t4.dtype, name: null != t4.name ? t4.name : getUid("input").toString() }) || this;
      if (null == t4.batchSize && (t4.batchSize = null), null == t4.sparse && (t4.sparse = false), n2.trainable = false, n2.built = true, n2.sparse = t4.sparse, null != t4.inputShape && null != t4.batchInputShape)
        throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
      var r2 = t4.batchInputShape;
      if (null == r2) {
        if (null == t4.inputShape)
          throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
        r2 = [t4.batchSize].concat(t4.inputShape);
      } else if (null != t4.batchSize)
        throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
      var i2 = t4.dtype || "float32";
      n2.batchInputShape = r2, n2.dtype = i2, n2.inputSpec = [{ shape: r2 }];
      var a2 = new SymbolicTensor(n2.dtype, n2.batchInputShape, n2, [], {}, n2.name);
      return a2.nodeIndex = 0, a2.tensorIndex = 0, new Node({ outboundLayer: n2, inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: [a2], outputTensors: [a2], inputMasks: [null], outputMasks: [null], inputShapes: [r2], outputShapes: [r2] }), n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      throw new ValueError("Cannot pass any input to an InputLayer's apply() method. InputLayer name: " + this.name);
    }, t3.prototype.dispose = function() {
      return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };
    }, t3.prototype.getConfig = function() {
      return { batchInputShape: this.batchInputShape, dtype: this.dtype, sparse: this.sparse, name: this.name };
    }, t3.className = "InputLayer", t3;
  }(Layer);
  function Input(e2) {
    if (null == e2.batchShape && null == e2.shape)
      throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
    if (null != e2.batchShape && null != e2.shape)
      throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
    var t3 = e2.batchShape;
    null != e2.shape && null == t3 && (t3 = [null].concat(e2.shape));
    var n2 = e2.dtype;
    return null == n2 && (n2 = "float32"), new InputLayer({ batchInputShape: t3, name: e2.name, dtype: n2, sparse: e2.sparse }).inboundNodes[0].outputTensors[0];
  }
  function resolveScalarsInLogs(e2) {
    return __awaiter(this, void 0, void 0, function() {
      var t3, n2, r2, i2, a2, o2, s2, l3;
      return __generator(this, function(u2) {
        switch (u2.label) {
          case 0:
            if (null == e2)
              return [2];
            for (i2 in t3 = [], n2 = [], r2 = [], e2)
              "number" != typeof (a2 = e2[i2]) && (o2 = a2, t3.push(o2.data()), n2.push(i2), r2.push(o2));
            return t3.length > 0 ? [4, Promise.all(t3)] : [3, 2];
          case 1:
            for (s2 = u2.sent(), l3 = 0; l3 < s2.length; ++l3)
              e2[n2[l3]] = s2[l3][0];
            Xe(r2), u2.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }
  function disposeTensorsInLogs(e2) {
    if (null != e2)
      for (var t3 in e2) {
        var n2 = e2[t3];
        "number" != typeof n2 && n2.dispose();
      }
  }
  Mf.registerClass(InputLayer), function(e2) {
    e2[e2.SILENT = 0] = "SILENT", e2[e2.VERBOSE = 1] = "VERBOSE";
  }(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));
  var DEFAULT_YIELD_EVERY_MS = 125;
  var BaseCallback = function() {
    function e2() {
      this.validationData = null;
    }
    return e2.prototype.setParams = function(e3) {
      this.params = e3;
    }, e2.prototype.onEpochBegin = function(e3, t3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e4) {
          return [2];
        });
      });
    }, e2.prototype.onEpochEnd = function(e3, t3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e4) {
          return [2];
        });
      });
    }, e2.prototype.onBatchBegin = function(e3, t3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e4) {
          return [2];
        });
      });
    }, e2.prototype.onBatchEnd = function(e3, t3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e4) {
          return [2];
        });
      });
    }, e2.prototype.onTrainBegin = function(e3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e4) {
          return [2];
        });
      });
    }, e2.prototype.onTrainEnd = function(e3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e4) {
          return [2];
        });
      });
    }, e2.prototype.setModel = function(e3) {
    }, e2;
  }();
  var CallbackList = function() {
    function e2(e3, t3) {
      void 0 === t3 && (t3 = 10), null == e3 && (e3 = []), this.callbacks = e3, this.queueLength = t3;
    }
    return e2.prototype.append = function(e3) {
      this.callbacks.push(e3);
    }, e2.prototype.setParams = function(e3) {
      for (var t3 = 0, n2 = this.callbacks; t3 < n2.length; t3++) {
        n2[t3].setParams(e3);
      }
    }, e2.prototype.setModel = function(e3) {
      for (var t3 = 0, n2 = this.callbacks; t3 < n2.length; t3++) {
        n2[t3].setModel(e3);
      }
    }, e2.prototype.onEpochBegin = function(e3, t3) {
      return __awaiter(this, void 0, void 0, function() {
        var n2, r2;
        return __generator(this, function(i2) {
          switch (i2.label) {
            case 0:
              null == t3 && (t3 = {}), n2 = 0, r2 = this.callbacks, i2.label = 1;
            case 1:
              return n2 < r2.length ? [4, r2[n2].onEpochBegin(e3, t3)] : [3, 4];
            case 2:
              i2.sent(), i2.label = 3;
            case 3:
              return n2++, [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }, e2.prototype.onEpochEnd = function(e3, t3) {
      return __awaiter(this, void 0, void 0, function() {
        var n2, r2;
        return __generator(this, function(i2) {
          switch (i2.label) {
            case 0:
              null == t3 && (t3 = {}), n2 = 0, r2 = this.callbacks, i2.label = 1;
            case 1:
              return n2 < r2.length ? [4, r2[n2].onEpochEnd(e3, t3)] : [3, 4];
            case 2:
              i2.sent(), i2.label = 3;
            case 3:
              return n2++, [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }, e2.prototype.onBatchBegin = function(e3, t3) {
      return __awaiter(this, void 0, void 0, function() {
        var n2, r2;
        return __generator(this, function(i2) {
          switch (i2.label) {
            case 0:
              null == t3 && (t3 = {}), n2 = 0, r2 = this.callbacks, i2.label = 1;
            case 1:
              return n2 < r2.length ? [4, r2[n2].onBatchBegin(e3, t3)] : [3, 4];
            case 2:
              i2.sent(), i2.label = 3;
            case 3:
              return n2++, [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }, e2.prototype.onBatchEnd = function(e3, t3) {
      return __awaiter(this, void 0, void 0, function() {
        var n2, r2;
        return __generator(this, function(i2) {
          switch (i2.label) {
            case 0:
              null == t3 && (t3 = {}), n2 = 0, r2 = this.callbacks, i2.label = 1;
            case 1:
              return n2 < r2.length ? [4, r2[n2].onBatchEnd(e3, t3)] : [3, 4];
            case 2:
              i2.sent(), i2.label = 3;
            case 3:
              return n2++, [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }, e2.prototype.onTrainBegin = function(e3) {
      return __awaiter(this, void 0, void 0, function() {
        var t3, n2;
        return __generator(this, function(r2) {
          switch (r2.label) {
            case 0:
              null == e3 && (e3 = {}), t3 = 0, n2 = this.callbacks, r2.label = 1;
            case 1:
              return t3 < n2.length ? [4, n2[t3].onTrainBegin(e3)] : [3, 4];
            case 2:
              r2.sent(), r2.label = 3;
            case 3:
              return t3++, [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }, e2.prototype.onTrainEnd = function(e3) {
      return __awaiter(this, void 0, void 0, function() {
        var t3, n2;
        return __generator(this, function(r2) {
          switch (r2.label) {
            case 0:
              null == e3 && (e3 = {}), t3 = 0, n2 = this.callbacks, r2.label = 1;
            case 1:
              return t3 < n2.length ? [4, n2[t3].onTrainEnd(e3)] : [3, 4];
            case 2:
              r2.sent(), r2.label = 3;
            case 3:
              return t3++, [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }, e2;
  }();
  var BaseLogger = function(e2) {
    function t3() {
      return e2.call(this) || this;
    }
    return __extends(t3, e2), t3.prototype.onEpochBegin = function(e3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e4) {
          return this.seen = 0, this.totals = {}, [2];
        });
      });
    }, t3.prototype.onBatchEnd = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        var e4, n2, r2, i2, a2 = this;
        return __generator(this, function(o2) {
          for (i2 in null == t4 && (t4 = {}), e4 = null == t4.size ? 0 : t4.size, this.seen += e4, n2 = function(n3) {
            var i3 = t4[n3];
            if ("number" == typeof i3)
              r2.totals.hasOwnProperty(n3) || (r2.totals[n3] = 0), r2.totals[n3] = r2.totals[n3] + i3 * e4;
            else {
              var o3 = void 0;
              n3 in r2.totals ? o3 = r2.totals[n3] : r2.totals[n3] = 0;
              var s2 = je(function() {
                return Vs(a2.totals[n3], tc(i3, e4));
              });
              r2.totals[n3] = s2, null != o3 && o3.dispose();
            }
          }, r2 = this, t4)
            n2(i2);
          return [2];
        });
      });
    }, t3.prototype.onEpochEnd = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        var e4, n2, r2, i2, a2, o2 = this;
        return __generator(this, function(s2) {
          if (null != t4)
            for (e4 = function(e5) {
              if (null == n2.totals[e5])
                return "continue";
              "number" == typeof n2.totals[e5] ? t4[e5] = n2.totals[e5] / n2.seen : je(function() {
                var n3 = tc(qs(1, o2.seen), o2.totals[e5]);
                t4[e5] = n3, o2.totals[e5].dispose(), $e(t4[e5]);
              });
            }, n2 = this, r2 = 0, i2 = this.params.metrics; r2 < i2.length; r2++)
              a2 = i2[r2], e4(a2);
          return [2];
        });
      });
    }, t3;
  }(BaseCallback);
  var History = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.onTrainBegin = function(e3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e4) {
          return this.epoch = [], this.history = {}, [2];
        });
      });
    }, t3.prototype.onEpochEnd = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        var n2;
        return __generator(this, function(r2) {
          for (n2 in null == t4 && (t4 = {}), this.epoch.push(e3), t4)
            null == this.history[n2] && (this.history[n2] = []), this.history[n2].push(t4[n2]);
          return [2];
        });
      });
    }, t3.prototype.syncData = function() {
      return __awaiter(this, void 0, void 0, function() {
        var e3, t4, n2, r2, i2, a2, o2, s2, l3;
        return __generator(this, function(u2) {
          switch (u2.label) {
            case 0:
              for (r2 in e3 = [], t4 = [], n2 = [], this.history)
                for (i2 = this.history[r2], a2 = 0; a2 < i2.length; ++a2)
                  "number" != typeof i2[a2] && (o2 = i2[a2], e3.push(o2.data()), t4.push(r2), n2.push(a2));
              return [4, Promise.all(e3)];
            case 1:
              for (s2 = u2.sent(), l3 = 0; l3 < s2.length; ++l3)
                this.history[t4[l3]][n2[l3]].dispose(), this.history[t4[l3]][n2[l3]] = s2[l3][0];
              return [2];
          }
        });
      });
    }, t3;
  }(BaseCallback);
  var CustomCallback = function(e2) {
    function t3(t4, n2) {
      var r2 = e2.call(this) || this;
      if (r2.currentEpoch = 0, r2.yieldEvery = n2 || "auto", "auto" === r2.yieldEvery && (r2.yieldEvery = DEFAULT_YIELD_EVERY_MS), "never" === r2.yieldEvery && null != t4.onYield)
        throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
      return tt.isNumber(r2.yieldEvery) && (r2.maybeWait = debounce(r2.maybeWait.bind(r2), r2.yieldEvery)), r2.trainBegin = t4.onTrainBegin, r2.trainEnd = t4.onTrainEnd, r2.epochBegin = t4.onEpochBegin, r2.epochEnd = t4.onEpochEnd, r2.batchBegin = t4.onBatchBegin, r2.batchEnd = t4.onBatchEnd, r2.yield = t4.onYield, r2;
    }
    return __extends(t3, e2), t3.prototype.maybeWait = function(e3, t4, n2) {
      return __awaiter(this, void 0, void 0, function() {
        var r2;
        return __generator(this, function(i2) {
          switch (i2.label) {
            case 0:
              return r2 = [], null == this.yield ? [3, 2] : [4, resolveScalarsInLogs(n2)];
            case 1:
              i2.sent(), r2.push(this.yield(e3, t4, n2)), i2.label = 2;
            case 2:
              return r2.push(ep()), [4, Promise.all(r2)];
            case 3:
              return i2.sent(), [2];
          }
        });
      });
    }, t3.prototype.onEpochBegin = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return this.currentEpoch = e3, null == this.epochBegin ? [3, 3] : [4, resolveScalarsInLogs(t4)];
            case 1:
              return n2.sent(), [4, this.epochBegin(e3, t4)];
            case 2:
              n2.sent(), n2.label = 3;
            case 3:
              return [2];
          }
        });
      });
    }, t3.prototype.onEpochEnd = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        var n2;
        return __generator(this, function(r2) {
          switch (r2.label) {
            case 0:
              return n2 = [], null == this.epochEnd ? [3, 2] : [4, resolveScalarsInLogs(t4)];
            case 1:
              r2.sent(), n2.push(this.epochEnd(e3, t4)), r2.label = 2;
            case 2:
              return "epoch" === this.yieldEvery && n2.push(ep()), [4, Promise.all(n2)];
            case 3:
              return r2.sent(), [2];
          }
        });
      });
    }, t3.prototype.onBatchBegin = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return null == this.batchBegin ? [3, 3] : [4, resolveScalarsInLogs(t4)];
            case 1:
              return n2.sent(), [4, this.batchBegin(e3, t4)];
            case 2:
              n2.sent(), n2.label = 3;
            case 3:
              return [2];
          }
        });
      });
    }, t3.prototype.onBatchEnd = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        var n2;
        return __generator(this, function(r2) {
          switch (r2.label) {
            case 0:
              return n2 = [], null == this.batchEnd ? [3, 2] : [4, resolveScalarsInLogs(t4)];
            case 1:
              r2.sent(), n2.push(this.batchEnd(e3, t4)), r2.label = 2;
            case 2:
              return "batch" === this.yieldEvery ? n2.push(ep()) : tt.isNumber(this.yieldEvery) && n2.push(this.maybeWait(this.currentEpoch, e3, t4)), [4, Promise.all(n2)];
            case 3:
              return r2.sent(), [2];
          }
        });
      });
    }, t3.prototype.onTrainBegin = function(e3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t4) {
          switch (t4.label) {
            case 0:
              return null == this.trainBegin ? [3, 3] : [4, resolveScalarsInLogs(e3)];
            case 1:
              return t4.sent(), [4, this.trainBegin(e3)];
            case 2:
              t4.sent(), t4.label = 3;
            case 3:
              return [2];
          }
        });
      });
    }, t3.prototype.onTrainEnd = function(e3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t4) {
          switch (t4.label) {
            case 0:
              return null == this.trainEnd ? [3, 3] : [4, resolveScalarsInLogs(e3)];
            case 1:
              return t4.sent(), [4, this.trainEnd(e3)];
            case 2:
              t4.sent(), t4.label = 3;
            case 3:
              return [2];
          }
        });
      });
    }, t3;
  }(BaseCallback);
  function standardizeCallbacks(e2, t3) {
    return null == e2 && (e2 = {}), e2 instanceof BaseCallback ? [e2] : Array.isArray(e2) && e2[0] instanceof BaseCallback ? e2 : toList(e2).map(function(e3) {
      return new CustomCallback(e3, t3);
    });
  }
  var CallbackConstructorRegistry = function() {
    function e2() {
    }
    return e2.registerCallbackConstructor = function(t3, n2) {
      tt.assert(t3 >= 0 && Number.isInteger(t3), function() {
        return "Verbosity level is expected to be an integer >= 0, but got " + t3;
      }), e2.checkForDuplicate(n2), null == e2.constructors[t3] && (e2.constructors[t3] = []), e2.constructors[t3].push(n2);
    }, e2.checkForDuplicate = function(t3) {
      for (var n2 in e2.constructors) {
        e2.constructors[+n2].forEach(function(e3) {
          if (e3 === t3)
            throw new ValueError("Duplicate callback constructor.");
        });
      }
    }, e2.clear = function() {
      e2.constructors = {};
    }, e2.createCallbacks = function(t3) {
      var n2 = [];
      for (var r2 in e2.constructors) {
        var i2 = +r2;
        t3 >= i2 && n2.push.apply(n2, e2.constructors[i2]);
      }
      return n2.map(function(e3) {
        return new e3();
      });
    }, e2.constructors = {}, e2;
  }();
  function configureCallbacks(e2, t3, n2, r2, i2, a2, o2, s2, l3) {
    var u2 = new History(), c2 = [new BaseLogger()].concat(CallbackConstructorRegistry.createCallbacks(t3));
    null != e2 && c2.push.apply(c2, e2), c2.push(u2);
    var p2 = new CallbackList(c2);
    return p2.setParams({ epochs: n2, initialEpoch: r2, samples: i2, steps: a2, batchSize: o2, verbose: t3, doValidation: s2, metrics: l3 }), { callbackList: p2, history: u2 };
  }
  function deserialize(e2, t3, n2) {
    return void 0 === t3 && (t3 = {}), void 0 === n2 && (n2 = false), deserializeKerasObject(e2, Mf.SerializationMap.getMap().classNameMap, t3, "layer", n2);
  }
  function l2Normalize(e2, t3) {
    return je(function() {
      "float32" !== e2.dtype && (e2 = e2.asType("float32"));
      var n2 = vl(square(e2), t3, true), r2 = Ln(n2.shape, epsilon()), i2 = gs(Xs(n2, r2));
      return qs(e2, i2);
    });
  }
  function meanSquaredError(e2, t3) {
    return je(function() {
      return fl(square(ic(t3, e2)), -1);
    });
  }
  function meanAbsoluteError(e2, t3) {
    return je(function() {
      return fl(Vu(ic(t3, e2)), -1);
    });
  }
  function meanAbsolutePercentageError(e2, t3) {
    return je(function() {
      var n2 = ic(e2, t3), r2 = $u(Vu(e2), epsilon(), Number.MAX_VALUE), i2 = Vu(qs(n2, r2));
      return tc(100, fl(i2, -1));
    });
  }
  function meanSquaredLogarithmicError(e2, t3) {
    return je(function() {
      var n2 = $u(t3, epsilon(), Number.MAX_VALUE), r2 = ns(Vs(1, n2)), i2 = $u(e2, epsilon(), Number.MAX_VALUE), a2 = ns(Vs(1, i2));
      return fl(square(ic(r2, a2)), -1);
    });
  }
  function squaredHinge(e2, t3) {
    return je(function() {
      var n2 = Xs(0, ic(1, tc(e2, t3)));
      return fl(square(n2), -1);
    });
  }
  function hinge(e2, t3) {
    return je(function() {
      var n2 = Xs(0, ic(1, tc(e2, t3)));
      return fl(n2, -1);
    });
  }
  function categoricalHinge(e2, t3) {
    return je(function() {
      var n2 = vl(tc(e2, t3), -1), r2 = hl(tc(ic(1, e2), t3), -1);
      return Xs(0, Vs(1, ic(r2, n2)));
    });
  }
  function logcosh(e2, t3) {
    return je(function() {
      var n2 = Math.log(2), r2 = ic(t3, e2), i2 = ic(Vs(r2, ms(tc(-2, r2))), n2);
      return fl(i2, -1);
    });
  }
  function categoricalCrossentropy(e2, t3, n2) {
    return void 0 === n2 && (n2 = false), je(function() {
      if (n2)
        t3 = io(t3);
      else {
        var r2 = vl(t3, t3.shape.length - 1, true);
        t3 = qs(t3, r2);
      }
      return t3 = $u(t3, epsilon(), 1 - epsilon()), as(vl(tc(e2.toFloat(), ns(t3)), t3.shape.length - 1));
    });
  }
  function sparseCategoricalCrossentropy(e2, t3) {
    return je(function() {
      var n2 = es(flatten(e2)).toInt(), r2 = (t3 = $u(t3, epsilon(), 1 - epsilon())).shape;
      return categoricalCrossentropy(gr(n2, r2[r2.length - 1]).reshape(r2), t3, false);
    });
  }
  function sigmoidCrossEntropyWithLogits(e2, t3) {
    if (!tt.arraysEqual(e2.shape, t3.shape))
      throw new ValueError("logits and labels must have the same shape, but got shapes " + JSON.stringify(e2.shape) + " and " + JSON.stringify(t3.shape));
    return je(function() {
      var n2 = t3.relu(), r2 = t3.abs().neg();
      return n2.sub(t3.mul(e2)).add(r2.exp().log1p());
    });
  }
  function binaryCrossentropy(e2, t3) {
    return je(function() {
      var n2;
      return n2 = $u(t3, epsilon(), 1 - epsilon()), n2 = ns(qs(n2, ic(1, n2))), fl(sigmoidCrossEntropyWithLogits(e2, n2), -1);
    });
  }
  function kullbackLeiblerDivergence(e2, t3) {
    return je(function() {
      var n2 = $u(e2, epsilon(), 1), r2 = $u(t3, epsilon(), 1);
      return vl(tc(e2, ns(qs(n2, r2))), -1);
    });
  }
  function poisson(e2, t3) {
    return je(function() {
      var n2 = ns(Vs(epsilon(), t3));
      return fl(ic(t3, tc(e2, n2)), -1);
    });
  }
  function cosineProximity(e2, t3) {
    return je(function() {
      var n2 = l2Normalize(e2, -1), r2 = l2Normalize(t3, -1), i2 = tc(n2, r2);
      return as(vl(i2, -1));
    });
  }
  var lossesMap = { meanSquaredError, meanAbsoluteError, meanAbsolutePercentageError, meanSquaredLogarithmicError, squaredHinge, hinge, categoricalHinge, logcosh, categoricalCrossentropy, sparseCategoricalCrossentropy, binaryCrossentropy, kullbackLeiblerDivergence, poisson, cosineProximity };
  function get(e2) {
    if ("string" == typeof e2) {
      if (e2 in lossesMap)
        return lossesMap[e2];
      var t3 = "Unknown loss " + e2;
      throw e2.toLowerCase().includes("softmaxcrossentropy") && (t3 = "Unknown loss " + e2 + '. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'), new ValueError(t3);
    }
    return e2;
  }
  function binaryAccuracy(e2, t3) {
    return je(function() {
      var n2 = tc(0.5, Vn(t3)), r2 = cast$1(lc(t3, n2), e2.dtype);
      return fl(sc(e2, r2), -1);
    });
  }
  function categoricalAccuracy(e2, t3) {
    return je(function() {
      return cast$1(sc(sl(e2, -1), sl(t3, -1)), "float32");
    });
  }
  function truePositives(e2, t3) {
    return je(function() {
      return Ms(e2.equal(1), t3.equal(1)).sum().cast("float32");
    });
  }
  function falseNegatives(e2, t3) {
    return je(function() {
      return Ms(e2.equal(1), t3.equal(0)).sum().cast("float32");
    });
  }
  function falsePositives(e2, t3) {
    return je(function() {
      return Ms(e2.equal(0), t3.equal(1)).sum().cast("float32");
    });
  }
  function precision(e2, t3) {
    return je(function() {
      var n2 = truePositives(e2, t3), r2 = falsePositives(e2, t3), i2 = n2.add(r2);
      return Ws(lc(i2, 0), n2.div(i2), 0).cast("float32");
    });
  }
  function recall(e2, t3) {
    return je(function() {
      var n2 = truePositives(e2, t3), r2 = falseNegatives(e2, t3), i2 = n2.add(r2);
      return Ws(lc(i2, 0), n2.div(i2), 0).cast("float32");
    });
  }
  function binaryCrossentropy$1(e2, t3) {
    return binaryCrossentropy(e2, t3);
  }
  function sparseCategoricalAccuracy(e2, t3) {
    return e2.rank === t3.rank && (e2 = e2.squeeze([e2.rank - 1])), (t3 = t3.argMax(-1)).dtype !== e2.dtype && (t3 = t3.asType(e2.dtype)), sc(e2, t3).asType("float32");
  }
  var mse$1 = meanSquaredError;
  var MSE$1 = meanSquaredError;
  var mae$1 = meanAbsoluteError;
  var MAE$1 = meanAbsoluteError;
  var mape$1 = meanAbsolutePercentageError;
  var MAPE$1 = meanAbsolutePercentageError;
  var categoricalCrossentropy$1 = categoricalCrossentropy;
  var cosine$1 = cosineProximity;
  var sparseCategoricalCrossentropy$1 = sparseCategoricalCrossentropy;
  var metricsMap = { binaryAccuracy, categoricalAccuracy, precision, categoricalCrossentropy: categoricalCrossentropy$1, sparseCategoricalCrossentropy: sparseCategoricalCrossentropy$1, mse: mse$1, MSE: MSE$1, mae: mae$1, MAE: MAE$1, mape: mape$1, MAPE: MAPE$1, cosine: cosine$1 };
  function get$1(e2) {
    if ("string" == typeof e2 && e2 in metricsMap)
      return metricsMap[e2];
    if ("string" != typeof e2 && null != e2)
      return e2;
    throw new ValueError("Unknown metric " + e2);
  }
  function getLossOrMetricName(e2) {
    if (assert(null !== e2, "Unknown LossOrMetricFn " + e2), "string" == typeof e2)
      return e2;
    for (var t3 = void 0, n2 = 0, r2 = Object.keys(lossesMap); n2 < r2.length; n2++) {
      var i2 = r2[n2];
      if (lossesMap[i2] === e2) {
        t3 = i2;
        break;
      }
    }
    if (void 0 !== t3)
      return t3;
    for (var a2 = 0, o2 = Object.keys(metricsMap); a2 < o2.length; a2++) {
      i2 = o2[a2];
      if (metricsMap[i2] === e2) {
        t3 = i2;
        break;
      }
    }
    return void 0 !== t3 ? t3 : e2.name;
  }
  function getOptimizer(e2) {
    var t3 = { Adagrad: function() {
      return Zf.adagrad(0.01);
    }, Adadelta: function() {
      return Zf.adadelta(1, 0.95, epsilon());
    }, Adam: function() {
      return Zf.adam(1e-3, 0.9, 0.999, epsilon());
    }, Adamax: function() {
      return Zf.adamax(2e-3, 0.9, 0.999, epsilon(), 0);
    }, RMSProp: function() {
      return Zf.rmsprop(1e-3, 0.9, 0, epsilon());
    }, SGD: function() {
      return Zf.sgd(0.01);
    } };
    if (t3.adagrad = t3.Adagrad, t3.adadelta = t3.Adadelta, t3.adam = t3.Adam, t3.adamax = t3.Adamax, t3.rmsprop = t3.RMSProp, t3.sgd = t3.SGD, e2 in t3)
      return t3[e2]();
    throw new ValueError("Unknown Optimizer " + e2);
  }
  var MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH = 1048576;
  function checkUserDefinedMetadata(e2, t3, n2) {
    if (void 0 === n2 && (n2 = false), null == e2 || "object" != typeof e2 || Object.getPrototypeOf(e2) !== Object.prototype || !plainObjectCheck(e2))
      throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
    if (n2) {
      var r2 = JSON.stringify(e2);
      r2.length > MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH && console.warn('User-defined metadata of model "' + t3 + '" is too large in size (length=' + r2.length + " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= " + MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH + ".");
    }
  }
  function plainObjectCheck(e2) {
    if (null === e2)
      return true;
    if ("object" == typeof e2) {
      if (Object.getPrototypeOf(e2) === Object.prototype) {
        for (var t3 = 0, n2 = Object.keys(e2); t3 < n2.length; t3++) {
          var r2 = n2[t3];
          if ("string" != typeof r2)
            return false;
          if (!plainObjectCheck(e2[r2]))
            return false;
        }
        return true;
      }
      if (Array.isArray(e2)) {
        for (var i2 = 0, a2 = e2; i2 < a2.length; i2++) {
          if (!plainObjectCheck(a2[i2]))
            return false;
        }
        return true;
      }
      return false;
    }
    var o2 = typeof e2;
    return "string" === o2 || "number" === o2 || "boolean" === o2;
  }
  function printSummary(e2, t3, n2, r2) {
    void 0 === r2 && (r2 = console.log);
    var i2, a2 = isModelSequentialLike(e2), o2 = ["Layer (type)", "Output shape", "Param #"];
    if (a2 ? (t3 = t3 || 65, n2 = n2 || [0.45, 0.85, 1]) : (t3 = t3 || 98, n2 = n2 || [0.33, 0.55, 0.67, 1]), n2[n2.length - 1] <= 1 && (n2 = n2.map(function(e3) {
      return Math.floor(t3 * e3);
    })), !a2)
      for (var s2 in o2.push("Receives inputs"), i2 = [], e2.nodesByDepth)
        i2.push.apply(i2, e2.nodesByDepth[s2]);
    r2("_".repeat(t3)), printRow(o2, n2, r2), r2("=".repeat(t3));
    for (var l3 = e2.layers, u2 = 0; u2 < l3.length; ++u2)
      a2 ? printLayerSummary(l3[u2], n2, r2) : printLayerSummaryWithConnections(l3[u2], n2, i2, r2), r2((u2 === l3.length - 1 ? "=" : "_").repeat(t3));
    e2.checkTrainableWeightsConsistency();
    var c2 = countTrainableParams(e2), p2 = countParamsInWeights(e2.nonTrainableWeights);
    r2("Total params: " + (c2 + p2)), r2("Trainable params: " + c2), r2("Non-trainable params: " + p2), r2("_".repeat(t3));
  }
  function countTrainableParams(e2) {
    return null != e2.collectedTrainableWeights ? countParamsInWeights(e2.collectedTrainableWeights) : countParamsInWeights(e2.trainableWeights);
  }
  function isModelSequentialLike(e2) {
    var t3 = true, n2 = [], r2 = [];
    for (var i2 in e2.nodesByDepth)
      n2.push(e2.nodesByDepth[i2]);
    for (var a2 = 0, o2 = n2; a2 < o2.length; a2++) {
      var s2 = o2[a2];
      if (s2.length > 1 || 1 === s2.length && s2[0].inboundLayers.length > 1) {
        t3 = false;
        break;
      }
      r2.push.apply(r2, s2);
    }
    if (t3)
      for (var l3 = 0, u2 = e2.layers; l3 < u2.length; l3++) {
        for (var c2 = false, p2 = 0, h = u2[l3].inboundNodes; p2 < h.length; p2++) {
          var d2 = h[p2];
          if (-1 !== r2.indexOf(d2)) {
            if (c2) {
              t3 = false;
              break;
            }
            c2 = true;
          }
        }
        if (!t3)
          break;
      }
    return t3;
  }
  function printRow(e2, t3, n2) {
    void 0 === n2 && (n2 = console.log);
    for (var r2 = "", i2 = 0; i2 < e2.length; ++i2)
      i2 > 0 && (r2 = r2.slice(0, r2.length - 1) + " "), r2 = (r2 += e2[i2]).slice(0, t3[i2]), r2 += " ".repeat(t3[i2] - r2.length);
    n2(r2);
  }
  function printLayerSummary(e2, t3, n2) {
    var r2;
    try {
      r2 = JSON.stringify(e2.outputShape);
    } catch (e3) {
      r2 = "multiple";
    }
    printRow([e2.name + " (" + e2.getClassName() + ")", r2, e2.countParams().toString()], t3, n2);
  }
  function printLayerSummaryWithConnections(e2, t3, n2, r2) {
    var i2;
    try {
      i2 = JSON.stringify(e2.outputShape);
    } catch (e3) {
      i2 = "multiple";
    }
    for (var a2 = [], o2 = 0, s2 = e2.inboundNodes; o2 < s2.length; o2++) {
      var l3 = s2[o2];
      if (!(null != n2 && n2.length > 0 && -1 === n2.indexOf(l3)))
        for (var u2 = 0; u2 < l3.inboundLayers.length; ++u2) {
          var c2 = l3.inboundLayers[u2].name, p2 = l3.nodeIndices[u2], h = l3.tensorIndices[u2];
          a2.push(c2 + "[" + p2 + "][" + h + "]");
        }
    }
    var d2 = e2.name, f2 = e2.getClassName(), g2 = 0 === a2.length ? "" : a2[0];
    printRow([d2 + " (" + f2 + ")", i2, e2.countParams().toString(), g2], t3, r2);
    for (u2 = 1; u2 < a2.length; ++u2)
      printRow(["", "", "", a2[u2]], t3, r2);
  }
  function isArrayItemInputOrOutputName(e2, t3, n2) {
    return ("inboundNodes" === e2 || "outputLayers" === e2 || "inputLayers" === e2) && 0 === t3 && "string" == typeof n2;
  }
  function convertPythonicToTs(e2, t3) {
    if (null === e2)
      return null;
    if ("string" == typeof e2)
      return toCamelCase(e2);
    if ("number" == typeof e2 || "boolean" == typeof e2)
      return e2;
    if (e2 instanceof Array) {
      for (var n2 = [], r2 = e2.length, i2 = 0; i2 < r2; ++i2) {
        var a2 = e2[i2];
        isArrayItemInputOrOutputName(t3, i2, a2) ? n2.push(a2) : n2.push(convertPythonicToTs(a2, t3));
      }
      return n2;
    }
    for (var o2 = {}, s2 = 0, l3 = Object.keys(e2); s2 < l3.length; s2++) {
      var u2 = l3[s2], c2 = e2[u2];
      if ("name" === u2 && "string" == typeof c2)
        o2[u2] = c2;
      else {
        var p2 = toCamelCase(u2);
        o2[p2] = convertPythonicToTs(c2, p2);
      }
    }
    return o2;
  }
  function convertTsToPythonic(e2, t3) {
    if (null === e2 || void 0 === e2)
      return null;
    if ("string" == typeof e2)
      return toSnakeCase(e2);
    if ("number" == typeof e2 || "boolean" == typeof e2)
      return e2;
    if (e2 instanceof Array) {
      for (var n2 = [], r2 = e2.length, i2 = 0; i2 < r2; ++i2) {
        var a2 = e2[i2];
        isArrayItemInputOrOutputName(t3, i2, a2) ? n2.push(a2) : n2.push(convertTsToPythonic(a2, t3));
      }
      return n2;
    }
    for (var o2 = {}, s2 = 0, l3 = Object.keys(e2); s2 < l3.length; s2++) {
      var u2 = l3[s2], c2 = e2[u2], p2 = toSnakeCase(u2);
      o2[p2] = "name" !== u2 && "className" !== u2 || "string" != typeof c2 ? convertTsToPythonic(c2, u2) : c2;
    }
    return o2;
  }
  var version = "1.3.1";
  function assertFeedCompatibility(e2, t3) {
    if (null == e2.dtype || e2.dtype === t3.dtype)
      return t3;
    try {
      return lr(t3, e2.dtype);
    } catch (n2) {
      throw new ValueError("The dtype of the feed (" + t3.dtype + ") can not be cast to the dtype of the key '" + e2.name + "' (" + e2.dtype + ").");
    }
  }
  var FeedDict = function() {
    function e2(t3) {
      if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, t3 instanceof e2)
        for (var n2 in t3.id2Value)
          this.id2Value[n2] = t3.id2Value[n2], n2 in t3.id2Mask && (this.id2Mask[n2] = t3.id2Mask[n2]);
      else {
        if (null == t3)
          return;
        for (var r2 = 0, i2 = t3; r2 < i2.length; r2++) {
          var a2 = i2[r2];
          this.add(a2.key, a2.value);
        }
      }
    }
    return e2.prototype.add = function(e3, t3, n2) {
      if (null != this.id2Value[e3.id])
        throw new ValueError("Duplicate key: name=" + e3.name + ", id=" + e3.id);
      return this.id2Value[e3.id] = assertFeedCompatibility(e3, t3), this.name2Id[e3.name] = e3.id, null != n2 && (this.id2Mask[e3.id] = n2), this;
    }, e2.prototype.addFeed = function(e3) {
      this.add(e3.key, e3.value);
    }, e2.prototype.hasKey = function(e3) {
      return null != this.id2Value[e3.id];
    }, e2.prototype.names = function() {
      return Object.keys(this.name2Id);
    }, e2.prototype.getValue = function(e3) {
      if (e3 instanceof SymbolicTensor) {
        if (null == this.id2Value[e3.id])
          throw new ValueError("Nonexistent key: " + e3.name);
        return this.id2Value[e3.id];
      }
      var t3 = this.name2Id[e3];
      if (null == t3)
        throw new ValueError("Feed dict has no SymbolicTensor name: " + e3);
      return this.id2Value[t3];
    }, e2.prototype.getMask = function(e3) {
      if (e3 instanceof SymbolicTensor) {
        if (null == this.id2Value[e3.id])
          throw new ValueError("Nonexistent key: " + e3.name);
        return this.id2Mask[e3.id];
      }
      var t3 = this.name2Id[e3];
      if (null == t3)
        throw new ValueError("Feed dict has no SymbolicTensor name: " + e3);
      return this.id2Mask[t3];
    }, e2.prototype.disposeMasks = function() {
      null != this.id2Mask && Xe(this.id2Mask);
    }, e2;
  }();
  var cachedSorted = {};
  var cachedRecipientCounts = {};
  function execute(e2, t3, n2, r2) {
    for (var i2 = null != n2 && n2.training, a2 = Array.isArray(e2), o2 = a2 ? e2 : [e2], s2 = o2.map(function(e3) {
      return e3.name;
    }), l3 = [], u2 = t3.names(), c2 = 0, p2 = s2; c2 < p2.length; c2++) {
      var h = p2[c2];
      -1 !== u2.indexOf(h) ? l3.push(t3.getValue(h)) : l3.push(null);
    }
    null != r2 && (r2.maxNumTensors = -1 / 0, r2.minNumTensors = 1 / 0);
    var d2, f2, g2 = s2.join(",") + "|" + t3.names().join(",");
    if (null == cachedSorted[g2]) {
      var m2 = getTopologicalSortAndRecipientCounts(o2, t3);
      d2 = m2.sorted, f2 = m2.recipientCounts, cachedSorted[g2] = d2, cachedRecipientCounts[g2] = f2;
    }
    d2 = cachedSorted[g2], f2 = {}, i2 || Object.assign(f2, cachedRecipientCounts[g2]);
    for (var y2 = new FeedDict(t3), v2 = 0; v2 < d2.length; ++v2) {
      if (null != r2) {
        var b2 = qe().numTensors;
        b2 > r2.maxNumTensors && (r2.maxNumTensors = b2), b2 < r2.minNumTensors && (r2.minNumTensors = b2);
      }
      var w2 = d2[v2], z3 = w2.sourceLayer;
      if (!(z3 instanceof InputLayer)) {
        for (var S3 = [], A2 = [], _3 = [], I3 = false, C3 = 0, E3 = w2.inputs; C3 < E3.length; C3++) {
          var N3 = E3[C3], k4 = y2.getValue(N3), x2 = y2.getMask(N3);
          S3.push(k4), A2.push(x2), null != x2 && (I3 = true), i2 || (f2[N3.name]--, 0 !== f2[N3.name] || t3.hasKey(N3) || -1 !== s2.indexOf(N3.name) || k4.isDisposed || true === N3.sourceLayer.stateful || _3.push(k4));
        }
        I3 && ((n2 = n2 || {}).mask = A2[0]);
        var L3 = toList(z3.apply(S3, n2)), T2 = null;
        z3.supportsMasking && (T2 = z3.computeMask(S3, A2));
        for (var D3 = getNodeOutputs(w2), O3 = Array.isArray(D3) ? D3 : [D3], R3 = 0; R3 < O3.length; ++R3) {
          y2.hasKey(O3[R3]) || y2.add(O3[R3], L3[R3], Array.isArray(T2) ? T2[0] : T2);
          var M2 = s2.indexOf(O3[R3].name);
          -1 !== M2 && (l3[M2] = L3[R3]);
        }
        i2 || Xe(_3);
      }
    }
    return y2.disposeMasks(), a2 ? l3 : l3[0];
  }
  function getTopologicalSortAndRecipientCounts(e2, t3) {
    tt.assert(null != e2 && e2.length > 0, function() {
      return "Expected at least one fetch, got none";
    });
    var n2 = [], r2 = {};
    if (1 === e2.length) {
      var i2 = getTopologicalSortAndRecipientCountsForOneFetch(e2[0], t3);
      n2 = i2.sorted, r2 = i2.recipientMap;
    } else
      for (var a2 = /* @__PURE__ */ new Set(), o2 = 0, s2 = e2; o2 < s2.length; o2++) {
        for (var l3 = getTopologicalSortAndRecipientCountsForOneFetch(s2[o2], t3), u2 = l3.sorted, c2 = l3.recipientMap, p2 = 0, h = u2; p2 < h.length; p2++) {
          var d2 = h[p2];
          a2.has(d2.name) || (n2.push(d2), a2.add(d2.name));
        }
        var f2 = function(e3) {
          null == r2[e3] && (r2[e3] = /* @__PURE__ */ new Set()), c2[e3].forEach(function(t4) {
            return r2[e3].add(t4);
          });
        };
        for (var g2 in c2)
          f2(g2);
      }
    return { sorted: n2, recipientCounts: recipientMap2Counts(r2) };
  }
  function recipientMap2Counts(e2) {
    var t3 = {};
    for (var n2 in e2)
      t3[n2] = e2[n2].size;
    return t3;
  }
  function getTopologicalSortAndRecipientCountsForOneFetch(e2, t3) {
    for (var n2 = /* @__PURE__ */ new Set(), r2 = [], i2 = {}, a2 = 0, o2 = t3.names(); a2 < o2.length; a2++) {
      var s2 = o2[a2];
      n2.add(s2);
    }
    var l3 = [], u2 = [];
    for (l3.push(e2); l3.length > 0; ) {
      var c2 = l3[l3.length - 1];
      if (n2.has(c2.name))
        l3.pop();
      else {
        var p2 = u2[u2.length - 1] === l3.length - 1;
        if (0 === c2.inputs.length || p2)
          l3.pop(), r2.push(c2), n2.add(c2.name), p2 && u2.pop();
        else {
          u2.push(l3.length - 1);
          for (var h = 0, d2 = c2.inputs; h < d2.length; h++) {
            var f2 = d2[h];
            null == i2[f2.name] && (i2[f2.name] = /* @__PURE__ */ new Set()), i2[f2.name].add(c2.name), n2.has(f2.name) || l3.push(f2);
          }
        }
      }
    }
    return { sorted: r2, recipientMap: i2 };
  }
  function getNodeOutputs(e2) {
    var t3;
    if (1 === e2.sourceLayer.inboundNodes.length)
      t3 = e2.sourceLayer.output;
    else {
      for (var n2 = null, r2 = 0; r2 < e2.sourceLayer.inboundNodes.length; ++r2)
        for (var i2 = 0, a2 = e2.sourceLayer.inboundNodes[r2].outputTensors; i2 < a2.length; i2++) {
          if (a2[i2].id === e2.id) {
            n2 = r2;
            break;
          }
        }
      t3 = e2.sourceLayer.getOutputAt(n2);
    }
    return t3;
  }
  var Container = function(e2) {
    function t3(n2) {
      var r2 = e2.call(this, {}) || this;
      if (r2.containerNodes = /* @__PURE__ */ new Set(), r2.name = n2.name, null == r2.name) {
        var i2 = r2.getClassName().toLowerCase();
        r2.name = getUid(i2);
      }
      if (r2.supportsMasking = false, r2.trainable_ = true, Array.isArray(n2.inputs) ? r2.inputs = n2.inputs.slice() : r2.inputs = [n2.inputs], Array.isArray(n2.outputs) ? r2.outputs = n2.outputs.slice() : r2.outputs = [n2.outputs], unique(r2.inputs).length !== r2.inputs.length)
        throw new ValueError("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " + r2.inputs.map(function(e3) {
          return e3.name;
        }));
      unique(r2.outputs).length !== r2.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " + r2.outputs.map(function(e3) {
        return e3.name;
      })), r2.inputLayers = [], r2.inputLayersNodeIndices = [], r2.inputLayersTensorIndices = [], r2.outputLayers = [], r2.outputLayersNodeIndices = [], r2.outputLayersTensorIndices = [], r2.layers = [], r2.internalContainerRefs = [];
      for (var a2 = 0, o2 = r2.outputs; a2 < o2.length; a2++) {
        var s2 = (C3 = o2[a2]).sourceLayer, l3 = C3.nodeIndex, u2 = C3.tensorIndex;
        r2.outputLayers.push(s2), r2.outputLayersNodeIndices.push(l3), r2.outputLayersTensorIndices.push(u2);
      }
      for (var c2 = 0, p2 = r2.inputs; c2 < p2.length; c2++) {
        s2 = (C3 = p2[c2]).sourceLayer, l3 = C3.nodeIndex, u2 = C3.tensorIndex;
        assert(0 === l3, "input layer has >1 nodes"), assert(0 === u2, "input layer has >1 tensors"), r2.inputLayers.push(s2), r2.inputLayersNodeIndices.push(l3), r2.inputLayersTensorIndices.push(u2);
      }
      r2.inputNames = [], r2.outputNames = [], r2.feedInputShapes = [], r2.feedInputNames = [], r2.feedOutputNames = [];
      for (var h = 0; h < r2.inputLayers.length; h++) {
        if (!((s2 = r2.inputLayers[h]) instanceof InputLayer))
          throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: " + n2.inputs + ". Input " + h + " (0-based) originates from layer type " + s2.getClassName() + ".");
        r2.inputNames.push(s2.name), r2.feedInputShapes.push(s2.batchInputShape), r2.feedInputNames.push(s2.name);
      }
      for (var d2 = 0, f2 = r2.outputLayers; d2 < f2.length; d2++) {
        s2 = f2[d2];
        r2.outputNames.push(s2.name);
      }
      r2.internalInputShapes = r2.inputs.map(function(e3) {
        return e3.shape;
      }), r2.internalOutputShapes = r2.outputs.map(function(e3) {
        return e3.shape;
      });
      for (var g2 = {}, m2 = {}, y2 = {}, v2 = {}, b2 = {}, w2 = [], z3 = function(e3, n3, i3, a3, o3, s3) {
        null != a3 && null != o3 && null != s3 || (a3 = e3.sourceLayer, o3 = e3.nodeIndex, s3 = e3.tensorIndex);
        var l4 = a3.inboundNodes[o3];
        if (-1 !== i3.indexOf(l4))
          throw new RuntimeError("The tensor " + e3.name + ' at layer "' + a3.name + '" is part of a cycle.');
        if (-1 === n3.indexOf(l4)) {
          r2.containerNodes.add(t3.nodeKey(a3, o3)), a3.id in b2 || (b2[a3.id] = Object.keys(b2).length), -1 === i3.indexOf(l4) && i3.push(l4);
          for (var u3 = l4.inboundLayers.length, c3 = 0; c3 < u3; c3++) {
            var p3 = l4.inputTensors[c3], h2 = l4.inboundLayers[c3], d3 = l4.nodeIndices[c3], f3 = l4.tensorIndices[c3];
            z3(p3, n3, i3, h2, d3, f3);
          }
          for (n3.push(l4); i3.indexOf(l4) >= 0; )
            i3.splice(i3.indexOf(l4), 1);
          w2.push(l4);
        }
      }, S3 = [], A2 = [], _3 = 0, I3 = r2.outputs; _3 < I3.length; _3++) {
        var C3 = I3[_3];
        z3(C3, S3, A2);
      }
      for (var E3 = 0, N3 = w2.slice().reverse(); E3 < N3.length; E3++) {
        m2[(K3 = N3[E3]).id] = K3, K3.id in g2 || (g2[K3.id] = 0);
        var k4 = g2[K3.id], x2 = null == y2[K3.outboundLayer.id] ? 0 : y2[K3.outboundLayer.id];
        k4 = Math.max(k4, x2), y2[K3.outboundLayer.id] = k4, v2[K3.outboundLayer.id] = K3.outboundLayer, g2[K3.id] = k4;
        for (h = 0; h < K3.inboundLayers.length; h++) {
          var L3 = K3.inboundLayers[h], T2 = (l3 = K3.nodeIndices[h], L3.inboundNodes[l3]), D3 = null == g2[T2.id] ? 0 : g2[T2.id];
          g2[T2.id] = Math.max(k4 + 1, D3), m2[T2.id] = T2;
        }
      }
      var O3 = {};
      for (var R3 in g2) {
        (k4 = g2[R3]) in O3 || (O3[k4] = []), O3[k4].push(m2[R3]);
      }
      var M2 = {};
      for (var P3 in y2) {
        (k4 = y2[P3]) in M2 || (M2[k4] = []), M2[k4].push(v2[P3]);
      }
      var F3 = Object.keys(M2).map(function(e3) {
        return parseInt(e3, 10);
      }).sort(reverseNumberCompare);
      r2.layers = [];
      for (var V3 = 0, B3 = F3; V3 < B3.length; V3++) {
        var U3 = M2[k4 = B3[V3]];
        U3.sort(function(e3, t4) {
          var n3 = b2[e3.id], r3 = b2[t4.id];
          return n3 < r3 ? -1 : n3 > r3 ? 1 : 0;
        });
        for (var j3 = 0, W3 = U3; j3 < W3.length; j3++) {
          (s2 = W3[j3]) instanceof t3 && r2.internalContainerRefs.push(s2), r2.layers.push(s2);
        }
      }
      r2.layersByDepth = M2, F3 = Object.keys(O3).map(function(e3) {
        return parseInt(e3, 10);
      }).sort(reverseNumberCompare);
      for (var $3 = r2.inputs.slice(), q3 = [], G3 = 0, H3 = F3; G3 < H3.length; G3++)
        for (var J3 = 0, Z3 = O3[k4 = H3[G3]]; J3 < Z3.length; J3++) {
          var K3;
          if (null != (s2 = (K3 = Z3[J3]).outboundLayer)) {
            for (var Y3 = 0, X3 = K3.inputTensors; Y3 < X3.length; Y3++) {
              C3 = X3[Y3];
              if (-1 === $3.indexOf(C3))
                throw new RuntimeError("Graph disconnected: cannot obtain value for tensor " + C3 + ' at layer "' + s2.name + '". The following previous layers were accessed without issue: ' + q3);
            }
            for (var Q3 = 0, ee2 = K3.outputTensors; Q3 < ee2.length; Q3++) {
              C3 = ee2[Q3];
              $3.push(C3);
            }
            q3.push(s2.name);
          }
        }
      r2.nodesByDepth = O3;
      for (var te2 = r2.layers.map(function(e3) {
        return e3.name;
      }), ne2 = function(e3) {
        var t4 = te2.filter(function(t5) {
          return t5 === e3;
        }).length;
        if (1 !== t4)
          throw new RuntimeError('The name "' + e3 + '" is used ' + t4 + " times in the model. All layer names should be unique. Layer names: " + JSON.stringify(te2));
      }, re2 = 0, ie2 = te2; re2 < ie2.length; re2++) {
        ne2(ie2[re2]);
      }
      return r2.outboundNodes = [], r2.inboundNodes = [], new Node({ outboundLayer: r2, inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: r2.inputs, outputTensors: r2.outputs, inputMasks: r2.inputs.map(function(e3) {
        return null;
      }), outputMasks: r2.outputs.map(function(e3) {
        return null;
      }), inputShapes: r2.inputs.map(function(e3) {
        return e3.shape;
      }), outputShapes: r2.outputs.map(function(e3) {
        return e3.shape;
      }) }), r2.built = true, r2._refCount = 1, r2;
    }
    return __extends(t3, e2), t3.prototype.assertNotDisposed = function() {
      if (0 === this._refCount)
        throw new Error("Container '" + this.name + "' is already disposed.");
    }, t3.prototype.dispose = function() {
      this.assertNotDisposed();
      var e3 = { refCountAfterDispose: null, numDisposedVariables: 0 };
      if (0 == --this._refCount) {
        for (var t4 = 0, n2 = this.layers; t4 < n2.length; t4++) {
          var r2 = n2[t4];
          e3.numDisposedVariables += r2.dispose().numDisposedVariables;
        }
        for (var i2 = 0, a2 = this.internalContainerRefs; i2 < a2.length; i2++) {
          var o2 = a2[i2];
          e3.numDisposedVariables += o2.dispose().numDisposedVariables;
        }
      }
      return e3.refCountAfterDispose = this._refCount, e3;
    }, Object.defineProperty(t3.prototype, "trainable", { get: function() {
      return this.trainable_;
    }, set: function(e3) {
      this.layers.forEach(function(t4) {
        t4._trainableWeights.forEach(function(t5) {
          return t5.trainable = e3;
        });
      }), this.trainable_ = e3;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "trainableWeights", { get: function() {
      if (this._trainableWeights.length > 0)
        throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
      if (!this.trainable)
        return [];
      for (var e3 = [], t4 = 0, n2 = this.layers; t4 < n2.length; t4++) {
        var r2 = n2[t4];
        e3 = e3.concat(r2.trainableWeights);
      }
      return e3;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "nonTrainableWeights", { get: function() {
      for (var e3 = [], t4 = 0, n2 = this.layers; t4 < n2.length; t4++) {
        var r2 = n2[t4];
        e3.push.apply(e3, r2.nonTrainableWeights);
      }
      if (!this.trainable) {
        for (var i2 = [], a2 = 0, o2 = this.layers; a2 < o2.length; a2++) {
          r2 = o2[a2];
          i2.push.apply(i2, r2.trainableWeights);
        }
        return i2.concat(e3);
      }
      return e3;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "weights", { get: function() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }, enumerable: true, configurable: true }), t3.prototype.loadWeights = function(e3, t4) {
      void 0 === t4 && (t4 = true);
      for (var n2 = {}, r2 = 0, i2 = 0, a2 = this.layers; i2 < a2.length; i2++)
        for (var o2 = 0, s2 = a2[i2].weights; o2 < s2.length; o2++) {
          var l3 = s2[o2];
          if (null != n2[l3.originalName])
            throw new ValueError("Duplicate weight name: " + l3.originalName);
          n2[l3.originalName] = l3, r2++;
        }
      var u2 = [];
      for (var c2 in e3) {
        if (null != n2[c2])
          u2.push([n2[c2], e3[c2]]);
        else if (t4)
          throw new ValueError("Provided weight data has no target variable: " + c2);
        delete n2[c2];
      }
      if (t4) {
        var p2 = [];
        for (var h in n2)
          p2.push(h);
        if (p2.length > 0)
          throw new ValueError(p2.length + " of " + r2 + " weights are not set: " + p2);
      }
      batchSetValue(u2);
    }, t3.prototype.updatedConfig = function() {
      var e3 = this.getConfig(), t4 = {};
      return t4.className = this.getClassName(), t4.config = e3, t4.kerasVersion = "tfjs-layers " + version, t4.backend = "TensorFlow.js", t4;
    }, t3.prototype.toJSON = function(e3, t4) {
      void 0 === t4 && (t4 = true);
      var n2 = convertTsToPythonic(this.updatedConfig());
      return t4 ? JSON.stringify(n2) : n2;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        e3 = toList(e3);
        for (var r2 = new FeedDict(), i2 = 0; i2 < n2.inputs.length; ++i2)
          r2.add(n2.inputs[i2], e3[i2]);
        return execute(n2.outputs, r2, t4);
      });
    }, t3.prototype.computeMask = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var r2;
        return e3 = toList(e3), r2 = null == t4 ? pyListRepeat(null, e3.length) : toList(t4), n2.runInternalGraph(e3, r2)[1];
      });
    }, t3.prototype.computeOutputShape = function(e3) {
      var t4 = normalizeShapeList(e3);
      if (t4.length !== this.inputLayers.length)
        throw new ValueError("Invalid inputShape argument " + e3 + ": model has " + this.inputLayers.length + " tensor inputs.");
      for (var n2 = {}, r2 = 0; r2 < t4.length; r2++) {
        var i2 = this.inputLayers[r2], a2 = t4[r2];
        n2[A2 = i2.name + "_0_0"] = a2;
      }
      var o2 = Object.keys(this.nodesByDepth).map(function(e4) {
        return parseInt(e4, 10);
      }).sort(reverseNumberCompare);
      if (o2.length > 1)
        for (var s2 = 0, l3 = o2; s2 < l3.length; s2++)
          for (var u2 = l3[s2], c2 = 0, p2 = this.nodesByDepth[u2]; c2 < p2.length; c2++) {
            var h = p2[c2];
            i2 = h.outboundLayer;
            if (-1 === this.inputLayers.map(function(e4) {
              return e4.id;
            }).indexOf(i2.id)) {
              for (var d2 = [], f2 = 0; f2 < h.inboundLayers.length; f2++) {
                var g2 = h.inboundLayers[f2], m2 = h.nodeIndices[f2], y2 = h.tensorIndices[f2], v2 = n2[A2 = g2.name + "_" + m2 + "_" + y2];
                d2.push(v2);
              }
              var b2 = normalizeShapeList(i2.computeOutputShape(singletonOrArray(d2))), w2 = i2.inboundNodes.indexOf(h);
              for (f2 = 0; f2 < b2.length; f2++) {
                n2[A2 = i2.name + "_" + w2 + "_" + f2] = b2[f2];
              }
            }
          }
      var z3 = [], S3 = [];
      for (r2 = 0; r2 < this.outputLayers.length; r2++) {
        i2 = this.outputLayers[r2], w2 = this.outputLayersNodeIndices[r2], y2 = this.outputLayersTensorIndices[r2];
        var A2 = i2.name + "_" + w2 + "_" + y2;
        S3.push(A2);
      }
      for (r2 = 0; r2 < S3.length; r2++) {
        var _3 = S3[r2];
        assert(_3 in n2), z3.push(n2[_3]);
      }
      return singletonOrArray(z3);
    }, t3.prototype.runInternalGraph = function(e3, t4) {
      null == t4 && (t4 = pyListRepeat(null, e3.length));
      for (var n2 = {}, r2 = 0; r2 < this.inputs.length; ++r2) {
        var i2 = this.inputs[r2], a2 = e3[r2], o2 = t4[r2];
        n2[i2.id] = [a2, o2];
      }
      for (var s2 = 0, l3 = Object.keys(this.nodesByDepth).map(function(e4) {
        return parseInt(e4, 10);
      }).sort(reverseNumberCompare); s2 < l3.length; s2++)
        for (var u2 = l3[s2], c2 = 0, p2 = this.nodesByDepth[u2]; c2 < p2.length; c2++) {
          for (var h = p2[c2], d2 = h.outboundLayer, f2 = h.inputTensors, g2 = h.outputTensors, m2 = new Array(), y2 = 0, v2 = f2; y2 < v2.length; y2++) {
            (i2 = v2[y2]).id in n2 && m2.push(n2[i2.id]);
          }
          if (m2.length === f2.length) {
            var b2 = {}, w2 = void 0, z3 = void 0, S3 = void 0, A2 = void 0;
            if (null != h.callArgs && (b2 = h.callArgs), 1 === m2.length) {
              var _3 = m2[0], I3 = _3[0], C3 = _3[1];
              null == b2.mask && (b2.mask = C3), S3 = toList(d2.call(I3, b2)), A2 = toList(d2.computeMask(I3, C3)), w2 = [I3], z3 = [C3];
            } else
              w2 = m2.map(function(e4) {
                return e4[0];
              }), z3 = m2.map(function(e4) {
                return e4[1];
              }), null == b2.mask && (b2.mask = z3), S3 = toList(d2.call(w2, b2)), A2 = toList(d2.computeMask(w2, z3));
            if (d2.activityRegularizer)
              throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
            for (r2 = 0; r2 < g2.length; ++r2) {
              i2 = g2[r2], a2 = S3[r2], o2 = A2[r2];
              n2[i2.id] = [a2, o2];
            }
          }
        }
      for (var E3 = [], N3 = [], k4 = [], x2 = 0, L3 = this.outputs; x2 < L3.length; x2++) {
        assert((i2 = L3[x2]).id in n2, "Could not compute output " + i2.name + " : " + i2.id);
        var T2 = n2[i2.id], D3 = T2[0];
        o2 = T2[1];
        k4.push(D3.shape), E3.push(D3), N3.push(o2);
      }
      return [E3, N3, k4];
    }, t3.prototype.buildNodeConversionMap = function(e3) {
      for (var n2, r2 = {}, i2 = 0, a2 = this.layers; i2 < a2.length; i2++) {
        var o2 = a2[i2];
        n2 = o2 instanceof t3 ? 1 : 0;
        for (var s2 = 0; s2 < o2.inboundNodes.length; s2++) {
          var l3 = t3.nodeKey(o2, s2);
          this.containerNodes.has(l3) && (r2[l3] = n2, n2 += 1);
        }
      }
      return r2;
    }, t3.prototype.getLayer = function(e3, t4) {
      if (null != t4) {
        if (this.layers.length <= t4)
          throw new ValueError("Was asked to retrieve layer at index " + t4 + ", but model only has " + this.layers.length + " layer(s).");
        return this.layers[t4];
      }
      if (null == e3)
        throw new ValueError("Provide either a layer name or layer index");
      for (var n2 = 0, r2 = this.layers; n2 < r2.length; n2++) {
        var i2 = r2[n2];
        if (i2.name === e3)
          return i2;
      }
      throw new ValueError("No such layer: " + e3);
    }, t3.prototype.calculateLosses = function() {
      var e3 = this;
      return je(function() {
        for (var n2 = [], r2 = 0, i2 = e3.layers; r2 < i2.length; r2++)
          for (var a2 = i2[r2], o2 = 0; o2 < a2.inboundNodes.length; ++o2) {
            var s2 = t3.nodeKey(a2, o2);
            e3.containerNodes.has(s2) && n2.push.apply(n2, a2.calculateLosses());
          }
        return n2;
      });
    }, t3.prototype.getConfig = function() {
      for (var e3 = { name: this.name }, n2 = this.buildNodeConversionMap(this.layers), r2 = [], i2 = 0, a2 = this.layers; i2 < a2.length; i2++) {
        for (var o2 = (w2 = a2[i2]).getClassName(), s2 = w2.getConfig(), l3 = [], u2 = 0; u2 < w2.inboundNodes.length; u2++) {
          var c2 = w2.inboundNodes[u2], p2 = t3.nodeKey(w2, u2), h = {};
          if (this.containerNodes.has(p2)) {
            if (c2.callArgs)
              try {
                JSON.stringify(c2.callArgs), h = c2.callArgs;
              } catch (e4) {
                console.warn("Layer " + w2.name + " was passed non-serializable keyword arguments: " + c2.callArgs + ". They will not be included in the serialized model (and thus will be missing at deserialization time)."), h = {};
              }
            if (c2.inboundLayers.length > 0) {
              for (var d2 = [], f2 = 0; f2 < c2.inboundLayers.length; f2++) {
                var g2 = c2.inboundLayers[f2], m2 = c2.nodeIndices[f2], y2 = c2.tensorIndices[f2];
                null == (S3 = n2[t3.nodeKey(g2, m2)]) && (S3 = 0), d2.push([g2.name, S3, y2, h]);
              }
              l3.push(d2);
            }
          }
        }
        var v2 = {};
        v2.name = w2.name, v2.className = o2, v2.config = s2, v2.inboundNodes = l3, r2.push(v2);
      }
      e3.layers = r2;
      var b2 = [];
      for (f2 = 0; f2 < this.inputLayers.length; f2++) {
        var w2 = this.inputLayers[f2];
        m2 = this.inputLayersNodeIndices[f2], p2 = t3.nodeKey(w2, m2);
        if (this.containerNodes.has(p2)) {
          null !== (S3 = n2[p2]) && void 0 !== S3 || (S3 = 0);
          y2 = this.inputLayersTensorIndices[f2];
          b2.push([w2.name, S3, y2]);
        }
      }
      e3.inputLayers = b2;
      var z3 = [];
      for (f2 = 0; f2 < this.outputLayers.length; f2++) {
        w2 = this.outputLayers[f2], m2 = this.outputLayersNodeIndices[f2], p2 = t3.nodeKey(w2, m2);
        if (this.containerNodes.has(p2)) {
          var S3;
          null !== (S3 = n2[p2]) && void 0 !== S3 || (S3 = 0);
          y2 = this.outputLayersTensorIndices[f2];
          z3.push([w2.name, S3, y2]);
        }
      }
      return e3.outputLayers = z3, e3;
    }, t3.fromConfig = function(e3, t4, n2, r2) {
      void 0 === n2 && (n2 = {}), void 0 === r2 && (r2 = false);
      var i2 = {}, a2 = {};
      function o2(e4, t5) {
        e4.name in a2 ? a2[e4.name].push(t5) : a2[e4.name] = [t5];
      }
      function s2(e4, t5) {
        for (var n3, r3 = [], a3 = 0, s3 = t5; a3 < s3.length; a3++) {
          var l4 = s3[a3], u3 = l4[0], c3 = l4[1], p3 = l4[2];
          if (n3 = null == l4[3] ? {} : l4[3], !(u3 in i2))
            return void o2(e4, t5);
          var h2 = i2[u3];
          if (h2.inboundNodes.length <= c3)
            return void o2(e4, t5);
          var d3 = h2.inboundNodes[c3];
          r3.push(d3.outputTensors[p3]);
        }
        r3.length > 0 && e4.apply(singletonOrArray(r3), n3);
      }
      function l3(e4) {
        var n3 = e4.name, a3 = deserialize(e4, null != t4.customObjects ? t4.customObjects : {});
        a3.setFastWeightInitDuringBuild(r2), i2[n3] = a3, e4.inboundNodes.forEach(function(e5) {
          if (!(e5 instanceof Array))
            throw new ValueError("Corrupted configuration, expected array for nodeData: " + e5);
          o2(a3, e5);
        });
      }
      for (var u2 = t4.name, c2 = t4.layers, p2 = 0, h = c2; p2 < h.length; p2++) {
        l3(g2 = h[p2]);
      }
      for (; !isObjectEmpty(a2); )
        for (var d2 = 0, f2 = c2; d2 < f2.length; d2++) {
          var g2 = f2[d2];
          if ((k4 = i2[g2.name]).name in a2) {
            var m2 = a2[k4.name];
            delete a2[k4.name];
            for (var y2 = 0, v2 = m2; y2 < v2.length; y2++) {
              s2(k4, v2[y2]);
            }
          }
        }
      for (var b2 = [], w2 = [], z3 = 0, S3 = t4.inputLayers; z3 < S3.length; z3++) {
        var A2 = (g2 = S3[z3])[0], _3 = g2[1], I3 = g2[2];
        assert(A2 in i2);
        var C3 = (k4 = i2[A2]).inboundNodes[_3].outputTensors;
        b2.push(C3[I3]);
      }
      for (var E3 = 0, N3 = t4.outputLayers; E3 < N3.length; E3++) {
        A2 = (g2 = N3[E3])[0], _3 = g2[1], I3 = g2[2];
        assert(A2 in i2);
        var k4;
        C3 = (k4 = i2[A2]).inboundNodes[_3].outputTensors;
        w2.push(C3[I3]);
      }
      return new e3({ inputs: b2, outputs: w2, name: u2 });
    }, Object.defineProperty(t3.prototype, "stateful", { get: function() {
      if (this._stateful)
        throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
      for (var e3 = 0, t4 = this.layers; e3 < t4.length; e3++) {
        if (t4[e3].stateful)
          return true;
      }
      return false;
    }, enumerable: true, configurable: true }), t3.prototype.resetStates = function() {
      var e3 = this;
      je(function() {
        e3.layers.forEach(function(e4) {
          e4.stateful && e4.resetStates();
        });
      });
    }, t3;
  }(Layer);
  function standardizeSampleOrClassWeights(e2, t3, n2) {
    var r2 = t3.length;
    if (null == e2 || Array.isArray(e2) && 0 === e2.length)
      return t3.map(function(e3) {
        return null;
      });
    if (1 === r2)
      return Array.isArray(e2) && 1 === e2.length ? e2 : "object" == typeof e2 && t3[0] in e2 ? [e2[t3[0]]] : [e2];
    if (Array.isArray(e2)) {
      if (e2.length !== r2)
        throw new Error("Provided " + n2 + " is an array of " + e2.length + " element(s), but the model has " + r2 + " outputs. Make sure a set of weights is provided for each model output.");
      return e2;
    }
    if ("object" == typeof e2 && Object.keys(e2).length > 0 && "object" == typeof e2[Object.keys(e2)[0]]) {
      var i2 = [];
      return t3.forEach(function(t4) {
        t4 in e2 ? i2.push(e2[t4]) : i2.push(null);
      }), i2;
    }
    throw new Error("The model has multiple (" + r2 + ") outputs, so " + n2 + " must be either an array with " + r2 + " elements or an object with " + t3 + " keys. Provided " + n2 + " not understood: " + JSON.stringify(e2));
  }
  function standardizeClassWeights(e2, t3) {
    return standardizeSampleOrClassWeights(e2, t3, "classWeight");
  }
  function standardizeWeights(e2, t3, n2, r2) {
    return __awaiter(this, void 0, void 0, function() {
      var i2, a2, o2, s2, l3;
      return __generator(this, function(u2) {
        switch (u2.label) {
          case 0:
            if (null != t3 || null != r2)
              throw new Error("Support sampleWeight is not implemented yet");
            return null == n2 ? [3, 2] : (i2 = je(function() {
              if (1 === e2.shape.length)
                return e2.clone();
              if (2 === e2.shape.length) {
                if (e2.shape[1] > 1) {
                  return e2.argMax(1);
                }
                if (1 === e2.shape[1])
                  return e2.reshape([e2.shape[0]]);
                throw new Error("Encountered unexpected last-dimension size (" + e2.shape[1] + ") during handling of class weights. The size is expected to be >= 1.");
              }
              throw new Error("Unexpected rank of target (y) tensor (" + e2.rank + ") during handling of class weights. The rank is expected to be 1 or 2.");
            }), s2 = (o2 = Array).from, [4, i2.data()]);
          case 1:
            return a2 = s2.apply(o2, [u2.sent()]), Xe(i2), l3 = [], a2.forEach(function(e3) {
              if (null == n2[e3])
                throw new Error("classWeight must contain all classes in the training data. The class " + e3 + " exists in the data but not in classWeight");
              l3.push(n2[e3]);
            }), [2, Dn(l3, "float32")];
          case 2:
            return [2, null];
        }
      });
    });
  }
  function computeWeightedLoss(e2, t3) {
    return tc(e2, t3);
  }
  var DEFAULT_VALIDATION_BATCH_SIZE = 32;
  function standardizeDataIteratorOutput(e2, t3) {
    var n2, r2, i2 = t3;
    n2 = i2.xs, r2 = i2.ys, tt.assert(null != n2 && null != r2, function() {
      return "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " + t3;
    });
    var a2 = flattenTensorOrArrayOrMap("input", e2.inputNames, n2), o2 = flattenTensorOrArrayOrMap("output", e2.outputNames, r2), s2 = a2[0].shape[0];
    tt.assert(a2.length === e2.inputs.length, function() {
      return "LayersModel has " + e2.inputs.length + " inputs, but the dataset provides " + a2.length + " inputs.  (Expected input keys: " + JSON.stringify(e2.inputNames) + ")";
    }), tt.assert(o2.length === e2.outputs.length, function() {
      return "LayersModel has " + e2.outputs.length + " outputs, but the dataset provides " + o2.length + " outputs.  (Expected output keys: " + JSON.stringify(e2.outputNames) + ")";
    });
    var l3 = function(t4) {
      tt.assert(a2[t4].shape[0] === s2, function() {
        return "Batch size mismatch: input " + e2.inputNames[t4] + " has " + a2[t4].shape[0] + "; expected  " + s2 + " based on input " + e2.inputNames[0] + ".";
      });
    };
    for (var u2 in a2)
      l3(u2);
    var c2 = function(t4) {
      tt.assert(o2[t4].shape[0] === s2, function() {
        return "Batch size mismatch: output " + e2.outputNames[t4] + " has " + o2[t4].shape[0] + "; expected  " + s2 + " based on input " + e2.inputNames[0] + ".";
      });
    };
    for (var p2 in o2)
      c2(p2);
    return { xs: a2, ys: o2 };
  }
  function flattenTensorOrArrayOrMap(e2, t3, n2) {
    if (n2 instanceof dt)
      return [n2];
    if (Array.isArray(n2))
      return tt.assert(n2.length === t3.length, function() {
        return "Received an array of " + n2.length + " Tensors, but expected " + t3.length + " to match the " + e2 + " keys " + t3 + ".";
      }), n2;
    for (var r2 = [], i2 = 0, a2 = t3; i2 < a2.length; i2++) {
      var o2 = a2[i2];
      if (null == n2[o2])
        throw new ValueError("The feature data generated by the dataset lacks the required " + e2 + " key '" + o2 + "'.");
      r2.push(n2[o2]);
    }
    return r2;
  }
  function standardizeTensorValidationData(e2) {
    if (3 === e2.length)
      throw new NotImplementedError("Validation with sample weights is not implemented yet.");
    return { xs: e2[0], ys: e2[1] };
  }
  function fitDataset(e2, t3, n2) {
    return __awaiter(this, void 0, void 0, function() {
      var r2, i2, a2, o2, s2, l3, u2, c2, p2, h, d2, f2, g2, m2, y2, v2, b2, w2, z3, S3, A2, _3, I3, C3, E3, N3, k4, x2, L3, T2, D3, O3, R3, M2;
      return __generator(this, function(P3) {
        switch (P3.label) {
          case 0:
            if (r2 = null != n2.batchesPerEpoch, tt.assert(null != e2.optimizer, function() {
              return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).";
            }), tt.assert(null != n2, function() {
              return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.";
            }), tt.assert(null != n2.epochs && n2.epochs > 0 && Number.isInteger(n2.epochs), function() {
              return "For fitDataset(), config.epochs is expected to be a positive integer, but got " + n2.epochs;
            }), tt.assert(!r2 || n2.batchesPerEpoch > 0 && Number.isInteger(n2.batchesPerEpoch), function() {
              return "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got " + n2.batchesPerEpoch;
            }), tt.assert(null == n2.validationSplit, function() {
              return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.";
            }), e2.isTraining)
              throw new Error("Cannot start training because another fit() call is ongoing.");
            e2.isTraining = true, P3.label = 1;
          case 1:
            return P3.trys.push([1, , 26, 27]), i2 = null != n2.validationData, a2 = void 0, o2 = void 0, i2 && (isDatasetObject(n2.validationData) ? tt.assert(null == n2.validationBatches || n2.validationBatches > 0 && Number.isInteger(n2.validationBatches), function() {
              return "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got " + n2.validationBatches;
            }) : (s2 = standardizeTensorValidationData(n2.validationData), a2 = s2.xs, o2 = s2.ys)), l3 = e2.makeTrainFunction(), u2 = e2.getDedupedMetricsNames(), c2 = void 0, c2 = i2 ? u2.slice().concat(u2.map(function(e3) {
              return "val_" + e3;
            })) : u2.slice(), p2 = standardizeCallbacks(n2.callbacks, n2.yieldEvery), h = null == n2.verbose ? 1 : n2.verbose, d2 = configureCallbacks(p2, h, n2.epochs, null, null, getStepsPerEpoch(t3, n2), null, i2, c2), f2 = d2.callbackList, g2 = d2.history, f2.setModel(e2), e2.history = g2, [4, f2.onTrainBegin()];
          case 2:
            return P3.sent(), e2.stopTraining_ = false, m2 = null == n2.initialEpoch ? 0 : n2.initialEpoch, [4, t3.iterator()];
          case 3:
            y2 = P3.sent(), P3.label = 4;
          case 4:
            return m2 < n2.epochs ? (v2 = {}, [4, f2.onEpochBegin(m2)]) : [3, 23];
          case 5:
            return P3.sent(), b2 = 0, w2 = 0, r2 ? [3, 7] : [4, t3.iterator()];
          case 6:
            y2 = P3.sent(), P3.label = 7;
          case 7:
            return !r2 || b2 < n2.batchesPerEpoch ? [4, y2.next()] : [3, 21];
          case 8:
            return z3 = P3.sent(), r2 && z3.done ? (console.warn("You provided `batchesPerEpoch` as " + n2.batchesPerEpoch + ", but your dataset iterator ran out of data after " + b2 + " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " + n2.batchesPerEpoch * n2.epochs + " batches). You may need to use the repeat() function when building your dataset."), [3, 21]) : null == z3.value ? [3, 15] : (S3 = standardizeDataIteratorOutput(e2, z3.value), A2 = S3.xs, _3 = S3.ys, (I3 = {}).batch = w2, I3.size = A2[0].shape[0], [4, f2.onBatchBegin(w2, I3)]);
          case 9:
            if (P3.sent(), C3 = [], null == n2.classWeight)
              return [3, 13];
            E3 = standardizeClassWeights(n2.classWeight, e2.outputNames), M2 = 0, P3.label = 10;
          case 10:
            return M2 < E3.length ? (k4 = (N3 = C3).push, [4, standardizeWeights(_3[M2], null, E3[M2])]) : [3, 13];
          case 11:
            k4.apply(N3, [P3.sent()]), P3.label = 12;
          case 12:
            return ++M2, [3, 10];
          case 13:
            for (x2 = A2.concat(_3).concat(C3), L3 = l3(x2), Xe(x2), M2 = 0; M2 < u2.length; ++M2)
              T2 = u2[M2], D3 = L3[M2], I3[T2] = D3, $e(D3);
            return [4, f2.onBatchEnd(w2, I3)];
          case 14:
            P3.sent(), disposeTensorsInLogs(I3), w2++, b2++, P3.label = 15;
          case 15:
            return (r2 ? b2 >= n2.batchesPerEpoch : z3.done) ? i2 ? (O3 = void 0, isDatasetObject(n2.validationData) ? (R3 = toList, [4, e2.evaluateDataset(n2.validationData, { batches: n2.validationBatches })]) : [3, 17]) : [3, 19] : [3, 20];
          case 16:
            return O3 = R3.apply(void 0, [P3.sent()]), [3, 18];
          case 17:
            O3 = toList(e2.evaluate(a2, o2, { batchSize: null == n2.validationBatchSize ? DEFAULT_VALIDATION_BATCH_SIZE : n2.validationBatchSize, verbose: 0 })), P3.label = 18;
          case 18:
            for (M2 = 0; M2 < e2.metricsNames.length; ++M2)
              v2["val_" + e2.metricsNames[M2]] = O3[M2];
            P3.label = 19;
          case 19:
            return [3, 21];
          case 20:
            return e2.stopTraining_ ? [3, 21] : [3, 7];
          case 21:
            return [4, f2.onEpochEnd(m2, v2)];
          case 22:
            return P3.sent(), m2++, e2.stopTraining_ ? [3, 23] : [3, 4];
          case 23:
            return [4, f2.onTrainEnd()];
          case 24:
            return P3.sent(), [4, e2.history.syncData()];
          case 25:
            return P3.sent(), [2, e2.history];
          case 26:
            return e2.isTraining = false, [7];
          case 27:
            return [2];
        }
      });
    });
  }
  function getStepsPerEpoch(e2, t3) {
    var n2 = null;
    return null != t3.batchesPerEpoch ? n2 = t3.batchesPerEpoch : Number.isFinite(e2.size) && (n2 = e2.size), n2;
  }
  function isDatasetObject(e2) {
    return "function" == typeof e2.iterator;
  }
  function isLazyIteratorObject(e2) {
    return "function" == typeof e2.next;
  }
  function evaluateDataset(e2, t3, n2) {
    return __awaiter(this, void 0, void 0, function() {
      var r2, i2, a2, o2, s2, l3, u2, c2, p2, h;
      return __generator(this, function(d2) {
        switch (d2.label) {
          case 0:
            if (r2 = null != (n2 = n2 || {}).batches, i2 = e2.testFunction, a2 = [], n2.verbose > 0)
              throw new NotImplementedError("Verbose mode is not implemented yet.");
            return tt.assert(!r2 || n2.batches > 0 && Number.isInteger(n2.batches), function() {
              return "Test loop expects `batches` to be a positive integer, but received " + JSON.stringify(n2.batches);
            }), isLazyIteratorObject(t3) ? (s2 = t3, [3, 3]) : [3, 1];
          case 1:
            return [4, t3.iterator()];
          case 2:
            s2 = d2.sent(), d2.label = 3;
          case 3:
            o2 = s2, l3 = 0, u2 = 0, c2 = function() {
              var t4;
              return __generator(this, function(s3) {
                switch (s3.label) {
                  case 0:
                    return [4, o2.next()];
                  case 1:
                    return t4 = s3.sent(), a2 = je(function() {
                      if (t4.value) {
                        var n3 = standardizeDataIteratorOutput(e2, t4.value), r3 = n3.xs, o3 = n3.ys, s4 = r3.concat(o3), c3 = je(function() {
                          return i2(s4);
                        });
                        if (Xe(s4), 0 === u2)
                          for (var p3 = 0; p3 < c3.length; ++p3)
                            a2.push(An(0));
                        var h2 = s4[0].shape[0], d3 = function(e3) {
                          var t5 = c3[e3], n4 = a2[e3];
                          a2[e3] = je(function() {
                            return Vs(a2[e3], tc(h2, t5));
                          }), u2 > 0 && Xe(n4);
                        };
                        for (p3 = 0; p3 < c3.length; ++p3)
                          d3(p3);
                        Xe(c3), l3 += h2, ++u2;
                      }
                      return a2;
                    }), t4.done ? (r2 && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, " + n2.batches + " batches). You may need to use the repeat() function when building your dataset."), [2, "break"]) : [2];
                }
              });
            }, d2.label = 4;
          case 4:
            return !r2 || u2 < n2.batches ? [5, c2()] : [3, 6];
          case 5:
            return "break" === d2.sent() ? [3, 6] : [3, 4];
          case 6:
            for (p2 = 0; p2 < a2.length; ++p2)
              h = a2[p2], a2[p2] = qs(a2[p2], l3), Xe(h);
            return [2, singletonOrArray(a2)];
        }
      });
    });
  }
  function checkBatchSize(e2) {
    tt.assert(e2 > 0 && Number.isInteger(e2), function() {
      return "batchSize is required to be a positive integer, but got " + e2;
    });
  }
  function sliceArrays(e2, t3, n2) {
    return null == e2 ? [null] : Array.isArray(e2) ? e2.map(function(e3) {
      return sliceAlongFirstAxis(e3, t3, n2 - t3);
    }) : sliceAlongFirstAxis(e2, t3, n2 - t3);
  }
  function sliceArraysByIndices(e2, t3) {
    return je(function() {
      return null == e2 ? null : Array.isArray(e2) ? e2.map(function(e3) {
        return sliceArraysByIndices(e3, t3);
      }) : gather$1(e2, "int32" === t3.dtype ? t3 : t3.toInt());
    });
  }
  function makeBatches(e2, t3) {
    for (var n2 = [], r2 = 0, i2 = null; r2 < e2; )
      (i2 = r2 + t3) >= e2 && (i2 = e2), n2.push([r2, i2]), r2 = i2;
    return n2;
  }
  function fitLoop(e2, t3, n2, r2, i2, a2, o2, s2, l3, u2, c2, p2, h, d2, f2) {
    return __awaiter(this, void 0, void 0, function() {
      var g2, m2, y2, v2, b2, w2, z3, S3;
      return __generator(this, function(A2) {
        switch (A2.label) {
          case 0:
            if (null == i2 && (i2 = 32), null == a2 && (a2 = 1), null == c2 && (c2 = true), null == h && (h = 0), g2 = false, null != l3 && null != u2 && (g2 = true), null != f2 && (g2 = true, null == d2))
              throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
            return null != (m2 = e2.checkNumSamples(n2, i2, d2, "steps_per_epoch")) && (y2 = range(0, m2)), null == o2 && (o2 = 1), v2 = configureCallbacks(s2, o2, a2, h, m2, d2, i2, g2, p2), b2 = v2.callbackList, w2 = v2.history, b2.setModel(e2), e2.history = w2, [4, b2.onTrainBegin()];
          case 1:
            A2.sent(), e2.stopTraining_ = false, z3 = function(a3) {
              var o3, s3, p3, h2, f3;
              return __generator(this, function(v3) {
                switch (v3.label) {
                  case 0:
                    return [4, b2.onEpochBegin(a3)];
                  case 1:
                    if (v3.sent(), o3 = {}, null == d2)
                      return [3, 2];
                    throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");
                  case 2:
                    if ("batch" === c2)
                      throw new NotImplementedError("batch shuffling is not implemneted yet");
                    c2 && tt.shuffle(y2), s3 = Dn(y2), p3 = makeBatches(m2, i2), h2 = function(a4) {
                      var c3;
                      return __generator(this, function(h3) {
                        switch (h3.label) {
                          case 0:
                            return c3 = {}, [4, b2.onBatchBegin(a4, c3)];
                          case 1:
                            return h3.sent(), je(function() {
                              var h4 = p3[a4][0], d3 = p3[a4][1], f4 = sliceAlongFirstAxis(s3, h4, d3 - h4);
                              c3.batch = a4, c3.size = d3 - h4;
                              for (var m3 = sliceArraysByIndices(n2, f4), y3 = t3(m3), v4 = 0; v4 < r2.length; ++v4) {
                                var b3 = r2[v4], w3 = y3[v4];
                                c3[b3] = w3, $e(w3);
                              }
                              if (a4 === p3.length - 1 && g2) {
                                var z4 = e2.testLoop(l3, u2, i2);
                                for (v4 = 0; v4 < r2.length; ++v4) {
                                  b3 = r2[v4], w3 = z4[v4];
                                  $e(w3), o3["val_" + b3] = w3;
                                }
                              }
                            }), [4, b2.onBatchEnd(a4, c3)];
                          case 2:
                            return h3.sent(), disposeTensorsInLogs(c3), e2.stopTraining_ ? [2, "break"] : [2];
                        }
                      });
                    }, f3 = 0, v3.label = 3;
                  case 3:
                    return f3 < p3.length ? [5, h2(f3)] : [3, 6];
                  case 4:
                    if ("break" === v3.sent())
                      return [3, 6];
                    v3.label = 5;
                  case 5:
                    return ++f3, [3, 3];
                  case 6:
                    s3.dispose(), v3.label = 7;
                  case 7:
                    return [4, b2.onEpochEnd(a3, o3)];
                  case 8:
                    return v3.sent(), e2.stopTraining_ ? [2, "break"] : [2];
                }
              });
            }, S3 = h, A2.label = 2;
          case 2:
            return S3 < a2 ? [5, z3(S3)] : [3, 5];
          case 3:
            if ("break" === A2.sent())
              return [3, 5];
            A2.label = 4;
          case 4:
            return ++S3, [3, 2];
          case 5:
            return [4, b2.onTrainEnd()];
          case 6:
            return A2.sent(), [4, e2.history.syncData()];
          case 7:
            return A2.sent(), [2, e2.history];
        }
      });
    });
  }
  function fitTensors(e2, t3, n2, r2) {
    return void 0 === r2 && (r2 = {}), __awaiter(this, void 0, void 0, function() {
      var i2, a2, o2, s2, l3, u2, c2, p2, h, d2, f2, g2, m2, y2, v2, b2, w2, z3, S3, A2, _3, I3;
      return __generator(this, function(C3) {
        switch (C3.label) {
          case 0:
            if (e2.isTraining)
              throw new Error("Cannot start training because another fit() call is ongoing.");
            e2.isTraining = true, C3.label = 1;
          case 1:
            return C3.trys.push([1, , 7, 8]), checkBatchSize(p2 = null == r2.batchSize ? 32 : r2.batchSize), h = false, [4, e2.standardizeUserData(t3, n2, r2.sampleWeight, r2.classWeight, h, p2)];
          case 2:
            if (d2 = C3.sent(), i2 = d2[0], a2 = d2[1], c2 = d2[2], f2 = false, g2 = void 0, !(null != r2.validationData && r2.validationData.length > 0))
              return [3, 4];
            if (f2 = true, 2 !== r2.validationData.length)
              throw 3 === r2.validationData.length ? new NotImplementedError("validationData including sample weights is not supported yet.") : new ValueError("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " + r2.validationData + " is invalid.");
            return o2 = r2.validationData[0], s2 = r2.validationData[1], m2 = true, [4, e2.standardizeUserData(o2, s2, null, null, m2, p2)];
          case 3:
            return y2 = C3.sent(), l3 = y2[0], u2 = y2[1], g2 = l3.concat(u2), [3, 5];
          case 4:
            null != r2.validationSplit && r2.validationSplit > 0 && r2.validationSplit < 1 ? (f2 = true, v2 = Math.floor(i2[0].shape[0] * (1 - r2.validationSplit)), b2 = i2[0].shape[0], l3 = sliceArrays(i2, v2, b2), i2 = sliceArrays(i2, 0, v2), u2 = sliceArrays(a2, v2, b2), a2 = sliceArrays(a2, 0, v2), g2 = l3.concat(u2)) : null != r2.validationSteps && (f2 = true), C3.label = 5;
          case 5:
            return w2 = i2.concat(a2).concat(c2), e2.checkTrainableWeightsConsistency(), z3 = e2.makeTrainFunction(), S3 = e2.getDedupedMetricsNames(), A2 = void 0, _3 = void 0, f2 ? (e2.makeTestFunction(), A2 = e2.testFunction, _3 = S3.slice().concat(S3.map(function(e3) {
              return "val_" + e3;
            }))) : (A2 = null, g2 = [], _3 = S3.slice()), I3 = standardizeCallbacks(r2.callbacks, r2.yieldEvery), [4, fitLoop(e2, z3, w2, S3, p2, r2.epochs, r2.verbose, I3, A2, g2, r2.shuffle, _3, r2.initialEpoch, null, null)];
          case 6:
            return [2, C3.sent()];
          case 7:
            return e2.isTraining = false, disposeNewTensors(i2, t3), disposeNewTensors(a2, n2), disposeNewTensors(l3, o2), disposeNewTensors(u2, s2), null != c2 && Xe(c2), [7];
          case 8:
            return [2];
        }
      });
    });
  }
  function ensureTensorsRank2OrHigher(e2) {
    var t3 = [];
    e2 instanceof dt && (e2 = [e2]);
    for (var n2 = 0; n2 < e2.length; ++n2) {
      var r2 = e2[n2];
      if (1 === r2.rank)
        t3.push(expandDims$1(r2, 1));
      else {
        if (0 === r2.rank)
          throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
        t3.push(r2);
      }
    }
    return t3;
  }
  function disposeNewTensors(e2, t3) {
    if (null != e2) {
      var n2 = [];
      if (t3 instanceof dt)
        n2.push(t3.id);
      else if (Array.isArray(t3))
        t3.forEach(function(e3) {
          return n2.push(e3.id);
        });
      else if (null != t3)
        for (var r2 in t3) {
          var i2 = t3[r2];
          n2.push(i2.id);
        }
      var a2 = [];
      if (e2 instanceof dt)
        -1 === n2.indexOf(e2.id) && a2.push(e2);
      else if (Array.isArray(e2))
        e2.forEach(function(e3) {
          -1 === n2.indexOf(e3.id) && a2.push(e3);
        });
      else if (null != e2)
        for (var o2 in e2) {
          var s2 = e2[o2];
          -1 === n2.indexOf(s2.id) && a2.push(s2);
        }
      a2.forEach(function(e3) {
        e3.isDisposed || e3.dispose();
      });
    }
  }
  function isDataTensor(e2) {
    return e2 instanceof dt;
  }
  function isDataArray(e2) {
    return Array.isArray(e2);
  }
  function isDataDict(e2) {
    return !isDataTensor(e2) && !isDataArray(e2);
  }
  function standardizeInputData(e2, t3, n2, r2, i2) {
    if (void 0 === r2 && (r2 = true), void 0 === i2 && (i2 = ""), null == t3 || 0 === t3.length) {
      if (null != e2) {
        var a2 = false;
        if (isDataArray(e2) && e2.length > 0)
          a2 = true;
        else if (isDataDict(e2)) {
          for (var o2 in e2)
            if (e2.hasOwnProperty(o2)) {
              a2 = true;
              break;
            }
        } else
          a2 = true;
        if (a2)
          throw new ValueError("Error when checking model " + i2 + " expected no data, but got " + e2);
      }
      return [];
    }
    if (null == e2)
      return t3.map(function(e3) {
        return null;
      });
    var s2;
    if (isDataDict(e2)) {
      e2 = e2, s2 = [];
      for (var l3 = 0, u2 = t3; l3 < u2.length; l3++) {
        var c2 = u2[l3];
        if (null == e2[c2])
          throw new ValueError('No data provided for "' + c2 + '". Need data for each key in: ' + t3);
        s2.push(e2[c2]);
      }
    } else if (isDataArray(e2)) {
      if ((e2 = e2).length !== t3.length)
        throw new ValueError("Error when checking model " + i2 + ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see " + t3.length + " Tensor(s), but instead got the following list of Tensor(s): " + e2);
      s2 = e2;
    } else {
      if (e2 = e2, t3.length > 1)
        throw new ValueError("The model " + i2 + " expects " + t3.length + " Tensor(s), but only received one Tensor. Found: Tensor with shape " + e2.shape);
      s2 = [e2];
    }
    if (s2 = ensureTensorsRank2OrHigher(s2), null != n2) {
      for (var p2 = 0; p2 < t3.length; ++p2)
        if (null != n2[p2]) {
          var h = s2[p2];
          if (h.shape.length !== n2[p2].length)
            throw new ValueError("Error when checking " + i2 + ": expected " + t3[p2] + " to have " + n2[p2].length + " dimension(s). but got array with shape " + h.shape);
          for (var d2 = 0; d2 < n2[p2].length; ++d2)
            if (0 !== d2 || r2) {
              var f2 = h.shape[d2], g2 = n2[p2][d2];
              if (null != g2 && g2 >= 0 && f2 !== g2)
                throw new ValueError("Error when checking " + i2 + ": expected " + t3[p2] + " to have shape [" + n2[p2] + "], but got array with shape [" + h.shape + "].");
            }
        }
    }
    return s2;
  }
  function checkArrayLengths(e2, t3, n2) {
    var r2 = unique(e2.map(function(e3) {
      return e3.shape[0];
    }));
    r2.sort();
    var i2 = unique(t3.map(function(e3) {
      return e3.shape[0];
    }));
    if (i2.sort(), r2.length > 1)
      throw new ValueError("All input Tensors (x) should have the same number of samples. Got array shapes: " + JSON.stringify(e2.map(function(e3) {
        return e3.shape;
      })));
    if (i2.length > 1)
      throw new ValueError("All target Tensors (y) should have the same number of samples. Got array shapes: " + JSON.stringify(t3.map(function(e3) {
        return e3.shape;
      })));
    if (r2.length > 0 && i2.length > 0 && !tt.arraysEqual(r2, i2))
      throw new ValueError("Input Tensors should have the same number of samples as target Tensors. Found " + r2[0] + " input sample(s) and " + i2[0] + " target sample(s).");
  }
  function checkLossAndTargetCompatibility(e2, t3, n2) {
    for (var r2 = [meanSquaredError, binaryCrossentropy, categoricalCrossentropy], i2 = 0; i2 < e2.length; ++i2) {
      var a2 = e2[i2], o2 = t3[i2], s2 = n2[i2];
      if (null != o2) {
        if (o2 === categoricalCrossentropy && 1 === a2.shape[a2.shape.length - 1])
          throw new ValueError("You are passing a target array of shape " + a2.shape + " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");
        if (-1 !== r2.indexOf(o2))
          for (var l3 = a2.shape.slice(1), u2 = s2.slice(1), c2 = 0; c2 < l3.length; ++c2) {
            var p2 = l3[c2], h = u2[c2];
            if (null != h && p2 !== h)
              throw new ValueError("A target Tensor with shape " + a2.shape + " was passed for an output of shape " + s2 + ", while using a loss function that expects targets to have the same shape as the output.");
          }
      }
    }
  }
  function checkInputData(e2, t3, n2, r2, i2) {
    var a2;
    if (void 0 === r2 && (r2 = true), void 0 === i2 && (i2 = ""), Array.isArray(e2)) {
      if (e2.length !== t3.length)
        throw new ValueError("Error when checking model " + i2 + ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see " + t3.length + " Tensor(s), but instead got " + e2.length + " Tensors(s).");
      a2 = e2;
    } else {
      if (t3.length > 1)
        throw new ValueError("The model expects " + t3.length + " " + i2 + " Tensors, but only received one Tensor. Found: array with shape " + JSON.stringify(e2.shape) + ".");
      a2 = [e2];
    }
    if (null != n2) {
      for (var o2 = 0; o2 < t3.length; ++o2)
        if (null != n2[o2]) {
          var s2 = a2[o2];
          if (s2.shape.length !== n2[o2].length)
            throw new ValueError("Error when checking " + i2 + ": expected " + t3[o2] + " to have " + n2[o2].length + " dimension(s), but got array with shape " + JSON.stringify(s2.shape));
          for (var l3 = 0; l3 < n2[o2].length; ++l3)
            if (0 !== l3 || r2) {
              var u2 = s2.shape[l3], c2 = n2[o2][l3];
              if (null != c2 && c2 !== u2)
                throw new ValueError("Error when checking " + i2 + ": expected " + t3[o2] + " to have shape " + JSON.stringify(n2[o2]) + " but got array with shape " + JSON.stringify(s2.shape) + ".");
            }
        }
    }
  }
  function collectMetrics(e2, t3) {
    if (null == e2 || Array.isArray(e2) && 0 === e2.length)
      return t3.map(function(e3) {
        return [];
      });
    var n2;
    if ("string" == typeof e2 || "function" == typeof e2)
      n2 = [e2];
    else {
      if (!Array.isArray(e2) && "object" != typeof e2)
        throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: " + e2);
      n2 = e2;
    }
    if (Array.isArray(n2))
      return t3.map(function(e3) {
        return n2;
      });
    for (var r2 = [], i2 = 0, a2 = t3; i2 < a2.length; i2++) {
      var o2 = a2[i2], s2 = n2.hasOwnProperty(o2) ? n2[o2] : [];
      Array.isArray(s2) || (s2 = [s2]), r2.push(s2);
    }
    return r2;
  }
  var LAYERS_MODEL_FORMAT_NAME = "layers-model";
  var LayersModel = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.isTraining = false, n2;
    }
    return __extends(t3, e2), t3.prototype.summary = function(e3, t4, n2) {
      if (void 0 === n2 && (n2 = console.log), !this.built)
        throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
      printSummary(this, e3, t4, n2);
    }, t3.prototype.compile = function(e3) {
      var t4 = this;
      if (null == e3.loss && (e3.loss = []), this.loss = e3.loss, "string" == typeof e3.optimizer)
        this.optimizer_ = getOptimizer(e3.optimizer), this.isOptimizerOwned = true;
      else {
        if (!(e3.optimizer instanceof Hf))
          throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");
        this.optimizer_ = e3.optimizer, this.isOptimizerOwned = false;
      }
      var n2 = [];
      if (Array.isArray(e3.loss) || "string" == typeof e3.loss || "function" == typeof e3.loss)
        if (Array.isArray(e3.loss)) {
          if (e3.loss.length !== this.outputs.length)
            throw new ValueError("When passing an Array as loss, it should have one entry per model output. The model has " + this.outputs.length + " output(s), but you passed loss=" + e3.loss + ".");
          var r2 = e3.loss;
          n2 = r2.map(function(e4) {
            return get(e4);
          });
        } else {
          var i2 = get(e3.loss);
          this.outputs.forEach(function(e4) {
            n2.push(i2);
          });
        }
      else {
        for (var a2 in e3.loss = e3.loss, e3.loss)
          if (-1 === this.outputNames.indexOf(a2))
            throw new ValueError('Unknown entry in loss dictionary: "' + a2 + '". Only expected the following keys: ' + this.outputNames);
        for (var o2 = 0, s2 = this.outputNames; o2 < s2.length; o2++) {
          var l3 = s2[o2];
          null == e3.loss[l3] && console.warn('Output "' + l3 + '" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ' + l3 + " during training"), n2.push(get(e3.loss[l3]));
        }
      }
      this.lossFunctions = n2, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
      for (var u2 = 0; u2 < this.outputs.length; ++u2) {
        var c2 = this.internalOutputShapes[u2], p2 = this.outputNames[u2];
        this.feedOutputNames.push(p2), this.feedOutputShapes.push(c2), this.feedLossFns.push(this.lossFunctions[u2]);
      }
      var h = [];
      this.metrics = e3.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], nameScope("loss", function() {
        for (var e4 = 0; e4 < t4.outputs.length; ++e4)
          if (-1 === h.indexOf(e4)) {
            var n3 = t4.lossFunctions[e4];
            t4.outputs.length > 1 && (t4.metricsTensors.push([n3, e4]), t4.metricsNames.push(t4.outputNames[e4] + "_loss"));
          }
      });
      var d2 = collectMetrics(e3.metrics, this.outputNames);
      nameScope("metric", function() {
        for (var e4 = function(e5) {
          if (-1 !== h.indexOf(e5))
            return "continue";
          !function(n4) {
            for (var r3, i3, a3, o3 = function(n5) {
              if ("string" == typeof n5 && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(n5)) {
                var o4 = t4.internalOutputShapes[e5];
                1 === o4[o4.length - 1] || t4.lossFunctions[e5] === binaryCrossentropy ? -1 !== ["accuracy", "acc"].indexOf(n5) ? i3 = binaryAccuracy : -1 !== ["crossentropy", "ce"].indexOf(n5) && (i3 = binaryCrossentropy$1) : t4.lossFunctions[e5] === sparseCategoricalCrossentropy ? -1 !== ["accuracy", "acc"].indexOf(n5) ? i3 = sparseCategoricalAccuracy : -1 !== ["crossentropy", "ce"].indexOf(n5) && (i3 = sparseCategoricalCrossentropy$1) : -1 !== ["accuracy", "acc"].indexOf(n5) ? i3 = categoricalAccuracy : -1 !== ["crossentropy", "ce"].indexOf(n5) && (i3 = categoricalCrossentropy$1);
                var s4 = void 0;
                -1 !== ["accuracy", "acc"].indexOf(n5) ? s4 = "acc" : -1 !== ["crossentropy", "ce"].indexOf(n5) && (s4 = "ce"), a3 = i3, r3 = "" + s4;
              } else {
                var l5 = get$1(n5);
                a3 = l5, r3 = "" + getLossOrMetricName(n5);
              }
              var u3;
              nameScope(r3, function() {
                u3 = a3;
              }), function(e6, n6, r4) {
                t4.outputNames.length > 1 && (n6 = t4.outputNames[e6] + "_" + n6), t4.metricsNames.push(n6), t4.metricsTensors.push([r4, e6]);
              }(e5, r3, u3);
            }, s3 = 0, l4 = n4; s3 < l4.length; s3++)
              o3(l4[s3]);
          }(d2[e5]);
        }, n3 = 0; n3 < t4.outputs.length; ++n3)
          e4(n3);
      }), this.collectedTrainableWeights = this.trainableWeights;
    }, t3.prototype.checkTrainableWeightsConsistency = function() {
      null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
    }, t3.prototype.evaluate = function(e3, t4, n2) {
      void 0 === n2 && (n2 = {});
      var r2 = null == n2.batchSize ? 32 : n2.batchSize;
      checkBatchSize(r2);
      var i2 = this.standardizeUserDataXY(e3, t4, true, r2);
      try {
        var a2 = i2[0].concat(i2[1]);
        this.makeTestFunction();
        var o2 = this.testFunction;
        return singletonOrArray(this.testLoop(o2, a2, r2, n2.verbose, n2.steps));
      } finally {
        disposeNewTensors(i2[0], e3), disposeNewTensors(i2[1], t4);
      }
    }, t3.prototype.evaluateDataset = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(n2) {
          return this.makeTestFunction(), [2, evaluateDataset(this, e3, t4)];
        });
      });
    }, t3.prototype.checkNumSamples = function(e3, t4, n2, r2) {
      var i2;
      if (void 0 === r2 && (r2 = "steps"), null != n2) {
        if (i2 = null, null != t4)
          throw new ValueError("If " + r2 + " is set, batchSize must be null or undefined.Got batchSize = " + t4);
      } else {
        if (null == e3)
          throw new ValueError("Either the input data should have a defined shape, or " + r2 + " shoud be specified.");
        i2 = Array.isArray(e3) ? e3[0].shape[0] : e3.shape[0];
      }
      return i2;
    }, t3.prototype.execute = function(e3, t4) {
      if (Array.isArray(t4) && 0 === t4.length)
        throw new ValueError("`outputs` is an empty Array, which is not allowed.");
      var n2 = Array.isArray(t4), r2 = n2 ? t4 : [t4], i2 = this.retrieveSymbolicTensors(r2), a2 = new FeedDict();
      if (e3 instanceof dt && (e3 = [e3]), Array.isArray(e3)) {
        if (e3.length !== this.inputs.length)
          throw new ValueError("The number of inputs provided (" + e3.length + ") does not match the number of inputs of this model (" + this.inputs.length + ").");
        for (var o2 = 0; o2 < this.inputs.length; ++o2)
          a2.add(this.inputs[o2], e3[o2]);
      } else
        for (var s2 = 0, l3 = this.inputs; s2 < l3.length; s2++) {
          var u2 = l3[s2], c2 = e3[u2.name];
          if (null == c2)
            throw new ValueError("No value is provided for the model's input " + u2.name);
          a2.add(u2, c2);
        }
      var p2 = execute(i2, a2);
      return n2 ? p2 : p2[0];
    }, t3.prototype.retrieveSymbolicTensors = function(e3) {
      for (var t4 = pyListRepeat(null, e3.length), n2 = e3.length, r2 = 0, i2 = this.layers; r2 < i2.length; r2++) {
        for (var a2 = i2[r2], o2 = Array.isArray(a2.output) ? a2.output : [a2.output], s2 = o2.map(function(e4) {
          return e4.name;
        }), l3 = 0; l3 < e3.length; ++l3) {
          var u2 = s2.indexOf(e3[l3]);
          if (-1 !== u2 && (t4[l3] = o2[u2], n2--), 0 === n2)
            break;
        }
        if (0 === n2)
          break;
      }
      if (n2 > 0) {
        var c2 = [];
        throw t4.forEach(function(t5, n3) {
          null == t5 && c2.push(e3[n3]);
        }), new ValueError("Cannot find SymbolicTensors for output name(s): " + JSON.stringify(c2));
      }
      return t4;
    }, t3.prototype.predictLoop = function(e3, t4, n2) {
      var r2 = this;
      return void 0 === t4 && (t4 = 32), void 0 === n2 && (n2 = false), je(function() {
        var i2 = r2.checkNumSamples(e3);
        if (n2)
          throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");
        for (var a2 = makeBatches(i2, t4), o2 = r2.outputs.map(function(e4) {
          return [];
        }), s2 = function(t5) {
          je(function() {
            var n3 = a2[t5][0], i3 = a2[t5][1], o3 = sliceArrays(e3, n3, i3), s3 = [];
            if (Array.isArray(o3))
              for (var l4 = 0; l4 < o3.length; ++l4)
                s3.push({ key: r2.inputs[l4], value: o3[l4] });
            else
              s3.push({ key: r2.inputs[0], value: o3 });
            var u2 = new FeedDict(s3);
            return execute(r2.outputs, u2);
          }).forEach(function(e4, t6) {
            return o2[t6].push(e4);
          });
        }, l3 = 0; l3 < a2.length; ++l3)
          s2(l3);
        return singletonOrArray(o2.map(function(e4) {
          return Gn(e4, 0);
        }));
      });
    }, t3.prototype.predict = function(e3, t4) {
      void 0 === t4 && (t4 = {});
      var n2 = ensureTensorsRank2OrHigher(e3);
      checkInputData(n2, this.inputNames, this.feedInputShapes, false);
      try {
        var r2 = null == t4.batchSize ? 32 : t4.batchSize;
        return checkBatchSize(r2), this.predictLoop(n2, r2);
      } finally {
        disposeNewTensors(n2, e3);
      }
    }, t3.prototype.predictOnBatch = function(e3) {
      checkInputData(e3, this.inputNames, this.feedInputShapes, true);
      var t4 = (Array.isArray(e3) ? e3[0] : e3).shape[0];
      return this.predictLoop(e3, t4);
    }, t3.prototype.standardizeUserDataXY = function(e3, t4, n2, r2) {
      if (void 0 === n2 && (n2 = true), null == this.optimizer_)
        throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
      for (var i2 = [], a2 = 0; a2 < this.feedOutputShapes.length; ++a2) {
        var o2 = this.feedOutputShapes[a2];
        this.feedLossFns[a2] === sparseCategoricalCrossentropy ? i2.push(o2.slice(0, o2.length - 1).concat([1])) : i2.push(o2);
      }
      if (checkArrayLengths(e3 = standardizeInputData(e3, this.feedInputNames, this.feedInputShapes, false, "input"), t4 = standardizeInputData(t4, this.feedOutputNames, i2, false, "target"), null), checkLossAndTargetCompatibility(t4, this.feedLossFns, this.feedOutputShapes), this.stateful && null != r2 && r2 > 0 && e3[0].shape[0] % r2 != 0)
        throw new ValueError("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " + r2 + ". Found: " + e3[0].shape[0] + " sample(s).");
      return [e3, t4];
    }, t3.prototype.standardizeUserData = function(e3, t4, n2, r2, i2, a2) {
      return void 0 === i2 && (i2 = true), __awaiter(this, void 0, void 0, function() {
        var o2, s2, l3, u2, c2, p2, h, d2;
        return __generator(this, function(f2) {
          switch (f2.label) {
            case 0:
              if (o2 = this.standardizeUserDataXY(e3, t4, i2, a2), s2 = o2[0], l3 = o2[1], null != n2)
                throw new Error("sample weight is not supported yet.");
              if (u2 = null, null == r2)
                return [3, 4];
              c2 = standardizeClassWeights(r2, this.outputNames), u2 = [], p2 = 0, f2.label = 1;
            case 1:
              return p2 < c2.length ? (d2 = (h = u2).push, [4, standardizeWeights(l3[p2], null, c2[p2])]) : [3, 4];
            case 2:
              d2.apply(h, [f2.sent()]), f2.label = 3;
            case 3:
              return ++p2, [3, 1];
            case 4:
              return [2, [s2, l3, u2]];
          }
        });
      });
    }, t3.prototype.testLoop = function(e3, t4, n2, r2, i2) {
      var a2 = this;
      return void 0 === r2 && (r2 = 0), je(function() {
        var o2 = a2.checkNumSamples(t4, n2, i2, "steps"), s2 = [];
        if (r2 > 0)
          throw new NotImplementedError("Verbose mode is not implemented yet.");
        if (null != i2)
          throw new NotImplementedError("steps mode in testLoop() is not implemented yet");
        for (var l3 = makeBatches(o2, n2), u2 = Dn(range(0, o2)), c2 = 0; c2 < l3.length; ++c2) {
          var p2 = l3[c2][0], h = l3[c2][1], d2 = sliceAlongFirstAxis(u2, p2, h - p2), f2 = sliceArraysByIndices(t4, d2), g2 = e3(f2);
          if (0 === c2)
            for (var m2 = 0; m2 < g2.length; ++m2)
              s2.push(An(0));
          for (m2 = 0; m2 < g2.length; ++m2) {
            var y2 = g2[m2];
            s2[m2] = Vs(s2[m2], tc(h - p2, y2));
          }
        }
        for (m2 = 0; m2 < s2.length; ++m2)
          s2[m2] = qs(s2[m2], o2);
        return s2;
      });
    }, t3.prototype.getDedupedMetricsNames = function() {
      for (var e3 = this.metricsNames, t4 = [], n2 = 0; n2 < e3.length; ++n2) {
        var r2 = e3[n2], i2 = r2;
        if (count(e3, r2) > 1)
          i2 += "_" + count(e3.slice(0, n2), r2);
        t4.push(i2);
      }
      return t4;
    }, t3.prototype.makeTrainFunction = function() {
      var e3 = this;
      return function(t4) {
        var n2 = [], r2 = t4.slice(0, e3.inputs.length), i2 = t4.slice(e3.inputs.length, e3.inputs.length + e3.outputs.length), a2 = t4.slice(e3.inputs.length + e3.outputs.length, e3.inputs.length + 2 * e3.outputs.length), o2 = [], s2 = e3.collectedTrainableWeights.map(function(e4) {
          return e4.read();
        });
        return [e3.optimizer_.minimize(function() {
          for (var t5 = [], s3 = 0; s3 < e3.inputs.length; ++s3)
            t5.push({ key: e3.inputs[s3], value: r2[s3] });
          var l3, u2 = new FeedDict(t5), c2 = execute(e3.outputs, u2, { training: true });
          for (s3 = 0; s3 < e3.lossFunctions.length; ++s3) {
            var p2 = (0, e3.lossFunctions[s3])(i2[s3], c2[s3]);
            null != a2[s3] && (p2 = computeWeightedLoss(p2, a2[s3]));
            var h = fl(p2);
            n2.push(h), l3 = 0 === s3 ? p2 : Vs(l3, p2);
          }
          for (s3 = 0; s3 < e3.metricsTensors.length; ++s3) {
            var d2 = void 0;
            if (e3.outputs.length > 1 && s3 < e3.outputs.length)
              d2 = n2[s3];
            else {
              var f2 = e3.metricsTensors[s3][0], g2 = e3.metricsTensors[s3][1];
              d2 = fl(f2(i2[g2], c2[g2]));
            }
            $e(d2), o2.push(d2);
          }
          return l3 = fl(l3), e3.calculateLosses().forEach(function(e4) {
            l3 = Vs(l3, e4);
          }), l3;
        }, true, s2)].concat(o2);
      };
    }, t3.prototype.makeTestFunction = function() {
      var e3 = this;
      this.testFunction = function(t4) {
        return je(function() {
          for (var n2, r2 = [], i2 = t4.slice(0, e3.inputs.length), a2 = t4.slice(e3.inputs.length, e3.inputs.length + e3.outputs.length), o2 = [], s2 = 0; s2 < e3.inputs.length; ++s2)
            o2.push({ key: e3.inputs[s2], value: i2[s2] });
          var l3 = new FeedDict(o2), u2 = execute(e3.outputs, l3);
          for (s2 = 0; s2 < e3.lossFunctions.length; ++s2) {
            var c2 = e3.lossFunctions[s2], p2 = fl(c2(a2[s2], u2[s2]));
            n2 = 0 === s2 ? p2 : Vs(n2, p2), r2.push(n2);
          }
          for (s2 = 0; s2 < e3.metricsTensors.length; ++s2) {
            var h = e3.metricsTensors[s2][0], d2 = e3.metricsTensors[s2][1], f2 = fl(h(a2[d2], u2[d2]));
            r2.push(f2);
          }
          return r2;
        });
      };
    }, t3.prototype.fit = function(e3, t4, n2) {
      return void 0 === n2 && (n2 = {}), __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(r2) {
          return [2, fitTensors(this, e3, t4, n2)];
        });
      });
    }, t3.prototype.fitDataset = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(n2) {
          return [2, fitDataset(this, e3, t4)];
        });
      });
    }, t3.prototype.trainOnBatch = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        var n2, r2, i2, a2, o2, s2, l3, u2, c2;
        return __generator(this, function(p2) {
          switch (p2.label) {
            case 0:
              return [4, this.standardizeUserData(e3, t4)];
            case 1:
              n2 = p2.sent(), r2 = n2[0], i2 = n2[1], a2 = this.makeTrainFunction(), o2 = a2(r2.concat(i2)), s2 = [], l3 = 0, u2 = o2, p2.label = 2;
            case 2:
              return l3 < u2.length ? [4, u2[l3].data()] : [3, 5];
            case 3:
              c2 = p2.sent(), s2.push(c2[0]), p2.label = 4;
            case 4:
              return l3++, [3, 2];
            case 5:
              return Xe(o2), [2, singletonOrArray(s2)];
          }
        });
      });
    }, t3.prototype.getNamedWeights = function(e3) {
      for (var t4 = [], n2 = null != e3 && e3.trainableOnly, r2 = n2 ? this.trainableWeights : this.weights, i2 = this.getWeights(n2), a2 = 0; a2 < r2.length; ++a2)
        n2 && !r2[a2].trainable || t4.push({ name: r2[a2].originalName, tensor: i2[a2] });
      return t4;
    }, Object.defineProperty(t3.prototype, "stopTraining", { get: function() {
      return this.stopTraining_;
    }, set: function(e3) {
      this.stopTraining_ = e3;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "optimizer", { get: function() {
      return this.optimizer_;
    }, set: function(e3) {
      this.optimizer_ !== e3 && (this.optimizer_ = e3, this.isOptimizerOwned = false);
    }, enumerable: true, configurable: true }), t3.prototype.dispose = function() {
      var t4 = e2.prototype.dispose.call(this);
      if (0 === t4.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
        var n2 = qe().numTensors;
        this.optimizer_.dispose(), t4.numDisposedVariables += n2 - qe().numTensors;
      }
      return t4;
    }, t3.prototype.getLossIdentifiers = function() {
      var e3;
      if ("string" == typeof this.loss)
        e3 = toSnakeCase(this.loss);
      else if (Array.isArray(this.loss)) {
        for (var t4 = 0, n2 = this.loss; t4 < n2.length; t4++) {
          if ("string" != typeof n2[t4])
            throw new Error("Serialization of non-string loss is not supported.");
        }
        e3 = this.loss.map(function(e4) {
          return toSnakeCase(e4);
        });
      } else {
        var r2 = Object.keys(this.loss);
        e3 = {};
        for (var i2 = this.loss, a2 = 0, o2 = r2; a2 < o2.length; a2++) {
          var s2 = o2[a2];
          if ("string" != typeof i2[s2])
            throw new Error("Serialization of non-string loss is not supported.");
          e3[s2] = toSnakeCase(i2[s2]);
        }
      }
      return e3;
    }, t3.prototype.getMetricIdentifiers = function() {
      if ("string" == typeof this.metrics || "function" == typeof this.metrics)
        return [toSnakeCase(getLossOrMetricName(this.metrics))];
      if (Array.isArray(this.metrics))
        return this.metrics.map(function(e4) {
          return toSnakeCase(getLossOrMetricName(e4));
        });
      var e3 = {};
      for (var t4 in this.metrics)
        e3[t4] = toSnakeCase(getLossOrMetricName(this.metrics[t4]));
      return e3;
    }, t3.prototype.getTrainingConfig = function() {
      return { loss: this.getLossIdentifiers(), metrics: this.getMetricIdentifiers(), optimizer_config: { class_name: this.optimizer.getClassName(), config: this.optimizer.getConfig() } };
    }, t3.prototype.loadTrainingConfig = function(e3) {
      if (null != e3.weighted_metrics)
        throw new Error("Loading weight_metrics is not supported yet.");
      if (null != e3.loss_weights)
        throw new Error("Loading loss_weights is not supported yet.");
      if (null != e3.sample_weight_mode)
        throw new Error("Loading sample_weight_mode is not supported yet.");
      var t4, n2, r2 = deserialize(convertPythonicToTs(e3.optimizer_config));
      if ("string" == typeof e3.loss)
        t4 = toCamelCase(e3.loss);
      else if (Array.isArray(e3.loss))
        t4 = e3.loss.map(function(e4) {
          return toCamelCase(e4);
        });
      else if (null != e3.loss)
        for (var i2 in t4 = {}, e3.loss)
          t4[i2] = toCamelCase(e3.loss[i2]);
      if (Array.isArray(e3.metrics))
        n2 = e3.metrics.map(function(e4) {
          return toCamelCase(e4);
        });
      else if (null != e3.metrics)
        for (var i2 in n2 = {}, e3.metrics)
          n2[i2] = toCamelCase(e3.metrics[i2]);
      this.compile({ loss: t4, metrics: n2, optimizer: r2 });
    }, t3.prototype.save = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        var n2, r2, i2, a2, o2, s2, l3, u2, c2, p2, h, d2, f2, g2;
        return __generator(this, function(m2) {
          switch (m2.label) {
            case 0:
              if ("string" == typeof e3) {
                if (0 === (n2 = Sf.getSaveHandlers(e3)).length)
                  throw new ValueError("Cannot find any save handlers for URL '" + e3 + "'");
                if (n2.length > 1)
                  throw new ValueError("Found more than one (" + n2.length + ") save handlers for URL '" + e3 + "'");
                e3 = n2[0];
              }
              if (null == e3.save)
                throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
              return [4, Sf.encodeWeights(this.getNamedWeights(t4))];
            case 1:
              return r2 = m2.sent(), i2 = false, a2 = null, o2 = this.toJSON(a2, i2), s2 = { modelTopology: o2, format: LAYERS_MODEL_FORMAT_NAME, generatedBy: "TensorFlow.js tfjs-layers v" + version, convertedBy: null }, null != t4 && t4.includeOptimizer && null != this.optimizer ? (s2.trainingConfig = this.getTrainingConfig(), l3 = "optimizer", d2 = (h = Sf).encodeWeights, [4, this.optimizer.getWeights()]) : [3, 4];
            case 2:
              return [4, d2.apply(h, [m2.sent(), l3])];
            case 3:
              u2 = m2.sent(), c2 = u2.data, p2 = u2.specs, (g2 = r2.specs).push.apply(g2, p2), r2.data = Sf.concatenateArrayBuffers([r2.data, c2]), m2.label = 4;
            case 4:
              return null != this.userDefinedMetadata && (f2 = true, checkUserDefinedMetadata(this.userDefinedMetadata, this.name, f2), s2.userDefinedMetadata = this.userDefinedMetadata), s2.weightData = r2.data, s2.weightSpecs = r2.specs, [2, e3.save(s2)];
          }
        });
      });
    }, t3.prototype.setUserDefinedMetadata = function(e3) {
      checkUserDefinedMetadata(e3, this.name), this.userDefinedMetadata = e3;
    }, t3.prototype.getUserDefinedMetadata = function() {
      return this.userDefinedMetadata;
    }, t3.className = "Model", t3;
  }(Container);
  function modelFromJSON(e2, t3) {
    return __awaiter(this, void 0, void 0, function() {
      var n2, r2, i2, a2, o2, s2, l3, u2;
      return __generator(this, function(c2) {
        switch (c2.label) {
          case 0:
            return "modelTopology" in e2 || (e2 = { modelTopology: e2 }), null != (n2 = (e2 = e2).modelTopology).model_config && (n2 = n2.model_config), r2 = convertPythonicToTs(n2), i2 = deserialize(r2, t3), null == e2.weightsManifest ? [3, 2] : [4, Sf.loadWeights(e2.weightsManifest, e2.pathPrefix, i2.weights.map(function(e3) {
              return e3.originalName;
            }))];
          case 1:
            for (a2 = c2.sent(), o2 = {}, s2 = 0, l3 = i2.weights; s2 < l3.length; s2++)
              u2 = l3[s2], o2[u2.originalName] = a2[u2.originalName];
            i2.loadWeights(o2), Xe(a2), c2.label = 2;
          case 2:
            return [2, i2];
        }
      });
    });
  }
  function loadLayersModelInternal(e2, t3) {
    return __awaiter(this, void 0, void 0, function() {
      var n2;
      return __generator(this, function(r2) {
        if (null == t3 && (t3 = {}), "string" == typeof e2) {
          if (0 === (n2 = Sf.getLoadHandlers(e2, t3.onProgress)).length)
            n2.push(Sf.browserHTTPRequest(e2, t3));
          else if (n2.length > 1)
            throw new ValueError("Found more than one (" + n2.length + ") load handlers for URL '" + e2 + "'");
          e2 = n2[0];
        }
        return [2, loadLayersModelFromIOHandler(e2, void 0, t3)];
      });
    });
  }
  function loadLayersModelFromIOHandler(e2, t3, n2) {
    return __awaiter(this, void 0, void 0, function() {
      var r2, i2, a2, o2, s2, l3, u2, c2, p2;
      return __generator(this, function(h) {
        switch (h.label) {
          case 0:
            if (null == n2 && (n2 = {}), null == e2.load)
              throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
            return [4, e2.load()];
          case 1:
            if (r2 = h.sent(), null != (i2 = r2.modelTopology).model_config && (i2 = i2.model_config), a2 = null == n2.strict || n2.strict, o2 = null != r2.weightData && null != r2.weightSpecs && a2, s2 = deserialize(convertPythonicToTs(i2), t3, o2), null != (l3 = r2.trainingConfig) && s2.loadTrainingConfig(l3), null != r2.userDefinedMetadata && s2.setUserDefinedMetadata(r2.userDefinedMetadata), null == r2.weightData)
              return [3, 4];
            if (null == r2.weightSpecs)
              throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
            return u2 = decodeModelAndOptimizerWeights(r2.weightData, r2.weightSpecs), c2 = u2.modelWeights, p2 = u2.optimizerWeights, s2.loadWeights(c2, a2), null != s2.optimizer && p2.length > 0 ? [4, s2.optimizer.setWeights(p2)] : [3, 3];
          case 2:
            h.sent(), h.label = 3;
          case 3:
            Xe(c2), Xe(p2.map(function(e3) {
              return e3.tensor;
            })), h.label = 4;
          case 4:
            return [2, s2];
        }
      });
    });
  }
  function decodeModelAndOptimizerWeights(e2, t3) {
    var n2 = Sf.decodeWeights(e2, t3), r2 = {}, i2 = [];
    return t3.forEach(function(e3) {
      "optimizer" === e3.group ? i2.push({ name: e3.name, tensor: n2[e3.name] }) : r2[e3.name] = n2[e3.name];
    }), { modelWeights: r2, optimizerWeights: i2 };
  }
  Mf.registerClass(LayersModel);
  var Sequential = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, { inputs: [], outputs: [] }) || this;
      if (t4 = t4 || {}, n2.trainable = true, n2.built = false, n2.name = null != t4.name ? t4.name : getUid("sequential_"), null != t4.layers)
        for (var r2 = 0, i2 = t4.layers; r2 < i2.length; r2++) {
          var a2 = i2[r2];
          n2.add(a2);
        }
      return n2;
    }
    return __extends(t3, e2), t3.prototype.checkShape = function(e3) {
      if (e3.inboundNodes[0].outputTensors[0].shape.some(function(e4) {
        return e4 < 0;
      }))
        throw new ValueError("Negative dimension size caused by adding layer " + e3.name + " with input shape [" + e3.inboundNodes[0].inputTensors[0].shape + "]");
    }, t3.prototype.add = function(e3) {
      var n2, r2 = e3 instanceof t3 || e3 instanceof LayersModel;
      if (r2) {
        if (1 !== (n2 = e3).outputs.length)
          throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        if (1 !== n2.inputs.length)
          throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
      }
      if (0 === this.outputs.length) {
        if (0 === e3.inboundNodes.length) {
          if (null == e3.batchInputShape)
            throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
          var i2 = Input({ batchShape: e3.batchInputShape, dtype: e3.dtype, name: e3.name + "_input" });
          e3.apply(i2);
        }
        if (r2)
          this.outputs = n2.outputs, this.inputs = n2.inputs;
        else {
          if (1 !== e3.inboundNodes.length)
            throw new ValueError("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer " + e3.name + " which has " + e3.inboundNodes.length + " pre-existing inbound connections.");
          if (1 !== e3.inboundNodes[0].outputTensors.length)
            throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          this.checkShape(e3), this.outputs = [e3.inboundNodes[0].outputTensors[0]], this.inputs = getSourceInputs(this.outputs[0]);
        }
        this.inboundNodes = [], new Node({ outboundLayer: this, inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: this.inputs, outputTensors: this.outputs, inputMasks: pyListRepeat(null, this.inputs.length), outputMasks: [null], inputShapes: this.inputs.map(function(e4) {
          return e4.shape;
        }), outputShapes: this.outputs[0].shape });
      } else {
        var a2 = e3.apply(this.outputs[0]);
        if (Array.isArray(a2))
          throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(e3), this.outputs = [a2], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
      }
      this.layers.push(e3), this.built = false;
    }, t3.prototype.pop = function() {
      if (0 === this.layers.length)
        throw new TypeError("There are no layers in the model.");
      if (this.layers.pop(), 0 === this.layers.length)
        this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
      else {
        var e3 = this.layers.length - 1;
        this.layers[e3].outboundNodes = [], this.outputs = [this.layers[e3].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
      }
    }, t3.prototype.call = function(e3, t4) {
      return null == this.model && this.build(), this.model.call(e3, t4);
    }, t3.prototype.build = function(e3) {
      if (getExactlyOneShape(e3), 0 === this.inputs.length || 0 === this.outputs.length)
        throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
      this.model = new LayersModel({ inputs: this.inputs, outputs: this.outputs[0], name: this.name + "_model" }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = true;
    }, t3.prototype.countParams = function() {
      return this.built || this.build(), e2.prototype.countParams.call(this);
    }, t3.prototype.summary = function(t4, n2, r2) {
      void 0 === r2 && (r2 = console.log), this.built || this.build(), e2.prototype.summary.call(this, t4, n2, r2);
    }, t3.prototype.setWeights = function(e3) {
      null == this.model && this.build(), this.model.setWeights(e3);
    }, t3.prototype.evaluate = function(e3, t4, n2) {
      if (void 0 === n2 && (n2 = {}), !this.built)
        throw new RuntimeError("The model needs to be compiled before being used.");
      return this.model.evaluate(e3, t4, n2);
    }, t3.prototype.evaluateDataset = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(n2) {
          if (!this.built)
            throw new RuntimeError("The model needs to be compiled before being used.");
          return [2, this.model.evaluateDataset(e3, t4)];
        });
      });
    }, t3.prototype.predict = function(e3, t4) {
      return void 0 === t4 && (t4 = {}), null == this.model && this.build(), this.model.predict(e3, t4);
    }, t3.prototype.predictOnBatch = function(e3) {
      return null == this.model && this.build(), this.model.predictOnBatch(e3);
    }, t3.prototype.compile = function(e3) {
      this.build(), this.model.compile(e3), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
    }, Object.defineProperty(t3.prototype, "optimizer", { get: function() {
      return null == this.model ? void 0 : this.model.optimizer;
    }, set: function(e3) {
      this.model.optimizer = e3;
    }, enumerable: true, configurable: true }), t3.prototype.fit = function(e3, t4, n2) {
      return void 0 === n2 && (n2 = {}), __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(r2) {
          if (!this.built)
            throw new RuntimeError("The model needs to be compiled before being used.");
          return [2, this.model.fit(e3, t4, n2)];
        });
      });
    }, t3.prototype.fitDataset = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(n2) {
          if (!this.built)
            throw new RuntimeError("The model needs to be compiled before being used.");
          return [2, this.model.fitDataset(e3, t4)];
        });
      });
    }, t3.prototype.trainOnBatch = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(n2) {
          return [2, this.model.trainOnBatch(e3, t4)];
        });
      });
    }, t3.fromConfig = function(e3, n2, r2, i2) {
      var a2;
      void 0 === r2 && (r2 = {}), void 0 === i2 && (i2 = false);
      var o2 = {};
      if (n2 instanceof Array) {
        if (null == n2[0].className || "Merge" === n2[0].className)
          throw new ValueError("Legacy serialization format not supported yet.");
        a2 = n2;
      } else
        tt.assert(null != n2.layers, function() {
          return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.";
        }), a2 = n2.layers, delete n2.layers, o2 = n2;
      var s2 = new e3(o2);
      if (!(s2 instanceof t3))
        throw new NotImplementedError("Sequential.fromConfig called on non-Sequential input: " + s2);
      for (var l3 = 0, u2 = a2; l3 < u2.length; l3++) {
        var c2 = deserialize(u2[l3], void 0, i2);
        i2 && c2.setFastWeightInitDuringBuild(true), s2.add(c2);
      }
      return s2;
    }, Object.defineProperty(t3.prototype, "stopTraining", { get: function() {
      if (null == this.model)
        throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");
      return this.model.stopTraining;
    }, set: function(e3) {
      if (null == this.model)
        throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");
      this.model.stopTraining = e3;
    }, enumerable: true, configurable: true }), t3.prototype.getConfig = function() {
      for (var e3 = [], t4 = 0, n2 = this.layers; t4 < n2.length; t4++) {
        var r2 = n2[t4], i2 = {};
        i2.className = r2.getClassName(), i2.config = r2.getConfig(), e3.push(i2);
      }
      return { name: this.name, layers: e3 };
    }, t3.className = "Sequential", t3;
  }(LayersModel);
  function loadLayersModel(e2, t3) {
    return null == t3 && (t3 = {}), loadLayersModelInternal(e2, t3);
  }
  function input(e2) {
    return Input(e2);
  }
  Mf.registerClass(Sequential);
  var Activation = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.getConfig = function() {
      return {};
    }, t3;
  }(Mf.Serializable);
  var Elu = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      return void 0 === t4 && (t4 = 1), elu$1(e3, t4);
    }, t3.className = "elu", t3;
  }(Activation);
  Mf.registerClass(Elu);
  var Selu = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      return Cl(e3);
    }, t3.className = "selu", t3;
  }(Activation);
  Mf.registerClass(Selu);
  var Relu = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      return bl(e3);
    }, t3.className = "relu", t3;
  }(Activation);
  Mf.registerClass(Relu);
  var Relu6 = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      return je(function() {
        return Ys(6, bl(e3));
      });
    }, t3.className = "relu6", t3;
  }(Activation);
  Mf.registerClass(Relu6);
  var Linear = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      return e3;
    }, t3.className = "linear", t3;
  }(Activation);
  Mf.registerClass(Linear);
  var Sigmoid = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      return cs(e3);
    }, t3.className = "sigmoid", t3;
  }(Activation);
  Mf.registerClass(Sigmoid);
  var HardSigmoid = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      return hardSigmoid(e3);
    }, t3.className = "hardSigmoid", t3;
  }(Activation);
  Mf.registerClass(HardSigmoid);
  var Softplus = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      return ms(e3);
    }, t3.className = "softplus", t3;
  }(Activation);
  Mf.registerClass(Softplus);
  var Softsign = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      return softsign(e3);
    }, t3.className = "softsign", t3;
  }(Activation);
  Mf.registerClass(Softsign);
  var Tanh = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      return bs(e3);
    }, t3.className = "tanh", t3;
  }(Activation);
  Mf.registerClass(Tanh);
  var Softmax = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      return void 0 === t4 && (t4 = -1), io(e3, t4);
    }, t3.className = "softmax", t3;
  }(Activation);
  Mf.registerClass(Softmax);
  var LogSoftmax = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3, t4) {
      return void 0 === t4 && (t4 = -1), uo(e3, t4);
    }, t3.className = "logSoftmax", t3;
  }(Activation);
  function serializeActivation(e2) {
    return e2.getClassName();
  }
  function deserializeActivation(e2, t3) {
    return void 0 === t3 && (t3 = {}), deserializeKerasObject(e2, Mf.SerializationMap.getMap().classNameMap, t3, "activation");
  }
  function getActivation(e2) {
    var t3;
    return null == e2 ? deserializeActivation(t3 = { className: "linear", config: {} }) : "string" == typeof e2 ? ((t3 = {}).className = e2, t3.config = {}, deserializeActivation(t3)) : e2 instanceof Activation ? e2 : deserializeActivation(e2);
  }
  function assertObjectArgs(e2) {
    if (null != e2 && "object" != typeof e2)
      throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: " + e2);
  }
  Mf.registerClass(LogSoftmax);
  var Regularizer = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3;
  }(Mf.Serializable);
  var L1L2 = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      return assertObjectArgs(t4), n2.l1 = null == t4 || null == t4.l1 ? 0.01 : t4.l1, n2.l2 = null == t4 || null == t4.l2 ? 0.01 : t4.l2, n2.hasL1 = 0 !== n2.l1, n2.hasL2 = 0 !== n2.l2, n2;
    }
    return __extends(t3, e2), t3.prototype.apply = function(e3) {
      var t4 = this;
      return je(function() {
        var n2 = Pn([1]);
        return t4.hasL1 && (n2 = Vs(n2, vl(tc(t4.l1, Vu(e3))))), t4.hasL2 && (n2 = Vs(n2, vl(tc(t4.l2, square(e3))))), n2.asScalar();
      });
    }, t3.prototype.getConfig = function() {
      return { l1: this.l1, l2: this.l2 };
    }, t3.fromConfig = function(e3, t4) {
      return new e3({ l1: t4.l1, l2: t4.l2 });
    }, t3.className = "L1L2", t3;
  }(Regularizer);
  function l1(e2) {
    return assertObjectArgs(e2), new L1L2({ l1: null != e2 ? e2.l1 : null, l2: 0 });
  }
  function l2(e2) {
    return assertObjectArgs(e2), new L1L2({ l2: null != e2 ? e2.l2 : null, l1: 0 });
  }
  Mf.registerClass(L1L2);
  var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = { l1l2: "L1L2" };
  function serializeRegularizer(e2) {
    return serializeKerasObject(e2);
  }
  function deserializeRegularizer(e2, t3) {
    return void 0 === t3 && (t3 = {}), deserializeKerasObject(e2, Mf.SerializationMap.getMap().classNameMap, t3, "regularizer");
  }
  function getRegularizer(e2) {
    return null == e2 ? null : "string" == typeof e2 ? deserializeRegularizer({ className: e2 in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e2] : e2, config: {} }) : e2 instanceof Regularizer ? e2 : deserializeRegularizer(e2);
  }
  var ReLU = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, null == t4 ? {} : t4) || this;
      return n2.supportsMasking = true, null != t4 && (n2.maxValue = t4.maxValue), n2;
    }
    return __extends(t3, e2), t3.prototype.call = function(e3, t4) {
      e3 = getExactlyOneTensor(e3);
      var n2 = bl(e3);
      return null != this.maxValue && (n2 = $u(n2, 0, this.maxValue)), n2;
    }, t3.prototype.computeOutputShape = function(e3) {
      return e3;
    }, t3.prototype.getConfig = function() {
      var t4 = { maxValue: this.maxValue }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "ReLU", t3;
  }(Layer);
  Mf.registerClass(ReLU);
  var LeakyReLU = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, null == t4 ? {} : t4) || this;
      return n2.DEFAULT_ALPHA = 0.3, null == t4 && (t4 = {}), n2.alpha = null == t4.alpha ? n2.DEFAULT_ALPHA : t4.alpha, n2;
    }
    return __extends(t3, e2), t3.prototype.call = function(e3, t4) {
      var n2 = getExactlyOneTensor(e3);
      return yl(n2, this.alpha);
    }, t3.prototype.computeOutputShape = function(e3) {
      return e3;
    }, t3.prototype.getConfig = function() {
      var t4 = { alpha: this.alpha }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "LeakyReLU", t3;
  }(Layer);
  Mf.registerClass(LeakyReLU);
  var PReLU = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, null == t4 ? {} : t4) || this;
      if (n2.DEFAULT_ALPHA_INITIALIZER = "zeros", null == t4 && (t4 = {}), n2.supportsMasking = true, n2.alphaInitializer = getInitializer(t4.alphaInitializer || n2.DEFAULT_ALPHA_INITIALIZER), n2.alphaRegularizer = getRegularizer(t4.alphaRegularizer), n2.alphaConstraint = getConstraint(t4.alphaConstraint), null == t4.sharedAxes)
        n2.sharedAxes = null;
      else if (Array.isArray(t4.sharedAxes))
        n2.sharedAxes = t4.sharedAxes;
      else {
        if ("number" != typeof t4.sharedAxes)
          throw new ValueError("Expected sharedAxes to be a number or an array of numbers, but got " + t4.sharedAxes);
        n2.sharedAxes = [t4.sharedAxes];
      }
      return n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      var t4 = (e3 = getExactlyOneShape(e3)).slice(1);
      if (null != this.sharedAxes)
        for (var n2 = 0, r2 = this.sharedAxes; n2 < r2.length; n2++) {
          t4[(a2 = r2[n2]) - 1] = 1;
        }
      this.alpha = this.addWeight("alpha", t4, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
      var i2 = {};
      if (null != this.sharedAxes)
        for (var a2 = 1; a2 < e3.length; ++a2)
          i2[a2] = e3[a2];
      this.inputSpec = [new InputSpec({ ndim: e3.length, axes: i2 })], this.built = true;
    }, t3.prototype.call = function(e3, t4) {
      return e3 = getExactlyOneTensor(e3), xl(e3, this.alpha.read());
    }, t3.prototype.getConfig = function() {
      var t4 = { alphaInitializer: serializeInitializer(this.alphaInitializer), alphaRegularizer: serializeRegularizer(this.alphaRegularizer), alphaConstraint: serializeConstraint(this.alphaConstraint), sharedAxes: this.sharedAxes }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "PReLU", t3;
  }(Layer);
  Mf.registerClass(PReLU);
  var ELU = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, null == t4 ? {} : t4) || this;
      if (n2.DEFAULT_ALPHA = 1, null == t4 && (t4 = {}), null != t4.alpha && t4.alpha !== n2.DEFAULT_ALPHA)
        throw new NotImplementedError("Non-default alpha value (" + t4.alpha + ") is not supported by the ELU layer yet.");
      return n2.alpha = null == t4.alpha ? n2.DEFAULT_ALPHA : t4.alpha, n2;
    }
    return __extends(t3, e2), t3.prototype.call = function(e3, t4) {
      var n2 = getExactlyOneTensor(e3);
      return gl(n2);
    }, t3.prototype.computeOutputShape = function(e3) {
      return e3;
    }, t3.prototype.getConfig = function() {
      var t4 = { alpha: this.alpha }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "ELU", t3;
  }(Layer);
  Mf.registerClass(ELU);
  var ThresholdedReLU = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, null == t4 ? {} : t4) || this;
      return n2.DEFAULT_THETA = 1, null == t4 && (t4 = {}), n2.theta = null == t4.theta ? n2.DEFAULT_THETA : t4.theta, n2;
    }
    return __extends(t3, e2), t3.prototype.call = function(e3, t4) {
      var n2 = getExactlyOneTensor(e3);
      return n2.mul(cast$1(n2.greater(this.theta), "float32"));
    }, t3.prototype.computeOutputShape = function(e3) {
      return e3;
    }, t3.prototype.getConfig = function() {
      var t4 = { theta: this.theta }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "ThresholdedReLU", t3;
  }(Layer);
  Mf.registerClass(ThresholdedReLU);
  var Softmax$1 = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, null == t4 ? {} : t4) || this;
      return n2.DEFAULT_AXIS = 1, null == t4 && (t4 = {}), n2.softmax = new Softmax().apply, n2.axis = null == t4.axis ? n2.DEFAULT_AXIS : t4.axis, n2;
    }
    return __extends(t3, e2), t3.prototype.call = function(e3, t4) {
      var n2 = getExactlyOneTensor(e3);
      return this.softmax(n2, this.axis);
    }, t3.prototype.computeOutputShape = function(e3) {
      return e3;
    }, t3.prototype.getConfig = function() {
      var t4 = { axis: this.axis }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "Softmax", t3;
  }(Layer);
  function normalizeArray(e2, t3, n2) {
    if ("number" == typeof e2)
      return pyListRepeat(e2, t3);
    if (e2.length !== t3)
      throw new ValueError("The " + n2 + " argument must be an integer or tuple of " + t3 + " integers. Received: " + e2.length + " elements.");
    for (var r2 = 0; r2 < t3; ++r2) {
      var i2 = e2[r2];
      if (!isInteger(i2))
        throw new ValueError("The " + n2 + " argument must be an integer or tuple of " + t3 + " integers. Received: " + JSON.stringify(e2) + " including a non-integer number " + i2);
    }
    return e2;
  }
  function convOutputLength(e2, t3, n2, r2, i2) {
    return void 0 === i2 && (i2 = 1), null == e2 ? e2 : (a2 = "same" === n2 ? e2 : e2 - (t3 + (t3 - 1) * (i2 - 1)) + 1, Math.floor((a2 + r2 - 1) / r2));
    var a2;
  }
  function deconvLength(e2, t3, n2, r2) {
    if (null == e2)
      return null;
    if ("valid" === r2)
      e2 = e2 * t3 + max$1([n2 - t3, 0]);
    else {
      if ("same" !== r2)
        throw new ValueError("Unsupport padding mode: " + r2 + ".");
      e2 *= t3;
    }
    return e2;
  }
  function preprocessConv2DInput(e2, t3) {
    return je(function() {
      return checkDataFormat(t3), "channelsFirst" === t3 ? El(e2, [0, 2, 3, 1]) : e2;
    });
  }
  function preprocessConv3DInput(e2, t3) {
    return je(function() {
      return checkDataFormat(t3), "channelsFirst" === t3 ? El(e2, [0, 2, 3, 4, 1]) : e2;
    });
  }
  function conv1dWithBias(e2, t3, n2, r2, i2, a2, o2) {
    return void 0 === r2 && (r2 = 1), void 0 === i2 && (i2 = "valid"), void 0 === o2 && (o2 = 1), je(function() {
      if (null == a2 && (a2 = imageDataFormat()), checkDataFormat(a2), 3 !== e2.shape.length)
        throw new ValueError("The input of a conv1dWithBias operation should be 3, but is " + e2.shape.length + " instead.");
      if (3 !== t3.shape.length)
        throw new ValueError("The kernel for a conv1dWithBias operation should be 3, but is " + t3.shape.length + " instead");
      if (null != n2 && 1 !== n2.shape.length)
        throw new ValueError("The bias for a conv1dWithBias operation should be 1, but is " + t3.shape.length + " instead");
      if ("channelsFirst" === a2 && (e2 = El(e2, [0, 2, 1])), "causal" === i2)
        throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      var s2 = Ac(e2, t3, r2, "same" === i2 ? "same" : "valid", "NWC", o2);
      return null != n2 && (s2 = biasAdd(s2, n2)), s2;
    });
  }
  function conv2dWithBiasActivation(e2, t3, n2, r2, i2, a2, o2, s2) {
    return void 0 === r2 && (r2 = [1, 1]), void 0 === i2 && (i2 = "valid"), void 0 === s2 && (s2 = null), je(function() {
      if (null == a2 && (a2 = imageDataFormat()), checkDataFormat(a2), 3 !== e2.rank && 4 !== e2.rank)
        throw new ValueError("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received " + e2.rank + ".");
      if (3 !== t3.rank && 4 !== t3.rank)
        throw new ValueError("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received " + e2.rank + ".");
      var l3 = preprocessConv2DInput(e2, a2);
      if ("causal" === i2)
        throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      return l3 = Eh.conv2d({ x: l3, filter: t3, strides: r2, pad: "same" === i2 ? "same" : "valid", dilations: o2, dataFormat: "NHWC", bias: n2, activation: s2 }), "channelsFirst" === a2 && (l3 = El(l3, [0, 3, 1, 2])), l3;
    });
  }
  function conv3dWithBias(e2, t3, n2, r2, i2, a2, o2) {
    return void 0 === r2 && (r2 = [1, 1, 1]), void 0 === i2 && (i2 = "valid"), je(function() {
      if (null == a2 && (a2 = imageDataFormat()), checkDataFormat(a2), 4 !== e2.rank && 5 !== e2.rank)
        throw new ValueError("conv3dWithBias expects input to be of rank 4 or 5, but received " + e2.rank + ".");
      if (4 !== t3.rank && 5 !== t3.rank)
        throw new ValueError("conv3dWithBias expects kernel to be of rank 4 or 5, but received " + e2.rank + ".");
      var s2 = preprocessConv3DInput(e2, a2);
      if ("causal" === i2)
        throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
      return s2 = Tc(s2, t3, r2, "same" === i2 ? "same" : "valid", "NDHWC", o2), null != n2 && (s2 = biasAdd(s2, n2)), "channelsFirst" === a2 && (s2 = El(s2, [0, 4, 1, 2, 3])), s2;
    });
  }
  Mf.registerClass(Softmax$1);
  var BaseConv = function(e2) {
    function t3(n2, r2) {
      var i2 = e2.call(this, r2) || this;
      if (i2.bias = null, i2.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", i2.DEFAULT_BIAS_INITIALIZER = "zeros", t3.verifyArgs(r2), i2.rank = n2, assertPositiveInteger(i2.rank, "rank"), 1 !== i2.rank && 2 !== i2.rank && 3 !== i2.rank)
        throw new NotImplementedError("Convolution layer for rank other than 1, 2, or 3 (" + i2.rank + ") is not implemented yet.");
      if (i2.kernelSize = normalizeArray(r2.kernelSize, n2, "kernelSize"), i2.strides = normalizeArray(null == r2.strides ? 1 : r2.strides, n2, "strides"), i2.padding = null == r2.padding ? "valid" : r2.padding, checkPaddingMode(i2.padding), i2.dataFormat = null == r2.dataFormat ? "channelsLast" : r2.dataFormat, checkDataFormat(i2.dataFormat), i2.activation = getActivation(r2.activation), i2.useBias = null == r2.useBias || r2.useBias, i2.biasInitializer = getInitializer(r2.biasInitializer || i2.DEFAULT_BIAS_INITIALIZER), i2.biasConstraint = getConstraint(r2.biasConstraint), i2.biasRegularizer = getRegularizer(r2.biasRegularizer), i2.activityRegularizer = getRegularizer(r2.activityRegularizer), i2.dilationRate = normalizeArray(null == r2.dilationRate ? 1 : r2.dilationRate, n2, "dilationRate"), 1 === i2.rank && Array.isArray(i2.dilationRate) && 1 !== i2.dilationRate.length)
        throw new ValueError("dilationRate must be a number or an array of a single number for 1D convolution, but received " + JSON.stringify(i2.dilationRate));
      if (2 === i2.rank) {
        if ("number" == typeof i2.dilationRate)
          i2.dilationRate = [i2.dilationRate, i2.dilationRate];
        else if (2 !== i2.dilationRate.length)
          throw new ValueError("dilationRate must be a number or array of two numbers for 2D convolution, but received " + JSON.stringify(i2.dilationRate));
      } else if (3 === i2.rank) {
        if ("number" == typeof i2.dilationRate)
          i2.dilationRate = [i2.dilationRate, i2.dilationRate, i2.dilationRate];
        else if (3 !== i2.dilationRate.length)
          throw new ValueError("dilationRate must be a number or array of three numbers for 3D convolution, but received " + JSON.stringify(i2.dilationRate));
      }
      return i2;
    }
    return __extends(t3, e2), t3.verifyArgs = function(e3) {
      if (assert("kernelSize" in e3, "required key 'kernelSize' not in config"), "number" != typeof e3.kernelSize && !checkArrayTypeAndLength(e3.kernelSize, "number", 1, 3))
        throw new ValueError("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received " + JSON.stringify(e3.kernelSize) + ".");
    }, t3.prototype.getConfig = function() {
      var t4 = { kernelSize: this.kernelSize, strides: this.strides, padding: this.padding, dataFormat: this.dataFormat, dilationRate: this.dilationRate, activation: serializeActivation(this.activation), useBias: this.useBias, biasInitializer: serializeInitializer(this.biasInitializer), biasRegularizer: serializeRegularizer(this.biasRegularizer), activityRegularizer: serializeRegularizer(this.activityRegularizer), biasConstraint: serializeConstraint(this.biasConstraint) }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3;
  }(Layer);
  var Conv = function(e2) {
    function t3(n2, r2) {
      var i2 = e2.call(this, n2, r2) || this;
      return i2.kernel = null, t3.verifyArgs(r2), i2.filters = r2.filters, assertPositiveInteger(i2.filters, "filters"), i2.kernelInitializer = getInitializer(r2.kernelInitializer || i2.DEFAULT_KERNEL_INITIALIZER), i2.kernelConstraint = getConstraint(r2.kernelConstraint), i2.kernelRegularizer = getRegularizer(r2.kernelRegularizer), i2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      var t4;
      e3 = getExactlyOneShape(e3);
      var n2 = "channelsFirst" === this.dataFormat ? 1 : e3.length - 1;
      if (null == e3[n2])
        throw new ValueError("The channel dimension of the input should be defined. Found " + e3[n2]);
      var r2 = e3[n2], i2 = this.kernelSize.concat([r2, this.filters]);
      this.kernel = this.addWeight("kernel", i2, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [{ ndim: this.rank + 2, axes: (t4 = {}, t4[n2] = r2, t4) }], this.built = true;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var t5;
        e3 = getExactlyOneTensor(e3);
        var r2 = null == n2.bias ? null : n2.bias.read(), i2 = mapActivationToFusedKernel(n2.activation.getClassName());
        if (null != i2 && 2 === n2.rank)
          t5 = conv2dWithBiasActivation(e3, n2.kernel.read(), r2, n2.strides, n2.padding, n2.dataFormat, n2.dilationRate, i2);
        else {
          if (1 === n2.rank)
            t5 = conv1dWithBias(e3, n2.kernel.read(), r2, n2.strides[0], n2.padding, n2.dataFormat, n2.dilationRate[0]);
          else if (2 === n2.rank)
            t5 = conv2dWithBiasActivation(e3, n2.kernel.read(), r2, n2.strides, n2.padding, n2.dataFormat, n2.dilationRate);
          else {
            if (3 !== n2.rank)
              throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");
            t5 = conv3dWithBias(e3, n2.kernel.read(), r2, n2.strides, n2.padding, n2.dataFormat, n2.dilationRate);
          }
          null != n2.activation && (t5 = n2.activation.apply(t5));
        }
        return t5;
      });
    }, t3.prototype.computeOutputShape = function(e3) {
      e3 = getExactlyOneShape(e3);
      for (var t4 = [], n2 = "channelsLast" === this.dataFormat ? e3.slice(1, e3.length - 1) : e3.slice(2), r2 = 0; r2 < n2.length; ++r2) {
        var i2 = convOutputLength(n2[r2], this.kernelSize[r2], this.padding, this.strides[r2], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r2]);
        t4.push(i2);
      }
      var a2 = [e3[0]];
      return "channelsLast" === this.dataFormat ? (a2 = a2.concat(t4)).push(this.filters) : (a2.push(this.filters), a2 = a2.concat(t4)), a2;
    }, t3.prototype.getConfig = function() {
      var t4 = { filters: this.filters, kernelInitializer: serializeInitializer(this.kernelInitializer), kernelRegularizer: serializeRegularizer(this.kernelRegularizer), kernelConstraint: serializeConstraint(this.kernelConstraint) }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.verifyArgs = function(e3) {
      if (!("filters" in e3) || "number" != typeof e3.filters || e3.filters < 1)
        throw new ValueError("Convolution layer expected config.filters to be a 'number' > 0 but got " + JSON.stringify(e3.filters));
    }, t3;
  }(BaseConv);
  var Conv2D = function(e2) {
    function t3(n2) {
      var r2 = e2.call(this, 2, n2) || this;
      return t3.verifyArgs(n2), r2;
    }
    return __extends(t3, e2), t3.prototype.getConfig = function() {
      var t4 = e2.prototype.getConfig.call(this);
      return delete t4.rank, t4;
    }, t3.verifyArgs = function(e3) {
      if ("number" != typeof e3.kernelSize && !checkArrayTypeAndLength(e3.kernelSize, "number", 1, 2))
        throw new ValueError("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received " + JSON.stringify(e3.kernelSize) + ".");
    }, t3.className = "Conv2D", t3;
  }(Conv);
  Mf.registerClass(Conv2D);
  var Conv3D = function(e2) {
    function t3(n2) {
      var r2 = e2.call(this, 3, n2) || this;
      return t3.verifyArgs(n2), r2;
    }
    return __extends(t3, e2), t3.prototype.getConfig = function() {
      var t4 = e2.prototype.getConfig.call(this);
      return delete t4.rank, t4;
    }, t3.verifyArgs = function(e3) {
      if ("number" != typeof e3.kernelSize && (!Array.isArray(e3.kernelSize) || 1 !== e3.kernelSize.length && 3 !== e3.kernelSize.length))
        throw new ValueError("Conv3D expects config.kernelSize to be number or [number, number, number], but received " + JSON.stringify(e3.kernelSize) + ".");
    }, t3.className = "Conv3D", t3;
  }(Conv);
  Mf.registerClass(Conv3D);
  var Conv2DTranspose = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      if (n2.inputSpec = [new InputSpec({ ndim: 4 })], "same" !== n2.padding && "valid" !== n2.padding)
        throw new ValueError("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode " + n2.padding);
      return n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      var t4;
      if (4 !== (e3 = getExactlyOneShape(e3)).length)
        throw new ValueError("Input should have rank 4; Received input shape: " + JSON.stringify(e3));
      var n2 = "channelsFirst" === this.dataFormat ? 1 : e3.length - 1;
      if (null == e3[n2])
        throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");
      var r2 = e3[n2], i2 = this.kernelSize.concat([this.filters, r2]);
      this.kernel = this.addWeight("kernel", i2, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [new InputSpec({ ndim: 4, axes: (t4 = {}, t4[n2] = r2, t4) })], this.built = true;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var t5 = getExactlyOneTensor(e3);
        if (4 !== t5.shape.length)
          throw new ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-" + t5.shape.length);
        var r2, i2, a2 = t5.shape, o2 = a2[0];
        "channelsFirst" === n2.dataFormat ? (r2 = 2, i2 = 3) : (r2 = 1, i2 = 2);
        var s2 = a2[r2], l3 = a2[i2], u2 = n2.kernelSize[0], c2 = n2.kernelSize[1], p2 = n2.strides[0], h = n2.strides[1], d2 = [o2, deconvLength(s2, p2, u2, n2.padding), deconvLength(l3, h, c2, n2.padding), n2.filters];
        "channelsLast" !== n2.dataFormat && (t5 = El(t5, [0, 2, 3, 1]));
        var f2 = Pc(t5, n2.kernel.read(), d2, n2.strides, n2.padding);
        return "channelsLast" !== n2.dataFormat && (f2 = El(f2, [0, 3, 1, 2])), null != n2.bias && (f2 = biasAdd(f2, n2.bias.read(), n2.dataFormat)), null != n2.activation && (f2 = n2.activation.apply(f2)), f2;
      });
    }, t3.prototype.computeOutputShape = function(e3) {
      var t4, n2, r2, i2 = (e3 = getExactlyOneShape(e3)).slice();
      "channelsFirst" === this.dataFormat ? (t4 = 1, n2 = 2, r2 = 3) : (t4 = 3, n2 = 1, r2 = 2);
      var a2 = this.kernelSize[0], o2 = this.kernelSize[1], s2 = this.strides[0], l3 = this.strides[1];
      return i2[t4] = this.filters, i2[n2] = deconvLength(i2[n2], s2, a2, this.padding), i2[r2] = deconvLength(i2[r2], l3, o2, this.padding), i2;
    }, t3.prototype.getConfig = function() {
      var t4 = e2.prototype.getConfig.call(this);
      return delete t4.dilationRate, t4;
    }, t3.className = "Conv2DTranspose", t3;
  }(Conv2D);
  Mf.registerClass(Conv2DTranspose);
  var SeparableConv = function(e2) {
    function t3(t4, n2) {
      var r2 = e2.call(this, t4, n2) || this;
      if (r2.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", r2.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", r2.depthwiseKernel = null, r2.pointwiseKernel = null, null == n2.filters)
        throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");
      if (null != n2.kernelInitializer || null != n2.kernelRegularizer || null != n2.kernelConstraint)
        throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
      if (null != n2.padding && "same" !== n2.padding && "valid" !== n2.padding)
        throw new ValueError("SeparableConv" + r2.rank + "D supports only padding modes: 'same' and 'valid', but received " + JSON.stringify(n2.padding));
      return r2.depthMultiplier = null == n2.depthMultiplier ? 1 : n2.depthMultiplier, r2.depthwiseInitializer = getInitializer(n2.depthwiseInitializer || r2.DEFAULT_DEPTHWISE_INITIALIZER), r2.depthwiseRegularizer = getRegularizer(n2.depthwiseRegularizer), r2.depthwiseConstraint = getConstraint(n2.depthwiseConstraint), r2.pointwiseInitializer = getInitializer(n2.depthwiseInitializer || r2.DEFAULT_POINTWISE_INITIALIZER), r2.pointwiseRegularizer = getRegularizer(n2.pointwiseRegularizer), r2.pointwiseConstraint = getConstraint(n2.pointwiseConstraint), r2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      var t4;
      if ((e3 = getExactlyOneShape(e3)).length < this.rank + 2)
        throw new ValueError("Inputs to SeparableConv" + this.rank + "D should have rank " + (this.rank + 2) + ", but received input shape: " + JSON.stringify(e3));
      var n2 = "channelsFirst" === this.dataFormat ? 1 : e3.length - 1;
      if (null == e3[n2] || e3[n2] < 0)
        throw new ValueError("The channel dimension of the inputs should be defined, but found " + JSON.stringify(e3[n2]));
      for (var r2 = e3[n2], i2 = this.kernelSize.concat([r2, this.depthMultiplier]), a2 = [], o2 = 0; o2 < this.rank; ++o2)
        a2.push(1);
      a2.push(r2 * this.depthMultiplier, this.filters);
      this.depthwiseKernel = this.addWeight("depthwise_kernel", i2, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", a2, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, true, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.inputSpec = [new InputSpec({ ndim: this.rank + 2, axes: (t4 = {}, t4[n2] = r2, t4) })], this.built = true;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var t5;
        if (e3 = getExactlyOneTensor(e3), 1 === n2.rank)
          throw new NotImplementedError("1D separable convolution is not implemented yet.");
        return 2 === n2.rank && ("channelsFirst" === n2.dataFormat && (e3 = El(e3, [0, 2, 3, 1])), t5 = Bc(e3, n2.depthwiseKernel.read(), n2.pointwiseKernel.read(), n2.strides, n2.padding, n2.dilationRate, "NHWC")), n2.useBias && (t5 = biasAdd(t5, n2.bias.read(), n2.dataFormat)), null != n2.activation && (t5 = n2.activation.apply(t5)), "channelsFirst" === n2.dataFormat && (t5 = El(t5, [0, 3, 1, 2])), t5;
      });
    }, t3.prototype.getConfig = function() {
      var t4 = e2.prototype.getConfig.call(this);
      return delete t4.rank, delete t4.kernelInitializer, delete t4.kernelRegularizer, delete t4.kernelConstraint, t4.depthwiseInitializer = serializeInitializer(this.depthwiseInitializer), t4.pointwiseInitializer = serializeInitializer(this.pointwiseInitializer), t4.depthwiseRegularizer = serializeRegularizer(this.depthwiseRegularizer), t4.pointwiseRegularizer = serializeRegularizer(this.pointwiseRegularizer), t4.depthwiseConstraint = serializeConstraint(this.depthwiseConstraint), t4.pointwiseConstraint = serializeConstraint(this.pointwiseConstraint), t4;
    }, t3.className = "SeparableConv", t3;
  }(Conv);
  var SeparableConv2D = function(e2) {
    function t3(t4) {
      return e2.call(this, 2, t4) || this;
    }
    return __extends(t3, e2), t3.className = "SeparableConv2D", t3;
  }(SeparableConv);
  Mf.registerClass(SeparableConv2D);
  var Conv1D = function(e2) {
    function t3(n2) {
      var r2 = e2.call(this, 1, n2) || this;
      return t3.verifyArgs(n2), r2.inputSpec = [{ ndim: 3 }], r2;
    }
    return __extends(t3, e2), t3.prototype.getConfig = function() {
      var t4 = e2.prototype.getConfig.call(this);
      return delete t4.rank, delete t4.dataFormat, t4;
    }, t3.verifyArgs = function(e3) {
      if ("number" != typeof e3.kernelSize && !checkArrayTypeAndLength(e3.kernelSize, "number", 1, 1))
        throw new ValueError("Conv1D expects config.kernelSize to be number or number[] with length 1, but received " + JSON.stringify(e3.kernelSize) + ".");
    }, t3.className = "Conv1D", t3;
  }(Conv);
  Mf.registerClass(Conv1D);
  var Cropping2D = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return "number" == typeof t4.cropping ? n2.cropping = [[t4.cropping, t4.cropping], [t4.cropping, t4.cropping]] : "number" == typeof t4.cropping[0] ? n2.cropping = [[t4.cropping[0], t4.cropping[0]], [t4.cropping[1], t4.cropping[1]]] : n2.cropping = t4.cropping, n2.dataFormat = void 0 === t4.dataFormat ? "channelsLast" : t4.dataFormat, n2.inputSpec = [{ ndim: 4 }], n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      return "channelsFirst" === this.dataFormat ? [e3[0], e3[1], e3[2] - this.cropping[0][0] - this.cropping[0][1], e3[3] - this.cropping[1][0] - this.cropping[1][1]] : [e3[0], e3[1] - this.cropping[0][0] - this.cropping[0][1], e3[2] - this.cropping[1][0] - this.cropping[1][1], e3[3]];
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        return e3 = getExactlyOneTensor(e3), "channelsLast" === n2.dataFormat ? sliceAlongAxis(sliceAlongAxis(e3, n2.cropping[0][0], e3.shape[1] - n2.cropping[0][0] - n2.cropping[0][1], 2), n2.cropping[1][0], e3.shape[2] - n2.cropping[1][1] - n2.cropping[1][0], 3) : sliceAlongAxis(sliceAlongAxis(e3, n2.cropping[0][0], e3.shape[2] - n2.cropping[0][0] - n2.cropping[0][1], 3), n2.cropping[1][0], e3.shape[3] - n2.cropping[1][1] - n2.cropping[1][0], 4);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { cropping: this.cropping, dataFormat: this.dataFormat }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "Cropping2D", t3;
  }(Layer);
  Mf.registerClass(Cropping2D);
  var UpSampling2D = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.DEFAULT_SIZE = [2, 2], n2.inputSpec = [{ ndim: 4 }], n2.size = null == t4.size ? n2.DEFAULT_SIZE : t4.size, n2.dataFormat = null == t4.dataFormat ? "channelsLast" : t4.dataFormat, n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      if ("channelsFirst" === this.dataFormat) {
        var t4 = null == e3[2] ? null : this.size[0] * e3[2], n2 = null == e3[3] ? null : this.size[1] * e3[3];
        return [e3[0], e3[1], t4, n2];
      }
      t4 = null == e3[1] ? null : this.size[0] * e3[1], n2 = null == e3[2] ? null : this.size[1] * e3[2];
      return [e3[0], t4, n2, e3[3]];
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var t5 = getExactlyOneTensor(e3), r2 = t5.shape;
        if ("channelsFirst" === n2.dataFormat) {
          t5 = El(t5, [0, 2, 3, 1]);
          var i2 = n2.size[0] * r2[2], a2 = n2.size[1] * r2[3], o2 = t5.resizeNearestNeighbor([i2, a2]);
          return El(o2, [0, 3, 1, 2]);
        }
        i2 = n2.size[0] * r2[1], a2 = n2.size[1] * r2[2];
        return t5.resizeNearestNeighbor([i2, a2]);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { size: this.size, dataFormat: this.dataFormat }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "UpSampling2D", t3;
  }(Layer);
  function depthwiseConv2d$1(e2, t3, n2, r2, i2, a2) {
    return void 0 === n2 && (n2 = [1, 1]), void 0 === r2 && (r2 = "valid"), je(function() {
      null == i2 && (i2 = imageDataFormat()), checkDataFormat(i2);
      var o2 = preprocessConv2DInput(e2, i2);
      if (4 !== e2.rank)
        throw new ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead " + e2.rank + "-D");
      if (4 !== t3.rank)
        throw new ValueError("depthwiseKernel is required to be 4-D, but is instead " + t3.rank + "-D");
      return o2 = Oc(o2, t3, n2, "same" === r2 ? "same" : "valid", "NHWC", a2), "channelsFirst" === i2 && (o2 = El(o2, [0, 3, 1, 2])), o2;
    });
  }
  Mf.registerClass(UpSampling2D);
  var DepthwiseConv2D = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, 2, t4) || this;
      return n2.depthwiseKernel = null, n2.depthMultiplier = null == t4.depthMultiplier ? 1 : t4.depthMultiplier, n2.depthwiseInitializer = getInitializer(t4.depthwiseInitializer || n2.DEFAULT_KERNEL_INITIALIZER), n2.depthwiseConstraint = getConstraint(t4.depthwiseConstraint), n2.depthwiseRegularizer = getRegularizer(t4.depthwiseRegularizer), n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      if ((e3 = getExactlyOneShape(e3)).length < 4)
        throw new ValueError("Inputs to DepthwiseConv2D should have rank 4. Received input shape: " + JSON.stringify(e3) + ".");
      var t4 = "channelsFirst" === this.dataFormat ? 1 : 3;
      if (null == e3[t4] || e3[t4] < 0)
        throw new ValueError("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (" + e3[t4] + ").");
      var n2 = e3[t4], r2 = [this.kernelSize[0], this.kernelSize[1], n2, this.depthMultiplier];
      this.depthwiseKernel = this.addWeight("depthwise_kernel", r2, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n2 * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var t5 = depthwiseConv2d$1(e3 = getExactlyOneTensor(e3), n2.depthwiseKernel.read(), n2.strides, n2.padding, n2.dataFormat, null);
        return n2.useBias && (t5 = biasAdd(t5, n2.bias.read(), n2.dataFormat)), null != n2.activation && (t5 = n2.activation.apply(t5)), t5;
      });
    }, t3.prototype.computeOutputShape = function(e3) {
      e3 = getExactlyOneShape(e3);
      var t4 = "channelsFirst" === this.dataFormat ? e3[2] : e3[1], n2 = "channelsFirst" === this.dataFormat ? e3[3] : e3[2], r2 = "channelsFirst" === this.dataFormat ? e3[1] * this.depthMultiplier : e3[3] * this.depthMultiplier, i2 = convOutputLength(t4, this.kernelSize[0], this.padding, this.strides[0]), a2 = convOutputLength(n2, this.kernelSize[1], this.padding, this.strides[1]);
      return "channelsFirst" === this.dataFormat ? [e3[0], r2, i2, a2] : [e3[0], i2, a2, r2];
    }, t3.prototype.getConfig = function() {
      var t4 = e2.prototype.getConfig.call(this);
      return t4.depthMultiplier = this.depthMultiplier, t4.depthwiseInitializer = serializeInitializer(this.depthwiseInitializer), t4.depthwiseRegularizer = serializeRegularizer(this.depthwiseRegularizer), t4.depthwiseConstraint = serializeConstraint(this.depthwiseRegularizer), t4;
    }, t3.className = "DepthwiseConv2D", t3;
  }(BaseConv);
  Mf.registerClass(DepthwiseConv2D);
  var Dropout = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.rate = Math.max(Math.min(t4.rate, 1), 0), n2.noiseShape = t4.noiseShape, n2.seed = t4.seed, n2.supportsMasking = true, n2;
    }
    return __extends(t3, e2), t3.prototype.getNoiseShape = function(e3) {
      if (null == this.noiseShape)
        return this.noiseShape;
      for (var t4 = e3.shape, n2 = [], r2 = 0; r2 < this.noiseShape.length; ++r2)
        n2.push(null == this.noiseShape[r2] ? t4[r2] : this.noiseShape[r2]);
      return n2;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        n2.invokeCallHook(e3, t4);
        var r2 = getExactlyOneTensor(e3);
        if (0 < n2.rate && n2.rate < 1) {
          var i2 = null != t4.training && t4.training, a2 = n2.getNoiseShape(r2);
          return inTrainPhase(function() {
            return dropout$1(r2, n2.rate, a2, n2.seed);
          }, function() {
            return r2;
          }, i2);
        }
        return e3;
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { rate: this.rate, noiseShape: this.noiseShape, seed: this.seed }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.prototype.dispose = function() {
      return e2.prototype.dispose.call(this);
    }, t3.className = "Dropout", t3;
  }(Layer);
  Mf.registerClass(Dropout);
  var Dense = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      if (n2.activation = null, n2.useBias = true, n2.kernel = null, n2.bias = null, n2.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n2.DEFAULT_BIAS_INITIALIZER = "zeros", null == t4.batchInputShape && null == t4.inputShape && null != t4.inputDim) {
        var r2 = null;
        null != t4.batchSize && (r2 = t4.batchSize), n2.batchInputShape = [r2, t4.inputDim];
      }
      return n2.units = t4.units, assertPositiveInteger(n2.units, "units"), n2.activation = getActivation(t4.activation), null != t4.useBias && (n2.useBias = t4.useBias), n2.kernelInitializer = getInitializer(t4.kernelInitializer || n2.DEFAULT_KERNEL_INITIALIZER), n2.biasInitializer = getInitializer(t4.biasInitializer || n2.DEFAULT_BIAS_INITIALIZER), n2.kernelConstraint = getConstraint(t4.kernelConstraint), n2.biasConstraint = getConstraint(t4.biasConstraint), n2.kernelRegularizer = getRegularizer(t4.kernelRegularizer), n2.biasRegularizer = getRegularizer(t4.biasRegularizer), n2.activityRegularizer = getRegularizer(t4.activityRegularizer), n2.supportsMasking = true, n2.inputSpec = [{ minNDim: 2 }], n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      var t4, n2 = (e3 = getExactlyOneShape(e3))[e3.length - 1];
      null == this.kernel && (this.kernel = this.addWeight("kernel", [n2, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint))), this.inputSpec = [{ minNDim: 2, axes: (t4 = {}, t4[-1] = n2, t4) }], this.built = true;
    }, t3.prototype.computeOutputShape = function(e3) {
      var t4 = (e3 = getExactlyOneShape(e3)).slice();
      return t4[t4.length - 1] = this.units, t4;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        n2.invokeCallHook(e3, t4);
        var r2, i2 = getExactlyOneTensor(e3), a2 = mapActivationToFusedKernel(n2.activation.getClassName());
        return null != a2 ? r2 = dot(i2, n2.kernel.read(), a2, n2.bias ? n2.bias.read() : null) : (r2 = dot(i2, n2.kernel.read()), null != n2.bias && (r2 = biasAdd(r2, n2.bias.read())), null != n2.activation && (r2 = n2.activation.apply(r2))), r2;
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { units: this.units, activation: serializeActivation(this.activation), useBias: this.useBias, kernelInitializer: serializeInitializer(this.kernelInitializer), biasInitializer: serializeInitializer(this.biasInitializer), kernelRegularizer: serializeRegularizer(this.kernelRegularizer), biasRegularizer: serializeRegularizer(this.biasRegularizer), activityRegularizer: serializeRegularizer(this.activityRegularizer), kernelConstraint: serializeConstraint(this.kernelConstraint), biasConstraint: serializeConstraint(this.biasConstraint) }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "Dense", t3;
  }(Layer);
  Mf.registerClass(Dense);
  var Flatten = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4 || {}) || this;
      return n2.inputSpec = [{ minNDim: 3 }], n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      for (var t4 = 0, n2 = (e3 = getExactlyOneShape(e3)).slice(1); t4 < n2.length; t4++) {
        if (null == n2[t4])
          throw new ValueError('The shape of the input to "Flatten" is not fully defined (got ' + e3.slice(1) + '). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.');
      }
      return [e3[0], arrayProd(e3, 1)];
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        return n2.invokeCallHook(e3, t4), batchFlatten(getExactlyOneTensor(e3));
      });
    }, t3.className = "Flatten", t3;
  }(Layer);
  Mf.registerClass(Flatten);
  var Activation$1 = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.supportsMasking = true, n2.activation = getActivation(t4.activation), n2;
    }
    return __extends(t3, e2), t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        n2.invokeCallHook(e3, t4);
        var r2 = getExactlyOneTensor(e3);
        return n2.activation.apply(r2);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { activation: serializeActivation(this.activation) }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "Activation", t3;
  }(Layer);
  Mf.registerClass(Activation$1);
  var RepeatVector = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.n = t4.n, n2.inputSpec = [{ ndim: 2 }], n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      return [e3[0], this.n, e3[1]];
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        return repeat(e3 = getExactlyOneTensor(e3), n2.n);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { n: this.n }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "RepeatVector", t3;
  }(Layer);
  Mf.registerClass(RepeatVector);
  var Reshape = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      n2.targetShape = t4.targetShape;
      for (var r2 = 0; r2 < n2.targetShape.length; ++r2)
        n2.isUnknown(n2.targetShape[r2]) && (n2.targetShape[r2] = null);
      return n2;
    }
    return __extends(t3, e2), t3.prototype.isUnknown = function(e3) {
      return e3 < 0 || null == e3;
    }, t3.prototype.fixUnknownDimension = function(e3, t4) {
      for (var n2 = "Total size of new array must be unchanged.", r2 = t4.slice(), i2 = 1, a2 = null, o2 = 0; o2 < r2.length; ++o2) {
        var s2 = r2[o2];
        if (this.isUnknown(s2)) {
          if (null !== a2)
            throw new ValueError("Can only specifiy one unknown dimension.");
          a2 = o2;
        } else
          i2 *= s2;
      }
      var l3 = arrayProd(e3);
      if (null !== a2) {
        if (0 === i2 || l3 % i2 != 0)
          throw new ValueError(n2);
        r2[a2] = l3 / i2;
      } else if (l3 !== i2)
        throw new ValueError(n2);
      return r2;
    }, t3.prototype.computeOutputShape = function(e3) {
      for (var t4 = false, n2 = 0; n2 < e3.length; ++n2)
        if (this.isUnknown(e3[n2])) {
          t4 = true;
          break;
        }
      return t4 ? e3.slice(0, 1).concat(this.targetShape) : e3.slice(0, 1).concat(this.fixUnknownDimension(e3.slice(1), this.targetShape));
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        n2.invokeCallHook(e3, t4);
        var r2 = getExactlyOneTensor(e3), i2 = r2.shape, a2 = i2.slice(0, 1).concat(n2.fixUnknownDimension(i2.slice(1), n2.targetShape));
        return r2.reshape(a2);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { targetShape: this.targetShape }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "Reshape", t3;
  }(Layer);
  Mf.registerClass(Reshape);
  var Permute = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      if (null == t4.dims)
        throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
      if (!Array.isArray(t4.dims))
        throw new Error("Permute constructor requires `dims` to be an Array, but received " + t4.dims + " instead.");
      var r2 = range(1, t4.dims.length + 1);
      if (!tt.arraysEqual(t4.dims.slice().sort(), r2))
        throw new Error("Invalid permutation `dims`: " + JSON.stringify(t4.dims) + " `dims` must contain consecutive integers starting from 1.");
      return n2.dims = t4.dims, n2.dimsIncludingBatch = [0].concat(n2.dims), n2.inputSpec = [new InputSpec({ ndim: n2.dims.length + 1 })], n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      var t4 = (e3 = getExactlyOneShape(e3)).slice();
      return this.dims.forEach(function(n2, r2) {
        t4[r2 + 1] = e3[n2];
      }), t4;
    }, t3.prototype.call = function(e3, t4) {
      return El(getExactlyOneTensor(e3), this.dimsIncludingBatch);
    }, t3.prototype.getConfig = function() {
      var t4 = { dims: this.dims }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "Permute", t3;
  }(Layer);
  Mf.registerClass(Permute);
  var Masking = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, null == t4 ? {} : t4) || this;
      return n2.supportsMasking = true, n2.maskValue = null != t4 ? null == t4.maskValue ? 0 : t4.maskValue : 0, n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      return e3;
    }, t3.prototype.getConfig = function() {
      var t4 = e2.prototype.getConfig.call(this), n2 = { maskValue: this.maskValue };
      return Object.assign(n2, t4), n2;
    }, t3.prototype.computeMask = function(e3, t4) {
      var n2 = getExactlyOneTensor(e3);
      return ul(yc(n2, this.maskValue), -1);
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        n2.invokeCallHook(e3, t4);
        var r2 = getExactlyOneTensor(e3), i2 = ul(yc(r2, n2.maskValue), -1, true);
        return r2.mul(i2.asType(r2.dtype));
      });
    }, t3.className = "Masking", t3;
  }(Layer);
  Mf.registerClass(Masking);
  var Embedding = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      if (n2.embeddings = null, n2.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == t4.batchInputShape && null == t4.inputShape) {
        var r2 = null;
        null != t4.batchSize && (r2 = t4.batchSize), null == t4.inputLength ? n2.batchInputShape = [r2, null] : n2.batchInputShape = [r2].concat(toList(t4.inputLength));
      }
      return n2.inputDim = t4.inputDim, assertPositiveInteger(n2.inputDim, "inputDim"), n2.outputDim = t4.outputDim, assertPositiveInteger(n2.outputDim, "outputDim"), n2.embeddingsInitializer = getInitializer(t4.embeddingsInitializer || n2.DEFAULT_EMBEDDINGS_INITIALIZER), n2.embeddingsRegularizer = getRegularizer(t4.embeddingsRegularizer), n2.activityRegularizer = getRegularizer(t4.activityRegularizer), n2.embeddingsConstraint = getConstraint(t4.embeddingsConstraint), n2.maskZero = t4.maskZero, n2.supportsMasking = t4.maskZero, n2.inputLength = t4.inputLength, n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint), this.built = true;
    }, t3.prototype.warnOnIncompatibleInputShape = function(e3) {
    }, t3.prototype.computeMask = function(e3, t4) {
      var n2 = this;
      return je(function() {
        return n2.maskZero ? (e3 = getExactlyOneTensor(e3), yc(e3, zn(e3))) : null;
      });
    }, t3.prototype.computeOutputShape = function(e3) {
      if (e3 = getExactlyOneShape(e3), null == this.inputLength)
        return e3.concat([this.outputDim]);
      var t4 = toList(this.inputLength);
      if (t4.length !== e3.length - 1)
        throw new ValueError('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e3);
      for (var n2 = 0, r2 = 0; r2 < t4.length; ++r2) {
        var i2 = t4[r2], a2 = e3[r2 + 1];
        if (null != i2 && null != a2 && i2 !== a2)
          throw new ValueError('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e3);
        null == i2 && (t4[n2] = a2), n2++;
      }
      return [e3[0]].concat(t4, [this.outputDim]);
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        n2.invokeCallHook(e3, t4);
        var r2 = getExactlyOneTensor(e3);
        return "int32" !== r2.dtype && (r2 = cast$1(r2, "int32")), gather$1(n2.embeddings.read(), r2.as1D()).reshape(getExactlyOneShape(n2.computeOutputShape(r2.shape)));
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { inputDim: this.inputDim, outputDim: this.outputDim, embeddingsInitializer: serializeInitializer(this.embeddingsInitializer), embeddingsRegularizer: serializeRegularizer(this.embeddingsRegularizer), activityRegularizer: serializeRegularizer(this.activityRegularizer), embeddingsConstraint: serializeConstraint(this.embeddingsConstraint), maskZero: this.maskZero, inputLength: this.inputLength }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "Embedding", t3;
  }(Layer);
  Mf.registerClass(Embedding);
  var Merge = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4 || {}) || this;
      return n2.supportsMasking = true, n2;
    }
    return __extends(t3, e2), t3.prototype.mergeFunction = function(e3) {
      throw new NotImplementedError();
    }, t3.prototype.computeElementwiseOpOutputShape = function(e3, t4) {
      if (null == e3 || null == t4)
        return null;
      if (e3.length < t4.length)
        return this.computeElementwiseOpOutputShape(t4, e3);
      if (0 === t4.length)
        return e3;
      for (var n2 = e3.slice(0, e3.length - t4.length), r2 = 0; r2 < t4.length; ++r2) {
        var i2 = e3[e3.length - t4.length + r2], a2 = t4[r2];
        if (null == i2 || null == a2 || i2 < 0 || a2 < 0)
          n2.push(null);
        else if (1 === i2)
          n2.push(a2);
        else if (1 === a2)
          n2.push(i2);
        else {
          if (i2 !== a2)
            throw new ValueError("Operands could not be broadcast together with shapes " + JSON.stringify(e3) + " " + JSON.stringify(t4));
          n2.push(i2);
        }
      }
      return n2;
    }, t3.prototype.build = function(e3) {
      if (Array.isArray(e3) && !Array.isArray(e3[0]) && (e3 = [getExactlyOneShape(e3)]), (e3 = e3).length < 2)
        throw new ValueError("A merge layer should be called on an Array of at least 2 inputs. Got " + e3.length + " input(s).");
      for (var t4 = [], n2 = 0, r2 = e3; n2 < r2.length; n2++) {
        null != (o2 = r2[n2]) && null !== o2[0] && t4.push(o2[0]);
      }
      if ((t4 = unique(t4)).length > 1)
        throw new ValueError("Can not merge tensors with different batch sizes. Got tensors with shapes: " + JSON.stringify(e3) + ".");
      for (var i2 = null == e3[0] ? null : e3[0].slice(1), a2 = 1; a2 < e3.length; ++a2) {
        var o2 = null == e3[a2] ? null : e3[a2].slice(1);
        i2 = this.computeElementwiseOpOutputShape(i2, o2);
      }
      var s2 = e3.map(function(e4) {
        return e4.length;
      });
      -1 === e3.indexOf(null) && 1 === unique(s2).length ? this.reshapeRequired = false : this.reshapeRequired = true;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        if (e3 = e3, n2.reshapeRequired) {
          var t5 = [], r2 = e3.map(function(e4) {
            return e4.rank;
          });
          if (-1 === r2.indexOf(null)) {
            for (var i2 = max$1(r2), a2 = 0, o2 = e3; a2 < o2.length; a2++) {
              for (var s2 = (h = o2[a2]).rank, l3 = 0; l3 < i2 - s2; ++l3)
                h = expandDims$1(h, 1);
              t5.push(h);
            }
            return n2.mergeFunction(t5);
          }
          for (var u2 = false, c2 = 0, p2 = e3; c2 < p2.length; c2++) {
            var h;
            if (null == (s2 = (h = p2[c2]).rank)) {
              var d2 = h.shape, f2 = d2[0], g2 = d2.slice(1).concat([f2]), m2 = h.reshape([f2].concat(arrayProd(d2.slice(1))));
              m2 = (m2 = El(m2, [1, 0])).reshape(g2), t5.push(m2), u2 = true;
            } else if (s2 > 1) {
              var y2 = range(1, s2).concat([0]);
              t5.push(El(h, y2)), u2 = true;
            } else
              t5.push(h);
          }
          var v2 = n2.mergeFunction(t5), b2 = v2.rank;
          if (u2) {
            if (null == b2) {
              var w2 = v2.shape;
              g2 = [f2 = w2[w2.length - 1]].concat(w2.slice(0, w2.length - 1));
              v2 = El(v2.reshape([-1, f2]), [1, 0]).reshape(g2);
            } else if (b2 > 1) {
              y2 = [b2 - 1].concat(range(0, b2 - 1));
              v2 = El(v2, y2);
            }
          }
          return v2;
        }
        return n2.mergeFunction(e3);
      });
    }, t3.prototype.computeOutputShape = function(e3) {
      var t4;
      t4 = null == (e3 = e3)[0] ? null : e3[0].slice(1);
      for (var n2 = 1; n2 < e3.length; ++n2) {
        var r2 = null == e3[n2] ? null : e3[n2].slice(1);
        t4 = this.computeElementwiseOpOutputShape(t4, r2);
      }
      for (var i2 = [], a2 = 0, o2 = e3; a2 < o2.length; a2++) {
        null != (r2 = o2[a2]) && null !== r2[0] && i2.push(r2[0]);
      }
      return t4 = 1 === (i2 = unique(i2)).length ? i2.concat(t4) : [null].concat(t4);
    }, t3.prototype.computeMask = function(e3, t4) {
      return je(function() {
        if (null == t4)
          return null;
        if (!Array.isArray(t4))
          throw new ValueError("`mask` should be an Array");
        if (!Array.isArray(e3))
          throw new ValueError("`inputs` should be an Array");
        if (t4.length !== e3.length)
          throw new ValueError("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (" + e3.length + " vs " + t4.length + ")");
        if (t4.every(function(e4) {
          return null == e4;
        }))
          return null;
        for (var n2 = (t4 = t4.map(function(e4) {
          return null == e4 ? e4 : dr(e4, 0);
        }))[0], r2 = 1; r2 < t4.length - 1; ++r2)
          n2 = Ms(n2, t4[r2]);
        return n2;
      });
    }, t3;
  }(Layer);
  var Add = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.mergeFunction = function(e3) {
      return je(function() {
        for (var t4 = e3[0].clone(), n2 = 1; n2 < e3.length; ++n2)
          t4 = Vs(t4, e3[n2]);
        return t4;
      });
    }, t3.className = "Add", t3;
  }(Merge);
  Mf.registerClass(Add);
  var Multiply = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.mergeFunction = function(e3) {
      return je(function() {
        for (var t4 = e3[0].clone(), n2 = 1; n2 < e3.length; ++n2)
          t4 = tc(t4, e3[n2]);
        return t4;
      });
    }, t3.className = "Multiply", t3;
  }(Merge);
  Mf.registerClass(Multiply);
  var Average = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.mergeFunction = function(e3) {
      return je(function() {
        for (var t4 = e3[0].clone(), n2 = 1; n2 < e3.length; ++n2)
          t4 = Vs(t4, e3[n2]);
        return tc(1 / e3.length, t4);
      });
    }, t3.className = "Average", t3;
  }(Merge);
  Mf.registerClass(Average);
  var Maximum = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.mergeFunction = function(e3) {
      return je(function() {
        for (var t4 = e3[0], n2 = 1; n2 < e3.length; ++n2)
          t4 = Xs(t4, e3[n2]);
        return t4;
      });
    }, t3.className = "Maximum", t3;
  }(Merge);
  Mf.registerClass(Maximum);
  var Minimum = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.mergeFunction = function(e3) {
      return je(function() {
        for (var t4 = e3[0], n2 = 1; n2 < e3.length; ++n2)
          t4 = Ys(t4, e3[n2]);
        return t4;
      });
    }, t3.className = "Minimum", t3;
  }(Merge);
  Mf.registerClass(Minimum);
  var Concatenate = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.DEFAULT_AXIS = -1, null == t4 && (t4 = {}), n2.axis = null == t4.axis ? n2.DEFAULT_AXIS : t4.axis, n2.supportsMasking = true, n2.reshapeRequired = false, n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      if (!Array.isArray(e3) || !Array.isArray(e3[0]) || 1 === e3.length)
        throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");
      for (var t4 = true, n2 = 0, r2 = e3 = e3; n2 < r2.length; n2++) {
        if (null != (c2 = r2[n2])) {
          t4 = false;
          break;
        }
      }
      if (!t4) {
        for (var i2 = [], a2 = 0; a2 < e3.length; ++a2) {
          var o2 = e3[a2].slice();
          o2.splice(this.axis, 1);
          for (var s2 = false, l3 = 0, u2 = i2; l3 < u2.length; l3++) {
            var c2 = u2[l3];
            if (tt.arraysEqual(c2, o2)) {
              s2 = true;
              break;
            }
          }
          s2 || i2.push(o2);
        }
        if (i2.length > 1)
          throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e3));
      }
    }, t3.prototype.mergeFunction = function(e3) {
      var t4 = this;
      return je(function() {
        return concatenate(e3, t4.axis);
      });
    }, t3.prototype.computeOutputShape = function(e3) {
      if (!Array.isArray(e3) || !Array.isArray(e3[0]))
        throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");
      for (var t4 = e3, n2 = t4[0].slice(), r2 = this.axis < 0 ? n2.length + this.axis : this.axis, i2 = 0, a2 = t4.slice(1); i2 < a2.length; i2++) {
        var o2 = a2[i2];
        if (null == n2[r2] || null == o2[r2]) {
          n2[r2] = null;
          break;
        }
        n2[r2] += o2[r2];
      }
      return n2;
    }, t3.prototype.computeMask = function(e3, t4) {
      var n2 = this;
      if (null == t4)
        return null;
      if (!Array.isArray(t4))
        throw new ValueError("`mask` should be an array for Concatenate");
      if (!Array.isArray(e3))
        throw new ValueError("`inputs` should be an array for Concatenate");
      if (t4.length !== e3.length)
        throw new ValueError("Mismatch in the length of mask (" + t4.length + ") and the legnth of inputs (" + e3.length + ")");
      return je(function() {
        var r2 = true;
        if (t4.forEach(function(e4) {
          null == e4 || (r2 = false);
        }), r2)
          return null;
        for (var i2 = [], a2 = 0; a2 < e3.length; ++a2)
          null == t4[a2] ? i2.push(Vn(e3[a2]).asType("bool")) : t4[a2].rank < e3[a2].rank ? i2.push(dr(t4[a2], -1)) : i2.push(t4[a2]);
        var o2 = Gn(i2, n2.axis);
        return il(o2, -1, false);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { axis: this.axis }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "Concatenate", t3;
  }(Merge);
  function interpretAxis(e2, t3) {
    for (; e2 < 0; )
      e2 += t3;
    return e2;
  }
  function batchDot(e2, t3, n2) {
    if (e2.shape.length > 3 || t3.shape.length > 3)
      throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");
    if (tt.assert(e2.shape.length >= 2, function() {
      return "batchDot requires the rank of x to be >= 2, but got " + e2.shape.length;
    }), tt.assert(e2.shape.length >= 2, function() {
      return "batchDot requires the rank of y to be >= 2, but got " + t3.shape.length;
    }), "number" == typeof n2 && (n2 = [n2, n2]), "complex64" === e2.dtype || "complex64" === t3.dtype)
      throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");
    var r2 = e2.shape.length, i2 = t3.shape.length;
    null == n2 && (n2 = [r2 - 1, i2 - 2]);
    var a2 = n2;
    return je(function() {
      var n3, o2;
      if (r2 > i2) {
        n3 = r2 - i2;
        for (var s2 = [], l3 = 0; l3 < n3; ++l3)
          s2.push(1);
        t3 = t3.reshape(t3.shape.concat(s2));
      } else if (i2 > r2) {
        n3 = i2 - r2;
        for (s2 = [], l3 = 0; l3 < n3; ++l3)
          s2.push(1);
        e2 = e2.reshape(e2.shape.concat(s2));
      } else
        n3 = 0;
      if (2 === e2.shape.length && 2 === t3.shape.length)
        o2 = a2[0] === a2[1] ? e2.mulStrict(t3).sum(a2[0]) : e2.transpose([1, 0]).mulStrict(t3).sum(a2[1]);
      else {
        var u2 = a2[0] !== e2.shape.length - 1, c2 = a2[1] === t3.shape.length - 1;
        o2 = e2.matMul(t3, u2, c2);
      }
      if (n3 > 0) {
        var p2 = void 0, h = [];
        for (l3 = p2 = r2 > i2 ? r2 + i2 - 3 : r2 - 1; l3 < p2 + n3; ++l3)
          h.push(l3);
        o2 = o2.squeeze(h);
      }
      return 1 === o2.shape.length && (o2 = o2.expandDims(1)), o2;
    });
  }
  Mf.registerClass(Concatenate);
  var Dot = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.axes = t4.axes, n2.normalize = null != t4.normalize && t4.normalize, n2.supportsMasking = true, n2.reshapeRequired = false, n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      tt.assert(Array.isArray(e3) && 2 === e3.length && Array.isArray(e3[0]) && Array.isArray(e3[1]), function() {
        return "A `Dot` layer should be called on a list of exactly 2 inputs.";
      });
      var t4 = e3[0], n2 = e3[1];
      if (t4.length > 3 || n2.length > 3)
        throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
      var r2 = this.interpretAxes(t4, n2);
      if (t4[r2[0]] !== n2[r2[1]])
        throw new ValueError("Dimension incompatibility: " + t4[r2[0]] + " !== " + n2[r2[1]]);
    }, t3.prototype.mergeFunction = function(e3) {
      if (2 !== e3.length)
        throw new ValueError("A `Dot` layer must be called on exactly 2 inputs, but received " + e3.length + " input(s).");
      var t4, n2 = e3[0], r2 = e3[1];
      return t4 = Array.isArray(this.axes) ? this.axes.map(function(t5, n3) {
        return interpretAxis(t5, e3[n3].shape.length);
      }) : [interpretAxis(this.axes, n2.shape.length), interpretAxis(this.axes, r2.shape.length)], this.normalize && (n2 = l2Normalize(n2, t4[0]), r2 = l2Normalize(r2, t4[1])), batchDot(n2, r2, t4);
    }, t3.prototype.interpretAxes = function(e3, t4) {
      return Array.isArray(this.axes) ? this.axes : [interpretAxis(this.axes, e3.length), interpretAxis(this.axes, t4.length)];
    }, t3.prototype.computeOutputShape = function(e3) {
      tt.assert(Array.isArray(e3) && 2 === e3.length && Array.isArray(e3[0]) && Array.isArray(e3[1]), function() {
        return "A `Dot` layer should be called on a list of exactly 2 inputs.";
      });
      var t4 = e3[0].slice(), n2 = e3[1].slice();
      if (t4.length > 3 || n2.length > 3)
        throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
      var r2 = this.interpretAxes(t4, n2);
      t4.splice(r2[0], 1), n2.splice(r2[1], 1), n2.splice(0, 1);
      var i2 = t4.concat(n2);
      return 1 === i2.length && i2.push(1), i2;
    }, t3.prototype.computeMask = function(e3, t4) {
      return null;
    }, t3.prototype.getConfig = function() {
      var t4 = { axes: this.axes, normalize: this.normalize }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "Dot", t3;
  }(Merge);
  Mf.registerClass(Dot);
  var GaussianNoise = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.supportsMasking = true, n2.stddev = t4.stddev, n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      return e3;
    }, t3.prototype.getConfig = function() {
      var t4 = e2.prototype.getConfig.call(this), n2 = { stddev: this.stddev };
      return Object.assign(n2, t4), n2;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        n2.invokeCallHook(e3, t4);
        var r2 = getExactlyOneTensor(e3);
        return inTrainPhase(function() {
          return randomNormal$1(r2.shape, 0, n2.stddev).add(r2);
        }, function() {
          return r2;
        }, t4.training || false);
      });
    }, t3.className = "GaussianNoise", t3;
  }(Layer);
  Mf.registerClass(GaussianNoise);
  var GaussianDropout = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.supportsMasking = true, n2.rate = t4.rate, n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      return e3;
    }, t3.prototype.getConfig = function() {
      var t4 = e2.prototype.getConfig.call(this), n2 = { rate: this.rate };
      return Object.assign(n2, t4), n2;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        n2.invokeCallHook(e3, t4);
        var r2 = getExactlyOneTensor(e3);
        if (n2.rate > 0 && n2.rate < 1) {
          return inTrainPhase(function() {
            var e4 = Math.sqrt(n2.rate / (1 - n2.rate));
            return r2.mul(randomNormal$1(r2.shape, 1, e4));
          }, function() {
            return r2;
          }, t4.training || false);
        }
        return r2;
      });
    }, t3.className = "GaussianDropout", t3;
  }(Layer);
  Mf.registerClass(GaussianDropout);
  var AlphaDropout = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.supportsMasking = true, n2.rate = t4.rate, n2.noiseShape = t4.noiseShape, n2;
    }
    return __extends(t3, e2), t3.prototype._getNoiseShape = function(e3) {
      return this.noiseShape || getExactlyOneTensor(e3).shape;
    }, t3.prototype.computeOutputShape = function(e3) {
      return e3;
    }, t3.prototype.getConfig = function() {
      var t4 = e2.prototype.getConfig.call(this), n2 = { rate: this.rate };
      return Object.assign(n2, t4), n2;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        if (n2.rate < 1 && n2.rate > 0) {
          var r2 = n2._getNoiseShape(e3);
          return inTrainPhase(function() {
            var t5 = getExactlyOneTensor(e3), i2 = -1.7580993408473766, a2 = hc(kr(r2), n2.rate);
            a2 = cast$1(a2, "float32");
            var o2 = Math.pow((1 - n2.rate) * (1 + n2.rate * Math.pow(i2, 2)), -0.5), s2 = -o2 * i2 * n2.rate;
            return t5.mul(a2).add(a2.add(-1).mul(i2)).mul(o2).add(s2);
          }, function() {
            return getExactlyOneTensor(e3);
          }, t4.training || false);
        }
        return e3;
      });
    }, t3.className = "AlphaDropout", t3;
  }(Layer);
  function batchNormalization(e2, t3, n2, r2, i2, a2) {
    var o2;
    if (void 0 === a2 && (a2 = 1e-3), 2 === e2.rank)
      o2 = Fs(e2, t3, n2, r2, i2, a2);
    else if (3 === e2.rank)
      o2 = Os(e2, t3, n2, r2, i2, a2);
    else {
      if (4 !== e2.rank)
        throw new NotImplementedError("batchNormalization is not implemented for array of rank " + e2.rank + " yet");
      o2 = _s(e2, t3, n2, r2, i2, a2);
    }
    return o2;
  }
  function regularNormalizeBatchInTraining(e2, t3, n2, r2, i2) {
    return void 0 === i2 && (i2 = 1e-3), je(function() {
      var a2 = dl(e2, r2), o2 = a2.mean, s2 = a2.variance;
      return [batchNormalization(e2, o2, s2, n2, t3, i2), o2, s2];
    });
  }
  function broadcastNormalizeBatchInTraining(e2, t3, n2, r2, i2) {
    return void 0 === i2 && (i2 = 1e-3), je(function() {
      for (var a2 = dl(e2, r2), o2 = a2.mean, s2 = a2.variance, l3 = [], u2 = 0, c2 = range(0, e2.rank); u2 < c2.length; u2++) {
        var p2 = c2[u2];
        -1 !== r2.indexOf(p2) ? l3.push(1) : l3.push(e2.shape[p2]);
      }
      var h = o2.reshape(l3), d2 = s2.reshape(l3), f2 = null == t3 ? null : t3.reshape(l3), g2 = null == n2 ? null : n2.reshape(l3);
      return [batchNormalization(e2, h, d2, g2, f2, i2), o2, s2];
    });
  }
  function normalizeBatchInTraining(e2, t3, n2, r2, i2) {
    return void 0 === i2 && (i2 = 1e-3), tt.arraysEqual(r2.slice().sort(), range(0, e2.rank - 1)) ? regularNormalizeBatchInTraining(e2, t3, n2, r2, i2) : broadcastNormalizeBatchInTraining(e2, t3, n2, r2, i2);
  }
  Mf.registerClass(AlphaDropout);
  var BatchNormalization = function(e2) {
    function t3(t4) {
      var n2 = this;
      return null == t4 && (t4 = {}), (n2 = e2.call(this, t4) || this).supportsMasking = true, n2.axis = null == t4.axis ? -1 : t4.axis, n2.momentum = null == t4.momentum ? 0.99 : t4.momentum, n2.epsilon = null == t4.epsilon ? 1e-3 : t4.epsilon, n2.center = null == t4.center || t4.center, n2.scale = null == t4.scale || t4.scale, n2.betaInitializer = getInitializer(t4.betaInitializer || "zeros"), n2.gammaInitializer = getInitializer(t4.gammaInitializer || "ones"), n2.movingMeanInitializer = getInitializer(t4.movingMeanInitializer || "zeros"), n2.movingVarianceInitializer = getInitializer(t4.movingVarianceInitializer || "ones"), n2.betaConstraint = getConstraint(t4.betaConstraint), n2.gammaConstraint = getConstraint(t4.gammaConstraint), n2.betaRegularizer = getRegularizer(t4.betaRegularizer), n2.gammaRegularizer = getRegularizer(t4.gammaRegularizer), n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      var t4;
      e3 = getExactlyOneShape(e3);
      var n2 = this.axis >= 0 ? this.axis : this.axis + e3.length, r2 = e3[n2];
      if (null == r2)
        throw new ValueError("Axis " + n2 + " of input tensor should have a defined dimension but the layer received an input with shape " + JSON.stringify(e3) + ".");
      this.inputSpec = [new InputSpec({ ndim: e3.length, axes: (t4 = {}, t4[n2] = r2, t4) })];
      var i2 = [r2];
      this.scale && (this.gamma = this.addWeight("gamma", i2, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", i2, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", i2, null, this.movingMeanInitializer, null, false), this.movingVariance = this.addWeight("moving_variance", i2, null, this.movingVarianceInitializer, null, false), this.built = true;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var r2 = null != t4.training && t4.training, i2 = getExactlyOneTensor(e3), a2 = i2.shape, o2 = a2.length, s2 = range(0, o2), l3 = n2.axis >= 0 ? n2.axis : n2.axis + o2;
        s2.splice(l3, 1);
        var u2 = pyListRepeat(1, o2);
        u2[l3] = a2[l3];
        var c2 = s2.slice();
        c2.sort();
        var p2 = !tt.arraysEqual(c2, range(0, o2).slice(0, o2 - 1));
        if (!r2)
          return function() {
            if (p2) {
              var e4 = n2.movingMean.read().reshape(u2), t5 = n2.movingVariance.read().reshape(u2), r3 = n2.center ? n2.beta.read().reshape(u2) : null, a3 = n2.scale ? n2.gamma.read().reshape(u2) : null;
              return batchNormalization(i2, e4, t5, r3, a3, n2.epsilon);
            }
            return batchNormalization(i2, n2.movingMean.read(), n2.movingVariance.read(), null == n2.beta ? null : n2.beta.read(), null == n2.gamma ? null : n2.gamma.read(), n2.epsilon);
          }();
        var h = normalizeBatchInTraining(i2, n2.gamma.read(), n2.beta.read(), s2, n2.epsilon), d2 = h[0], f2 = h[1], g2 = h[2], m2 = function(e4, t5, n3) {
          je(function() {
            var r3 = 1 - n3, i3 = e4.read(), a3 = i3.sub(t5).mul(r3);
            e4.write(i3.sub(a3));
          });
        };
        return m2(n2.movingMean, f2, n2.momentum), m2(n2.movingVariance, g2, n2.momentum), d2;
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { axis: this.axis, momentum: this.momentum, epsilon: this.epsilon, center: this.center, scale: this.scale, betaInitializer: serializeInitializer(this.betaInitializer), gammaInitializer: serializeInitializer(this.gammaInitializer), movingMeanInitializer: serializeInitializer(this.movingMeanInitializer), movingVarianceInitializer: serializeInitializer(this.movingVarianceInitializer), betaRegularizer: serializeRegularizer(this.betaRegularizer), gammaRegularizer: serializeRegularizer(this.gammaRegularizer), betaConstraint: serializeConstraint(this.betaConstraint), gammaConstraint: serializeConstraint(this.gammaConstraint) }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "BatchNormalization", t3;
  }(Layer);
  Mf.registerClass(BatchNormalization);
  var LayerNormalization = function(e2) {
    function t3(t4) {
      var n2 = this;
      if (null == t4 && (t4 = {}), (n2 = e2.call(this, t4) || this).axis = null == t4.axis ? -1 : t4.axis, "number" == typeof n2.axis) {
        if (!Number.isInteger(n2.axis))
          throw new Error("Expected axis to be an integer, but received " + n2.axis);
      } else {
        if (!Array.isArray(n2.axis))
          throw new Error("Expected axis to be an integer or an array of integers, but received " + JSON.stringify(n2.axis));
        for (var r2 = 0, i2 = n2.axis; r2 < i2.length; r2++) {
          var a2 = i2[r2];
          if (!Number.isInteger(a2))
            throw new Error("Expected axis to be an array of integers, but received " + JSON.stringify(n2.axis));
        }
      }
      return n2.epsilon = null == t4.epsilon ? 1e-3 : t4.epsilon, n2.center = null == t4.center || t4.center, n2.scale = null == t4.scale || t4.scale, n2.betaInitializer = getInitializer(t4.betaInitializer || "zeros"), n2.gammaInitializer = getInitializer(t4.gammaInitializer || "ones"), n2.betaRegularizer = getRegularizer(t4.betaRegularizer), n2.gammaRegularizer = getRegularizer(t4.gammaRegularizer), n2.supportsMasking = true, n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      var t4 = (e3 = getExactlyOneShape(e3)).length;
      "number" == typeof this.axis && (this.axis = [this.axis]);
      for (var n2 = 0; n2 < this.axis.length; ++n2)
        this.axis[n2] < 0 && (this.axis[n2] += t4);
      for (var r2 = 0, i2 = this.axis; r2 < i2.length; r2++) {
        var a2 = i2[r2];
        if (a2 < 0 || a2 >= t4)
          throw new Error("Invalid axis: " + a2);
      }
      if (this.axis.length !== unique(this.axis).length)
        throw new Error("Found duplicate axes in: " + this.axis);
      var o2 = this.axis.map(function(t5) {
        return e3[t5];
      });
      this.scale ? this.gamma = this.addWeight("gamma", o2, "float32", this.gammaInitializer, this.gammaRegularizer, true) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", o2, "float32", this.betaInitializer, this.betaRegularizer, true) : this.beta = null, this.built = true;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this, r2 = getExactlyOneTensor(e3), i2 = r2.shape, a2 = i2.length;
      return je(function() {
        for (var e4 = dl(r2, n2.axis, true), t5 = e4.mean, o2 = e4.variance, s2 = pyListRepeat(1, a2), l3 = 0, u2 = n2.axis; l3 < u2.length; l3++) {
          var c2 = u2[l3];
          s2[c2] = i2[c2];
        }
        for (var p2 = function(e5) {
          return null != e5 && e5.shape.length !== a2 && n2.axis !== [a2 - 1] ? e5.reshape(s2) : e5;
        }, h = p2(n2.gamma.read()), d2 = p2(n2.beta.read()), f2 = [], g2 = [], m2 = 0; m2 < a2; ++m2)
          -1 !== n2.axis.indexOf(m2) ? (f2.push(i2[m2]), g2.push(1)) : (f2.push(1), g2.push(i2[m2]));
        return t5 = t5.tile(f2), o2 = o2.tile(f2), h = h.tile(g2), d2 = d2.tile(g2), batchNormalization(r2, t5, o2, d2, h, n2.epsilon);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { axis: this.axis, epsilon: this.epsilon, center: this.center, scale: this.scale, betaInitializer: serializeInitializer(this.betaInitializer), gammaInitializer: serializeInitializer(this.gammaInitializer), betaRegularizer: serializeRegularizer(this.betaRegularizer), gammaRegularizer: serializeRegularizer(this.gammaRegularizer) }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "LayerNormalization", t3;
  }(Layer);
  function spatial2dPadding(e2, t3, n2) {
    return je(function() {
      if (4 !== e2.rank)
        throw new ValueError("temporalPadding expects input tensor to be 4-D, but received a " + e2.rank + "-D tensor.");
      if (null == t3 && (t3 = [[1, 1], [1, 1]]), 2 !== t3.length || 2 !== t3[0].length || 2 !== t3[1].length)
        throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
      if (null == n2 && (n2 = imageDataFormat()), "channelsLast" !== n2 && "channelsFirst" !== n2)
        throw new ValueError("Unknown data format: " + n2 + ". Supported data formats are 'channelsLast' and 'channelsFirst.");
      var r2;
      return r2 = "channelsFirst" === n2 ? [[0, 0], [0, 0], t3[0], t3[1]] : [[0, 0], t3[0], t3[1], [0, 0]], yr(e2, r2);
    });
  }
  Mf.registerClass(LayerNormalization);
  var ZeroPadding2D = function(e2) {
    function t3(t4) {
      var n2 = this;
      if (null == t4 && (t4 = {}), (n2 = e2.call(this, t4) || this).dataFormat = null == t4.dataFormat ? imageDataFormat() : t4.dataFormat, null == t4.padding)
        n2.padding = [[1, 1], [1, 1]];
      else if ("number" == typeof t4.padding)
        n2.padding = [[t4.padding, t4.padding], [t4.padding, t4.padding]];
      else {
        if (t4.padding = t4.padding, 2 !== t4.padding.length)
          throw new ValueError("ZeroPadding2D expects padding to be a length-2 array, but received a length-" + t4.padding.length + " array.");
        var r2 = void 0, i2 = void 0;
        if ("number" == typeof t4.padding[0])
          r2 = [t4.padding[0], t4.padding[0]], i2 = [t4.padding[1], t4.padding[1]];
        else {
          if (t4.padding = t4.padding, 2 !== t4.padding[0].length)
            throw new ValueError("ZeroPadding2D expects height padding to be a length-2 array, but received a length-" + t4.padding[0].length + " array.");
          if (r2 = t4.padding[0], 2 !== t4.padding[1].length)
            throw new ValueError("ZeroPadding2D expects width padding to be a length-2 array, but received a length-" + t4.padding[1].length + " array.");
          i2 = t4.padding[1];
        }
        n2.padding = [r2, i2];
      }
      return n2.inputSpec = [new InputSpec({ ndim: 4 })], n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      var t4, n2;
      return e3 = getExactlyOneShape(e3), "channelsFirst" === this.dataFormat ? (t4 = null != e3[2] && e3[2] >= 0 ? e3[2] + this.padding[0][0] + this.padding[0][1] : null, n2 = null != e3[3] && e3[3] >= 0 ? e3[3] + this.padding[1][0] + this.padding[1][1] : null, [e3[0], e3[1], t4, n2]) : (t4 = null != e3[1] && e3[1] >= 0 ? e3[1] + this.padding[0][0] + this.padding[0][1] : null, n2 = null != e3[2] && e3[2] >= 0 ? e3[2] + this.padding[1][0] + this.padding[1][1] : null, [e3[0], t4, n2, e3[3]]);
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        return spatial2dPadding(getExactlyOneTensor(e3), n2.padding, n2.dataFormat);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { padding: this.padding, dataFormat: this.dataFormat }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "ZeroPadding2D", t3;
  }(Layer);
  function pool2d(e2, t3, n2, r2, i2, a2) {
    return je(function() {
      var o2;
      checkDataFormat(i2), checkPoolMode(a2), checkPaddingMode(r2), null == n2 && (n2 = [1, 1]), null == r2 && (r2 = "valid"), null == i2 && (i2 = imageDataFormat()), null == a2 && (a2 = "max"), e2 = preprocessConv2DInput(e2, i2);
      var s2 = "same" === r2 ? "same" : "valid";
      return o2 = "max" === a2 ? $c(e2, t3, n2, s2) : Yc(e2, t3, n2, s2), "channelsFirst" === i2 && (o2 = El(o2, [0, 3, 1, 2])), o2;
    });
  }
  function pool3d(e2, t3, n2, r2, i2, a2) {
    return je(function() {
      var o2;
      checkDataFormat(i2), checkPoolMode(a2), checkPaddingMode(r2), null == n2 && (n2 = [1, 1, 1]), null == r2 && (r2 = "valid"), null == i2 && (i2 = imageDataFormat()), null == a2 && (a2 = "max"), e2 = preprocessConv3DInput(e2, i2);
      var s2 = "same" === r2 ? "same" : "valid";
      return o2 = "max" === a2 ? Jc(e2, t3, n2, s2) : Zc(e2, t3, n2, s2), "channelsFirst" === i2 && (o2 = El(o2, [0, 4, 1, 2, 3])), o2;
    });
  }
  Mf.registerClass(ZeroPadding2D);
  var Pooling1D = function(e2) {
    function t3(t4) {
      var n2 = this;
      if (null == t4.poolSize && (t4.poolSize = 2), n2 = e2.call(this, t4) || this, "number" == typeof t4.poolSize)
        n2.poolSize = [t4.poolSize];
      else {
        if (!Array.isArray(t4.poolSize) || 1 !== t4.poolSize.length || "number" != typeof t4.poolSize[0])
          throw new ValueError("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(t4.poolSize));
        n2.poolSize = t4.poolSize;
      }
      if (assertPositiveInteger(n2.poolSize, "poolSize"), null == t4.strides)
        n2.strides = n2.poolSize;
      else if ("number" == typeof t4.strides)
        n2.strides = [t4.strides];
      else {
        if (!Array.isArray(t4.strides) || 1 !== t4.strides.length || "number" != typeof t4.strides[0])
          throw new ValueError("strides for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(t4.strides));
        n2.strides = t4.strides;
      }
      return assertPositiveInteger(n2.strides, "strides"), n2.padding = null == t4.padding ? "valid" : t4.padding, checkPaddingMode(n2.padding), n2.inputSpec = [new InputSpec({ ndim: 3 })], n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      var t4 = convOutputLength((e3 = getExactlyOneShape(e3))[1], this.poolSize[0], this.padding, this.strides[0]);
      return [e3[0], t4, e3[2]];
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        n2.invokeCallHook(e3, t4), e3 = expandDims$1(getExactlyOneTensor(e3), 2);
        var r2 = n2.poolingFunction(getExactlyOneTensor(e3), [n2.poolSize[0], 1], [n2.strides[0], 1], n2.padding, "channelsLast");
        return Dr(r2, [2]);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { poolSize: this.poolSize, padding: this.padding, strides: this.strides }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3;
  }(Layer);
  var MaxPooling1D = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.poolingFunction = function(e3, t4, n2, r2, i2) {
      return checkDataFormat(i2), checkPaddingMode(r2), pool2d(e3, t4, n2, r2, i2, "max");
    }, t3.className = "MaxPooling1D", t3;
  }(Pooling1D);
  Mf.registerClass(MaxPooling1D);
  var AveragePooling1D = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.poolingFunction = function(e3, t4, n2, r2, i2) {
      return checkDataFormat(i2), checkPaddingMode(r2), pool2d(e3, t4, n2, r2, i2, "avg");
    }, t3.className = "AveragePooling1D", t3;
  }(Pooling1D);
  Mf.registerClass(AveragePooling1D);
  var Pooling2D = function(e2) {
    function t3(t4) {
      var n2 = this;
      if (null == t4.poolSize && (t4.poolSize = [2, 2]), (n2 = e2.call(this, t4) || this).poolSize = Array.isArray(t4.poolSize) ? t4.poolSize : [t4.poolSize, t4.poolSize], null == t4.strides)
        n2.strides = n2.poolSize;
      else if (Array.isArray(t4.strides)) {
        if (2 !== t4.strides.length)
          throw new ValueError("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " + t4.strides.length + ".");
        n2.strides = t4.strides;
      } else
        n2.strides = [t4.strides, t4.strides];
      return assertPositiveInteger(n2.poolSize, "poolSize"), assertPositiveInteger(n2.strides, "strides"), n2.padding = null == t4.padding ? "valid" : t4.padding, n2.dataFormat = null == t4.dataFormat ? "channelsLast" : t4.dataFormat, checkDataFormat(n2.dataFormat), checkPaddingMode(n2.padding), n2.inputSpec = [new InputSpec({ ndim: 4 })], n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      e3 = getExactlyOneShape(e3);
      var t4 = "channelsFirst" === this.dataFormat ? e3[2] : e3[1], n2 = "channelsFirst" === this.dataFormat ? e3[3] : e3[2];
      return t4 = convOutputLength(t4, this.poolSize[0], this.padding, this.strides[0]), n2 = convOutputLength(n2, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [e3[0], e3[1], t4, n2] : [e3[0], t4, n2, e3[3]];
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        return n2.invokeCallHook(e3, t4), n2.poolingFunction(getExactlyOneTensor(e3), n2.poolSize, n2.strides, n2.padding, n2.dataFormat);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { poolSize: this.poolSize, padding: this.padding, strides: this.strides, dataFormat: this.dataFormat }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3;
  }(Layer);
  var MaxPooling2D = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.poolingFunction = function(e3, t4, n2, r2, i2) {
      return checkDataFormat(i2), checkPaddingMode(r2), pool2d(e3, t4, n2, r2, i2, "max");
    }, t3.className = "MaxPooling2D", t3;
  }(Pooling2D);
  Mf.registerClass(MaxPooling2D);
  var AveragePooling2D = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.poolingFunction = function(e3, t4, n2, r2, i2) {
      return checkDataFormat(i2), checkPaddingMode(r2), pool2d(e3, t4, n2, r2, i2, "avg");
    }, t3.className = "AveragePooling2D", t3;
  }(Pooling2D);
  Mf.registerClass(AveragePooling2D);
  var Pooling3D = function(e2) {
    function t3(t4) {
      var n2 = this;
      if (null == t4.poolSize && (t4.poolSize = [2, 2, 2]), (n2 = e2.call(this, t4) || this).poolSize = Array.isArray(t4.poolSize) ? t4.poolSize : [t4.poolSize, t4.poolSize, t4.poolSize], null == t4.strides)
        n2.strides = n2.poolSize;
      else if (Array.isArray(t4.strides)) {
        if (3 !== t4.strides.length)
          throw new ValueError("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " + t4.strides.length + ".");
        n2.strides = t4.strides;
      } else
        n2.strides = [t4.strides, t4.strides, t4.strides];
      return assertPositiveInteger(n2.poolSize, "poolSize"), assertPositiveInteger(n2.strides, "strides"), n2.padding = null == t4.padding ? "valid" : t4.padding, n2.dataFormat = null == t4.dataFormat ? "channelsLast" : t4.dataFormat, checkDataFormat(n2.dataFormat), checkPaddingMode(n2.padding), n2.inputSpec = [new InputSpec({ ndim: 5 })], n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      e3 = getExactlyOneShape(e3);
      var t4 = "channelsFirst" === this.dataFormat ? e3[2] : e3[1], n2 = "channelsFirst" === this.dataFormat ? e3[3] : e3[2], r2 = "channelsFirst" === this.dataFormat ? e3[4] : e3[3];
      return t4 = convOutputLength(t4, this.poolSize[0], this.padding, this.strides[0]), n2 = convOutputLength(n2, this.poolSize[1], this.padding, this.strides[1]), r2 = convOutputLength(r2, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [e3[0], e3[1], t4, n2, r2] : [e3[0], t4, n2, r2, e3[4]];
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        return n2.invokeCallHook(e3, t4), n2.poolingFunction(getExactlyOneTensor(e3), n2.poolSize, n2.strides, n2.padding, n2.dataFormat);
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { poolSize: this.poolSize, padding: this.padding, strides: this.strides, dataFormat: this.dataFormat }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3;
  }(Layer);
  var MaxPooling3D = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.poolingFunction = function(e3, t4, n2, r2, i2) {
      return checkDataFormat(i2), checkPaddingMode(r2), pool3d(e3, t4, n2, r2, i2, "max");
    }, t3.className = "MaxPooling3D", t3;
  }(Pooling3D);
  Mf.registerClass(MaxPooling3D);
  var AveragePooling3D = function(e2) {
    function t3(t4) {
      return e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.poolingFunction = function(e3, t4, n2, r2, i2) {
      return checkDataFormat(i2), checkPaddingMode(r2), pool3d(e3, t4, n2, r2, i2, "avg");
    }, t3.className = "AveragePooling3D", t3;
  }(Pooling3D);
  Mf.registerClass(AveragePooling3D);
  var GlobalPooling1D = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.inputSpec = [new InputSpec({ ndim: 3 })], n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      return [e3[0], e3[2]];
    }, t3.prototype.call = function(e3, t4) {
      throw new NotImplementedError();
    }, t3;
  }(Layer);
  var GlobalAveragePooling1D = function(e2) {
    function t3(t4) {
      return e2.call(this, t4 || {}) || this;
    }
    return __extends(t3, e2), t3.prototype.call = function(e3, t4) {
      return je(function() {
        var t5 = getExactlyOneTensor(e3);
        return fl(t5, 1);
      });
    }, t3.className = "GlobalAveragePooling1D", t3;
  }(GlobalPooling1D);
  Mf.registerClass(GlobalAveragePooling1D);
  var GlobalMaxPooling1D = function(e2) {
    function t3(t4) {
      return e2.call(this, t4 || {}) || this;
    }
    return __extends(t3, e2), t3.prototype.call = function(e3, t4) {
      return je(function() {
        var t5 = getExactlyOneTensor(e3);
        return hl(t5, 1);
      });
    }, t3.className = "GlobalMaxPooling1D", t3;
  }(GlobalPooling1D);
  Mf.registerClass(GlobalMaxPooling1D);
  var GlobalPooling2D = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.dataFormat = null == t4.dataFormat ? "channelsLast" : t4.dataFormat, checkDataFormat(n2.dataFormat), n2.inputSpec = [new InputSpec({ ndim: 4 })], n2;
    }
    return __extends(t3, e2), t3.prototype.computeOutputShape = function(e3) {
      return e3 = e3, "channelsLast" === this.dataFormat ? [e3[0], e3[3]] : [e3[0], e3[1]];
    }, t3.prototype.call = function(e3, t4) {
      throw new NotImplementedError();
    }, t3.prototype.getConfig = function() {
      var t4 = { dataFormat: this.dataFormat }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3;
  }(Layer);
  var GlobalAveragePooling2D = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var t5 = getExactlyOneTensor(e3);
        return "channelsLast" === n2.dataFormat ? fl(t5, [1, 2]) : fl(t5, [2, 3]);
      });
    }, t3.className = "GlobalAveragePooling2D", t3;
  }(GlobalPooling2D);
  Mf.registerClass(GlobalAveragePooling2D);
  var GlobalMaxPooling2D = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var t5 = getExactlyOneTensor(e3);
        return "channelsLast" === n2.dataFormat ? hl(t5, [1, 2]) : hl(t5, [2, 3]);
      });
    }, t3.className = "GlobalMaxPooling2D", t3;
  }(GlobalPooling2D);
  function standardizeArgs(e2, t3, n2, r2) {
    if (Array.isArray(e2)) {
      if (null != t3 || null != n2)
        throw new ValueError("When inputs is an array, neither initialState or constants should be provided");
      null != r2 && (n2 = e2.slice(e2.length - r2, e2.length), e2 = e2.slice(0, e2.length - r2)), e2.length > 1 && (t3 = e2.slice(1, e2.length)), e2 = e2[0];
    }
    function i2(e3) {
      return null == e3 || Array.isArray(e3) ? e3 : [e3];
    }
    return { inputs: e2, initialState: t3 = i2(t3), constants: n2 = i2(n2) };
  }
  function rnn(e2, t3, n2, r2, i2, a2, o2, s2) {
    return void 0 === r2 && (r2 = false), void 0 === o2 && (o2 = false), void 0 === s2 && (s2 = false), je(function() {
      var l3 = t3.shape.length;
      if (l3 < 3)
        throw new ValueError("Input should be at least 3D, but is " + l3 + "D.");
      var u2 = [1, 0].concat(range(2, l3));
      if (t3 = El(t3, u2), null != a2)
        throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
      o2 && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != i2 && ((i2 = i2.asType("bool").asType("float32")).rank === l3 - 1 && (i2 = dr(i2, -1)), i2 = El(i2, u2)), r2 && (t3 = zc(t3, 0), null != i2 && (i2 = zc(i2, 0)));
      var c2, p2, h = [], d2 = n2, f2 = t3.shape[0], g2 = Or(t3);
      null != i2 && (p2 = Or(i2));
      for (var m2, y2 = function(t4) {
        var n3 = g2[t4], r3 = je(function() {
          return e2(n3, d2);
        });
        if (null == i2)
          c2 = r3[0], d2 = r3[1];
        else {
          var a3 = je(function() {
            var e3 = p2[t4], n4 = Vn(e3).sub(e3);
            return { output: r3[0].mul(e3).addStrict(d2[0].mul(n4)), newStates: d2.map(function(t5, i3) {
              return r3[1][i3].mul(e3).addStrict(t5.mul(n4));
            }) };
          });
          c2 = a3.output, d2 = a3.newStates;
        }
        s2 && h.push(c2);
      }, v2 = 0; v2 < f2; ++v2)
        y2(v2);
      if (s2) {
        m2 = Tr(h, 1);
      }
      return [c2, m2, d2];
    });
  }
  Mf.registerClass(GlobalMaxPooling2D);
  var RNN = function(e2) {
    function t3(t4) {
      var n2, r2 = e2.call(this, t4) || this;
      if (null == t4.cell)
        throw new ValueError("cell property is missing for the constructor of RNN.");
      if (null == (n2 = Array.isArray(t4.cell) ? new StackedRNNCells({ cells: t4.cell }) : t4.cell).stateSize)
        throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
      return r2.cell = n2, r2.returnSequences = null != t4.returnSequences && t4.returnSequences, r2.returnState = null != t4.returnState && t4.returnState, r2.goBackwards = null != t4.goBackwards && t4.goBackwards, r2._stateful = null != t4.stateful && t4.stateful, r2.unroll = null != t4.unroll && t4.unroll, r2.supportsMasking = true, r2.inputSpec = [new InputSpec({ ndim: 3 })], r2.stateSpec = null, r2.states_ = null, r2.numConstants = null, r2.keptStates = [], r2;
    }
    return __extends(t3, e2), t3.prototype.getStates = function() {
      return null == this.states_ ? range(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(function(e3) {
        return null;
      }) : this.states_;
    }, t3.prototype.setStates = function(e3) {
      this.states_ = e3;
    }, t3.prototype.computeOutputShape = function(e3) {
      isArrayOfShapes(e3) && (e3 = e3[0]), e3 = e3;
      var t4 = this.cell.stateSize;
      Array.isArray(t4) || (t4 = [t4]);
      var n2, r2 = t4[0];
      if (n2 = this.returnSequences ? [e3[0], e3[1], r2] : [e3[0], r2], this.returnState) {
        for (var i2 = [], a2 = 0, o2 = t4; a2 < o2.length; a2++) {
          var s2 = o2[a2];
          i2.push([e3[0], s2]);
        }
        return [n2].concat(i2);
      }
      return n2;
    }, t3.prototype.computeMask = function(e3, t4) {
      var n2 = this;
      return je(function() {
        Array.isArray(t4) && (t4 = t4[0]);
        var e4 = n2.returnSequences ? t4 : null;
        if (n2.returnState) {
          var r2 = n2.states.map(function(e5) {
            return null;
          });
          return [e4].concat(r2);
        }
        return e4;
      });
    }, Object.defineProperty(t3.prototype, "states", { get: function() {
      if (null == this.states_) {
        for (var e3 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, t4 = [], n2 = 0; n2 < e3; ++n2)
          t4.push(null);
        return t4;
      }
      return this.states_;
    }, set: function(e3) {
      this.states_ = e3;
    }, enumerable: true, configurable: true }), t3.prototype.build = function(e3) {
      if (null != this.numConstants)
        throw new NotImplementedError("Constants support is not implemented in RNN yet.");
      isArrayOfShapes(e3) && (e3 = e3[0]), e3 = e3;
      var t4 = this.stateful ? e3[0] : null, n2 = e3[e3.length - 1];
      this.inputSpec[0] = new InputSpec({ shape: [t4, null, n2] });
      var r2, i2 = [e3[0]].concat(e3.slice(2));
      if (this.cell.build(i2), r2 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
        if (!tt.arraysEqual(this.stateSpec.map(function(e4) {
          return e4.shape[e4.shape.length - 1];
        }), r2))
          throw new ValueError("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=" + this.stateSpec + "; However cell.stateSize is " + this.cell.stateSize);
      } else
        this.stateSpec = r2.map(function(e4) {
          return new InputSpec({ shape: [null, e4] });
        });
      this.stateful && this.resetStates();
    }, t3.prototype.resetStates = function(e3, t4) {
      var n2 = this;
      void 0 === t4 && (t4 = false), je(function() {
        if (!n2.stateful)
          throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
        var r2 = n2.inputSpec[0].shape[0];
        if (null == r2)
          throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        if (null == n2.states_)
          Array.isArray(n2.cell.stateSize) ? n2.states_ = n2.cell.stateSize.map(function(e4) {
            return Pn([r2, e4]);
          }) : n2.states_ = [Pn([r2, n2.cell.stateSize])];
        else if (null == e3)
          Xe(n2.states_), null != n2.keptStates && (Xe(n2.keptStates), n2.keptStates = []), Array.isArray(n2.cell.stateSize) ? n2.states_ = n2.cell.stateSize.map(function(e4) {
            return Pn([r2, e4]);
          }) : n2.states_[0] = Pn([r2, n2.cell.stateSize]);
        else {
          if (Array.isArray(e3) || (e3 = [e3]), e3.length !== n2.states_.length)
            throw new ValueError("Layer " + n2.name + " expects " + n2.states_.length + " state(s), but it received " + e3.length + " state value(s). Input received: " + e3);
          true === t4 ? n2.keptStates.push(n2.states_.slice()) : Xe(n2.states_);
          for (var i2 = 0; i2 < n2.states_.length; ++i2) {
            var a2 = e3[i2], o2 = Array.isArray(n2.cell.stateSize) ? n2.cell.stateSize[i2] : n2.cell.stateSize, s2 = [r2, o2];
            if (!tt.arraysEqual(a2.shape, s2))
              throw new ValueError("State " + i2 + " is incompatible with layer " + n2.name + ": expected shape=" + s2 + ", received shape=" + a2.shape);
            n2.states_[i2] = a2;
          }
        }
        n2.states_ = n2.states_.map(function(e4) {
          return $e(e4.clone());
        });
      });
    }, t3.prototype.apply = function(t4, n2) {
      var r2 = null == n2 ? null : n2.initialState, i2 = null == n2 ? null : n2.constants;
      null == n2 && (n2 = {});
      var a2 = standardizeArgs(t4, r2, i2, this.numConstants);
      t4 = a2.inputs, r2 = a2.initialState, i2 = a2.constants;
      var o2 = [], s2 = [];
      if (null != r2) {
        n2.initialState = r2, o2 = o2.concat(r2), this.stateSpec = [];
        for (var l3 = 0, u2 = r2; l3 < u2.length; l3++) {
          var c2 = u2[l3];
          this.stateSpec.push(new InputSpec({ shape: c2.shape }));
        }
        s2 = s2.concat(this.stateSpec);
      }
      if (null != i2 && (n2.constants = i2, o2 = o2.concat(i2), this.numConstants = i2.length), o2[0] instanceof SymbolicTensor) {
        var p2 = [t4].concat(o2), h = this.inputSpec.concat(s2), d2 = this.inputSpec;
        this.inputSpec = h;
        var f2 = e2.prototype.apply.call(this, p2, n2);
        return this.inputSpec = d2, f2;
      }
      return e2.prototype.apply.call(this, t4, n2);
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var r2 = null == t4 ? null : t4.mask, i2 = null == t4 ? null : t4.training, a2 = null == t4 ? null : t4.initialState;
        e3 = getExactlyOneTensor(e3), null == a2 && (a2 = n2.stateful ? n2.states_ : n2.getInitialState(e3));
        var o2 = Array.isArray(n2.cell.stateSize) ? n2.cell.stateSize.length : 1;
        if (a2.length !== o2)
          throw new ValueError("RNN Layer has " + o2 + " state(s) but was passed " + a2.length + " initial state(s).");
        n2.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
        var s2 = { training: i2 }, l3 = rnn(function(e4, t5) {
          var r3 = n2.cell.call([e4].concat(t5), s2);
          return [r3[0], r3.slice(1)];
        }, e3, a2, n2.goBackwards, r2, null, n2.unroll, n2.returnSequences), u2 = l3[0], c2 = l3[1], p2 = l3[2];
        n2.stateful && n2.resetStates(p2, i2);
        var h = n2.returnSequences ? c2 : u2;
        return n2.returnState ? [h].concat(p2) : h;
      });
    }, t3.prototype.getInitialState = function(e3) {
      var t4 = this;
      return je(function() {
        var n2 = Pn(e3.shape);
        return n2 = expandDims$1(n2 = vl(n2, [1, 2])), Array.isArray(t4.cell.stateSize) ? t4.cell.stateSize.map(function(e4) {
          return e4 > 1 ? tile$1(n2, [1, e4]) : n2;
        }) : t4.cell.stateSize > 1 ? [tile$1(n2, [1, t4.cell.stateSize])] : [n2];
      });
    }, Object.defineProperty(t3.prototype, "trainableWeights", { get: function() {
      return this.trainable ? this.cell.trainableWeights : [];
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "nonTrainableWeights", { get: function() {
      return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
    }, enumerable: true, configurable: true }), t3.prototype.setFastWeightInitDuringBuild = function(t4) {
      e2.prototype.setFastWeightInitDuringBuild.call(this, t4), null != this.cell && this.cell.setFastWeightInitDuringBuild(t4);
    }, t3.prototype.getConfig = function() {
      var t4 = { returnSequences: this.returnSequences, returnState: this.returnState, goBackwards: this.goBackwards, stateful: this.stateful, unroll: this.unroll };
      null != this.numConstants && (t4.numConstants = this.numConstants);
      var n2 = this.cell.getConfig();
      t4.cell = { className: this.cell.getClassName(), config: n2 };
      var r2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, r2), t4;
    }, t3.fromConfig = function(e3, t4, n2) {
      void 0 === n2 && (n2 = {});
      var r2 = deserialize(t4.cell, n2);
      return new e3(Object.assign(t4, { cell: r2 }));
    }, t3.className = "RNN", t3;
  }(Layer);
  Mf.registerClass(RNN);
  var RNNCell = function(e2) {
    function t3() {
      return null !== e2 && e2.apply(this, arguments) || this;
    }
    return __extends(t3, e2), t3;
  }(Layer);
  var SimpleRNNCell = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.DEFAULT_ACTIVATION = "tanh", n2.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n2.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n2.DEFAULT_BIAS_INITIALIZER = "zeros", n2.units = t4.units, assertPositiveInteger(n2.units, "units"), n2.activation = getActivation(null == t4.activation ? n2.DEFAULT_ACTIVATION : t4.activation), n2.useBias = null == t4.useBias || t4.useBias, n2.kernelInitializer = getInitializer(t4.kernelInitializer || n2.DEFAULT_KERNEL_INITIALIZER), n2.recurrentInitializer = getInitializer(t4.recurrentInitializer || n2.DEFAULT_RECURRENT_INITIALIZER), n2.biasInitializer = getInitializer(t4.biasInitializer || n2.DEFAULT_BIAS_INITIALIZER), n2.kernelRegularizer = getRegularizer(t4.kernelRegularizer), n2.recurrentRegularizer = getRegularizer(t4.recurrentRegularizer), n2.biasRegularizer = getRegularizer(t4.biasRegularizer), n2.kernelConstraint = getConstraint(t4.kernelConstraint), n2.recurrentConstraint = getConstraint(t4.recurrentConstraint), n2.biasConstraint = getConstraint(t4.biasConstraint), n2.dropout = min$1([1, max$1([0, null == t4.dropout ? 0 : t4.dropout])]), n2.recurrentDropout = min$1([1, max$1([0, null == t4.recurrentDropout ? 0 : t4.recurrentDropout])]), n2.stateSize = n2.units, n2.dropoutMask = null, n2.recurrentDropoutMask = null, n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      e3 = getExactlyOneShape(e3), this.kernel = this.addWeight("kernel", [e3[e3.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        if (2 !== (e3 = e3).length)
          throw new ValueError("SimpleRNNCell expects 2 input Tensors, got " + e3.length + ".");
        var r2 = e3[1];
        e3 = e3[0];
        var i2, a2 = null != t4.training && t4.training;
        0 < n2.dropout && n2.dropout < 1 && null == n2.dropoutMask && (n2.dropoutMask = generateDropoutMask(function() {
          return Vn(e3);
        }, n2.dropout, a2)), 0 < n2.recurrentDropout && n2.recurrentDropout < 1 && null == n2.recurrentDropoutMask && (n2.recurrentDropoutMask = generateDropoutMask(function() {
          return Vn(r2);
        }, n2.recurrentDropout, a2));
        var o2 = n2.dropoutMask, s2 = n2.recurrentDropoutMask;
        i2 = dot(null != o2 ? tc(e3, o2) : e3, n2.kernel.read()), null != n2.bias && (i2 = biasAdd(i2, n2.bias.read())), null != s2 && (r2 = tc(r2, s2));
        var l3 = Vs(i2, dot(r2, n2.recurrentKernel.read()));
        return null != n2.activation && (l3 = n2.activation.apply(l3)), [l3, l3];
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { units: this.units, activation: serializeActivation(this.activation), useBias: this.useBias, kernelInitializer: serializeInitializer(this.kernelInitializer), recurrentInitializer: serializeInitializer(this.recurrentInitializer), biasInitializer: serializeInitializer(this.biasInitializer), kernelRegularizer: serializeRegularizer(this.kernelRegularizer), recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer), biasRegularizer: serializeRegularizer(this.biasRegularizer), activityRegularizer: serializeRegularizer(this.activityRegularizer), kernelConstraint: serializeConstraint(this.kernelConstraint), recurrentConstraint: serializeConstraint(this.recurrentConstraint), biasConstraint: serializeConstraint(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "SimpleRNNCell", t3;
  }(RNNCell);
  Mf.registerClass(SimpleRNNCell);
  var SimpleRNN = function(e2) {
    function t3(t4) {
      return t4.cell = new SimpleRNNCell(t4), e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.call = function(t4, n2) {
      var r2 = this;
      return je(function() {
        null != r2.cell.dropoutMask && (Xe(r2.cell.dropoutMask), r2.cell.dropoutMask = null), null != r2.cell.recurrentDropoutMask && (Xe(r2.cell.recurrentDropoutMask), r2.cell.recurrentDropoutMask = null);
        var i2 = null == n2 ? null : n2.mask, a2 = null == n2 ? null : n2.training, o2 = null == n2 ? null : n2.initialState;
        return e2.prototype.call.call(r2, t4, { mask: i2, training: a2, initialState: o2 });
      });
    }, Object.defineProperty(t3.prototype, "units", { get: function() {
      return this.cell.units;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "activation", { get: function() {
      return this.cell.activation;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "useBias", { get: function() {
      return this.cell.useBias;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "kernelInitializer", { get: function() {
      return this.cell.kernelInitializer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentInitializer", { get: function() {
      return this.cell.recurrentInitializer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "biasInitializer", { get: function() {
      return this.cell.biasInitializer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "kernelRegularizer", { get: function() {
      return this.cell.kernelRegularizer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentRegularizer", { get: function() {
      return this.cell.recurrentRegularizer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "biasRegularizer", { get: function() {
      return this.cell.biasRegularizer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "kernelConstraint", { get: function() {
      return this.cell.kernelConstraint;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentConstraint", { get: function() {
      return this.cell.recurrentConstraint;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "biasConstraint", { get: function() {
      return this.cell.biasConstraint;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "dropout", { get: function() {
      return this.cell.dropout;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentDropout", { get: function() {
      return this.cell.recurrentDropout;
    }, enumerable: true, configurable: true }), t3.prototype.getConfig = function() {
      var t4 = { units: this.units, activation: serializeActivation(this.activation), useBias: this.useBias, kernelInitializer: serializeInitializer(this.kernelInitializer), recurrentInitializer: serializeInitializer(this.recurrentInitializer), biasInitializer: serializeInitializer(this.biasInitializer), kernelRegularizer: serializeRegularizer(this.kernelRegularizer), recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer), biasRegularizer: serializeRegularizer(this.biasRegularizer), activityRegularizer: serializeRegularizer(this.activityRegularizer), kernelConstraint: serializeConstraint(this.kernelConstraint), recurrentConstraint: serializeConstraint(this.recurrentConstraint), biasConstraint: serializeConstraint(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout }, n2 = e2.prototype.getConfig.call(this);
      return delete n2.cell, Object.assign(t4, n2), t4;
    }, t3.fromConfig = function(e3, t4) {
      return new e3(t4);
    }, t3.className = "SimpleRNN", t3;
  }(RNN);
  Mf.registerClass(SimpleRNN);
  var GRUCell = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.DEFAULT_ACTIVATION = "tanh", n2.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n2.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n2.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n2.DEFAULT_BIAS_INITIALIZER = "zeros", n2.units = t4.units, assertPositiveInteger(n2.units, "units"), n2.activation = getActivation(void 0 === t4.activation ? n2.DEFAULT_ACTIVATION : t4.activation), n2.recurrentActivation = getActivation(void 0 === t4.recurrentActivation ? n2.DEFAULT_RECURRENT_ACTIVATION : t4.recurrentActivation), n2.useBias = null == t4.useBias || t4.useBias, n2.kernelInitializer = getInitializer(t4.kernelInitializer || n2.DEFAULT_KERNEL_INITIALIZER), n2.recurrentInitializer = getInitializer(t4.recurrentInitializer || n2.DEFAULT_RECURRENT_INITIALIZER), n2.biasInitializer = getInitializer(t4.biasInitializer || n2.DEFAULT_BIAS_INITIALIZER), n2.kernelRegularizer = getRegularizer(t4.kernelRegularizer), n2.recurrentRegularizer = getRegularizer(t4.recurrentRegularizer), n2.biasRegularizer = getRegularizer(t4.biasRegularizer), n2.kernelConstraint = getConstraint(t4.kernelConstraint), n2.recurrentConstraint = getConstraint(t4.recurrentConstraint), n2.biasConstraint = getConstraint(t4.biasConstraint), n2.dropout = min$1([1, max$1([0, null == t4.dropout ? 0 : t4.dropout])]), n2.recurrentDropout = min$1([1, max$1([0, null == t4.recurrentDropout ? 0 : t4.recurrentDropout])]), n2.implementation = t4.implementation, n2.stateSize = n2.units, n2.dropoutMask = null, n2.recurrentDropoutMask = null, n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      var t4 = (e3 = getExactlyOneShape(e3))[e3.length - 1];
      this.kernel = this.addWeight("kernel", [t4, 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        if (2 !== (e3 = e3).length)
          throw new ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got " + e3.length + ".");
        var r2 = null != t4.training && t4.training, i2 = e3[1];
        e3 = e3[0], 0 < n2.dropout && n2.dropout < 1 && null == n2.dropoutMask && (n2.dropoutMask = generateDropoutMask(function() {
          return Vn(e3);
        }, n2.dropout, r2, 3)), 0 < n2.recurrentDropout && n2.recurrentDropout < 1 && null == n2.recurrentDropoutMask && (n2.recurrentDropoutMask = generateDropoutMask(function() {
          return Vn(i2);
        }, n2.recurrentDropout, r2, 3));
        var a2, o2, s2, l3 = n2.dropoutMask, u2 = n2.recurrentDropoutMask;
        0 < n2.dropout && n2.dropout < 1 && (e3 = tc(e3, l3[0]));
        var c2 = dot(e3, n2.kernel.read());
        n2.useBias && (c2 = biasAdd(c2, n2.bias.read())), 0 < n2.recurrentDropout && n2.recurrentDropout < 1 && (i2 = tc(i2, u2[0]));
        var p2 = n2.recurrentKernel.read(), h = Xn(p2, [2 * n2.units, n2.units], p2.rank - 1), d2 = h[0], f2 = h[1], g2 = dot(i2, d2), m2 = Xn(c2, 3, c2.rank - 1), y2 = m2[0], v2 = m2[1], b2 = m2[2], w2 = Xn(g2, 2, g2.rank - 1), z3 = w2[0], S3 = w2[1];
        a2 = n2.recurrentActivation.apply(Vs(y2, z3)), o2 = n2.recurrentActivation.apply(Vs(v2, S3));
        var A2 = dot(tc(o2, i2), f2);
        s2 = n2.activation.apply(Vs(b2, A2));
        var _3 = Vs(tc(a2, i2), tc(Vs(1, as(a2)), s2));
        return [_3, _3];
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { units: this.units, activation: serializeActivation(this.activation), recurrentActivation: serializeActivation(this.recurrentActivation), useBias: this.useBias, kernelInitializer: serializeInitializer(this.kernelInitializer), recurrentInitializer: serializeInitializer(this.recurrentInitializer), biasInitializer: serializeInitializer(this.biasInitializer), kernelRegularizer: serializeRegularizer(this.kernelRegularizer), recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer), biasRegularizer: serializeRegularizer(this.biasRegularizer), activityRegularizer: serializeRegularizer(this.activityRegularizer), kernelConstraint: serializeConstraint(this.kernelConstraint), recurrentConstraint: serializeConstraint(this.recurrentConstraint), biasConstraint: serializeConstraint(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout, implementation: this.implementation }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "GRUCell", t3;
  }(RNNCell);
  Mf.registerClass(GRUCell);
  var GRU = function(e2) {
    function t3(t4) {
      return 0 === t4.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t4.cell = new GRUCell(t4), e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.call = function(t4, n2) {
      var r2 = this;
      return je(function() {
        null != r2.cell.dropoutMask && (Xe(r2.cell.dropoutMask), r2.cell.dropoutMask = null), null != r2.cell.recurrentDropoutMask && (Xe(r2.cell.recurrentDropoutMask), r2.cell.recurrentDropoutMask = null);
        var i2 = null == n2 ? null : n2.mask, a2 = null == n2 ? null : n2.training, o2 = null == n2 ? null : n2.initialState;
        return e2.prototype.call.call(r2, t4, { mask: i2, training: a2, initialState: o2 });
      });
    }, Object.defineProperty(t3.prototype, "units", { get: function() {
      return this.cell.units;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "activation", { get: function() {
      return this.cell.activation;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentActivation", { get: function() {
      return this.cell.recurrentActivation;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "useBias", { get: function() {
      return this.cell.useBias;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "kernelInitializer", { get: function() {
      return this.cell.kernelInitializer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentInitializer", { get: function() {
      return this.cell.recurrentInitializer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "biasInitializer", { get: function() {
      return this.cell.biasInitializer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "kernelRegularizer", { get: function() {
      return this.cell.kernelRegularizer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentRegularizer", { get: function() {
      return this.cell.recurrentRegularizer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "biasRegularizer", { get: function() {
      return this.cell.biasRegularizer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "kernelConstraint", { get: function() {
      return this.cell.kernelConstraint;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentConstraint", { get: function() {
      return this.cell.recurrentConstraint;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "biasConstraint", { get: function() {
      return this.cell.biasConstraint;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "dropout", { get: function() {
      return this.cell.dropout;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentDropout", { get: function() {
      return this.cell.recurrentDropout;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "implementation", { get: function() {
      return this.cell.implementation;
    }, enumerable: true, configurable: true }), t3.prototype.getConfig = function() {
      var t4 = { units: this.units, activation: serializeActivation(this.activation), recurrentActivation: serializeActivation(this.recurrentActivation), useBias: this.useBias, kernelInitializer: serializeInitializer(this.kernelInitializer), recurrentInitializer: serializeInitializer(this.recurrentInitializer), biasInitializer: serializeInitializer(this.biasInitializer), kernelRegularizer: serializeRegularizer(this.kernelRegularizer), recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer), biasRegularizer: serializeRegularizer(this.biasRegularizer), activityRegularizer: serializeRegularizer(this.activityRegularizer), kernelConstraint: serializeConstraint(this.kernelConstraint), recurrentConstraint: serializeConstraint(this.recurrentConstraint), biasConstraint: serializeConstraint(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout, implementation: this.implementation }, n2 = e2.prototype.getConfig.call(this);
      return delete n2.cell, Object.assign(t4, n2), t4;
    }, t3.fromConfig = function(e3, t4) {
      return 0 === t4.implmentation && (t4.implementation = 1), new e3(t4);
    }, t3.className = "GRU", t3;
  }(RNN);
  Mf.registerClass(GRU);
  var LSTMCell = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.DEFAULT_ACTIVATION = "tanh", n2.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n2.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n2.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n2.DEFAULT_BIAS_INITIALIZER = "zeros", n2.units = t4.units, assertPositiveInteger(n2.units, "units"), n2.activation = getActivation(void 0 === t4.activation ? n2.DEFAULT_ACTIVATION : t4.activation), n2.recurrentActivation = getActivation(void 0 === t4.recurrentActivation ? n2.DEFAULT_RECURRENT_ACTIVATION : t4.recurrentActivation), n2.useBias = null == t4.useBias || t4.useBias, n2.kernelInitializer = getInitializer(t4.kernelInitializer || n2.DEFAULT_KERNEL_INITIALIZER), n2.recurrentInitializer = getInitializer(t4.recurrentInitializer || n2.DEFAULT_RECURRENT_INITIALIZER), n2.biasInitializer = getInitializer(t4.biasInitializer || n2.DEFAULT_BIAS_INITIALIZER), n2.unitForgetBias = t4.unitForgetBias, n2.kernelRegularizer = getRegularizer(t4.kernelRegularizer), n2.recurrentRegularizer = getRegularizer(t4.recurrentRegularizer), n2.biasRegularizer = getRegularizer(t4.biasRegularizer), n2.kernelConstraint = getConstraint(t4.kernelConstraint), n2.recurrentConstraint = getConstraint(t4.recurrentConstraint), n2.biasConstraint = getConstraint(t4.biasConstraint), n2.dropout = min$1([1, max$1([0, null == t4.dropout ? 0 : t4.dropout])]), n2.recurrentDropout = min$1([1, max$1([0, null == t4.recurrentDropout ? 0 : t4.recurrentDropout])]), n2.implementation = t4.implementation, n2.stateSize = [n2.units, n2.units], n2.dropoutMask = null, n2.recurrentDropoutMask = null, n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      var t4, n2, r2 = (e3 = getExactlyOneShape(e3))[e3.length - 1];
      if (this.kernel = this.addWeight("kernel", [r2, 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias) {
        if (this.unitForgetBias) {
          var i2 = this.biasInitializer, a2 = this.units;
          n2 = new ((t4 = function(e4) {
            function t5() {
              return null !== e4 && e4.apply(this, arguments) || this;
            }
            return __extends(t5, e4), t5.prototype.apply = function(e5, t6) {
              var n3 = i2.apply([a2]), r3 = new Ones().apply([a2]), o2 = i2.apply([2 * a2]);
              return concatAlongFirstAxis(concatAlongFirstAxis(n3, r3), o2);
            }, t5;
          }(Initializer)).className = "CustomInit", t4)();
        } else
          n2 = this.biasInitializer;
        this.bias = this.addWeight("bias", [4 * this.units], null, n2, this.biasRegularizer, true, this.biasConstraint);
      } else
        this.bias = null;
      this.built = true;
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        var r2 = null != t4.training && t4.training;
        if (3 !== (e3 = e3).length)
          throw new ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got " + e3.length + ".");
        var i2 = e3[1], a2 = e3[2];
        e3 = e3[0], 0 < n2.dropout && n2.dropout < 1 && null == n2.dropoutMask && (n2.dropoutMask = generateDropoutMask(function() {
          return Vn(e3);
        }, n2.dropout, r2, 4)), 0 < n2.recurrentDropout && n2.recurrentDropout < 1 && null == n2.recurrentDropoutMask && (n2.recurrentDropoutMask = generateDropoutMask(function() {
          return Vn(i2);
        }, n2.recurrentDropout, r2, 4));
        var o2, s2, l3, u2, c2 = n2.dropoutMask, p2 = n2.recurrentDropoutMask;
        0 < n2.dropout && n2.dropout < 1 && (e3 = tc(e3, c2[0]));
        var h = dot(e3, n2.kernel.read());
        0 < n2.recurrentDropout && n2.recurrentDropout < 1 && (i2 = tc(i2, p2[0])), h = Vs(h, dot(i2, n2.recurrentKernel.read())), n2.useBias && (h = biasAdd(h, n2.bias.read()));
        var d2 = Xn(h, 4, h.rank - 1), f2 = d2[0], g2 = d2[1], m2 = d2[2], y2 = d2[3];
        o2 = n2.recurrentActivation.apply(f2), s2 = n2.recurrentActivation.apply(g2), l3 = Vs(tc(s2, a2), tc(o2, n2.activation.apply(m2))), u2 = n2.recurrentActivation.apply(y2);
        var v2 = tc(u2, n2.activation.apply(l3));
        return [v2, v2, l3];
      });
    }, t3.prototype.getConfig = function() {
      var t4 = { units: this.units, activation: serializeActivation(this.activation), recurrentActivation: serializeActivation(this.recurrentActivation), useBias: this.useBias, kernelInitializer: serializeInitializer(this.kernelInitializer), recurrentInitializer: serializeInitializer(this.recurrentInitializer), biasInitializer: serializeInitializer(this.biasInitializer), unitForgetBias: this.unitForgetBias, kernelRegularizer: serializeRegularizer(this.kernelRegularizer), recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer), biasRegularizer: serializeRegularizer(this.biasRegularizer), activityRegularizer: serializeRegularizer(this.activityRegularizer), kernelConstraint: serializeConstraint(this.kernelConstraint), recurrentConstraint: serializeConstraint(this.recurrentConstraint), biasConstraint: serializeConstraint(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout, implementation: this.implementation }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.className = "LSTMCell", t3;
  }(RNNCell);
  Mf.registerClass(LSTMCell);
  var LSTM = function(e2) {
    function t3(t4) {
      return 0 === t4.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t4.cell = new LSTMCell(t4), e2.call(this, t4) || this;
    }
    return __extends(t3, e2), t3.prototype.call = function(t4, n2) {
      var r2 = this;
      return je(function() {
        null != r2.cell.dropoutMask && (Xe(r2.cell.dropoutMask), r2.cell.dropoutMask = null), null != r2.cell.recurrentDropoutMask && (Xe(r2.cell.recurrentDropoutMask), r2.cell.recurrentDropoutMask = null);
        var i2 = null == n2 ? null : n2.mask, a2 = null == n2 ? null : n2.training, o2 = null == n2 ? null : n2.initialState;
        return e2.prototype.call.call(r2, t4, { mask: i2, training: a2, initialState: o2 });
      });
    }, Object.defineProperty(t3.prototype, "units", { get: function() {
      return this.cell.units;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "activation", { get: function() {
      return this.cell.activation;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentActivation", { get: function() {
      return this.cell.recurrentActivation;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "useBias", { get: function() {
      return this.cell.useBias;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "kernelInitializer", { get: function() {
      return this.cell.kernelInitializer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentInitializer", { get: function() {
      return this.cell.recurrentInitializer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "biasInitializer", { get: function() {
      return this.cell.biasInitializer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "unitForgetBias", { get: function() {
      return this.cell.unitForgetBias;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "kernelRegularizer", { get: function() {
      return this.cell.kernelRegularizer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentRegularizer", { get: function() {
      return this.cell.recurrentRegularizer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "biasRegularizer", { get: function() {
      return this.cell.biasRegularizer;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "kernelConstraint", { get: function() {
      return this.cell.kernelConstraint;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentConstraint", { get: function() {
      return this.cell.recurrentConstraint;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "biasConstraint", { get: function() {
      return this.cell.biasConstraint;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "dropout", { get: function() {
      return this.cell.dropout;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "recurrentDropout", { get: function() {
      return this.cell.recurrentDropout;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "implementation", { get: function() {
      return this.cell.implementation;
    }, enumerable: true, configurable: true }), t3.prototype.getConfig = function() {
      var t4 = { units: this.units, activation: serializeActivation(this.activation), recurrentActivation: serializeActivation(this.recurrentActivation), useBias: this.useBias, kernelInitializer: serializeInitializer(this.kernelInitializer), recurrentInitializer: serializeInitializer(this.recurrentInitializer), biasInitializer: serializeInitializer(this.biasInitializer), unitForgetBias: this.unitForgetBias, kernelRegularizer: serializeRegularizer(this.kernelRegularizer), recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer), biasRegularizer: serializeRegularizer(this.biasRegularizer), activityRegularizer: serializeRegularizer(this.activityRegularizer), kernelConstraint: serializeConstraint(this.kernelConstraint), recurrentConstraint: serializeConstraint(this.recurrentConstraint), biasConstraint: serializeConstraint(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout, implementation: this.implementation }, n2 = e2.prototype.getConfig.call(this);
      return delete n2.cell, Object.assign(t4, n2), t4;
    }, t3.fromConfig = function(e3, t4) {
      return 0 === t4.implmentation && (t4.implementation = 1), new e3(t4);
    }, t3.className = "LSTM", t3;
  }(RNN);
  Mf.registerClass(LSTM);
  var StackedRNNCells = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.cells = t4.cells, n2;
    }
    return __extends(t3, e2), Object.defineProperty(t3.prototype, "stateSize", { get: function() {
      for (var e3 = [], t4 = 0, n2 = this.cells.slice().reverse(); t4 < n2.length; t4++) {
        var r2 = n2[t4];
        Array.isArray(r2.stateSize) ? e3.push.apply(e3, r2.stateSize) : e3.push(r2.stateSize);
      }
      return e3;
    }, enumerable: true, configurable: true }), t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        for (var r2 = (e3 = e3).slice(1), i2 = [], a2 = 0, o2 = n2.cells.slice().reverse(); a2 < o2.length; a2++) {
          var s2 = o2[a2];
          Array.isArray(s2.stateSize) ? i2.push(r2.splice(0, s2.stateSize.length)) : i2.push(r2.splice(0, 1));
        }
        i2.reverse();
        for (var l3, u2 = [], c2 = 0; c2 < n2.cells.length; ++c2) {
          s2 = n2.cells[c2];
          r2 = i2[c2], l3 = 0 === c2 ? [e3[0]].concat(r2) : [l3[0]].concat(r2), l3 = s2.call(l3, t4), u2.push(l3.slice(1));
        }
        r2 = [];
        for (var p2 = 0, h = u2.slice().reverse(); p2 < h.length; p2++) {
          var d2 = h[p2];
          r2.push.apply(r2, d2);
        }
        return [l3[0]].concat(r2);
      });
    }, t3.prototype.build = function(e3) {
      var t4;
      isArrayOfShapes(e3) && (e3 = e3[0]), e3 = e3, this.cells.forEach(function(n2, r2) {
        nameScope("RNNCell_" + r2, function() {
          n2.build(e3), t4 = Array.isArray(n2.stateSize) ? n2.stateSize[0] : n2.stateSize, e3 = [e3[0], t4];
        });
      }), this.built = true;
    }, t3.prototype.getConfig = function() {
      for (var t4 = [], n2 = 0, r2 = this.cells; n2 < r2.length; n2++) {
        var i2 = r2[n2];
        t4.push({ className: i2.getClassName(), config: i2.getConfig() });
      }
      var a2 = { cells: t4 }, o2 = e2.prototype.getConfig.call(this);
      return Object.assign(a2, o2), a2;
    }, t3.fromConfig = function(e3, t4, n2) {
      void 0 === n2 && (n2 = {});
      for (var r2 = [], i2 = 0, a2 = t4.cells; i2 < a2.length; i2++) {
        var o2 = a2[i2];
        r2.push(deserialize(o2, n2));
      }
      return new e3({ cells: r2 });
    }, Object.defineProperty(t3.prototype, "trainableWeights", { get: function() {
      if (!this.trainable)
        return [];
      for (var e3 = [], t4 = 0, n2 = this.cells; t4 < n2.length; t4++) {
        var r2 = n2[t4];
        e3.push.apply(e3, r2.trainableWeights);
      }
      return e3;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "nonTrainableWeights", { get: function() {
      for (var e3 = [], t4 = 0, n2 = this.cells; t4 < n2.length; t4++) {
        var r2 = n2[t4];
        e3.push.apply(e3, r2.nonTrainableWeights);
      }
      if (!this.trainable) {
        for (var i2 = [], a2 = 0, o2 = this.cells; a2 < o2.length; a2++) {
          r2 = o2[a2];
          i2.push.apply(i2, r2.trainableWeights);
        }
        return i2.concat(e3);
      }
      return e3;
    }, enumerable: true, configurable: true }), t3.prototype.getWeights = function() {
      for (var e3 = [], t4 = 0, n2 = this.cells; t4 < n2.length; t4++) {
        var r2 = n2[t4];
        e3.push.apply(e3, r2.weights);
      }
      return batchGetValue(e3);
    }, t3.prototype.setWeights = function(e3) {
      for (var t4 = [], n2 = 0, r2 = this.cells; n2 < r2.length; n2++)
        for (var i2 = r2[n2], a2 = i2.weights.length, o2 = e3.splice(a2), s2 = 0; s2 < i2.weights.length; ++s2)
          t4.push([i2.weights[s2], o2[s2]]);
      batchSetValue(t4);
    }, t3.className = "StackedRNNCells", t3;
  }(RNNCell);
  function generateDropoutMask(e2, t3, n2, r2) {
    function i2() {
      return dropout$1(e2(), t3);
    }
    if (void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = 1), r2 > 1) {
      for (var a2 = [], o2 = 0; o2 < r2; o2++)
        a2.push(inTrainPhase(i2, e2, n2));
      return a2.map(function(e3) {
        return $e(e3.clone());
      });
    }
    return $e(inTrainPhase(i2, e2, n2).clone());
  }
  Mf.registerClass(StackedRNNCells);
  var Wrapper = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.layer = t4.layer, n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(e3) {
      this.built = true;
    }, Object.defineProperty(t3.prototype, "trainable", { get: function() {
      return null != this.layer && this.layer.trainable;
    }, set: function(e3) {
      null != this.layer && (this.layer.trainable = e3);
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "trainableWeights", { get: function() {
      return this.layer.trainableWeights;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "nonTrainableWeights", { get: function() {
      return this.layer.nonTrainableWeights;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "updates", { get: function() {
      return this.layer._updates;
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "losses", { get: function() {
      return this.layer.losses;
    }, enumerable: true, configurable: true }), t3.prototype.getWeights = function() {
      return this.layer.getWeights();
    }, t3.prototype.setWeights = function(e3) {
      this.layer.setWeights(e3);
    }, t3.prototype.getConfig = function() {
      var t4 = { layer: { className: this.layer.getClassName(), config: this.layer.getConfig() } }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.prototype.setFastWeightInitDuringBuild = function(t4) {
      e2.prototype.setFastWeightInitDuringBuild.call(this, t4), null != this.layer && this.layer.setFastWeightInitDuringBuild(t4);
    }, t3.fromConfig = function(e3, t4, n2) {
      void 0 === n2 && (n2 = {});
      var r2 = deserialize(t4.layer, n2);
      delete t4.layer;
      var i2 = { layer: r2 };
      return Object.assign(i2, t4), new e3(i2);
    }, t3;
  }(Layer);
  var TimeDistributed = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this;
      return n2.supportsMasking = true, n2;
    }
    return __extends(t3, e2), t3.prototype.build = function(t4) {
      if ((t4 = getExactlyOneShape(t4)).length < 3)
        throw new ValueError("TimeDistributed layer expects an input shape >= 3D, but received input shape " + JSON.stringify(t4));
      this.inputSpec = [{ shape: t4 }];
      var n2 = [t4[0]].concat(t4.slice(2));
      this.layer.built || (this.layer.build(n2), this.layer.built = true), e2.prototype.build.call(this, t4);
    }, t3.prototype.computeOutputShape = function(e3) {
      var t4 = [(e3 = getExactlyOneShape(e3))[0]].concat(e3.slice(2)), n2 = this.layer.computeOutputShape(t4), r2 = e3[1];
      return [n2[0], r2].concat(n2.slice(1));
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        return rnn(function(e4, r2) {
          return [getExactlyOneTensor(n2.layer.call(e4, t4)), []];
        }, e3 = getExactlyOneTensor(e3), [], false, null, null, false, true)[1];
      });
    }, t3.className = "TimeDistributed", t3;
  }(Wrapper);
  function checkBidirectionalMergeMode(e2) {
    checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES, "BidirectionalMergeMode", e2);
  }
  Mf.registerClass(TimeDistributed);
  var DEFAULT_BIDIRECTIONAL_MERGE_MODE = "concat";
  var Bidirectional = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this, t4) || this, r2 = t4.layer.getConfig(), i2 = {};
      i2.className = t4.layer.getClassName(), i2.config = r2, n2.forwardLayer = deserialize(i2), r2.goBackwards = true !== r2.goBackwards;
      var a2 = {};
      if (a2.className = t4.layer.getClassName(), a2.config = r2, n2.backwardLayer = deserialize(a2), n2.forwardLayer.name = "forward_" + n2.forwardLayer.name, n2.backwardLayer.name = "backward_" + n2.backwardLayer.name, n2.mergeMode = void 0 === t4.mergeMode ? DEFAULT_BIDIRECTIONAL_MERGE_MODE : t4.mergeMode, checkBidirectionalMergeMode(n2.mergeMode), t4.weights)
        throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");
      return n2._stateful = t4.layer.stateful, n2.returnSequences = t4.layer.returnSequences, n2.returnState = t4.layer.returnState, n2.supportsMasking = true, n2._trainable = true, n2.inputSpec = t4.layer.inputSpec, n2.numConstants = null, n2;
    }
    return __extends(t3, e2), Object.defineProperty(t3.prototype, "trainable", { get: function() {
      return this._trainable;
    }, set: function(e3) {
      this._trainable = e3, null != this.forwardLayer && (this.forwardLayer.trainable = e3), null != this.backwardLayer && (this.backwardLayer.trainable = e3);
    }, enumerable: true, configurable: true }), t3.prototype.getWeights = function() {
      return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    }, t3.prototype.setWeights = function(e3) {
      var t4 = e3.length, n2 = Math.floor(t4 / 2);
      this.forwardLayer.setWeights(e3.slice(0, n2)), this.backwardLayer.setWeights(e3.slice(n2));
    }, t3.prototype.computeOutputShape = function(e3) {
      var t4, n2, r2, i2 = this.forwardLayer.computeOutputShape(e3);
      return Array.isArray(i2) && Array.isArray(i2[0]) || (i2 = [i2]), i2 = i2, this.returnState ? (r2 = i2.slice(1), t4 = i2[0]) : t4 = i2[0], t4 = t4, "concat" === this.mergeMode ? (t4[t4.length - 1] *= 2, n2 = [t4]) : n2 = null == this.mergeMode ? [t4, t4.slice()] : [t4], this.returnState ? null == this.mergeMode ? n2.concat(r2).concat(r2.slice()) : [t4].concat(r2).concat(r2.slice()) : singletonOrArray(n2);
    }, t3.prototype.apply = function(t4, n2) {
      var r2 = null == n2 ? null : n2.initialState, i2 = null == n2 ? null : n2.constants;
      null == n2 && (n2 = {});
      var a2 = standardizeArgs(t4, r2, i2, this.numConstants);
      if (t4 = a2.inputs, r2 = a2.initialState, i2 = a2.constants, Array.isArray(t4) && (r2 = t4.slice(1), t4 = t4[0]), (null == r2 || 0 === r2.length) && null == i2)
        return e2.prototype.apply.call(this, t4, n2);
      var o2 = [], s2 = [];
      if (null != r2) {
        var l3 = r2.length;
        if (l3 % 2 > 0)
          throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
        n2.initialState = r2, o2.push.apply(o2, r2);
        var u2 = r2.map(function(e3) {
          return new InputSpec({ shape: e3.shape });
        });
        this.forwardLayer.stateSpec = u2.slice(0, l3 / 2), this.backwardLayer.stateSpec = u2.slice(l3 / 2), s2.push.apply(s2, u2);
      }
      if (null != i2)
        throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");
      for (var c2 = o2[0] instanceof SymbolicTensor, p2 = 0, h = o2; p2 < h.length; p2++) {
        if (h[p2] instanceof SymbolicTensor !== c2)
          throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
      }
      if (c2) {
        var d2 = [t4].concat(o2), f2 = this.inputSpec.concat(s2), g2 = this.inputSpec;
        this.inputSpec = f2;
        var m2 = e2.prototype.apply.call(this, d2, n2);
        return this.inputSpec = g2, m2;
      }
      return e2.prototype.apply.call(this, t4, n2);
    }, t3.prototype.call = function(e3, t4) {
      var n2 = this;
      return je(function() {
        if (null != t4.mask)
          throw new NotImplementedError("The support for masking is not implemented for Bidirectional layers yet.");
        var r2, i2, a2, o2, s2 = t4.initialState;
        if (null == s2)
          r2 = n2.forwardLayer.call(e3, t4), i2 = n2.backwardLayer.call(e3, t4);
        else {
          var l3 = s2.slice(0, s2.length / 2), u2 = s2.slice(s2.length / 2);
          r2 = n2.forwardLayer.call(e3, Object.assign(t4, { initialState: l3 })), i2 = n2.backwardLayer.call(e3, Object.assign(t4, { initialState: u2 }));
        }
        return n2.returnState && (Array.isArray(r2) && (a2 = r2.slice(1).concat(i2.slice(1))), r2 = r2[0], i2 = i2[0]), n2.returnSequences && (i2 = zc(i2, 1)), "concat" === n2.mergeMode ? o2 = concatenate([r2, i2]) : "sum" === n2.mergeMode ? o2 = Vs(r2, i2) : "ave" === n2.mergeMode ? o2 = tc(0.5, Vs(r2, i2)) : "mul" === n2.mergeMode ? o2 = tc(r2, i2) : null == n2.mergeMode && (o2 = [r2, i2]), n2.returnState ? null == n2.mergeMode ? o2.concat(a2) : [o2].concat(a2) : o2;
      });
    }, t3.prototype.resetStates = function(e3) {
      this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
    }, t3.prototype.build = function(e3) {
      var t4 = this;
      nameScope(this.forwardLayer.name, function() {
        t4.forwardLayer.build(e3);
      }), nameScope(this.backwardLayer.name, function() {
        t4.backwardLayer.build(e3);
      }), this.built = true;
    }, Object.defineProperty(t3.prototype, "trainableWeights", { get: function() {
      return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
    }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "nonTrainableWeights", { get: function() {
      return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
    }, enumerable: true, configurable: true }), t3.prototype.setFastWeightInitDuringBuild = function(t4) {
      e2.prototype.setFastWeightInitDuringBuild.call(this, t4), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(t4), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(t4);
    }, t3.prototype.getConfig = function() {
      var t4 = { mergeMode: this.mergeMode }, n2 = e2.prototype.getConfig.call(this);
      return Object.assign(t4, n2), t4;
    }, t3.fromConfig = function(e3, t4) {
      var n2 = deserialize(t4.layer);
      if (delete t4.layer, null != t4.numConstants)
        throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
      var r2 = t4;
      return r2.layer = n2, new e3(r2);
    }, t3.className = "Bidirectional", t3;
  }(Wrapper);
  function inputLayer(e2) {
    return new InputLayer(e2);
  }
  function elu$2(e2) {
    return new ELU(e2);
  }
  function reLU(e2) {
    return new ReLU(e2);
  }
  function leakyReLU(e2) {
    return new LeakyReLU(e2);
  }
  function prelu$1(e2) {
    return new PReLU(e2);
  }
  function softmax$1(e2) {
    return new Softmax$1(e2);
  }
  function thresholdedReLU(e2) {
    return new ThresholdedReLU(e2);
  }
  function conv1d$2(e2) {
    return new Conv1D(e2);
  }
  function conv2d$1(e2) {
    return new Conv2D(e2);
  }
  function conv2dTranspose$1(e2) {
    return new Conv2DTranspose(e2);
  }
  function conv3d$2(e2) {
    return new Conv3D(e2);
  }
  function separableConv2d$1(e2) {
    return new SeparableConv2D(e2);
  }
  function cropping2D(e2) {
    return new Cropping2D(e2);
  }
  function upSampling2d(e2) {
    return new UpSampling2D(e2);
  }
  function depthwiseConv2d$2(e2) {
    return new DepthwiseConv2D(e2);
  }
  function activation(e2) {
    return new Activation$1(e2);
  }
  function dense(e2) {
    return new Dense(e2);
  }
  function dropout$2(e2) {
    return new Dropout(e2);
  }
  function flatten$1(e2) {
    return new Flatten(e2);
  }
  function repeatVector(e2) {
    return new RepeatVector(e2);
  }
  function reshape(e2) {
    return new Reshape(e2);
  }
  function permute(e2) {
    return new Permute(e2);
  }
  function embedding(e2) {
    return new Embedding(e2);
  }
  function add$2(e2) {
    return new Add(e2);
  }
  function average$1(e2) {
    return new Average(e2);
  }
  function concatenate$2(e2) {
    return new Concatenate(e2);
  }
  function maximum$2(e2) {
    return new Maximum(e2);
  }
  function minimum$2(e2) {
    return new Minimum(e2);
  }
  function multiply$1(e2) {
    return new Multiply(e2);
  }
  function dot$1(e2) {
    return new Dot(e2);
  }
  function batchNormalization$1(e2) {
    return new BatchNormalization(e2);
  }
  function layerNormalization(e2) {
    return new LayerNormalization(e2);
  }
  function zeroPadding2d(e2) {
    return new ZeroPadding2D(e2);
  }
  function averagePooling1d(e2) {
    return new AveragePooling1D(e2);
  }
  function avgPool1d(e2) {
    return averagePooling1d(e2);
  }
  function avgPooling1d(e2) {
    return averagePooling1d(e2);
  }
  function averagePooling2d(e2) {
    return new AveragePooling2D(e2);
  }
  function avgPool2d(e2) {
    return averagePooling2d(e2);
  }
  function avgPooling2d(e2) {
    return averagePooling2d(e2);
  }
  function averagePooling3d(e2) {
    return new AveragePooling3D(e2);
  }
  function avgPool3d$1(e2) {
    return averagePooling3d(e2);
  }
  function avgPooling3d(e2) {
    return averagePooling3d(e2);
  }
  function globalAveragePooling1d(e2) {
    return new GlobalAveragePooling1D(e2);
  }
  function globalAveragePooling2d(e2) {
    return new GlobalAveragePooling2D(e2);
  }
  function globalMaxPooling1d(e2) {
    return new GlobalMaxPooling1D(e2);
  }
  function globalMaxPooling2d(e2) {
    return new GlobalMaxPooling2D(e2);
  }
  function maxPooling1d(e2) {
    return new MaxPooling1D(e2);
  }
  function maxPooling2d(e2) {
    return new MaxPooling2D(e2);
  }
  function maxPooling3d(e2) {
    return new MaxPooling3D(e2);
  }
  function gru(e2) {
    return new GRU(e2);
  }
  function gruCell(e2) {
    return new GRUCell(e2);
  }
  function lstm(e2) {
    return new LSTM(e2);
  }
  function lstmCell(e2) {
    return new LSTMCell(e2);
  }
  function simpleRNN(e2) {
    return new SimpleRNN(e2);
  }
  function simpleRNNCell(e2) {
    return new SimpleRNNCell(e2);
  }
  function rnn$1(e2) {
    return new RNN(e2);
  }
  function stackedRNNCells(e2) {
    return new StackedRNNCells(e2);
  }
  function bidirectional(e2) {
    return new Bidirectional(e2);
  }
  function timeDistributed(e2) {
    return new TimeDistributed(e2);
  }
  Mf.registerClass(Bidirectional);
  var globalMaxPool1d = globalMaxPooling1d;
  var globalMaxPool2d = globalMaxPooling2d;
  var maxPool1d = maxPooling1d;
  var maxPool2d = maxPooling2d;
  function gaussianNoise(e2) {
    return new GaussianNoise(e2);
  }
  function gaussianDropout(e2) {
    return new GaussianDropout(e2);
  }
  function alphaDropout(e2) {
    return new AlphaDropout(e2);
  }
  function masking(e2) {
    return new Masking(e2);
  }
  var exports_layers = Object.freeze({ inputLayer, elu: elu$2, reLU, leakyReLU, prelu: prelu$1, softmax: softmax$1, thresholdedReLU, conv1d: conv1d$2, conv2d: conv2d$1, conv2dTranspose: conv2dTranspose$1, conv3d: conv3d$2, separableConv2d: separableConv2d$1, cropping2D, upSampling2d, depthwiseConv2d: depthwiseConv2d$2, activation, dense, dropout: dropout$2, flatten: flatten$1, repeatVector, reshape, permute, embedding, add: add$2, average: average$1, concatenate: concatenate$2, maximum: maximum$2, minimum: minimum$2, multiply: multiply$1, dot: dot$1, batchNormalization: batchNormalization$1, layerNormalization, zeroPadding2d, averagePooling1d, avgPool1d, avgPooling1d, averagePooling2d, avgPool2d, avgPooling2d, averagePooling3d, avgPool3d: avgPool3d$1, avgPooling3d, globalAveragePooling1d, globalAveragePooling2d, globalMaxPooling1d, globalMaxPooling2d, maxPooling1d, maxPooling2d, maxPooling3d, gru, gruCell, lstm, lstmCell, simpleRNN, simpleRNNCell, rnn: rnn$1, stackedRNNCells, bidirectional, timeDistributed, globalMaxPool1d, globalMaxPool2d, maxPool1d, maxPool2d, Layer, RNN, RNNCell, input, gaussianNoise, gaussianDropout, alphaDropout, masking });
  function binaryAccuracy$1(e2, t3) {
    return binaryAccuracy(e2, t3);
  }
  function binaryCrossentropy$2(e2, t3) {
    return binaryCrossentropy$1(e2, t3);
  }
  function sparseCategoricalAccuracy$1(e2, t3) {
    return sparseCategoricalAccuracy(e2, t3);
  }
  function categoricalAccuracy$1(e2, t3) {
    return categoricalAccuracy(e2, t3);
  }
  function categoricalCrossentropy$2(e2, t3) {
    return categoricalCrossentropy$1(e2, t3);
  }
  function precision$1(e2, t3) {
    return precision(e2, t3);
  }
  function recall$1(e2, t3) {
    return recall(e2, t3);
  }
  function cosineProximity$1(e2, t3) {
    return cosineProximity(e2, t3);
  }
  function meanAbsoluteError$1(e2, t3) {
    return meanAbsoluteError(e2, t3);
  }
  function meanAbsolutePercentageError$1(e2, t3) {
    return meanAbsolutePercentageError(e2, t3);
  }
  function MAPE$2(e2, t3) {
    return meanAbsolutePercentageError(e2, t3);
  }
  function mape$2(e2, t3) {
    return meanAbsolutePercentageError(e2, t3);
  }
  function meanSquaredError$1(e2, t3) {
    return meanSquaredError(e2, t3);
  }
  function MSE$2(e2, t3) {
    return meanSquaredError(e2, t3);
  }
  function mse$2(e2, t3) {
    return meanSquaredError(e2, t3);
  }
  var exports_metrics = Object.freeze({ binaryAccuracy: binaryAccuracy$1, binaryCrossentropy: binaryCrossentropy$2, sparseCategoricalAccuracy: sparseCategoricalAccuracy$1, categoricalAccuracy: categoricalAccuracy$1, categoricalCrossentropy: categoricalCrossentropy$2, precision: precision$1, recall: recall$1, cosineProximity: cosineProximity$1, meanAbsoluteError: meanAbsoluteError$1, meanAbsolutePercentageError: meanAbsolutePercentageError$1, MAPE: MAPE$2, mape: mape$2, meanSquaredError: meanSquaredError$1, MSE: MSE$2, mse: mse$2 });
  var exports_models = Object.freeze({ modelFromJSON });
  function l1l2(e2) {
    return new L1L2(e2);
  }
  function l1$1(e2) {
    return l1(e2);
  }
  function l2$1(e2) {
    return l2(e2);
  }
  var exports_regularizers = Object.freeze({ l1l2, l1: l1$1, l2: l2$1 });
  var Callback = function(e2) {
    function t3() {
      var t4 = null !== e2 && e2.apply(this, arguments) || this;
      return t4.model = null, t4;
    }
    return __extends(t3, e2), t3.prototype.setModel = function(e3) {
      if (!(e3 instanceof LayersModel))
        throw new Error("model must be a LayersModel, not some other Container");
      this.model = e3;
    }, t3;
  }(BaseCallback);
  function less(e2, t3) {
    return e2 < t3;
  }
  function greater$1(e2, t3) {
    return e2 > t3;
  }
  var EarlyStopping = function(e2) {
    function t3(t4) {
      var n2 = e2.call(this) || this;
      if (null == t4 && (t4 = {}), t4.restoreBestWeights)
        throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");
      return n2.monitor = t4.monitor || "val_loss", n2.minDelta = Math.abs(t4.minDelta || 0), n2.patience = t4.patience || 0, n2.verbose = t4.verbose || 0, n2.mode = t4.mode || "auto", n2.baseline = t4.baseline, -1 === ["auto", "min", "max"].indexOf(n2.mode) && (console.warn("EarlyStopping mode '" + n2.mode + "' is invalid. Falling back to mode 'auto'."), n2.mode = "auto"), "min" === n2.mode ? n2.monitorFunc = less : "max" === n2.mode ? n2.monitorFunc = greater$1 : -1 !== n2.monitor.indexOf("acc") ? n2.monitorFunc = greater$1 : n2.monitorFunc = less, n2.monitorFunc === less && (n2.minDelta *= -1), n2;
    }
    return __extends(t3, e2), t3.prototype.onTrainBegin = function(e3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e4) {
          return this.wait = 0, this.stoppedEpoch = 0, null != this.baseline ? this.best = this.baseline : this.best = this.monitorFunc === less ? 1 / 0 : -1 / 0, [2];
        });
      });
    }, t3.prototype.onEpochEnd = function(e3, t4) {
      return __awaiter(this, void 0, void 0, function() {
        var n2;
        return __generator(this, function(r2) {
          switch (r2.label) {
            case 0:
              return [4, resolveScalarsInLogs(t4)];
            case 1:
              return r2.sent(), null == (n2 = this.getMonitorValue(t4)) ? [2] : (this.monitorFunc(n2 - this.minDelta, this.best) ? (this.best = n2, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = e3, this.model.stopTraining = true)), [2]);
          }
        });
      });
    }, t3.prototype.onTrainEnd = function(e3) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e4) {
          return this.stoppedEpoch > 0 && this.verbose && console.log("Epoch " + this.stoppedEpoch + ": early stopping."), [2];
        });
      });
    }, t3.prototype.getMonitorValue = function(e3) {
      null == e3 && (e3 = {});
      var t4 = e3[this.monitor];
      return null == t4 && console.warn("Metric for EarlyStopping " + this.monitor + " is not available. Available metrics are: " + Object.keys(e3)), t4;
    }, t3;
  }(Callback);

  // node_modules/@tensorflow/tfjs/node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js
  var DataType;
  var SaverDef;
  var __assign2 = function() {
    return (__assign2 = Object.assign || function(e2) {
      for (var t3, a2 = 1, r2 = arguments.length; a2 < r2; a2++)
        for (var n2 in t3 = arguments[a2])
          Object.prototype.hasOwnProperty.call(t3, n2) && (e2[n2] = t3[n2]);
      return e2;
    }).apply(this, arguments);
  };
  function __awaiter2(e2, t3, a2, r2) {
    return new (a2 || (a2 = Promise))(function(n2, s2) {
      function o2(e3) {
        try {
          u2(r2.next(e3));
        } catch (e4) {
          s2(e4);
        }
      }
      function p2(e3) {
        try {
          u2(r2.throw(e3));
        } catch (e4) {
          s2(e4);
        }
      }
      function u2(e3) {
        e3.done ? n2(e3.value) : new a2(function(t4) {
          t4(e3.value);
        }).then(o2, p2);
      }
      u2((r2 = r2.apply(e2, t3 || [])).next());
    });
  }
  function __generator2(e2, t3) {
    var a2, r2, n2, s2, o2 = { label: 0, sent: function() {
      if (1 & n2[0])
        throw n2[1];
      return n2[1];
    }, trys: [], ops: [] };
    return s2 = { next: p2(0), throw: p2(1), return: p2(2) }, "function" == typeof Symbol && (s2[Symbol.iterator] = function() {
      return this;
    }), s2;
    function p2(s3) {
      return function(p3) {
        return function(s4) {
          if (a2)
            throw new TypeError("Generator is already executing.");
          for (; o2; )
            try {
              if (a2 = 1, r2 && (n2 = 2 & s4[0] ? r2.return : s4[0] ? r2.throw || ((n2 = r2.return) && n2.call(r2), 0) : r2.next) && !(n2 = n2.call(r2, s4[1])).done)
                return n2;
              switch (r2 = 0, n2 && (s4 = [2 & s4[0], n2.value]), s4[0]) {
                case 0:
                case 1:
                  n2 = s4;
                  break;
                case 4:
                  return o2.label++, { value: s4[1], done: false };
                case 5:
                  o2.label++, r2 = s4[1], s4 = [0];
                  continue;
                case 7:
                  s4 = o2.ops.pop(), o2.trys.pop();
                  continue;
                default:
                  if (!(n2 = (n2 = o2.trys).length > 0 && n2[n2.length - 1]) && (6 === s4[0] || 2 === s4[0])) {
                    o2 = 0;
                    continue;
                  }
                  if (3 === s4[0] && (!n2 || s4[1] > n2[0] && s4[1] < n2[3])) {
                    o2.label = s4[1];
                    break;
                  }
                  if (6 === s4[0] && o2.label < n2[1]) {
                    o2.label = n2[1], n2 = s4;
                    break;
                  }
                  if (n2 && o2.label < n2[2]) {
                    o2.label = n2[2], o2.ops.push(s4);
                    break;
                  }
                  n2[2] && o2.ops.pop(), o2.trys.pop();
                  continue;
              }
              s4 = t3.call(e2, o2);
            } catch (e3) {
              s4 = [6, e3], r2 = 0;
            } finally {
              a2 = n2 = 0;
            }
          if (5 & s4[0])
            throw s4[1];
          return { value: s4[0] ? s4[1] : void 0, done: true };
        }([s3, p3]);
      };
    }
  }
  !function(e2) {
    e2[e2.DT_INVALID = 0] = "DT_INVALID", e2[e2.DT_FLOAT = 1] = "DT_FLOAT", e2[e2.DT_DOUBLE = 2] = "DT_DOUBLE", e2[e2.DT_INT32 = 3] = "DT_INT32", e2[e2.DT_UINT8 = 4] = "DT_UINT8", e2[e2.DT_INT16 = 5] = "DT_INT16", e2[e2.DT_INT8 = 6] = "DT_INT8", e2[e2.DT_STRING = 7] = "DT_STRING", e2[e2.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e2[e2.DT_INT64 = 9] = "DT_INT64", e2[e2.DT_BOOL = 10] = "DT_BOOL", e2[e2.DT_QINT8 = 11] = "DT_QINT8", e2[e2.DT_QUINT8 = 12] = "DT_QUINT8", e2[e2.DT_QINT32 = 13] = "DT_QINT32", e2[e2.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e2[e2.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e2[e2.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e2[e2.DT_INT32_REF = 103] = "DT_INT32_REF", e2[e2.DT_UINT8_REF = 104] = "DT_UINT8_REF", e2[e2.DT_INT16_REF = 105] = "DT_INT16_REF", e2[e2.DT_INT8_REF = 106] = "DT_INT8_REF", e2[e2.DT_STRING_REF = 107] = "DT_STRING_REF", e2[e2.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e2[e2.DT_INT64_REF = 109] = "DT_INT64_REF", e2[e2.DT_BOOL_REF = 110] = "DT_BOOL_REF", e2[e2.DT_QINT8_REF = 111] = "DT_QINT8_REF", e2[e2.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e2[e2.DT_QINT32_REF = 113] = "DT_QINT32_REF", e2[e2.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
  }(DataType || (DataType = {})), function(e2) {
    !function(e3) {
      e3[e3.LEGACY = 0] = "LEGACY", e3[e3.V1 = 1] = "V1", e3[e3.V2 = 2] = "V2";
    }(e2.CheckpointFormatVersion || (e2.CheckpointFormatVersion = {}));
  }(SaverDef || (SaverDef = {}));
  var CUSTOM_OPS = {};
  function getRegisteredOp(e2) {
    return CUSTOM_OPS[e2];
  }
  function getParamValue(e2, t3, a2, r2) {
    var n2 = t3.inputParams[e2];
    if (n2 && void 0 !== n2.inputIndexStart) {
      var s2 = n2.inputIndexStart, o2 = 0 === n2.inputIndexEnd ? void 0 : void 0 === n2.inputIndexEnd ? s2 + 1 : n2.inputIndexEnd;
      if ("tensor" === n2.type)
        return getTensor(t3.inputNames[n2.inputIndexStart], a2, r2);
      if ("tensors" === n2.type)
        return t3.inputNames.slice(s2, o2).map(function(e3) {
          return getTensor(e3, a2, r2);
        });
      var p2 = Array.prototype.slice.call(getTensor(t3.inputNames.slice(s2)[0], a2, r2).dataSync());
      return "number" === n2.type ? p2[0] : p2;
    }
    var u2 = t3.attrParams[e2];
    return u2 && u2.value;
  }
  function getTensor(e2, t3, a2) {
    var r2 = parseNodeName(e2), n2 = r2[0], s2 = r2[1], o2 = a2.currentContextIds.find(function(e3) {
      return !!t3[getNodeNameWithContextId(n2, e3)];
    });
    return void 0 !== o2 ? t3[getNodeNameWithContextId(n2, o2)][s2] : void 0;
  }
  function getTensorsForCurrentContenxt(e2, t3, a2) {
    return t3[getNodeNameWithContextId(e2, a2.currentContextId)];
  }
  function getNodeNameAndIndex(e2, t3) {
    var a2 = parseNodeName(e2), r2 = a2[0], n2 = a2[1];
    return [getNodeNameWithContextId(r2, t3 && t3.currentContextId), n2];
  }
  function getNodeNameWithContextId(e2, t3) {
    return t3 ? e2 + "-" + t3 : e2;
  }
  function parseNodeName(e2) {
    var t3 = e2.lastIndexOf(":");
    return -1 === t3 ? [e2, 0] : [e2.substring(0, t3), Number(e2.substring(t3 + 1))];
  }
  function split$1(e2, t3) {
    for (var a2 = [], r2 = 0; r2 < e2.length; r2 += t3)
      a2.push(e2.slice(r2, r2 + t3));
    return a2;
  }
  var json = [{ tfOpName: "Add", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AddV2", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AddN", category: "arithmetic", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "BiasAdd", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sub", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "RealDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Div", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "FloorDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Mul", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Maximum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }] }, { tfOpName: "Minimum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }] }, { tfOpName: "Pow", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SquaredDifference", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Mod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "FloorMod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
  var arithmetic = Object.freeze({ json });
  var json$1 = [{ tfOpName: "Abs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Acos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Asin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atan2", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Ceil", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ClipByValue", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "clip_value_min", name: "clipValueMin", type: "number" }, { tfName: "clip_value_max", name: "clipValueMax", type: "number" }] }, { tfOpName: "Complex", category: "basic_math", inputs: [{ start: 0, name: "real", type: "tensor" }, { start: 1, name: "imag", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ComplexAbs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Elu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Exp", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Floor", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Log", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Imag", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: true }] }, { tfOpName: "Neg", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Real", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: true }] }, { tfOpName: "Prelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "alpha", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Relu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Relu6", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "clipValueMin", name: "clipValueMin", type: "number", defaultValue: 0 }, { tfName: "clipValueMax", name: "clipValueMax", type: "number", defaultValue: 6 }] }, { tfOpName: "Selu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sigmoid", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Rsqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Square", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Tan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Tanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sign", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Round", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Expm1", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Log1p", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Reciprocal", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Softplus", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Asinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Acosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Erf", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Prod", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axes", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool", notSupported: true }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LeakyRelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "alpha", name: "alpha", type: "number", defaultValue: 0.2 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
  var basicMath = Object.freeze({ json: json$1 });
  var json$2 = [{ tfOpName: "LoopCond", category: "control", inputs: [{ start: 0, name: "pred", type: "tensor" }] }, { tfOpName: "Switch", category: "control", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "pred", type: "tensor" }] }, { tfOpName: "Merge", category: "control", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "Enter", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "frame_name", name: "frameName", type: "string" }, { tfName: "is_constant", name: "isConstant", type: "bool" }] }, { tfOpName: "Exit", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "NextIteration", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayV3", category: "control", inputs: [{ start: 0, name: "size", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "dynamic_size", name: "dynamicSize", type: "bool" }, { tfName: "clear_after_read", name: "clearAfterRead", type: "bool" }, { tfName: "identical_element_shapes", name: "identicalElementShapes", type: "bool" }, { tfName: "tensor_array_name", name: "name", type: "string" }] }, { tfOpName: "TensorArrayWriteV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayReadV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayGatherV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }] }, { tfOpName: "TensorArrayScatterV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArrayConcatV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape_except0", name: "elementShapeExcept0", type: "shape", notSupported: true }] }, { tfOpName: "TensorArraySplitV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "tensor", type: "tensor" }, { start: 2, name: "lengths", type: "number[]" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArraySizeV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "flowIn", type: "number" }] }, { tfOpName: "TensorArrayCloseV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }] }];
  var control = Object.freeze({ json: json$2 });
  var json$3 = [{ tfOpName: "AvgPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AvgPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Conv1D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "stride", name: "stride", type: "number" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NWC" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "dilation", name: "dilation", type: "number", defaultValue: 1 }] }, { tfOpName: "Conv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "useCudnnOnGpu", name: "useCudnnOnGpu", type: "bool" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "_FusedConv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "use_cudnn_on_gpu", name: "useCudnnOnGpu", type: "bool", defaultValue: true }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }] }, { tfOpName: "Conv2DBackpropInput", category: "convolution", inputs: [{ start: 2, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 0, name: "outputShape", type: "number[]" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "DepthwiseConv2d", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "DepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "Conv3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }];
  var convolution = Object.freeze({ json: json$3 });
  var json$4 = [{ tfOpName: "Fill", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }, { start: 1, name: "value", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "LinSpace", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "num", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "OneHot", category: "creation", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "depth", type: "number" }, { start: 2, name: "onValue", type: "number", defaultValue: 1 }, { start: 3, name: "offValue", type: "number", defaultValue: 0 }], attrs: [{ tfName: "axis", name: "axis", type: "number", notSupported: true }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Ones", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "OnesLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "RandomUniform", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "minval", name: "minval", type: "number", defaultValue: 0 }, { tfName: "maxval", name: "maxval", type: "number", defaultValue: 1 }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "Range", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "step", type: "number", defaultValue: 0 }], attrs: [{ tfName: "Tidx", name: "dtype", type: "dtype" }] }, { tfOpName: "TruncatedNormal", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "means", name: "mean", type: "number", defaultValue: 0 }, { tfName: "stddev", name: "stdDev", type: "number", defaultValue: 1 }, { tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "Zeros", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "ZerosLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "Multinomial", category: "creation", inputs: [{ start: 0, name: "logits", type: "tensor" }, { start: 1, name: "numSamples", type: "number" }], attrs: [{ tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number" }, { tfName: "T", name: "dtype", type: "dtype" }, { tfName: "output_dtype", name: "output_dtype", type: "dtype" }] }];
  var creation = Object.freeze({ json: json$4 });
  var json$5 = [{ tfOpName: "NonMaxSuppressionV2", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV3", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }] }, { tfOpName: "Where", category: "dynamic", inputs: [{ start: 0, name: "condition", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ListDiff", category: "dynamic", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
  var dynamic = Object.freeze({ json: json$5 });
  var json$6 = [{ tfOpName: "TopKV2", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "k", type: "number" }], attrs: [{ tfName: "sorted", name: "sorted", type: "bool" }] }];
  var evaluation = Object.freeze({ json: json$6 });
  var json$7 = [{ tfOpName: "PlaceholderWithDefault", category: "graph", inputs: [{ start: 0, name: "default", type: "tensor" }], attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Placeholder", category: "graph", attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Const", category: "graph" }, { tfOpName: "Identity", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IdentityN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Snapshot", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Rank", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Size", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Shape", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "ShapeN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Print", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "data", type: "tensors" }], attrs: [{ tfName: "message", name: "message", type: "string" }, { tfName: "first_n", name: "firstN", type: "number", notSupported: true }, { tfName: "summarize", name: "summarize", type: "number", defaultValue: 3 }] }, { tfOpName: "NoOp", category: "graph", inputs: [] }, { tfOpName: "StopGradient", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "FakeQuantWithMinMaxVars", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "min", name: "min", type: "number" }, { tfName: "max", name: "max", type: "number" }] }];
  var graph = Object.freeze({ json: json$7 });
  var json$8 = [{ tfOpName: "ResizeBilinear", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ResizeNearestNeighbor", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "CropAndResize", category: "image", inputs: [{ start: 0, name: "image", type: "tensor" }, { start: 1, name: "boxes", type: "tensor" }, { start: 2, name: "boxInd", type: "tensor" }, { start: 3, name: "cropSize", type: "number[]" }], attrs: [{ tfName: "method", name: "method", type: "string" }, { tfName: "extrapolation_value", name: "extrapolationValue", type: "number" }] }];
  var image$1 = Object.freeze({ json: json$8 });
  var json$9 = [{ tfOpName: "Equal", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "NotEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Greater", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "GreaterEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Less", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LessEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalAnd", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalNot", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalOr", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Select", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
  var logical = Object.freeze({ json: json$9 });
  var json$10 = [{ tfOpName: "MatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BatchMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BatchMatMulV2", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Transpose", category: "matrices", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "perm", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
  var matrices = Object.freeze({ json: json$10 });
  var json$11 = [{ tfOpName: "FusedBatchNorm", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "FusedBatchNormV2", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "FusedBatchNormV3", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "LRN", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "depth_radius", name: "radius", type: "number", defaultValue: 5 }, { tfName: "bias", name: "bias", type: "number", defaultValue: 1 }, { tfName: "alpha", name: "alpha", type: "number", defaultValue: 1 }, { tfName: "beta", name: "beta", type: "number", defaultValue: 0.5 }] }, { tfOpName: "Softmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "LogSoftmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "SparseToDense", category: "normalization", inputs: [{ start: 0, name: "sparseIndices", type: "tensor" }, { start: 1, name: "outputShape", type: "number[]" }, { start: 2, name: "sparseValues", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: true, notSupported: true }] }];
  var normalization = Object.freeze({ json: json$11 });
  var json$12 = [{ tfOpName: "Max", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Mean", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Min", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Sum", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "All", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Any", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "ArgMax", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "ArgMin", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "Prod", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }];
  var reduction = Object.freeze({ json: json$12 });
  var json$13 = [{ tfOpName: "ConcatV2", category: "slice_join", inputs: [{ start: 0, end: -1, name: "tensors", type: "tensors" }, { start: -1, name: "axis", type: "number" }] }, { tfOpName: "Concat", category: "slice_join", inputs: [{ start: 1, end: 0, name: "tensors", type: "tensors" }, { start: 0, name: "axis", type: "number" }] }, { tfOpName: "GatherV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "Gather", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }, { tfName: "validate_indices", name: "validateIndices", type: "bool", notSupported: true }] }, { tfOpName: "Reverse", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "dims", type: "bool", notSupported: true }] }, { tfOpName: "ReverseV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }] }, { tfOpName: "Slice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "size", type: "number[]" }] }, { tfOpName: "StridedSlice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "end", type: "number[]" }, { start: 3, name: "strides", type: "number[]" }], attrs: [{ tfName: "begin_mask", name: "beginMask", type: "number", defaultValue: 0 }, { tfName: "end_mask", name: "endMask", type: "number", defaultValue: 0 }, { tfName: "new_axis_mask", name: "newAxisMask", type: "number", defaultValue: 0 }, { tfName: "ellipsis_mask", name: "ellipsisMask", type: "number", defaultValue: 0 }, { tfName: "shrink_axis_mask", name: "shrinkAxisMask", type: "number", defaultValue: 0 }] }, { tfOpName: "Pack", category: "slice_join", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "Unpack", category: "slice_join", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }, { tfName: "num", name: "num", type: "number", defaultValue: 0, notSupported: true }] }, { tfOpName: "Tile", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "reps", type: "number[]" }] }, { tfOpName: "Split", category: "slice_join", inputs: [{ start: 0, name: "axis", type: "number", defaultValue: 0 }, { start: 1, name: "x", type: "tensor" }], attrs: [{ tfName: "num_split", name: "numOrSizeSplits", type: "number", defaultValue: 1 }] }, { tfOpName: "SplitV", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "numOrSizeSplits", type: "number[]" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "ScatterNd", category: "slice_join", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "values", type: "tensor" }, { start: 2, name: "shape", type: "number[]" }] }, { tfOpName: "GatherNd", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }] }, { tfOpName: "SparseToDense", category: "slice_join", inputs: [{ start: 0, name: "sparseIndices", type: "tensor" }, { start: 1, name: "outputShape", type: "number[]" }, { start: 2, name: "sparseValues", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: false, notSupported: true }] }];
  var sliceJoin = Object.freeze({ json: json$13 });
  var json$14 = [{ tfOpName: "FFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "RFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: true }] }, { tfOpName: "IRFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: true }] }];
  var spectral = Object.freeze({ json: json$14 });
  var json$15 = [{ tfOpName: "Cast", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "SrcT", name: "sdtype", type: "dtype", notSupported: true }, { tfName: "DstT", name: "dtype", type: "dtype" }] }, { tfOpName: "ExpandDims", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "Pad", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }], attrs: [{ tfName: "constant_value", name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "PadV2", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }, { start: 2, name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "Reshape", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }] }, { tfOpName: "Squeeze", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "axis", tfDeprecatedName: "squeeze_dims", name: "axis", type: "number[]" }] }, { tfOpName: "SpaceToBatchND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "paddings", type: "number[]" }] }, { tfOpName: "BatchToSpaceND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "crops", type: "number[]" }] }, { tfOpName: "DepthToSpace", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "block_size", name: "blockSize", type: "number" }, { tfName: "data_format", name: "dataFormat", type: "string" }] }];
  var transformation = Object.freeze({ json: json$15 });
  var OperationMapper = function() {
    function e2() {
      var e3 = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, logical, image$1, graph, matrices, normalization, reduction, sliceJoin, spectral, transformation], t3 = [].concat.apply([], e3.map(function(e4) {
        return e4.json;
      }));
      this.opMappers = t3.reduce(function(e4, t4) {
        return e4[t4.tfOpName] = t4, e4;
      }, {});
    }
    return Object.defineProperty(e2, "Instance", { get: function() {
      return this._instance || (this._instance = new this());
    }, enumerable: true, configurable: true }), e2.prototype.transformGraph = function(e3) {
      var t3 = this, a2 = [], r2 = [], n2 = e3.node.reduce(function(e4, n3) {
        return e4[n3.name] = t3.mapNode(n3), "Placeholder" === n3.op && a2.push(e4[n3.name]), "Const" === n3.op && r2.push(e4[n3.name]), e4;
      }, {}), s2 = [], o2 = [], p2 = Object.keys(n2);
      return p2.forEach(function(e4) {
        var t4 = n2[e4];
        t4.inputNames.forEach(function(e5) {
          var a3 = getNodeNameAndIndex(e5)[0];
          t4.inputs.push(n2[a3]), n2[a3].children.push(t4);
        }), 0 === t4.inputs.length && s2.push(t4);
      }), p2.forEach(function(e4) {
        var t4 = n2[e4];
        0 === t4.children.length && o2.push(t4);
      }), { nodes: n2, inputs: s2, outputs: o2, weights: r2, placeholders: a2 };
    }, e2.prototype.mapNode = function(e3) {
      var t3 = getRegisteredOp(e3.op) || this.opMappers[e3.op] || {};
      null == e3.attr && (e3.attr = {});
      var a2 = { name: e3.name, op: e3.op, category: t3.category, inputNames: (e3.input || []).map(function(e4) {
        return e4.startsWith("^") ? e4.substr(1) : e4;
      }), inputs: [], children: [], inputParams: {}, attrParams: {}, rawAttrs: e3.attr };
      return null != t3.inputs && (a2.inputParams = t3.inputs.reduce(function(e4, t4) {
        return e4[t4.name] = { type: t4.type, inputIndexStart: t4.start, inputIndexEnd: t4.end }, e4;
      }, {})), null != t3.attrs && (a2.attrParams = t3.attrs.reduce(function(t4, a3) {
        var r2 = a3.type, n2 = void 0;
        switch (a3.type) {
          case "string":
            void 0 === (n2 = getStringParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getStringParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
            break;
          case "string[]":
            void 0 === (n2 = getStringArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getStringArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
            break;
          case "number":
            void 0 === (n2 = getNumberParam(e3.attr, a3.tfName, a3.defaultValue || 0)) && a3.tfDeprecatedName && (n2 = getNumberParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
            break;
          case "number[]":
            void 0 === (n2 = getNumericArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getNumericArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
            break;
          case "bool":
            void 0 === (n2 = getBoolParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getBoolParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
            break;
          case "bool[]":
            void 0 === (n2 = getBoolArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getBoolArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
            break;
          case "shape":
            void 0 === (n2 = getTensorShapeParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getTensorShapeParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
            break;
          case "shape[]":
            void 0 === (n2 = getTensorShapeArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getTensorShapeArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
            break;
          case "dtype":
            void 0 === (n2 = getDtypeParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getDtypeParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
            break;
          case "dtype[]":
            void 0 === (n2 = getDtypeArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getDtypeArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
            break;
          case "tensor":
          case "tensors":
            break;
          default:
            throw new Error("Unsupported param type: " + a3.type + " for op: " + e3.op);
        }
        return t4[a3.name] = { value: n2, type: r2 }, t4;
      }, {})), a2;
    }, e2;
  }();
  function decodeBase64(e2) {
    var t3 = a().global;
    if (void 0 !== t3.atob)
      return t3.atob(e2);
    if ("undefined" != typeof Buffer)
      return new Buffer(e2, "base64").toString();
    throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
  }
  function parseStringParam(e2, t3) {
    var a2 = Array.isArray(e2) ? String.fromCharCode.apply(null, e2) : decodeBase64(e2);
    return t3 ? a2 : a2.toLowerCase();
  }
  function getStringParam(e2, t3, a2, r2) {
    void 0 === r2 && (r2 = false);
    var n2 = e2[t3];
    return null != n2 ? parseStringParam(n2.s, r2) : a2;
  }
  function getBoolParam(e2, t3, a2) {
    var r2 = e2[t3];
    return r2 ? r2.b : a2;
  }
  function getNumberParam(e2, t3, a2) {
    var r2 = e2[t3] || {}, n2 = null != r2.i ? r2.i : null != r2.f ? r2.f : a2;
    return "number" == typeof n2 ? n2 : parseInt(n2, 10);
  }
  function parseDtypeParam(e2) {
    switch ("string" == typeof e2 && (e2 = DataType[e2]), e2) {
      case DataType.DT_FLOAT:
        return "float32";
      case DataType.DT_INT32:
      case DataType.DT_INT64:
        return "int32";
      case DataType.DT_BOOL:
        return "bool";
      case DataType.DT_DOUBLE:
        return "float32";
      case DataType.DT_STRING:
        return "string";
      default:
        return null;
    }
  }
  function getDtypeParam(e2, t3, a2) {
    var r2 = e2[t3];
    return r2 && r2.type ? parseDtypeParam(r2.type) : a2;
  }
  function getDtypeArrayParam(e2, t3, a2) {
    var r2 = e2[t3];
    return r2 && r2.list && r2.list.type ? r2.list.type.map(function(e3) {
      return parseDtypeParam(e3);
    }) : a2;
  }
  function parseTensorShapeParam(e2) {
    if (!e2.unknownRank)
      return null != e2.dim ? e2.dim.map(function(e3) {
        return "number" == typeof e3.size ? e3.size : parseInt(e3.size, 10);
      }) : [];
  }
  function getTensorShapeParam(e2, t3, a2) {
    var r2 = e2[t3];
    return r2 && r2.shape ? parseTensorShapeParam(r2.shape) : a2;
  }
  function getNumericArrayParam(e2, t3, a2) {
    var r2 = e2[t3];
    return r2 ? ((r2.list.f && r2.list.f.length ? r2.list.f : r2.list.i) || []).map(function(e3) {
      return "number" == typeof e3 ? e3 : parseInt(e3, 10);
    }) : a2;
  }
  function getStringArrayParam(e2, t3, a2, r2) {
    void 0 === r2 && (r2 = false);
    var n2 = e2[t3];
    return n2 && n2.list && n2.list.s ? n2.list.s.map(function(e3) {
      return parseStringParam(e3, r2);
    }) : a2;
  }
  function getTensorShapeArrayParam(e2, t3, a2) {
    var r2 = e2[t3];
    return r2 && r2.list && r2.list.shape ? r2.list.shape.map(function(e3) {
      return parseTensorShapeParam(e3);
    }) : a2;
  }
  function getBoolArrayParam(e2, t3, a2) {
    var r2 = e2[t3];
    return r2 && r2.list && r2.list.b ? r2.list.b : a2;
  }
  var NodeValueImpl = function() {
    function e2(e3, t3, a2) {
      var r2 = this;
      this.node = e3, this.tensorMap = t3, this.context = a2, this.inputs = [], this.attrs = {}, this.inputs = e3.inputNames.map(function(e4) {
        return r2.getInput(e4);
      }), null != e3.rawAttrs && (this.attrs = Object.keys(e3.rawAttrs).reduce(function(e4, t4) {
        return e4[t4] = r2.getAttr(t4), e4;
      }, {}));
    }
    return e2.prototype.getInput = function(e3) {
      return getTensor(e3, this.tensorMap, this.context);
    }, e2.prototype.getAttr = function(e3, t3) {
      var a2 = this.node.rawAttrs[e3];
      if (null != a2.tensor)
        return getTensor(e3, this.tensorMap, this.context);
      if (null != a2.i || null != a2.f)
        return getNumberParam(this.node.rawAttrs, e3, t3);
      if (null != a2.s)
        return getStringParam(this.node.rawAttrs, e3, t3);
      if (null != a2.b)
        return getBoolParam(this.node.rawAttrs, e3, t3);
      if (null != a2.shape)
        return getTensorShapeParam(this.node.rawAttrs, e3, t3);
      if (null != a2.type)
        return getDtypeParam(this.node.rawAttrs, e3, t3);
      if (null != a2.list) {
        if (null != a2.list.i || null != a2.list.f)
          return getNumericArrayParam(this.node.rawAttrs, e3, t3);
        if (null != a2.list.s)
          return getStringArrayParam(this.node.rawAttrs, e3, t3);
        if (null != a2.list.shape)
          return getTensorShapeArrayParam(this.node.rawAttrs, e3, t3);
        if (null != a2.list.b)
          return getBoolArrayParam(this.node.rawAttrs, e3, t3);
        if (null != a2.list.type)
          return getDtypeArrayParam(this.node.rawAttrs, e3, t3);
      }
      return t3;
    }, e2;
  }();
  var executeOp = function(e2, t3, a2) {
    switch (e2.op) {
      case "BiasAdd":
      case "AddV2":
      case "Add":
        return [Vs(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "AddN":
        return [zs(getParamValue("tensors", e2, t3, a2))];
      case "FloorMod":
      case "Mod":
        return [Js(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "Mul":
        return [tc(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "RealDiv":
      case "Div":
        return [qs(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "FloorDiv":
        return [js(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "Sub":
        return [ic(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "Minimum":
        return [Ys(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "Maximum":
        return [Xs(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "Pow":
        return [nc(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "SquaredDifference":
        return [oc(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$1 = function(e2, t3, a2) {
    switch (e2.op) {
      case "Abs":
      case "ComplexAbs":
        return [Vu(getParamValue("x", e2, t3, a2))];
      case "Acos":
        return [zu(getParamValue("x", e2, t3, a2))];
      case "Acosh":
        return [Gu(getParamValue("x", e2, t3, a2))];
      case "Asin":
        return [Hu(getParamValue("x", e2, t3, a2))];
      case "Asinh":
        return [qu(getParamValue("x", e2, t3, a2))];
      case "Atan":
        return [Ku(getParamValue("x", e2, t3, a2))];
      case "Atan2":
        return [Hs(getParamValue("x", e2, t3, a2), getParamValue("y", e2, t3, a2))];
      case "Atanh":
        return [ju(getParamValue("x", e2, t3, a2))];
      case "Ceil":
        return [Xu(getParamValue("x", e2, t3, a2))];
      case "Complex":
        return [En(getParamValue("real", e2, t3, a2), getParamValue("imag", e2, t3, a2))];
      case "Cos":
        return [Yu(getParamValue("x", e2, t3, a2))];
      case "Cosh":
        return [Qu(getParamValue("x", e2, t3, a2))];
      case "Elu":
        return [gl(getParamValue("x", e2, t3, a2))];
      case "Erf":
        return [Ju(getParamValue("x", e2, t3, a2))];
      case "Exp":
        return [Zu(getParamValue("x", e2, t3, a2))];
      case "Expm1":
        return [ts(getParamValue("x", e2, t3, a2))];
      case "Floor":
        return [es(getParamValue("x", e2, t3, a2))];
      case "Log":
        return [ns(getParamValue("x", e2, t3, a2))];
      case "Log1p":
        return [rs(getParamValue("x", e2, t3, a2))];
      case "Imag":
        return [In(getParamValue("x", e2, t3, a2))];
      case "Neg":
        return [as(getParamValue("x", e2, t3, a2))];
      case "Reciprocal":
        return [is(getParamValue("x", e2, t3, a2))];
      case "Real":
        return [Rn(getParamValue("x", e2, t3, a2))];
      case "Relu":
        return [bl(getParamValue("x", e2, t3, a2))];
      case "Round":
        return [us(getParamValue("x", e2, t3, a2))];
      case "Selu":
        return [Cl(getParamValue("x", e2, t3, a2))];
      case "Sigmoid":
        return [cs(getParamValue("x", e2, t3, a2))];
      case "Sin":
        return [ds(getParamValue("x", e2, t3, a2))];
      case "Sign":
        return [ls(getParamValue("x", e2, t3, a2))];
      case "Sinh":
        return [vs(getParamValue("x", e2, t3, a2))];
      case "Softplus":
        return [ms(getParamValue("x", e2, t3, a2))];
      case "Sqrt":
        return [gs(getParamValue("x", e2, t3, a2))];
      case "Square":
        return [Uu(getParamValue("x", e2, t3, a2))];
      case "Tanh":
        return [bs(getParamValue("x", e2, t3, a2))];
      case "Tan":
        return [xs(getParamValue("x", e2, t3, a2))];
      case "Relu6":
      case "ClipByValue":
        return [$u(getParamValue("x", e2, t3, a2), getParamValue("clipValueMin", e2, t3, a2), getParamValue("clipValueMax", e2, t3, a2))];
      case "Rsqrt":
        return [ss(getTensor(e2.inputNames[0], t3, a2))];
      case "Prod":
        return [ml(getParamValue("x", e2, t3, a2), getParamValue("axes", e2, t3, a2))];
      case "LeakyRelu":
        return [yl(getParamValue("x", e2, t3, a2), getParamValue("alpha", e2, t3, a2))];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var TensorArray = function() {
    function e2(t3, a2, r2, n2, s2, o2, p2) {
      this.name = t3, this.dtype = a2, this.maxSize = r2, this.elementShape = n2, this.identicalElementShapes = s2, this.dynamicSize = o2, this.clearAfterRead = p2, this.tensors = [], this.closed_ = false, this.id = e2.nextId++;
    }
    return Object.defineProperty(e2.prototype, "closed", { get: function() {
      return this.closed_;
    }, enumerable: true, configurable: true }), e2.prototype.clearAndClose = function() {
      this.tensors.forEach(function(e3) {
        return e3.tensor.dispose();
      }), this.tensors = [], this.closed_ = true;
    }, e2.prototype.size = function() {
      return this.tensors.length;
    }, e2.prototype.read = function(e3) {
      if (this.closed_)
        throw new Error("TensorArray " + this.name + " has already been closed.");
      if (e3 < 0 || e3 >= this.tensors.length)
        throw new Error("Tried to read from index " + e3 + ", but array size is: " + this.tensors.length);
      var t3 = this.tensors[e3];
      if (t3.cleared)
        throw new Error("TensorArray " + this.name + ": Could not read index " + e3 + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
      return this.clearAfterRead && (t3.cleared = true), t3.read = true, t3.tensor;
    }, e2.prototype.readMany = function(e3) {
      var t3 = this;
      return e3.map(function(e4) {
        return t3.read(e4);
      });
    }, e2.prototype.write = function(e3, t3) {
      if (this.closed_)
        throw new Error("TensorArray " + this.name + " has already been closed.");
      if (e3 < 0 || !this.dynamicSize && e3 >= this.maxSize)
        throw new Error("Tried to write to index " + e3 + ", but array is not resizeable and size is: " + this.maxSize);
      var a2 = this.tensors[e3] || {};
      if (t3.dtype !== this.dtype)
        throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + ",\n          because the value dtype is " + t3.dtype + ", but TensorArray dtype is " + this.dtype + ".");
      if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t3.shape), this.assertShapesMatchAllowUndefinedSize(this.elementShape, t3.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + "."), a2 && a2.read)
        throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + ", because it has already been read.");
      if (a2 && a2.written)
        throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + ", because it has already been written.");
      a2.tensor = t3, a2.written = true, this.tensors[e3] = a2;
    }, e2.prototype.writeMany = function(e3, t3) {
      var a2 = this;
      if (e3.length !== t3.length)
        throw new Error("TensorArray " + this.name + ": could not write multiple tensors,because the index size: " + e3.length + " is not the same as tensors size: " + t3.length + ".");
      e3.forEach(function(e4, r2) {
        return a2.write(e4, t3[r2]);
      });
    }, e2.prototype.gather = function(e3, t3) {
      if (t3 && t3 !== this.dtype)
        throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + t3);
      if (!e3) {
        e3 = [];
        for (var a2 = 0; a2 < this.size(); a2++)
          e3.push(a2);
      }
      if (0 === e3.length)
        return kn([], [0].concat(this.elementShape));
      var r2 = this.readMany(e3);
      return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r2[0].shape, "TensorArray shape mismatch: "), Tr(r2, 0);
    }, e2.prototype.concat = function(e3) {
      if (e3 && e3 !== this.dtype)
        throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + e3);
      if (0 === this.size())
        return kn([], [0].concat(this.elementShape));
      for (var t3 = [], a2 = 0; a2 < this.size(); a2++)
        t3.push(a2);
      var r2 = this.readMany(t3);
      return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r2[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + r2[0].shape + ")"), Gn(r2, 0);
    }, e2.prototype.scatter = function(e3, t3) {
      if (t3.dtype !== this.dtype)
        throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t3.dtype);
      if (e3.length !== t3.shape[0])
        throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + e3.length + " vs. " + t3.shape[0]);
      var a2 = Math.max.apply(Math, e3);
      if (!this.dynamicSize && a2 >= this.maxSize)
        throw new Error("Max index must be < array size (" + a2 + "  vs. " + this.maxSize + ")");
      this.writeMany(e3, Or(t3, 0));
    }, e2.prototype.split = function(e3, t3) {
      var a2 = this;
      if (t3.dtype !== this.dtype)
        throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t3.dtype);
      var r2 = 0, n2 = e3.map(function(e4) {
        return r2 += e4;
      });
      if (r2 !== t3.shape[0])
        throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + r2 + ", and tensor's shape is: " + t3.shape);
      if (!this.dynamicSize && e3.length !== this.maxSize)
        throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + e3.length + "), and the TensorArray is not marked as dynamically resizeable");
      var s2 = 0 === r2 ? 0 : t3.size / r2, o2 = [];
      je(function() {
        t3 = t3.reshape([1, r2, s2]);
        for (var p3 = 0; p3 < e3.length; ++p3) {
          var u3 = [0, 0 === p3 ? 0 : n2[p3 - 1], 0], i2 = [1, e3[p3], s2];
          o2[p3] = tl(t3, u3, i2).reshape(a2.elementShape);
        }
        return o2;
      });
      for (var p2 = [], u2 = 0; u2 < e3.length; u2++)
        p2[u2] = u2;
      this.writeMany(p2, o2);
    }, e2.prototype.assertShapesMatchAllowUndefinedSize = function(e3, t3, a2) {
      void 0 === a2 && (a2 = ""), tt.assert(this.shapesEqualAllowUndefinedSize(e3, t3), function() {
        return a2 + " Shapes " + e3 + " and " + t3 + " must match";
      });
    }, e2.prototype.shapesEqualAllowUndefinedSize = function(e3, t3) {
      if (e3.length !== t3.length)
        return false;
      for (var a2 = 0; a2 < e3.length; a2++)
        if (-1 !== e3[a2] && -1 !== t3[a2] && e3[a2] !== t3[a2])
          return false;
      return true;
    }, e2.nextId = 0, e2;
  }();
  function executeOp$2(e2, t3, a2) {
    return __awaiter2(this, void 0, void 0, function() {
      var r2, n2, s2, o2, p2, u2, i2, m2, l3, c2, d2, y2, f2, g2, h, N3, x2, V3, P3, b2, T2, O3, S3, v2, _3, w2, A2, D3, E3, I3, C3, M2, k4, z3, j3;
      return __generator2(this, function(F3) {
        switch (F3.label) {
          case 0:
            switch (e2.op) {
              case "LoopCond":
                return [3, 1];
              case "Switch":
                return [3, 2];
              case "Merge":
                return [3, 4];
              case "Enter":
                return [3, 5];
              case "Exit":
                return [3, 6];
              case "NextIteration":
                return [3, 7];
              case "TensorArrayV3":
                return [3, 8];
              case "TensorArrayWriteV3":
                return [3, 9];
              case "TensorArrayReadV3":
                return [3, 10];
              case "TensorArrayGatherV3":
                return [3, 11];
              case "TensorArrayScatterV3":
                return [3, 12];
              case "TensorArrayConcatV3":
                return [3, 13];
              case "TensorArraySplitV3":
                return [3, 14];
              case "TensorArraySizeV3":
                return [3, 15];
              case "TensorArrayCloseV3":
                return [3, 16];
            }
            return [3, 17];
          case 1:
            return [2, [getParamValue("pred", e2, t3, a2).clone()]];
          case 2:
            return r2 = getParamValue("pred", e2, t3, a2), n2 = getParamValue("data", e2, t3, a2), [4, r2.data()];
          case 3:
            return [2, F3.sent()[0] ? [void 0, n2.clone()] : [n2.clone(), void 0]];
          case 4:
            return [2, (s2 = e2.inputNames.find(function(e3) {
              return void 0 !== getTensor(e3, t3, a2);
            })) ? [getTensor(s2, t3, a2).clone()] : void 0];
          case 5:
            return o2 = getParamValue("frameName", e2, t3, a2), p2 = getParamValue("tensor", e2, t3, a2), a2.enterFrame(o2), [2, [p2.clone()]];
          case 6:
            return u2 = getParamValue("tensor", e2, t3, a2), a2.exitFrame(), [2, [u2.clone()]];
          case 7:
            return i2 = getParamValue("tensor", e2, t3, a2), a2.nextIteration(), [2, [i2.clone()]];
          case 8:
            return m2 = getParamValue("size", e2, t3, a2), l3 = getParamValue("dtype", e2, t3, a2), c2 = getParamValue("elementShape", e2, t3, a2), d2 = getParamValue("dynamicSize", e2, t3, a2), y2 = getParamValue("clearAfterRead", e2, t3, a2), f2 = getParamValue("identicalElementShapes", e2, t3, a2), g2 = getParamValue("name", e2, t3, a2), h = new TensorArray(g2, l3, m2, c2, f2, d2, y2), a2.addTensorArray(h), [2, [An(h.id), An(1)]];
          case 9:
            return N3 = getParamValue("tensorArrayId", e2, t3, a2), x2 = getParamValue("index", e2, t3, a2), V3 = getParamValue("tensor", e2, t3, a2), a2.getTensorArray(N3).write(x2, V3), [2, [An(1)]];
          case 10:
            return P3 = getParamValue("tensorArrayId", e2, t3, a2), b2 = getParamValue("index", e2, t3, a2), [2, [a2.getTensorArray(P3).read(b2)]];
          case 11:
            return T2 = getParamValue("tensorArrayId", e2, t3, a2), O3 = getParamValue("indices", e2, t3, a2), S3 = getParamValue("dtype", e2, t3, a2), [2, [a2.getTensorArray(T2).gather(O3, S3)]];
          case 12:
            return v2 = getParamValue("tensorArrayId", e2, t3, a2), _3 = getParamValue("indices", e2, t3, a2), w2 = getParamValue("tensor", e2, t3, a2), a2.getTensorArray(v2).scatter(_3, w2), [2, [An(1)]];
          case 13:
            return A2 = getParamValue("tensorArrayId", e2, t3, a2), D3 = a2.getTensorArray(A2), E3 = getParamValue("dtype", e2, t3, a2), [2, [D3.concat(E3)]];
          case 14:
            return I3 = getParamValue("tensorArrayId", e2, t3, a2), C3 = getParamValue("tensor", e2, t3, a2), M2 = getParamValue("lengths", e2, t3, a2), a2.getTensorArray(I3).split(M2, C3), [2, [An(1)]];
          case 15:
            return k4 = getParamValue("tensorArrayId", e2, t3, a2), z3 = a2.getTensorArray(k4), [2, [An(z3.size(), "int32")]];
          case 16:
            return j3 = getParamValue("tensorArrayId", e2, t3, a2), a2.getTensorArray(j3).clearAndClose(), [2, []];
          case 17:
            throw TypeError("Node type " + e2.op + " is not implemented");
        }
      });
    });
  }
  var executeOp$3 = function(e2, t3, a2) {
    var r2, n2;
    switch (e2.op) {
      case "Conv1D":
        var s2 = getParamValue("stride", e2, t3, a2), o2 = getParamValue("pad", e2, t3, a2), p2 = getParamValue("dataFormat", e2, t3, a2).toUpperCase(), u2 = getParamValue("dilation", e2, t3, a2);
        return [Ac(getParamValue("x", e2, t3, a2), getParamValue("filter", e2, t3, a2), s2, o2, p2, u2)];
      case "Conv2D":
        s2 = getParamValue("strides", e2, t3, a2), o2 = getParamValue("pad", e2, t3, a2), p2 = getParamValue("dataFormat", e2, t3, a2).toUpperCase();
        var i2 = getParamValue("dilations", e2, t3, a2);
        return [Dc(getParamValue("x", e2, t3, a2), getParamValue("filter", e2, t3, a2), [s2[1], s2[2]], o2, p2, [i2[1], i2[2]])];
      case "_FusedConv2D":
        var m2 = (r2 = getParamValue("fusedOps", e2, t3, a2))[0], l3 = r2[1], c2 = "biasadd" === m2, d2 = "prelu" === l3, y2 = "fusedbatchnorm" === m2, f2 = getParamValue("numArgs", e2, t3, a2);
        if (c2) {
          if (d2 && 2 !== f2)
            throw new Error("Fused Conv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
          if (!d2 && 1 !== f2)
            throw new Error("Fused Conv2d with BiasAdd must have one extra argument: bias.");
        }
        if (y2)
          throw new Error("Fused Conv2d with FusedBatchNorm is not supported.");
        s2 = getParamValue("strides", e2, t3, a2), o2 = getParamValue("pad", e2, t3, a2), p2 = getParamValue("dataFormat", e2, t3, a2).toUpperCase(), i2 = getParamValue("dilations", e2, t3, a2);
        var g2 = (n2 = getParamValue("args", e2, t3, a2))[0], h = n2[1];
        return [Eh.conv2d({ x: getParamValue("x", e2, t3, a2), filter: getParamValue("filter", e2, t3, a2), strides: [s2[1], s2[2]], pad: o2, dataFormat: p2, dilations: [i2[1], i2[2]], bias: g2, activation: l3, preluActivationWeights: h })];
      case "Conv2DBackpropInput":
      case "Conv2dTranspose":
        var N3 = getParamValue("outputShape", e2, t3, a2);
        s2 = getParamValue("strides", e2, t3, a2), o2 = getParamValue("pad", e2, t3, a2);
        return [Pc(getParamValue("x", e2, t3, a2), getParamValue("filter", e2, t3, a2), N3, [s2[1], s2[2]], o2)];
      case "DepthwiseConv2dNative":
      case "DepthwiseConv2d":
        s2 = getParamValue("strides", e2, t3, a2), o2 = getParamValue("pad", e2, t3, a2), i2 = getParamValue("dilations", e2, t3, a2), p2 = getParamValue("dataFormat", e2, t3, a2).toUpperCase();
        return [Oc(getParamValue("input", e2, t3, a2), getParamValue("filter", e2, t3, a2), [s2[1], s2[2]], o2, p2, [i2[1], i2[2]])];
      case "Conv3D":
        s2 = getParamValue("strides", e2, t3, a2), o2 = getParamValue("pad", e2, t3, a2), p2 = getParamValue("dataFormat", e2, t3, a2).toUpperCase(), i2 = getParamValue("dilations", e2, t3, a2);
        return [Tc(getParamValue("x", e2, t3, a2), getParamValue("filter", e2, t3, a2), [s2[1], s2[2], s2[3]], o2, p2, [i2[1], i2[2], i2[3]])];
      case "AvgPool":
        s2 = getParamValue("strides", e2, t3, a2), o2 = getParamValue("pad", e2, t3, a2);
        var x2 = getParamValue("kernelSize", e2, t3, a2);
        return [Yc(getParamValue("x", e2, t3, a2), [x2[1], x2[2]], [s2[1], s2[2]], o2)];
      case "MaxPool":
        s2 = getParamValue("strides", e2, t3, a2), o2 = getParamValue("pad", e2, t3, a2), x2 = getParamValue("kernelSize", e2, t3, a2);
        return [$c(getParamValue("x", e2, t3, a2), [x2[1], x2[2]], [s2[1], s2[2]], o2)];
      case "AvgPool3D":
        s2 = getParamValue("strides", e2, t3, a2), o2 = getParamValue("pad", e2, t3, a2), x2 = getParamValue("kernelSize", e2, t3, a2);
        return [Zc(getParamValue("x", e2, t3, a2), [x2[1], x2[2], x2[3]], [s2[1], s2[2], s2[3]], o2)];
      case "MaxPool3D":
        s2 = getParamValue("strides", e2, t3, a2), o2 = getParamValue("pad", e2, t3, a2), x2 = getParamValue("kernelSize", e2, t3, a2);
        return [Jc(getParamValue("x", e2, t3, a2), [x2[1], x2[2], x2[3]], [s2[1], s2[2], s2[3]], o2)];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$4 = function(e2, t3, a2) {
    switch (e2.op) {
      case "Fill":
        var r2 = getParamValue("shape", e2, t3, a2), n2 = getParamValue("dtype", e2, t3, a2), s2 = getParamValue("value", e2, t3, a2);
        return [Ln(r2, s2, n2)];
      case "LinSpace":
        var o2 = getParamValue("start", e2, t3, a2), p2 = getParamValue("stop", e2, t3, a2), u2 = getParamValue("num", e2, t3, a2);
        return [Wn(o2, p2, u2)];
      case "Multinomial":
        var i2 = getParamValue("logits", e2, t3, a2), m2 = getParamValue("numSamples", e2, t3, a2), l3 = getParamValue("seed", e2, t3, a2);
        return [mr(i2, m2, l3)];
      case "OneHot":
        var c2 = getParamValue("indices", e2, t3, a2), d2 = getParamValue("depth", e2, t3, a2), y2 = getParamValue("onValue", e2, t3, a2), f2 = getParamValue("offValue", e2, t3, a2);
        return [gr(c2, d2, y2, f2)];
      case "Ones":
        return [Bn(getParamValue("shape", e2, t3, a2), getParamValue("dtype", e2, t3, a2))];
      case "OnesLike":
        return [Vn(getParamValue("x", e2, t3, a2))];
      case "RandomUniform":
        return [kr(getParamValue("shape", e2, t3, a2), getParamValue("minval", e2, t3, a2), getParamValue("maxval", e2, t3, a2), getParamValue("dtype", e2, t3, a2))];
      case "Range":
        o2 = getParamValue("start", e2, t3, a2);
        var g2 = getParamValue("stop", e2, t3, a2), h = getParamValue("step", e2, t3, a2);
        return [Un(o2, g2, h, getParamValue("dtype", e2, t3, a2))];
      case "TruncatedNormal":
        r2 = getParamValue("shape", e2, t3, a2);
        var N3 = getParamValue("mean", e2, t3, a2), x2 = getParamValue("stdDev", e2, t3, a2);
        l3 = getParamValue("seed", e2, t3, a2);
        return [Fr(r2, N3, x2, getParamValue("dtype", e2, t3, a2), l3)];
      case "Zeros":
        return [Pn(getParamValue("shape", e2, t3, a2), getParamValue("dtype", e2, t3, a2))];
      case "ZerosLike":
        return [zn(getParamValue("x", e2, t3, a2))];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  function executeOp$5(e2, t3, a2) {
    return __awaiter2(this, void 0, void 0, function() {
      var r2, n2, s2, o2, p2;
      return __generator2(this, function(u2) {
        switch (u2.label) {
          case 0:
            switch (e2.op) {
              case "NonMaxSuppressionV3":
              case "NonMaxSuppressionV2":
                return [3, 1];
              case "Where":
                return [3, 3];
              case "ListDiff":
                return [3, 5];
            }
            return [3, 6];
          case 1:
            return r2 = getParamValue("boxes", e2, t3, a2), n2 = getParamValue("scores", e2, t3, a2), s2 = getParamValue("maxOutputSize", e2, t3, a2), o2 = getParamValue("iouThreshold", e2, t3, a2), p2 = getParamValue("scoreThreshold", e2, t3, a2), [4, vh.nonMaxSuppressionAsync(r2, n2, s2, o2, p2)];
          case 2:
            return [2, [u2.sent()]];
          case 3:
            return [4, Us(getParamValue("condition", e2, t3, a2).asType("bool"))];
          case 4:
            return [2, [u2.sent()]];
          case 5:
            return [2, _r(getParamValue("x", e2, t3, a2), getParamValue("y", e2, t3, a2))];
          case 6:
            throw TypeError("Node type " + e2.op + " is not implemented");
        }
      });
    });
  }
  var executeOp$6 = function(e2, t3, a2) {
    switch (e2.op) {
      case "TopKV2":
        var r2 = getParamValue("x", e2, t3, a2), n2 = getParamValue("k", e2, t3, a2), s2 = getParamValue("sorted", e2, t3, a2), o2 = Tl(r2, n2, s2);
        return [o2.values, o2.indices];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$7 = function(e2, t3, a2) {
    switch (e2.op) {
      case "Const":
        return t3[e2.name];
      case "PlaceholderWithDefault":
        var r2 = getParamValue("default", e2, t3, a2);
        return [getTensor(e2.name, t3, a2) || r2];
      case "Placeholder":
        return [getTensor(e2.name, t3, a2)];
      case "Identity":
      case "StopGradient":
      case "FakeQuantWithMinMaxVars":
        return [getParamValue("x", e2, t3, a2).clone()];
      case "IdentityN":
        return getParamValue("x", e2, t3, a2).map(function(e3) {
          return e3.clone();
        });
      case "Snapshot":
        return [getParamValue("x", e2, t3, a2).clone()];
      case "Shape":
        return [Dn(getParamValue("x", e2, t3, a2).shape, "int32")];
      case "ShapeN":
        return getParamValue("x", e2, t3, a2).map(function(e3) {
          return Dn(e3.shape);
        });
      case "Size":
        return [An(getParamValue("x", e2, t3, a2).size, "int32")];
      case "Rank":
        return [An(getParamValue("x", e2, t3, a2).rank, "int32")];
      case "NoOp":
        return [];
      case "Print":
        var n2 = getParamValue("x", e2, t3, a2), s2 = getParamValue("data", e2, t3, a2), o2 = getParamValue("message", e2, t3, a2), p2 = getParamValue("summarize", e2, t3, a2);
        console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(o2);
        for (var u2 = 0; u2 < s2.length; u2++)
          console.log(Array.prototype.slice.call(s2[u2].dataSync()).slice(0, p2));
        return [n2];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$8 = function(e2, t3, a2) {
    switch (e2.op) {
      case "ResizeBilinear":
        var r2 = getParamValue("images", e2, t3, a2), n2 = getParamValue("size", e2, t3, a2), s2 = getParamValue("alignCorners", e2, t3, a2);
        return [vh.resizeBilinear(r2, [n2[0], n2[1]], s2)];
      case "ResizeNearestNeighbor":
        r2 = getParamValue("images", e2, t3, a2), n2 = getParamValue("size", e2, t3, a2), s2 = getParamValue("alignCorners", e2, t3, a2);
        return [vh.resizeNearestNeighbor(r2, [n2[0], n2[1]], s2)];
      case "CropAndResize":
        var o2 = getParamValue("image", e2, t3, a2), p2 = getParamValue("boxes", e2, t3, a2), u2 = getParamValue("boxInd", e2, t3, a2), i2 = getParamValue("cropSize", e2, t3, a2), m2 = getParamValue("method", e2, t3, a2), l3 = getParamValue("extrapolationValue", e2, t3, a2);
        return [vh.cropAndResize(o2, p2, u2, i2, m2, l3)];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$9 = function(e2, t3, a2) {
    switch (e2.op) {
      case "Equal":
        return [sc(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "NotEqual":
        return [yc(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "Greater":
        return [lc(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "GreaterEqual":
        return [hc(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "Less":
        return [dc(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "LessEqual":
        return [vc(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "LogicalAnd":
        return [Ms(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "LogicalNot":
        return [Bs(getParamValue("a", e2, t3, a2))];
      case "LogicalOr":
        return [Ps(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      case "Select":
        return [Ws(getParamValue("condition", e2, t3, a2), getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2))];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$10 = function(e2, t3, a2) {
    switch (e2.op) {
      case "BatchMatMul":
      case "BatchMatMulV2":
      case "MatMul":
        return [Wc(getParamValue("a", e2, t3, a2), getParamValue("b", e2, t3, a2), getParamValue("transposeA", e2, t3, a2), getParamValue("transposeB", e2, t3, a2))];
      case "Transpose":
        return [El(getParamValue("x", e2, t3, a2), getParamValue("perm", e2, t3, a2))];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$11 = function(e2, t3, a2) {
    switch (e2.op) {
      case "FusedBatchNorm":
      case "FusedBatchNormV2":
      case "FusedBatchNormV3":
        return [Ns(getParamValue("x", e2, t3, a2), getParamValue("mean", e2, t3, a2), getParamValue("variance", e2, t3, a2), getParamValue("offset", e2, t3, a2), getParamValue("scale", e2, t3, a2), getParamValue("epsilon", e2, t3, a2))];
      case "LRN":
        return [Rl(getParamValue("x", e2, t3, a2), getParamValue("radius", e2, t3, a2), getParamValue("bias", e2, t3, a2), getParamValue("alpha", e2, t3, a2), getParamValue("beta", e2, t3, a2))];
      case "Softmax":
        return [io(getParamValue("x", e2, t3, a2))];
      case "LogSoftmax":
        return [uo(getParamValue("x", e2, t3, a2))];
      case "SparseToDense":
        return [Pl(getParamValue("sparseIndices", e2, t3, a2), getParamValue("outputShape", e2, t3, a2), getParamValue("sparseValues", e2, t3, a2), getParamValue("defaultValue", e2, t3, a2))];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$12 = function(e2, t3, a2) {
    switch (e2.op) {
      case "Max":
        var r2 = getParamValue("axis", e2, t3, a2), n2 = getParamValue("keepDims", e2, t3, a2);
        return [hl(getParamValue("x", e2, t3, a2), r2, n2)];
      case "Mean":
        r2 = getParamValue("axis", e2, t3, a2), n2 = getParamValue("keepDims", e2, t3, a2);
        return [fl(getParamValue("x", e2, t3, a2), r2, n2)];
      case "Min":
        r2 = getParamValue("axis", e2, t3, a2), n2 = getParamValue("keepDims", e2, t3, a2);
        return [pl(getParamValue("x", e2, t3, a2), r2, n2)];
      case "Sum":
        r2 = getParamValue("axis", e2, t3, a2), n2 = getParamValue("keepDims", e2, t3, a2);
        return [vl(getParamValue("x", e2, t3, a2), r2, n2)];
      case "All":
        r2 = getParamValue("axis", e2, t3, a2), n2 = getParamValue("keepDims", e2, t3, a2);
        return [il(getParamValue("x", e2, t3, a2), r2, n2)];
      case "Any":
        r2 = getParamValue("axis", e2, t3, a2), n2 = getParamValue("keepDims", e2, t3, a2);
        return [ul(getParamValue("x", e2, t3, a2), r2, n2)];
      case "ArgMax":
        r2 = getParamValue("axis", e2, t3, a2);
        return [sl(getParamValue("x", e2, t3, a2), r2)];
      case "ArgMin":
        r2 = getParamValue("axis", e2, t3, a2);
        return [cl(getParamValue("x", e2, t3, a2), r2)];
      case "Prod":
        r2 = getParamValue("axis", e2, t3, a2), n2 = getParamValue("keepDims", e2, t3, a2);
        return [ml(getParamValue("x", e2, t3, a2), r2, n2)];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$13 = function(e2, t3, a2) {
    switch (e2.op) {
      case "ConcatV2":
      case "Concat":
        var r2 = getParamValue("axis", e2, t3, a2), n2 = getParamValue("tensors", e2, t3, a2);
        return [Gn(n2, r2)];
      case "GatherV2":
      case "Gather":
        r2 = getParamValue("axis", e2, t3, a2);
        var s2 = getParamValue("x", e2, t3, a2), o2 = getParamValue("indices", e2, t3, a2);
        return [Cc(s2, o2.asType("int32"), r2)];
      case "ReverseV2":
      case "Reverse":
        r2 = getParamValue("axis", e2, t3, a2), s2 = getParamValue("x", e2, t3, a2);
        return [zc(s2, r2)];
      case "Slice":
        var p2 = getParamValue("begin", e2, t3, a2), u2 = getParamValue("size", e2, t3, a2);
        return [tl(getParamValue("x", e2, t3, a2), p2, u2)];
      case "StridedSlice":
        p2 = getParamValue("begin", e2, t3, a2);
        var i2 = getParamValue("end", e2, t3, a2), m2 = getParamValue("strides", e2, t3, a2), l3 = getParamValue("beginMask", e2, t3, a2), c2 = getParamValue("endMask", e2, t3, a2), d2 = getParamValue("ellipsisMask", e2, t3, a2), y2 = getParamValue("newAxisMask", e2, t3, a2), f2 = getParamValue("shrinkAxisMask", e2, t3, a2), g2 = getParamValue("x", e2, t3, a2);
        if (1 === p2.length && g2.shape.length > 1)
          for (var h = 1; h < g2.shape.length; h++)
            p2.push(0), i2.push(g2.shape[h]), m2.push(m2[0]);
        return [Dl(g2, p2, i2, m2, l3, c2, d2, y2, f2)];
      case "Pack":
        return je(function() {
          var r3 = getParamValue("axis", e2, t3, a2), n3 = getParamValue("tensors", e2, t3, a2), s3 = n3[0].shape, o3 = n3[0].squeeze().shape, p3 = n3.map(function(e3) {
            var t4 = tt.arraysEqual(e3.shape, s3);
            if (!t4 && !tt.arraysEqual(e3.squeeze().shape, o3))
              throw new Error("the input tensors shape does not match");
            return t4 ? e3 : e3.reshape(s3);
          });
          return [Tr(p3, r3)];
        });
      case "Unpack":
        return je(function() {
          var r3 = getParamValue("axis", e2, t3, a2), n3 = getParamValue("tensor", e2, t3, a2);
          return Or(n3, r3);
        });
      case "Tile":
        var N3 = getParamValue("reps", e2, t3, a2);
        return [Nr(getParamValue("x", e2, t3, a2), N3)];
      case "Split":
      case "SplitV":
        r2 = getParamValue("axis", e2, t3, a2);
        var x2 = getParamValue("numOrSizeSplits", e2, t3, a2);
        return Xn(getParamValue("x", e2, t3, a2), x2, r2);
      case "ScatterNd":
        o2 = getParamValue("indices", e2, t3, a2);
        var V3 = getParamValue("values", e2, t3, a2), P3 = getParamValue("shape", e2, t3, a2);
        return [Nl(o2, V3, P3)];
      case "GatherNd":
        var b2 = getParamValue("x", e2, t3, a2);
        o2 = getParamValue("indices", e2, t3, a2);
        return [Ll(b2, o2)];
      case "SparseToDense":
        o2 = getParamValue("sparseIndices", e2, t3, a2), P3 = getParamValue("outputShape", e2, t3, a2);
        var T2 = getParamValue("sparseValues", e2, t3, a2), O3 = getParamValue("defaultValue", e2, t3, a2);
        return [Pl(o2, T2, P3, T2.dtype === O3.dtype ? O3 : O3.asType(T2.dtype))];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$14 = function(e2, t3, a2) {
    switch (e2.op) {
      case "FFT":
        return [Fl(getParamValue("x", e2, t3, a2))];
      case "IFFT":
        return [Ol(getParamValue("x", e2, t3, a2))];
      case "RFFT":
        return [_l(getParamValue("x", e2, t3, a2))];
      case "IRFFT":
        return [Ml(getParamValue("x", e2, t3, a2))];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  var executeOp$15 = function(e2, t3, a2) {
    switch (e2.op) {
      case "Cast":
        return [lr(getParamValue("x", e2, t3, a2), getParamValue("dtype", e2, t3, a2))];
      case "ExpandDims":
        var r2 = getParamValue("axis", e2, t3, a2);
        return [dr(getParamValue("x", e2, t3, a2), r2)];
      case "Squeeze":
        r2 = getParamValue("axis", e2, t3, a2);
        return [Dr(getParamValue("x", e2, t3, a2), r2)];
      case "Reshape":
        return [Sr(getParamValue("x", e2, t3, a2), getParamValue("shape", e2, t3, a2))];
      case "PadV2":
      case "Pad":
        return [yr(getParamValue("x", e2, t3, a2), split$1(getParamValue("padding", e2, t3, a2), 2), getParamValue("constantValue", e2, t3, a2))];
      case "SpaceToBatchND":
        var n2 = getParamValue("blockShape", e2, t3, a2), s2 = split$1(getParamValue("paddings", e2, t3, a2), 2);
        return [Ar(getParamValue("x", e2, t3, a2), n2, s2)];
      case "BatchToSpaceND":
        n2 = getParamValue("blockShape", e2, t3, a2);
        var o2 = split$1(getParamValue("crops", e2, t3, a2), 2);
        return [cr(getParamValue("x", e2, t3, a2), n2, o2)];
      case "DepthToSpace":
        var p2 = getParamValue("blockSize", e2, t3, a2), u2 = getParamValue("dataFormat", e2, t3, a2).toUpperCase();
        return [pr(getParamValue("x", e2, t3, a2), p2, u2)];
      default:
        throw TypeError("Node type " + e2.op + " is not implemented");
    }
  };
  function executeOp$16(e2, t3, a2) {
    var r2 = function(e3, t4, a3) {
      switch (e3.category) {
        case "arithmetic":
          return executeOp(e3, t4, a3);
        case "basic_math":
          return executeOp$1(e3, t4, a3);
        case "control":
          return executeOp$2(e3, t4, a3);
        case "convolution":
          return executeOp$3(e3, t4, a3);
        case "creation":
          return executeOp$4(e3, t4, a3);
        case "dynamic":
          return executeOp$5(e3, t4, a3);
        case "evaluation":
          return executeOp$6(e3, t4, a3);
        case "image":
          return executeOp$8(e3, t4, a3);
        case "graph":
          return executeOp$7(e3, t4, a3);
        case "logical":
          return executeOp$9(e3, t4, a3);
        case "matrices":
          return executeOp$10(e3, t4, a3);
        case "normalization":
          return executeOp$11(e3, t4, a3);
        case "reduction":
          return executeOp$12(e3, t4, a3);
        case "slice_join":
          return executeOp$13(e3, t4, a3);
        case "spectral":
          return executeOp$14(e3, t4, a3);
        case "transformation":
          return executeOp$15(e3, t4, a3);
        case "custom":
          var r3 = getRegisteredOp(e3.op);
          if (r3 && r3.customExecutor)
            return r3.customExecutor(new NodeValueImpl(e3, t4, a3));
          throw TypeError("Custom op " + e3.op + " is not registered.");
        default:
          throw TypeError("Unknown op '" + e3.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");
      }
    }(e2, t3, a2);
    return r2 instanceof Promise ? r2.then(function(e3) {
      return [].concat(e3);
    }) : [].concat(r2);
  }
  var ExecutionContext = function() {
    function e2(e3, t3) {
      this.weightMap = e3, this.tensorArrayMap = t3, this.rootContext = { id: 0, frameName: "", iterationId: 0 }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
    }
    return e2.prototype.newFrame = function(e3, t3) {
      return { id: e3, frameName: t3, iterationId: 0 };
    }, Object.defineProperty(e2.prototype, "currentContext", { get: function() {
      return this.contexts;
    }, set: function(e3) {
      this.contexts !== e3 && (this.contexts = e3, this.generateCurrentContextIds());
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "currentContextId", { get: function() {
      return this._currentContextIds[0];
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "currentContextIds", { get: function() {
      return this._currentContextIds;
    }, enumerable: true, configurable: true }), e2.prototype.generateCurrentContextIds = function() {
      for (var e3 = [], t3 = 0; t3 < this.contexts.length - 1; t3++) {
        var a2 = this.contexts.slice(0, this.contexts.length - t3);
        e3.push(this.contextIdforContexts(a2));
      }
      e3.push(""), this._currentContextIds = e3;
    }, e2.prototype.contextIdforContexts = function(e3) {
      return e3 ? e3.map(function(e4) {
        return 0 === e4.id && 0 === e4.iterationId ? "" : e4.frameName + "-" + e4.iterationId;
      }).join("/") : "";
    }, e2.prototype.enterFrame = function(e3) {
      this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e3)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
    }, e2.prototype.exitFrame = function() {
      if (!(this.contexts && this.contexts.length > 1))
        throw new Error("Cannot exit frame, the context is empty");
      this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
    }, e2.prototype.nextIteration = function() {
      if (!(this.contexts && this.contexts.length > 0))
        throw new Error("Cannot increase frame iteration, the context is empty");
      this.contexts = this.contexts.slice(), this.lastId++;
      var e3 = Object.assign({}, this.contexts[this.contexts.length - 1]);
      e3.iterationId += 1, e3.id = this.lastId, this.contexts.splice(-1, 1, e3), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
    }, e2.prototype.getWeight = function(e3) {
      return this.weightMap[e3];
    }, e2.prototype.addTensorArray = function(e3) {
      this.tensorArrayMap[e3.id] = e3;
    }, e2.prototype.getTensorArray = function(e3) {
      return this.tensorArrayMap[e3];
    }, e2;
  }();
  function getExecutionSubgraph(e2, t3, a2) {
    for (var r2 = /* @__PURE__ */ new Set(), n2 = [], s2 = null, o2 = null, p2 = /* @__PURE__ */ new Set(), u2 = t3.slice(); u2.length > 0; ) {
      var i2 = u2.pop();
      (isControlFlow(i2) || isDynamicShape(i2)) && null == s2 && (o2 = (s2 = i2).children.map(function(e3) {
        return e3.name;
      }).filter(function(e3) {
        return r2.has(e3);
      })), r2.add(i2.name), null == a2[i2.name] && (null == e2[i2.name] && (0 !== i2.inputs.length ? i2.inputs.forEach(function(e3) {
        p2.has(e3.name) || (p2.add(e3.name), u2.push(e3));
      }) : n2.push(i2.name)));
    }
    return { inputs: e2, outputs: t3, usedNodes: r2, missingInputs: n2, dynamicNode: s2, syncInputs: o2 };
  }
  function getNodesInTopologicalOrder(e2, t3, a2) {
    var r2 = a2.usedNodes, n2 = a2.inputs, s2 = [];
    Object.keys(n2).map(function(t4) {
      return e2.nodes[t4];
    }).forEach(function(e3) {
      r2.has(e3.name) && s2.push(e3);
    }), e2.weights.forEach(function(e3) {
      r2.has(e3.name) && s2.push(e3);
    });
    for (var o2 = /* @__PURE__ */ new Set(), p2 = []; s2.length > 0; ) {
      var u2 = s2.pop();
      o2.add(u2.name), t3[u2.name] || p2.push(u2), u2.children.forEach(function(e3) {
        !o2.has(e3.name) && r2.has(e3.name) && e3.inputs.every(function(e4) {
          return o2.has(e4.name);
        }) && s2.push(e3);
      });
    }
    return p2;
  }
  var CONTROL_FLOW_OPS = ["Switch", "Merge", "Enter", "Exit", "NextIteration"];
  var DYNAMIC_SHAPE_OPS = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "Where"];
  function isControlFlow(e2) {
    return CONTROL_FLOW_OPS.indexOf(e2.op) >= 0;
  }
  function isDynamicShape(e2) {
    return DYNAMIC_SHAPE_OPS.indexOf(e2.op) >= 0;
  }
  var GraphExecutor = function() {
    function e2(e3) {
      this.graph = e3, this.compiledMap = /* @__PURE__ */ new Map(), this._weightMap = {}, this.SEPERATOR = ",", this.placeholders = e3.placeholders, this._outputs = e3.outputs;
    }
    return Object.defineProperty(e2.prototype, "weightMap", { get: function() {
      return this._weightMap;
    }, set: function(e3) {
      var t3 = Object.keys(e3).map(function(t4) {
        return e3[t4].map(function(e4) {
          return e4.id;
        });
      });
      this.weightIds = [].concat.apply([], t3), this._weightMap = e3;
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "inputs", { get: function() {
      return this.placeholders.map(function(e3) {
        return { name: e3.name, shape: e3.attrParams.shape ? e3.attrParams.shape.value : void 0, dtype: e3.attrParams.dtype ? e3.attrParams.dtype.value : void 0 };
      });
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "outputs", { get: function() {
      return this._outputs.map(function(e3) {
        return { name: e3.name, shape: e3.attrParams.shape ? e3.attrParams.shape.value : void 0, dtype: e3.attrParams.dtype ? e3.attrParams.dtype.value : void 0 };
      });
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "inputNodes", { get: function() {
      return this.placeholders.map(function(e3) {
        return e3.name;
      });
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "outputNodes", { get: function() {
      return this.outputs.map(function(e3) {
        return e3.name;
      });
    }, enumerable: true, configurable: true }), e2.prototype.getCompilationKey = function(e3, t3) {
      var a2 = e3.map(function(e4) {
        return e4.name;
      }).sort(), r2 = t3.map(function(e4) {
        return e4.name;
      }).sort();
      return a2.join(this.SEPERATOR) + "--" + r2.join(this.SEPERATOR);
    }, e2.prototype.compile = function(e3, t3) {
      var a2 = getExecutionSubgraph(e3, t3, this.weightMap), r2 = a2.missingInputs, n2 = a2.dynamicNode, s2 = a2.syncInputs;
      if (null != n2)
        throw new Error("This execution contains the node '" + n2.name + "', which has the dynamic op '" + n2.op + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + s2 + "]");
      if (r2.length > 0) {
        var o2 = t3.map(function(e4) {
          return e4.name;
        }), p2 = Object.keys(e3);
        throw new Error("Cannot compute the outputs [" + o2 + "] from the provided inputs [" + p2 + "]. Missing the following inputs: [" + r2 + "]");
      }
      return getNodesInTopologicalOrder(this.graph, this.weightMap, a2);
    }, e2.prototype.execute = function(e3, t3) {
      var a2 = this, r2 = Object.keys(e3).sort();
      this.checkInputs(e3), this.checkInputShapeAndType(e3), this.checkOutputs(t3);
      var n2 = r2.map(function(e4) {
        return a2.graph.nodes[e4];
      }), s2 = t3.map(function(e4) {
        return a2.graph.nodes[parseNodeName(e4)[0]];
      }), o2 = this.getCompilationKey(n2, s2), p2 = this.compiledMap.get(o2);
      null == p2 && (p2 = this.compile(e3, s2), this.compiledMap.set(o2, p2));
      var u2 = {};
      return je(function() {
        var r3 = new ExecutionContext(a2._weightMap, u2), n3 = __assign2({}, a2.weightMap);
        Object.keys(e3).forEach(function(t4) {
          n3[t4] = [e3[t4]];
        });
        for (var s3 = a2.getFrozenTensorIds(n3), o3 = {}, i2 = 0; i2 < p2.length; i2++) {
          var m2 = p2[i2];
          if (!n3[m2.name]) {
            var l3 = executeOp$16(m2, n3, r3);
            if (l3 instanceof Promise)
              throw new Error("The execution of the op '" + m2.op + "' returned a promise. Please use model.executeAsync() instead.");
            n3[m2.name] = l3, a2.checkTensorForDisposal(m2.name, m2, n3, r3, s3, t3, o3);
          }
        }
        return t3.map(function(e4) {
          return getTensor(e4, n3, r3);
        });
      });
    }, e2.prototype.getFrozenTensorIds = function(e3) {
      var t3 = [].concat.apply([], Object.keys(e3).map(function(t4) {
        return e3[t4];
      }).map(function(e4) {
        return e4.map(function(e5) {
          return e5.id;
        });
      }));
      return new Set(t3);
    }, e2.prototype.checkTensorForDisposal = function(e3, t3, a2, r2, n2, s2, o2) {
      "control" !== t3.category && -1 === s2.indexOf(e3) && (a2[e3].forEach(function(e4) {
        null != e4 && (o2[e4.id] = (o2[e4.id] || 0) + t3.children.length);
      }), t3.inputs.forEach(function(e4) {
        if ("control" !== e4.category) {
          var t4 = getTensorsForCurrentContenxt(e4.name, a2, r2);
          null != t4 && t4.forEach(function(e5) {
            if (e5 && !n2.has(e5.id)) {
              var t5 = o2[e5.id];
              1 === t5 ? (e5.dispose(), delete o2[e5.id]) : null != t5 && o2[e5.id]--;
            }
          });
        }
      }));
    }, e2.prototype.executeAsync = function(e3, t3) {
      return __awaiter2(this, void 0, void 0, function() {
        var a2, r2, n2, s2, o2, p2, u2 = this;
        return __generator2(this, function(i2) {
          switch (i2.label) {
            case 0:
              return this.checkInputs(e3), this.checkInputShapeAndType(e3), this.checkOutputs(t3), a2 = {}, r2 = new ExecutionContext(this._weightMap, a2), [4, this.executeWithControlFlow(e3, r2, t3)];
            case 1:
              return n2 = i2.sent(), s2 = t3.map(function(e4) {
                return getTensor(e4, n2, r2);
              }), o2 = new Set(s2.map(function(e4) {
                return e4.id;
              })), p2 = new Set(Object.keys(e3).map(function(t4) {
                return e3[t4].id;
              })), Object.keys(n2).forEach(function(e4) {
                n2[e4].forEach(function(e5) {
                  !e5 || e5.isDisposed || o2.has(e5.id) || p2.has(e5.id) || -1 !== u2.weightIds.indexOf(e5.id) || e5.dispose();
                });
              }), [2, s2];
          }
        });
      });
    }, e2.prototype.executeWithControlFlow = function(e3, t3, a2) {
      return __awaiter2(this, void 0, void 0, function() {
        var r2, n2, s2, o2, p2, u2, i2, m2, l3, c2, d2, y2, f2, g2, h, N3, x2 = this;
        return __generator2(this, function(V3) {
          switch (V3.label) {
            case 0:
              r2 = Object.keys(e3), n2 = r2.map(function(e4) {
                return x2.graph.nodes[e4];
              }), s2 = a2.map(function(e4) {
                return x2.graph.nodes[parseNodeName(e4)[0]];
              }), o2 = getExecutionSubgraph(e3, s2, this.weightMap), p2 = o2.usedNodes, u2 = o2.missingInputs, i2 = o2.dynamicNode, m2 = o2.syncInputs, l3 = n2.concat(this.graph.weights).map(function(e4) {
                return { node: e4, contexts: t3.currentContext };
              }), c2 = __assign2({}, this.weightMap), Object.keys(e3).forEach(function(t4) {
                c2[t4] = [e3[t4]];
              }), d2 = {}, y2 = this.getFrozenTensorIds(c2), f2 = {}, V3.label = 1;
            case 1:
              return l3.length > 0 ? (g2 = this.processStack(n2, l3, t3, c2, f2, y2, a2, d2, p2), [4, Promise.all(g2)]) : [3, 3];
            case 2:
              return V3.sent(), [3, 1];
            case 3:
              if (null == i2 && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), (h = s2.filter(function(e4) {
                return !isControlFlow(e4) && !getTensor(e4.name, c2, t3);
              }).map(function(e4) {
                return e4.name;
              })).length > 0)
                throw N3 = "", null != i2 && (N3 = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + m2 + "]"), new Error("Cannot compute the outputs [" + h + "] from the provided inputs [" + r2 + "]. Consider providing the following inputs: [" + u2 + "]. " + N3);
              return [2, c2];
          }
        });
      });
    }, e2.prototype.processStack = function(e3, t3, a2, r2, n2, s2, o2, p2, u2) {
      for (var i2 = this, m2 = [], l3 = function() {
        var l4 = t3.pop();
        a2.currentContext = l4.contexts;
        var d2 = "";
        if ("Enter" === l4.node.op && getParamValue("isConstant", l4.node, r2, a2) && (d2 = getNodeNameAndIndex(l4.node.name, a2)[0]), -1 === e3.indexOf(l4.node)) {
          var y2 = executeOp$16(l4.node, r2, a2);
          d2 || (d2 = getNodeNameAndIndex(l4.node.name, a2)[0]);
          var f2 = a2.currentContext;
          y2 instanceof Promise ? m2.push(y2.then(function(e4) {
            return r2[d2] = e4, a2.currentContext = f2, i2.checkTensorForDisposal(d2, l4.node, r2, a2, s2, o2, p2), i2.processChildNodes(l4.node, t3, a2, r2, n2, u2), e4;
          })) : (r2[d2] = y2, c2.checkTensorForDisposal(d2, l4.node, r2, a2, s2, o2, p2), c2.processChildNodes(l4.node, t3, a2, r2, n2, u2));
        } else
          c2.processChildNodes(l4.node, t3, a2, r2, n2, u2);
      }, c2 = this; t3.length > 0; )
        l3();
      return m2;
    }, e2.prototype.processChildNodes = function(e3, t3, a2, r2, n2, s2) {
      e3.children.forEach(function(e4) {
        var o2 = getNodeNameAndIndex(e4.name, a2)[0];
        !n2[o2] && s2.has(e4.name) && ("Merge" === e4.op ? e4.inputNames.some(function(e5) {
          return !!getTensor(e5, r2, a2);
        }) && (n2[o2] = true, t3.push({ contexts: a2.currentContext, node: e4 })) : e4.inputNames.every(function(e5) {
          return !!getTensor(e5, r2, a2);
        }) && (n2[o2] = true, t3.push({ contexts: a2.currentContext, node: e4 })));
      });
    }, e2.prototype.dispose = function() {
      var e3 = this;
      Object.keys(this.weightMap).forEach(function(t3) {
        return e3.weightMap[t3].forEach(function(e4) {
          return e4.dispose();
        });
      });
    }, e2.prototype.checkInputShapeAndType = function(e3) {
      var t3 = this;
      Object.keys(e3).forEach(function(a2) {
        var r2 = e3[a2], n2 = t3.graph.nodes[a2];
        if (n2.attrParams.shape && n2.attrParams.shape.value) {
          var s2 = n2.attrParams.shape.value, o2 = s2.length === r2.shape.length && r2.shape.every(function(e4, t4) {
            return -1 === s2[t4] || s2[t4] === e4;
          });
          tt.assert(o2, function() {
            return "The shape of dict['" + n2.name + "'] provided in model.execute(dict) must be [" + s2 + "], but was [" + r2.shape + "]";
          });
        }
        n2.attrParams.dtype && n2.attrParams.dtype.value && tt.assert(r2.dtype === n2.attrParams.dtype.value, function() {
          return "The dtype of dict['" + n2.name + "'] provided in model.execute(dict) must be " + n2.attrParams.dtype.value + ", but was " + r2.dtype;
        });
      });
    }, e2.prototype.checkInputs = function(e3) {
      var t3 = this, a2 = Object.keys(e3).filter(function(e4) {
        return !t3.graph.nodes[e4];
      });
      if (a2.length > 0)
        throw new Error("The dict provided in model.execute(dict) has keys: [" + a2 + "] that are not part of graph");
    }, e2.prototype.checkOutputs = function(e3) {
      var t3 = this;
      e3.forEach(function(e4) {
        var a2 = parseNodeName(e4)[0];
        if (!t3.graph.nodes[a2])
          throw new Error("The output '" + e4 + "' is not found in the graph");
      });
    }, e2;
  }();
  var GraphModel = function() {
    function e2(e3, t3) {
      void 0 === t3 && (t3 = {}), this.modelUrl = e3, this.loadOptions = t3, this.version = "n/a", null == t3 && (this.loadOptions = {});
    }
    return Object.defineProperty(e2.prototype, "modelVersion", { get: function() {
      return this.version;
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "inputNodes", { get: function() {
      return this.executor.inputNodes;
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "outputNodes", { get: function() {
      return this.executor.outputNodes;
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "inputs", { get: function() {
      return this.executor.inputs;
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "outputs", { get: function() {
      return this.executor.outputs;
    }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "weights", { get: function() {
      return this.executor.weightMap;
    }, enumerable: true, configurable: true }), e2.prototype.findIOHandler = function() {
      var e3 = this.modelUrl;
      if (null != e3.load)
        this.handler = e3;
      else if (null != this.loadOptions.requestInit)
        this.handler = Sf.browserHTTPRequest(e3, this.loadOptions);
      else {
        var t3 = Sf.getLoadHandlers(e3, this.loadOptions.onProgress);
        if (0 === t3.length)
          t3.push(Sf.browserHTTPRequest(e3, this.loadOptions));
        else if (t3.length > 1)
          throw new Error("Found more than one (" + t3.length + ") load handlers for URL '" + [e3] + "'");
        this.handler = t3[0];
      }
    }, e2.prototype.load = function() {
      return __awaiter2(this, void 0, void 0, function() {
        var e3, t3, a2;
        return __generator2(this, function(r2) {
          switch (r2.label) {
            case 0:
              if (this.findIOHandler(), null == this.handler.load)
                throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
              return [4, this.handler.load()];
            case 1:
              return e3 = r2.sent(), t3 = e3.modelTopology, this.version = t3.versions.producer + "." + t3.versions.minConsumer, a2 = Sf.decodeWeights(e3.weightData, e3.weightSpecs), this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(t3)), this.executor.weightMap = this.convertTensorMapToTensorsMap(a2), [2, true];
          }
        });
      });
    }, e2.prototype.predict = function(e3, t3) {
      return this.execute(e3, this.outputNodes);
    }, e2.prototype.normalizeInputs = function(e3) {
      if (!(e3 instanceof dt || Array.isArray(e3)))
        return e3;
      if ((e3 = Array.isArray(e3) ? e3 : [e3]).length !== this.inputNodes.length)
        throw new Error("Input tensor count mismatch,the graph model has " + this.inputNodes.length + " placeholders, while there are " + e3.length + " input tensors.");
      return this.inputNodes.reduce(function(t3, a2, r2) {
        return t3[a2] = e3[r2], t3;
      }, {});
    }, e2.prototype.normalizeOutputs = function(e3) {
      return e3 = e3 || this.outputNodes, Array.isArray(e3) ? e3 : [e3];
    }, e2.prototype.execute = function(e3, t3) {
      e3 = this.normalizeInputs(e3), t3 = this.normalizeOutputs(t3);
      var a2 = this.executor.execute(e3, t3);
      return a2.length > 1 ? a2 : a2[0];
    }, e2.prototype.executeAsync = function(e3, t3) {
      return __awaiter2(this, void 0, void 0, function() {
        var a2;
        return __generator2(this, function(r2) {
          switch (r2.label) {
            case 0:
              return e3 = this.normalizeInputs(e3), t3 = this.normalizeOutputs(t3), [4, this.executor.executeAsync(e3, t3)];
            case 1:
              return [2, (a2 = r2.sent()).length > 1 ? a2 : a2[0]];
          }
        });
      });
    }, e2.prototype.convertTensorMapToTensorsMap = function(e3) {
      return Object.keys(e3).reduce(function(t3, a2) {
        return t3[a2] = [e3[a2]], t3;
      }, {});
    }, e2.prototype.dispose = function() {
      this.executor.dispose();
    }, e2;
  }();

  // node_modules/@tensorflow/tfjs/node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js
  var extendStatics2 = function(t3, e2) {
    return (extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
      t4.__proto__ = e3;
    } || function(t4, e3) {
      for (var r2 in e3)
        e3.hasOwnProperty(r2) && (t4[r2] = e3[r2]);
    })(t3, e2);
  };
  function __extends2(t3, e2) {
    function r2() {
      this.constructor = t3;
    }
    extendStatics2(t3, e2), t3.prototype = null === e2 ? Object.create(e2) : (r2.prototype = e2.prototype, new r2());
  }
  function __awaiter3(t3, e2, r2, n2) {
    return new (r2 || (r2 = Promise))(function(i2, o2) {
      function a2(t4) {
        try {
          u2(n2.next(t4));
        } catch (t5) {
          o2(t5);
        }
      }
      function s2(t4) {
        try {
          u2(n2.throw(t4));
        } catch (t5) {
          o2(t5);
        }
      }
      function u2(t4) {
        t4.done ? i2(t4.value) : new r2(function(e3) {
          e3(t4.value);
        }).then(a2, s2);
      }
      u2((n2 = n2.apply(t3, e2 || [])).next());
    });
  }
  function __generator3(t3, e2) {
    var r2, n2, i2, o2, a2 = { label: 0, sent: function() {
      if (1 & i2[0])
        throw i2[1];
      return i2[1];
    }, trys: [], ops: [] };
    return o2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
      return this;
    }), o2;
    function s2(o3) {
      return function(s3) {
        return function(o4) {
          if (r2)
            throw new TypeError("Generator is already executing.");
          for (; a2; )
            try {
              if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                return i2;
              switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                case 0:
                case 1:
                  i2 = o4;
                  break;
                case 4:
                  return a2.label++, { value: o4[1], done: false };
                case 5:
                  a2.label++, n2 = o4[1], o4 = [0];
                  continue;
                case 7:
                  o4 = a2.ops.pop(), a2.trys.pop();
                  continue;
                default:
                  if (!(i2 = (i2 = a2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                    a2 = 0;
                    continue;
                  }
                  if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                    a2.label = o4[1];
                    break;
                  }
                  if (6 === o4[0] && a2.label < i2[1]) {
                    a2.label = i2[1], i2 = o4;
                    break;
                  }
                  if (i2 && a2.label < i2[2]) {
                    a2.label = i2[2], a2.ops.push(o4);
                    break;
                  }
                  i2[2] && a2.ops.pop(), a2.trys.pop();
                  continue;
              }
              o4 = e2.call(t3, a2);
            } catch (t4) {
              o4 = [6, t4], n2 = 0;
            } finally {
              r2 = i2 = 0;
            }
          if (5 & o4[0])
            throw o4[1];
          return { value: o4[0] ? o4[1] : void 0, done: true };
        }([o3, s3]);
      };
    }
  }
  function createCommonjsModule(t3, e2) {
    return t3(e2 = { exports: {} }, e2.exports), e2.exports;
  }
  var alea = createCommonjsModule(function(t3) {
    !function(t4, e2, r2) {
      function n2(t5, e3) {
        return e3.c = t5.c, e3.s0 = t5.s0, e3.s1 = t5.s1, e3.s2 = t5.s2, e3;
      }
      function i2(t5, e3) {
        var r3 = new function(t6) {
          var e4, r4 = this, n3 = (e4 = 4022871197, function(t7) {
            t7 = t7.toString();
            for (var r5 = 0; r5 < t7.length; r5++) {
              var n4 = 0.02519603282416938 * (e4 += t7.charCodeAt(r5));
              n4 -= e4 = n4 >>> 0, e4 = (n4 *= e4) >>> 0, e4 += 4294967296 * (n4 -= e4);
            }
            return 23283064365386963e-26 * (e4 >>> 0);
          });
          r4.next = function() {
            var t7 = 2091639 * r4.s0 + 23283064365386963e-26 * r4.c;
            return r4.s0 = r4.s1, r4.s1 = r4.s2, r4.s2 = t7 - (r4.c = 0 | t7);
          }, r4.c = 1, r4.s0 = n3(" "), r4.s1 = n3(" "), r4.s2 = n3(" "), r4.s0 -= n3(t6), r4.s0 < 0 && (r4.s0 += 1), r4.s1 -= n3(t6), r4.s1 < 0 && (r4.s1 += 1), r4.s2 -= n3(t6), r4.s2 < 0 && (r4.s2 += 1), n3 = null;
        }(t5), i3 = e3 && e3.state, o2 = r3.next;
        return o2.int32 = function() {
          return 4294967296 * r3.next() | 0;
        }, o2.double = function() {
          return o2() + 11102230246251565e-32 * (2097152 * o2() | 0);
        }, o2.quick = o2, i3 && ("object" == typeof i3 && n2(i3, r3), o2.state = function() {
          return n2(r3, {});
        }), o2;
      }
      e2 && e2.exports ? e2.exports = i2 : r2 && r2.amd ? r2(function() {
        return i2;
      }) : this.alea = i2;
    }(0, t3, false);
  });
  var xor128 = createCommonjsModule(function(t3) {
    !function(t4, e2, r2) {
      function n2(t5, e3) {
        return e3.x = t5.x, e3.y = t5.y, e3.z = t5.z, e3.w = t5.w, e3;
      }
      function i2(t5, e3) {
        var r3 = new function(t6) {
          var e4 = this, r4 = "";
          e4.x = 0, e4.y = 0, e4.z = 0, e4.w = 0, e4.next = function() {
            var t7 = e4.x ^ e4.x << 11;
            return e4.x = e4.y, e4.y = e4.z, e4.z = e4.w, e4.w ^= e4.w >>> 19 ^ t7 ^ t7 >>> 8;
          }, t6 === (0 | t6) ? e4.x = t6 : r4 += t6;
          for (var n3 = 0; n3 < r4.length + 64; n3++)
            e4.x ^= 0 | r4.charCodeAt(n3), e4.next();
        }(t5), i3 = e3 && e3.state, o2 = function() {
          return (r3.next() >>> 0) / 4294967296;
        };
        return o2.double = function() {
          do {
            var t6 = ((r3.next() >>> 11) + (r3.next() >>> 0) / 4294967296) / (1 << 21);
          } while (0 === t6);
          return t6;
        }, o2.int32 = r3.next, o2.quick = o2, i3 && ("object" == typeof i3 && n2(i3, r3), o2.state = function() {
          return n2(r3, {});
        }), o2;
      }
      e2 && e2.exports ? e2.exports = i2 : r2 && r2.amd ? r2(function() {
        return i2;
      }) : this.xor128 = i2;
    }(0, t3, false);
  });
  var xorwow = createCommonjsModule(function(t3) {
    !function(t4, e2, r2) {
      function n2(t5, e3) {
        return e3.x = t5.x, e3.y = t5.y, e3.z = t5.z, e3.w = t5.w, e3.v = t5.v, e3.d = t5.d, e3;
      }
      function i2(t5, e3) {
        var r3 = new function(t6) {
          var e4 = this, r4 = "";
          e4.next = function() {
            var t7 = e4.x ^ e4.x >>> 2;
            return e4.x = e4.y, e4.y = e4.z, e4.z = e4.w, e4.w = e4.v, (e4.d = e4.d + 362437 | 0) + (e4.v = e4.v ^ e4.v << 4 ^ t7 ^ t7 << 1) | 0;
          }, e4.x = 0, e4.y = 0, e4.z = 0, e4.w = 0, e4.v = 0, t6 === (0 | t6) ? e4.x = t6 : r4 += t6;
          for (var n3 = 0; n3 < r4.length + 64; n3++)
            e4.x ^= 0 | r4.charCodeAt(n3), n3 == r4.length && (e4.d = e4.x << 10 ^ e4.x >>> 4), e4.next();
        }(t5), i3 = e3 && e3.state, o2 = function() {
          return (r3.next() >>> 0) / 4294967296;
        };
        return o2.double = function() {
          do {
            var t6 = ((r3.next() >>> 11) + (r3.next() >>> 0) / 4294967296) / (1 << 21);
          } while (0 === t6);
          return t6;
        }, o2.int32 = r3.next, o2.quick = o2, i3 && ("object" == typeof i3 && n2(i3, r3), o2.state = function() {
          return n2(r3, {});
        }), o2;
      }
      e2 && e2.exports ? e2.exports = i2 : r2 && r2.amd ? r2(function() {
        return i2;
      }) : this.xorwow = i2;
    }(0, t3, false);
  });
  var xorshift7 = createCommonjsModule(function(t3) {
    !function(t4, e2, r2) {
      function n2(t5, e3) {
        return e3.x = t5.x.slice(), e3.i = t5.i, e3;
      }
      function i2(t5, e3) {
        null == t5 && (t5 = +/* @__PURE__ */ new Date());
        var r3 = new function(t6) {
          var e4 = this;
          e4.next = function() {
            var t7, r4, n3 = e4.x, i4 = e4.i;
            return t7 = n3[i4], r4 = (t7 ^= t7 >>> 7) ^ t7 << 24, r4 ^= (t7 = n3[i4 + 1 & 7]) ^ t7 >>> 10, r4 ^= (t7 = n3[i4 + 3 & 7]) ^ t7 >>> 3, r4 ^= (t7 = n3[i4 + 4 & 7]) ^ t7 << 7, t7 = n3[i4 + 7 & 7], r4 ^= (t7 ^= t7 << 13) ^ t7 << 9, n3[i4] = r4, e4.i = i4 + 1 & 7, r4;
          }, function(t7, e5) {
            var r4, n3 = [];
            if (e5 === (0 | e5))
              n3[0] = e5;
            else
              for (e5 = "" + e5, r4 = 0; r4 < e5.length; ++r4)
                n3[7 & r4] = n3[7 & r4] << 15 ^ e5.charCodeAt(r4) + n3[r4 + 1 & 7] << 13;
            for (; n3.length < 8; )
              n3.push(0);
            for (r4 = 0; r4 < 8 && 0 === n3[r4]; ++r4)
              ;
            for (8 == r4 ? n3[7] = -1 : n3[r4], t7.x = n3, t7.i = 0, r4 = 256; r4 > 0; --r4)
              t7.next();
          }(e4, t6);
        }(t5), i3 = e3 && e3.state, o2 = function() {
          return (r3.next() >>> 0) / 4294967296;
        };
        return o2.double = function() {
          do {
            var t6 = ((r3.next() >>> 11) + (r3.next() >>> 0) / 4294967296) / (1 << 21);
          } while (0 === t6);
          return t6;
        }, o2.int32 = r3.next, o2.quick = o2, i3 && (i3.x && n2(i3, r3), o2.state = function() {
          return n2(r3, {});
        }), o2;
      }
      e2 && e2.exports ? e2.exports = i2 : r2 && r2.amd ? r2(function() {
        return i2;
      }) : this.xorshift7 = i2;
    }(0, t3, false);
  });
  var xor4096 = createCommonjsModule(function(t3) {
    !function(t4, e2, r2) {
      function n2(t5, e3) {
        return e3.i = t5.i, e3.w = t5.w, e3.X = t5.X.slice(), e3;
      }
      function i2(t5, e3) {
        null == t5 && (t5 = +/* @__PURE__ */ new Date());
        var r3 = new function(t6) {
          var e4 = this;
          e4.next = function() {
            var t7, r4, n3 = e4.w, i4 = e4.X, o3 = e4.i;
            return e4.w = n3 = n3 + 1640531527 | 0, r4 = i4[o3 + 34 & 127], t7 = i4[o3 = o3 + 1 & 127], r4 ^= r4 << 13, t7 ^= t7 << 17, r4 ^= r4 >>> 15, t7 ^= t7 >>> 12, r4 = i4[o3] = r4 ^ t7, e4.i = o3, r4 + (n3 ^ n3 >>> 16) | 0;
          }, function(t7, e5) {
            var r4, n3, i4, o3, a2, s2 = [], u2 = 128;
            for (e5 === (0 | e5) ? (n3 = e5, e5 = null) : (e5 += "\0", n3 = 0, u2 = Math.max(u2, e5.length)), i4 = 0, o3 = -32; o3 < u2; ++o3)
              e5 && (n3 ^= e5.charCodeAt((o3 + 32) % e5.length)), 0 === o3 && (a2 = n3), n3 ^= n3 << 10, n3 ^= n3 >>> 15, n3 ^= n3 << 4, n3 ^= n3 >>> 13, o3 >= 0 && (a2 = a2 + 1640531527 | 0, i4 = 0 == (r4 = s2[127 & o3] ^= n3 + a2) ? i4 + 1 : 0);
            for (i4 >= 128 && (s2[127 & (e5 && e5.length || 0)] = -1), i4 = 127, o3 = 512; o3 > 0; --o3)
              n3 = s2[i4 + 34 & 127], r4 = s2[i4 = i4 + 1 & 127], n3 ^= n3 << 13, r4 ^= r4 << 17, n3 ^= n3 >>> 15, r4 ^= r4 >>> 12, s2[i4] = n3 ^ r4;
            t7.w = a2, t7.X = s2, t7.i = i4;
          }(e4, t6);
        }(t5), i3 = e3 && e3.state, o2 = function() {
          return (r3.next() >>> 0) / 4294967296;
        };
        return o2.double = function() {
          do {
            var t6 = ((r3.next() >>> 11) + (r3.next() >>> 0) / 4294967296) / (1 << 21);
          } while (0 === t6);
          return t6;
        }, o2.int32 = r3.next, o2.quick = o2, i3 && (i3.X && n2(i3, r3), o2.state = function() {
          return n2(r3, {});
        }), o2;
      }
      e2 && e2.exports ? e2.exports = i2 : r2 && r2.amd ? r2(function() {
        return i2;
      }) : this.xor4096 = i2;
    }(0, t3, false);
  });
  var tychei = createCommonjsModule(function(t3) {
    !function(t4, e2, r2) {
      function n2(t5, e3) {
        return e3.a = t5.a, e3.b = t5.b, e3.c = t5.c, e3.d = t5.d, e3;
      }
      function i2(t5, e3) {
        var r3 = new function(t6) {
          var e4 = this, r4 = "";
          e4.next = function() {
            var t7 = e4.b, r5 = e4.c, n4 = e4.d, i4 = e4.a;
            return t7 = t7 << 25 ^ t7 >>> 7 ^ r5, r5 = r5 - n4 | 0, n4 = n4 << 24 ^ n4 >>> 8 ^ i4, i4 = i4 - t7 | 0, e4.b = t7 = t7 << 20 ^ t7 >>> 12 ^ r5, e4.c = r5 = r5 - n4 | 0, e4.d = n4 << 16 ^ r5 >>> 16 ^ i4, e4.a = i4 - t7 | 0;
          }, e4.a = 0, e4.b = 0, e4.c = -1640531527, e4.d = 1367130551, t6 === Math.floor(t6) ? (e4.a = t6 / 4294967296 | 0, e4.b = 0 | t6) : r4 += t6;
          for (var n3 = 0; n3 < r4.length + 20; n3++)
            e4.b ^= 0 | r4.charCodeAt(n3), e4.next();
        }(t5), i3 = e3 && e3.state, o2 = function() {
          return (r3.next() >>> 0) / 4294967296;
        };
        return o2.double = function() {
          do {
            var t6 = ((r3.next() >>> 11) + (r3.next() >>> 0) / 4294967296) / (1 << 21);
          } while (0 === t6);
          return t6;
        }, o2.int32 = r3.next, o2.quick = o2, i3 && ("object" == typeof i3 && n2(i3, r3), o2.state = function() {
          return n2(r3, {});
        }), o2;
      }
      e2 && e2.exports ? e2.exports = i2 : r2 && r2.amd ? r2(function() {
        return i2;
      }) : this.tychei = i2;
    }(0, t3, false);
  });
  var seedrandom = createCommonjsModule(function(t3) {
    !function(e2, r2) {
      var n2, i2 = this, o2 = 256, a2 = 6, s2 = "random", u2 = r2.pow(o2, a2), c2 = r2.pow(2, 52), l3 = 2 * c2, h = o2 - 1;
      function f2(t4, f3, v2) {
        var _3 = [], w2 = p2(function t5(e3, r3) {
          var n3, i3 = [], o3 = typeof e3;
          if (r3 && "object" == o3)
            for (n3 in e3)
              try {
                i3.push(t5(e3[n3], r3 - 1));
              } catch (t6) {
              }
          return i3.length ? i3 : "string" == o3 ? e3 : e3 + "\0";
        }((f3 = 1 == f3 ? { entropy: true } : f3 || {}).entropy ? [t4, m2(e2)] : null == t4 ? function() {
          try {
            var t5;
            return n2 && (t5 = n2.randomBytes) ? t5 = t5(o2) : (t5 = new Uint8Array(o2), (i2.crypto || i2.msCrypto).getRandomValues(t5)), m2(t5);
          } catch (t6) {
            var r3 = i2.navigator, a3 = r3 && r3.plugins;
            return [+/* @__PURE__ */ new Date(), i2, a3, i2.screen, m2(e2)];
          }
        }() : t4, 3), _3), y2 = new function(t5) {
          var e3, r3 = t5.length, n3 = this, i3 = 0, a3 = n3.i = n3.j = 0, s3 = n3.S = [];
          r3 || (t5 = [r3++]);
          for (; i3 < o2; )
            s3[i3] = i3++;
          for (i3 = 0; i3 < o2; i3++)
            s3[i3] = s3[a3 = h & a3 + t5[i3 % r3] + (e3 = s3[i3])], s3[a3] = e3;
          (n3.g = function(t6) {
            for (var e4, r4 = 0, i4 = n3.i, a4 = n3.j, s4 = n3.S; t6--; )
              e4 = s4[i4 = h & i4 + 1], r4 = r4 * o2 + s4[h & (s4[i4] = s4[a4 = h & a4 + e4]) + (s4[a4] = e4)];
            return n3.i = i4, n3.j = a4, r4;
          })(o2);
        }(_3), g2 = function() {
          for (var t5 = y2.g(a2), e3 = u2, r3 = 0; t5 < c2; )
            t5 = (t5 + r3) * o2, e3 *= o2, r3 = y2.g(1);
          for (; t5 >= l3; )
            t5 /= 2, e3 /= 2, r3 >>>= 1;
          return (t5 + r3) / e3;
        };
        return g2.int32 = function() {
          return 0 | y2.g(4);
        }, g2.quick = function() {
          return y2.g(4) / 4294967296;
        }, g2.double = g2, p2(m2(y2.S), e2), (f3.pass || v2 || function(t5, e3, n3, i3) {
          return i3 && (i3.S && d2(i3, y2), t5.state = function() {
            return d2(y2, {});
          }), n3 ? (r2[s2] = t5, e3) : t5;
        })(g2, w2, "global" in f3 ? f3.global : this == r2, f3.state);
      }
      function d2(t4, e3) {
        return e3.i = t4.i, e3.j = t4.j, e3.S = t4.S.slice(), e3;
      }
      function p2(t4, e3) {
        for (var r3, n3 = t4 + "", i3 = 0; i3 < n3.length; )
          e3[h & i3] = h & (r3 ^= 19 * e3[h & i3]) + n3.charCodeAt(i3++);
        return m2(e3);
      }
      function m2(t4) {
        return String.fromCharCode.apply(0, t4);
      }
      if (r2["seed" + s2] = f2, p2(r2.random(), e2), t3.exports) {
        t3.exports = f2;
        try {
          n2 = require_crypto();
        } catch (t4) {
        }
      } else
        0;
    }([], Math);
  });
  seedrandom.alea = alea, seedrandom.xor128 = xor128, seedrandom.xorwow = xorwow, seedrandom.xorshift7 = xorshift7, seedrandom.xor4096 = xor4096, seedrandom.tychei = tychei;
  var seedrandom$1 = seedrandom;
  var seedrandom_1 = seedrandom$1.alea;
  function deepMap(t3, e2) {
    return deepMapInternal(t3, e2);
  }
  function deepMapInternal(t3, e2, r2, n2) {
    if (void 0 === r2 && (r2 = /* @__PURE__ */ new Map()), void 0 === n2 && (n2 = /* @__PURE__ */ new Set()), null == t3)
      return null;
    if (n2.has(t3))
      throw new Error("Circular references are not supported.");
    if (r2.has(t3))
      return r2.get(t3);
    var i2 = e2(t3);
    if (i2.recurse && null !== i2.value)
      throw new Error("A deep map function may not return both a value and recurse=true.");
    if (i2.recurse) {
      if (isIterable(t3)) {
        var o2 = Array.isArray(t3) ? [] : {};
        for (var a2 in n2.add(t3), t3) {
          var s2 = deepMapInternal(t3[a2], e2, r2, n2);
          o2[a2] = s2;
        }
        return n2.delete(t3), o2;
      }
      throw new Error("Can't recurse into non-iterable type: " + t3);
    }
    return r2.set(t3, i2.value), i2.value;
  }
  function deepZip(t3, e2) {
    return void 0 === e2 && (e2 = zipToList), deepZipInternal(t3, e2);
  }
  function deepZipInternal(t3, e2, r2) {
    void 0 === r2 && (r2 = /* @__PURE__ */ new Set());
    var n2 = t3[0];
    if (r2.has(n2))
      throw new Error("Circular references are not supported.");
    var i2 = e2(t3);
    if (i2.recurse && null !== i2.value)
      throw new Error("A deep zip function may not return both a value and recurse=true.");
    if (i2.recurse) {
      if (isIterable(n2)) {
        var o2 = Array.isArray(n2) ? [] : {};
        r2.add(n2);
        var a2 = function(n3) {
          var i3 = deepZipInternal(t3.map(function(t4) {
            return t4[n3];
          }), e2, r2);
          o2[n3] = i3;
        };
        for (var s2 in n2)
          a2(s2);
        return r2.delete(n2), o2;
      }
      throw new Error("Can't recurse into non-iterable type: " + n2);
    }
    return i2.value;
  }
  function zipToList(t3) {
    return null === t3 ? null : isIterable(t3[0]) ? { value: null, recurse: true } : { value: t3, recurse: false };
  }
  function deepMapAndAwaitAll(t3, e2) {
    return __awaiter3(this, void 0, void 0, function() {
      var r2, n2, i2, o2, a2, s2;
      return __generator3(this, function(u2) {
        switch (u2.label) {
          case 0:
            r2 = /* @__PURE__ */ new Map(), deepMapInternal(t3, e2, r2), n2 = 0, i2 = Array.from(r2.keys()), u2.label = 1;
          case 1:
            return n2 < i2.length ? (o2 = i2[n2], (a2 = r2.get(o2)) instanceof Promise ? [4, a2] : [3, 3]) : [3, 4];
          case 2:
            s2 = u2.sent(), r2.set(o2, s2), u2.label = 3;
          case 3:
            return n2++, [3, 1];
          case 4:
            return [2, deepMapInternal(t3, e2, r2)];
        }
      });
    });
  }
  function isIterable(t3) {
    return null != t3 && !ArrayBuffer.isView(t3) && (Array.isArray(t3) || "object" == typeof t3 && !(t3 instanceof dt));
  }
  function canTensorify(t3) {
    return null == t3 || isPrimitive(t3) || Array.isArray(t3) || "object" == typeof t3 && t3 instanceof dt || tt.isTypedArray(t3);
  }
  function isPrimitive(t3) {
    return null === t3 || "object" != typeof t3 && "function" != typeof t3;
  }
  function deepClone(t3) {
    return deepMap(t3, cloneIfTensor);
  }
  function cloneIfTensor(t3) {
    return t3 instanceof dt ? { value: t3.clone(), recurse: false } : isIterable(t3) ? { value: null, recurse: true } : { value: t3, recurse: false };
  }
  var RingBuffer = function() {
    function t3(t4) {
      if (this.capacity = t4, this.begin = 0, this.end = 0, null == t4)
        throw new RangeError("Can't create a ring buffer of unknown capacity.");
      if (t4 < 1)
        throw new RangeError("Can't create ring buffer of capacity < 1.");
      this.data = new Array(t4), this.doubledCapacity = 2 * t4;
    }
    return t3.prototype.wrap = function(t4) {
      for (; t4 < 0; )
        t4 += this.doubledCapacity;
      return t4 % this.doubledCapacity;
    }, t3.prototype.get = function(t4) {
      if (t4 < 0)
        throw new RangeError("Can't get item at a negative index.");
      return this.data[t4 % this.capacity];
    }, t3.prototype.set = function(t4, e2) {
      if (t4 < 0)
        throw new RangeError("Can't set item at a negative index.");
      this.data[t4 % this.capacity] = e2;
    }, t3.prototype.length = function() {
      var t4 = this.end - this.begin;
      return t4 < 0 && (t4 = this.doubledCapacity + t4), t4;
    }, t3.prototype.isFull = function() {
      return this.length() === this.capacity;
    }, t3.prototype.isEmpty = function() {
      return 0 === this.length();
    }, t3.prototype.push = function(t4) {
      if (this.isFull())
        throw new RangeError("Ring buffer is full.");
      this.set(this.end, t4), this.end = this.wrap(this.end + 1);
    }, t3.prototype.pushAll = function(t4) {
      for (var e2 = 0, r2 = t4; e2 < r2.length; e2++) {
        var n2 = r2[e2];
        this.push(n2);
      }
    }, t3.prototype.pop = function() {
      if (this.isEmpty())
        throw new RangeError("Ring buffer is empty.");
      this.end = this.wrap(this.end - 1);
      var t4 = this.get(this.end);
      return this.set(this.end, void 0), t4;
    }, t3.prototype.unshift = function(t4) {
      if (this.isFull())
        throw new RangeError("Ring buffer is full.");
      this.begin = this.wrap(this.begin - 1), this.set(this.begin, t4);
    }, t3.prototype.shift = function() {
      if (this.isEmpty())
        throw new RangeError("Ring buffer is empty.");
      var t4 = this.get(this.begin);
      return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), t4;
    }, t3.prototype.shuffleExcise = function(t4) {
      if (this.isEmpty())
        throw new RangeError("Ring buffer is empty.");
      var e2 = this.wrap(this.begin + t4), r2 = this.get(e2);
      return this.set(e2, this.pop()), r2;
    }, t3;
  }();
  var GrowingRingBuffer = function(t3) {
    function e2() {
      return t3.call(this, e2.INITIAL_CAPACITY) || this;
    }
    return __extends2(e2, t3), e2.prototype.isFull = function() {
      return false;
    }, e2.prototype.push = function(e3) {
      t3.prototype.isFull.call(this) && this.expand(), t3.prototype.push.call(this, e3);
    }, e2.prototype.unshift = function(e3) {
      t3.prototype.isFull.call(this) && this.expand(), t3.prototype.unshift.call(this, e3);
    }, e2.prototype.expand = function() {
      for (var t4 = 2 * this.capacity, e3 = new Array(t4), r2 = this.length(), n2 = 0; n2 < r2; n2++)
        e3[n2] = this.get(this.wrap(this.begin + n2));
      this.data = e3, this.capacity = t4, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = r2;
    }, e2.INITIAL_CAPACITY = 32, e2;
  }(RingBuffer);
  function iteratorFromItems(t3) {
    return new ArrayIterator(t3);
  }
  function iteratorFromFunction(t3) {
    return new FunctionCallIterator(t3);
  }
  function iteratorFromConcatenated(t3, e2) {
    return new ChainedIterator(t3, e2);
  }
  var ZipMismatchMode;
  var LazyIterator = function() {
    function t3() {
    }
    return t3.prototype.toArray = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e2;
        return __generator3(this, function(r2) {
          switch (r2.label) {
            case 0:
              return t4 = [], [4, this.next()];
            case 1:
              e2 = r2.sent(), r2.label = 2;
            case 2:
              return e2.done ? [3, 4] : (t4.push(e2.value), [4, this.next()]);
            case 3:
              return e2 = r2.sent(), [3, 2];
            case 4:
              return [2, t4];
          }
        });
      });
    }, t3.prototype.toArrayForTest = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e2, r2;
        return __generator3(this, function(n2) {
          switch (n2.label) {
            case 0:
              return t4 = this.prefetch(100), e2 = [], [4, t4.next()];
            case 1:
              r2 = n2.sent(), n2.label = 2;
            case 2:
              return r2.done ? [3, 4] : (e2.push(r2.value), [4, t4.next()]);
            case 3:
              return r2 = n2.sent(), [3, 2];
            case 4:
              return [2, e2];
          }
        });
      });
    }, t3.prototype.resolveFully = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4;
        return __generator3(this, function(e2) {
          switch (e2.label) {
            case 0:
              return [4, this.next()];
            case 1:
              t4 = e2.sent(), e2.label = 2;
            case 2:
              return t4.done ? [3, 4] : [4, this.next()];
            case 3:
              return t4 = e2.sent(), [3, 2];
            case 4:
              return [2];
          }
        });
      });
    }, t3.prototype.resolveWhile = function(t4) {
      return __awaiter3(this, void 0, void 0, function() {
        var e2, r2;
        return __generator3(this, function(n2) {
          switch (n2.label) {
            case 0:
              return [4, this.next()];
            case 1:
              e2 = n2.sent(), r2 = t4(e2.value), n2.label = 2;
            case 2:
              return e2.done || !r2 ? [3, 4] : [4, this.next()];
            case 3:
              return e2 = n2.sent(), r2 = t4(e2.value), [3, 2];
            case 4:
              return [2];
          }
        });
      });
    }, t3.prototype.handleErrors = function(t4) {
      return new ErrorHandlingLazyIterator(this, t4);
    }, t3.prototype.filter = function(t4) {
      return new FilterIterator(this, t4);
    }, t3.prototype.map = function(t4) {
      return new MapIterator(this, t4);
    }, t3.prototype.mapAsync = function(t4) {
      return new AsyncMapIterator(this, t4);
    }, t3.prototype.serialMapAsync = function(t4) {
      return new AsyncMapIterator(this, t4).serial();
    }, t3.prototype.flatmap = function(t4) {
      return new FlatmapIterator(this, t4);
    }, t3.prototype.forEachAsync = function(t4) {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(e2) {
          return [2, this.map(t4).resolveFully()];
        });
      });
    }, t3.prototype.serialForEach = function(t4) {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(e2) {
          return [2, this.serialMapAsync(t4).resolveWhile(function(t5) {
            return true === t5;
          })];
        });
      });
    }, t3.prototype.rowMajorBatch = function(t4, e2) {
      return void 0 === e2 && (e2 = true), new RowMajorBatchIterator(this, t4, e2);
    }, t3.prototype.columnMajorBatch = function(t4, e2, r2) {
      return void 0 === e2 && (e2 = true), void 0 === r2 && (r2 = zipToList), this.rowMajorBatch(t4, e2).map(function(t5) {
        return deepZip(t5, r2);
      });
    }, t3.prototype.concatenate = function(t4, e2) {
      return new ChainedIterator(iteratorFromItems([this, t4]), e2);
    }, t3.prototype.take = function(t4) {
      return t4 < 0 || null == t4 ? this : new TakeIterator(this, t4);
    }, t3.prototype.skip = function(t4) {
      return t4 < 0 || null == t4 ? this : new SkipIterator(this, t4);
    }, t3.prototype.prefetch = function(t4) {
      return new PrefetchIterator(this, t4);
    }, t3.prototype.shuffle = function(t4, e2) {
      return new ShuffleIterator(this, t4, e2);
    }, t3.prototype.serial = function() {
      return new SerialIterator(this);
    }, t3;
  }();
  var ArrayIterator = function(t3) {
    function e2(e3) {
      var r2 = t3.call(this) || this;
      return r2.items = e3, r2.trav = 0, r2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return "Array of " + this.items.length + " items";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4;
        return __generator3(this, function(e3) {
          return this.trav >= this.items.length ? [2, { value: null, done: true }] : (t4 = this.items[this.trav], this.trav++, [2, { value: deepClone(t4), done: false }]);
        });
      });
    }, e2;
  }(LazyIterator);
  var FunctionCallIterator = function(t3) {
    function e2(e3) {
      var r2 = t3.call(this) || this;
      return r2.nextFn = e3, r2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return "Function call";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          try {
            return [2, this.nextFn()];
          } catch (t5) {
            throw t5.message = "Error thrown while iterating through a dataset: " + t5.message, t5;
          }
          return [2];
        });
      });
    }, e2;
  }(LazyIterator);
  var SerialIterator = function(t3) {
    function e2(e3) {
      var r2 = t3.call(this) || this;
      return r2.upstream = e3, r2.lastRead = Promise.resolve({ value: null, done: false }), r2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> Serial";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4 = this;
        return __generator3(this, function(e3) {
          return this.lastRead = this.lastRead.then(function() {
            return t4.serialNext();
          }), [2, this.lastRead];
        });
      });
    }, e2.prototype.serialNext = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          return [2, this.upstream.next()];
        });
      });
    }, e2;
  }(LazyIterator);
  var SkipIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.upstream = e3, n2.maxCount = r2, n2.count = 0, n2.lastRead = Promise.resolve({ value: null, done: false }), n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> Skip";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4 = this;
        return __generator3(this, function(e3) {
          return this.lastRead = this.lastRead.then(function() {
            return t4.serialNext();
          }), [2, this.lastRead];
        });
      });
    }, e2.prototype.serialNext = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4;
        return __generator3(this, function(e3) {
          switch (e3.label) {
            case 0:
              return this.count++ < this.maxCount ? [4, this.upstream.next()] : [3, 2];
            case 1:
              return (t4 = e3.sent()).done ? [2, t4] : (Xe(t4.value), [3, 0]);
            case 2:
              return [2, this.upstream.next()];
          }
        });
      });
    }, e2;
  }(LazyIterator);
  var TakeIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.upstream = e3, n2.maxCount = r2, n2.count = 0, n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> Take";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          return this.count++ >= this.maxCount ? [2, { value: null, done: true }] : [2, this.upstream.next()];
        });
      });
    }, e2;
  }(LazyIterator);
  var RowMajorBatchIterator = function(t3) {
    function e2(e3, r2, n2) {
      void 0 === n2 && (n2 = true);
      var i2 = t3.call(this) || this;
      return i2.upstream = e3, i2.batchSize = r2, i2.enableSmallLastBatch = n2, i2.lastRead = Promise.resolve({ value: null, done: false }), i2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> RowMajorBatch";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4 = this;
        return __generator3(this, function(e3) {
          return this.lastRead = this.lastRead.then(function() {
            return t4.serialNext();
          }), [2, this.lastRead];
        });
      });
    }, e2.prototype.serialNext = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3;
        return __generator3(this, function(r2) {
          switch (r2.label) {
            case 0:
              t4 = [], r2.label = 1;
            case 1:
              return t4.length < this.batchSize ? [4, this.upstream.next()] : [3, 3];
            case 2:
              return (e3 = r2.sent()).done ? this.enableSmallLastBatch && t4.length > 0 ? [2, { value: t4, done: false }] : [2, { value: null, done: true }] : (t4.push(e3.value), [3, 1]);
            case 3:
              return [2, { value: t4, done: false }];
          }
        });
      });
    }, e2;
  }(LazyIterator);
  var FilterIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.upstream = e3, n2.predicate = r2, n2.lastRead = Promise.resolve({ value: null, done: false }), n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> Filter";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4 = this;
        return __generator3(this, function(e3) {
          return this.lastRead = this.lastRead.then(function() {
            return t4.serialNext();
          }), [2, this.lastRead];
        });
      });
    }, e2.prototype.serialNext = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4;
        return __generator3(this, function(e3) {
          switch (e3.label) {
            case 0:
              return [4, this.upstream.next()];
            case 1:
              return (t4 = e3.sent()).done || this.predicate(t4.value) ? [2, t4] : (Xe(t4.value), [3, 0]);
            case 2:
              return [2];
          }
        });
      });
    }, e2;
  }(LazyIterator);
  var MapIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.upstream = e3, n2.transform = r2, n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> Map";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2, n2, i2, o2, a2;
        return __generator3(this, function(s2) {
          switch (s2.label) {
            case 0:
              return [4, this.upstream.next()];
            case 1:
              if ((t4 = s2.sent()).done)
                return [2, { value: null, done: true }];
              for (e3 = At.getTensorsInContainer(t4.value), r2 = this.transform(t4.value), n2 = At.getTensorsInContainer(r2), i2 = 0, o2 = e3; i2 < o2.length; i2++)
                a2 = o2[i2], At.isTensorInList(a2, n2) || a2.dispose();
              return [2, { value: r2, done: false }];
          }
        });
      });
    }, e2;
  }(LazyIterator);
  var ErrorHandlingLazyIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.upstream = e3, n2.handler = r2, n2.count = 0, n2.lastRead = Promise.resolve({ value: null, done: false }), n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> handleErrors";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4 = this;
        return __generator3(this, function(e3) {
          return this.lastRead = this.lastRead.then(function() {
            return t4.serialNext();
          }), [2, this.lastRead];
        });
      });
    }, e2.prototype.serialNext = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4;
        return __generator3(this, function(e3) {
          switch (e3.label) {
            case 0:
              e3.label = 1;
            case 1:
              return e3.trys.push([1, 3, , 4]), [4, this.upstream.next()];
            case 2:
              return [2, e3.sent()];
            case 3:
              return t4 = e3.sent(), this.handler(t4) ? [3, 4] : [2, { value: null, done: true }];
            case 4:
              return [3, 0];
            case 5:
              return [2];
          }
        });
      });
    }, e2;
  }(LazyIterator);
  var AsyncMapIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.upstream = e3, n2.transform = r2, n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> AsyncMap";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2, n2, i2, o2, a2;
        return __generator3(this, function(s2) {
          switch (s2.label) {
            case 0:
              return [4, this.upstream.next()];
            case 1:
              return (t4 = s2.sent()).done ? [2, { value: null, done: true }] : (e3 = At.getTensorsInContainer(t4.value), [4, this.transform(t4.value)]);
            case 2:
              for (r2 = s2.sent(), n2 = At.getTensorsInContainer(r2), i2 = 0, o2 = e3; i2 < o2.length; i2++)
                a2 = o2[i2], At.isTensorInList(a2, n2) || a2.dispose();
              return [2, { value: r2, done: false }];
          }
        });
      });
    }, e2;
  }(LazyIterator);
  var OneToManyIterator = function(t3) {
    function e2() {
      var e3 = t3.call(this) || this;
      return e3.outputQueue = new GrowingRingBuffer(), e3.lastRead = Promise.resolve({ value: null, done: false }), e3;
    }
    return __extends2(e2, t3), e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4 = this;
        return __generator3(this, function(e3) {
          return this.lastRead = this.lastRead.then(function() {
            return t4.serialNext();
          }), [2, this.lastRead];
        });
      });
    }, e2.prototype.serialNext = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          switch (t4.label) {
            case 0:
              return 0 !== this.outputQueue.length() ? [3, 2] : [4, this.pump()];
            case 1:
              return t4.sent() ? [3, 0] : [2, { value: null, done: true }];
            case 2:
              return [2, { value: this.outputQueue.shift(), done: false }];
          }
        });
      });
    }, e2;
  }(LazyIterator);
  var FlatmapIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.upstream = e3, n2.transform = r2, n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> Flatmap";
    }, e2.prototype.pump = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2, n2, i2, o2, a2;
        return __generator3(this, function(s2) {
          switch (s2.label) {
            case 0:
              return [4, this.upstream.next()];
            case 1:
              if ((t4 = s2.sent()).done)
                return [2, false];
              for (e3 = At.getTensorsInContainer(t4.value), r2 = this.transform(t4.value), n2 = At.getTensorsInContainer(r2), this.outputQueue.pushAll(r2), i2 = 0, o2 = e3; i2 < o2.length; i2++)
                a2 = o2[i2], At.isTensorInList(a2, n2) || a2.dispose();
              return [2, true];
          }
        });
      });
    }, e2;
  }(OneToManyIterator);
  var ChainedIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.baseErrorHandler = r2, n2.lastRead = null, n2.iterator = null, n2.moreIterators = e3, n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return "TODO: fill in upstream of chained summaries -> Chained";
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          return this.lastRead = this.readFromChain(this.lastRead), [2, this.lastRead];
        });
      });
    }, e2.prototype.readFromChain = function(t4) {
      return __awaiter3(this, void 0, void 0, function() {
        var e3, r2;
        return __generator3(this, function(n2) {
          switch (n2.label) {
            case 0:
              return [4, t4];
            case 1:
              return n2.sent(), null != this.iterator ? [3, 3] : [4, this.moreIterators.next()];
            case 2:
              if ((e3 = n2.sent()).done)
                return [2, { value: null, done: true }];
              this.iterator = e3.value, null != this.baseErrorHandler && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler)), n2.label = 3;
            case 3:
              return [4, this.iterator.next()];
            case 4:
              return (r2 = n2.sent()).done ? (this.iterator = null, [2, this.readFromChain(t4)]) : [2, r2];
          }
        });
      });
    }, e2;
  }(LazyIterator);
  !function(t3) {
    t3[t3.FAIL = 0] = "FAIL", t3[t3.SHORTEST = 1] = "SHORTEST", t3[t3.LONGEST = 2] = "LONGEST";
  }(ZipMismatchMode || (ZipMismatchMode = {}));
  var ZipIterator = function(t3) {
    function e2(e3, r2) {
      void 0 === r2 && (r2 = ZipMismatchMode.FAIL);
      var n2 = t3.call(this) || this;
      return n2.iterators = e3, n2.mismatchMode = r2, n2.count = 0, n2.currentPromise = null, n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return "{TODO: fill in upstream of zip summaries} -> Zip";
    }, e2.prototype.nextState = function(t4) {
      return __awaiter3(this, void 0, void 0, function() {
        function e3(t5) {
          return t5 instanceof LazyIterator ? { value: t5.next().then(function(t6) {
            return r2++, t6.done && n2++, t6.value;
          }), recurse: false } : { value: null, recurse: true };
        }
        var r2, n2, i2;
        return __generator3(this, function(o2) {
          switch (o2.label) {
            case 0:
              return [4, t4];
            case 1:
              return o2.sent(), r2 = 0, n2 = 0, [4, deepMapAndAwaitAll(this.iterators, e3)];
            case 2:
              if (i2 = o2.sent(), r2 === n2)
                return [2, { value: null, done: true }];
              if (n2 > 0)
                switch (this.mismatchMode) {
                  case ZipMismatchMode.FAIL:
                    throw new Error("Zipped streams should have the same length. Mismatched at element " + this.count + ".");
                  case ZipMismatchMode.SHORTEST:
                    return [2, { value: null, done: true }];
                  case ZipMismatchMode.LONGEST:
                }
              return this.count++, [2, { value: i2, done: false }];
          }
        });
      });
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          return this.currentPromise = this.nextState(this.currentPromise), [2, this.currentPromise];
        });
      });
    }, e2;
  }(LazyIterator);
  var PrefetchIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.upstream = e3, n2.bufferSize = r2, n2.buffer = new RingBuffer(r2), n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> Prefetch";
    }, e2.prototype.refill = function() {
      for (; !this.buffer.isFull(); ) {
        var t4 = this.upstream.next();
        this.buffer.push(t4);
      }
    }, e2.prototype.next = function() {
      return this.refill(), this.buffer.shift();
    }, e2;
  }(LazyIterator);
  var ShuffleIterator = function(t3) {
    function e2(e3, r2, n2) {
      var i2 = t3.call(this, e3, r2) || this;
      return i2.upstream = e3, i2.windowSize = r2, i2.upstreamExhausted = false, i2.random = seedrandom_1(n2 || tt.now().toString()), i2.lastRead = Promise.resolve({ value: null, done: false }), i2;
    }
    return __extends2(e2, t3), e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4 = this;
        return __generator3(this, function(e3) {
          return this.lastRead = this.lastRead.then(function() {
            return t4.serialNext();
          }), [2, this.lastRead];
        });
      });
    }, e2.prototype.randomInt = function(t4) {
      return Math.floor(this.random() * t4);
    }, e2.prototype.chooseIndex = function() {
      return this.randomInt(this.buffer.length());
    }, e2.prototype.serialNext = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3;
        return __generator3(this, function(r2) {
          switch (r2.label) {
            case 0:
              this.upstreamExhausted || this.refill(), r2.label = 1;
            case 1:
              return this.buffer.isEmpty() ? [3, 3] : (t4 = this.chooseIndex(), [4, this.buffer.shuffleExcise(t4)]);
            case 2:
              return (e3 = r2.sent()).done ? (this.upstreamExhausted = true, [3, 1]) : (this.refill(), [2, e3]);
            case 3:
              return [2, { value: null, done: true }];
          }
        });
      });
    }, e2;
  }(PrefetchIterator);
  var Dataset = function() {
    function t3() {
      this.size = null;
    }
    return t3.prototype.batch = function(t4, e2) {
      var r2 = this;
      void 0 === e2 && (e2 = true);
      var n2 = this;
      return tt.assert(t4 > 0, function() {
        return "batchSize needs to be positive, but it is\n      " + t4;
      }), datasetFromIteratorFn(function() {
        return __awaiter3(r2, void 0, void 0, function() {
          return __generator3(this, function(r3) {
            switch (r3.label) {
              case 0:
                return [4, n2.iterator()];
              case 1:
                return [2, r3.sent().columnMajorBatch(t4, e2, deepBatchConcat)];
            }
          });
        });
      }, this.size === 1 / 0 || null == this.size ? this.size : e2 ? Math.ceil(this.size / t4) : Math.floor(this.size / t4));
    }, t3.prototype.concatenate = function(t4) {
      var e2 = this, r2 = this;
      return datasetFromIteratorFn(function() {
        return __awaiter3(e2, void 0, void 0, function() {
          var e3, n2;
          return __generator3(this, function(i2) {
            switch (i2.label) {
              case 0:
                return [4, r2.iterator()];
              case 1:
                return n2 = (e3 = i2.sent()).concatenate, [4, t4.iterator()];
              case 2:
                return [2, n2.apply(e3, [i2.sent()])];
            }
          });
        });
      }, this.size === 1 / 0 || t4.size === 1 / 0 ? 1 / 0 : null != this.size && null != t4.size ? this.size + t4.size : null);
    }, t3.prototype.filter = function(t4) {
      var e2 = this, r2 = this;
      return datasetFromIteratorFn(function() {
        return __awaiter3(e2, void 0, void 0, function() {
          return __generator3(this, function(e3) {
            switch (e3.label) {
              case 0:
                return [4, r2.iterator()];
              case 1:
                return [2, e3.sent().filter(function(e4) {
                  return je(function() {
                    return t4(e4);
                  });
                })];
            }
          });
        });
      }, this.size === 1 / 0 ? 1 / 0 : null);
    }, t3.prototype.forEachAsync = function(t4) {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(e2) {
          switch (e2.label) {
            case 0:
              return [4, this.iterator()];
            case 1:
              return [2, e2.sent().forEachAsync(t4)];
          }
        });
      });
    }, t3.prototype.forEach = function(t4) {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(e2) {
          return ze("dataset.forEach() is deprecated and will be removed. Please use dataset.forEachAsync() instead"), [2, this.forEachAsync(t4)];
        });
      });
    }, t3.prototype.map = function(t4) {
      var e2 = this, r2 = this;
      return datasetFromIteratorFn(function() {
        return __awaiter3(e2, void 0, void 0, function() {
          return __generator3(this, function(e3) {
            switch (e3.label) {
              case 0:
                return [4, r2.iterator()];
              case 1:
                return [2, e3.sent().map(function(e4) {
                  return je(function() {
                    return t4(e4);
                  });
                })];
            }
          });
        });
      }, this.size);
    }, t3.prototype.mapAsync = function(t4) {
      var e2 = this, r2 = this;
      return datasetFromIteratorFn(function() {
        return __awaiter3(e2, void 0, void 0, function() {
          return __generator3(this, function(e3) {
            switch (e3.label) {
              case 0:
                return [4, r2.iterator()];
              case 1:
                return [2, e3.sent().mapAsync(t4)];
            }
          });
        });
      }, this.size);
    }, t3.prototype.prefetch = function(t4) {
      var e2 = this;
      if (null == t4)
        throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
      var r2 = this;
      return datasetFromIteratorFn(function() {
        return __awaiter3(e2, void 0, void 0, function() {
          return __generator3(this, function(e3) {
            switch (e3.label) {
              case 0:
                return [4, r2.iterator()];
              case 1:
                return [2, e3.sent().prefetch(t4)];
            }
          });
        });
      }, this.size);
    }, t3.prototype.repeat = function(t4) {
      var e2 = this, r2 = this;
      return datasetFromIteratorFn(function() {
        return __awaiter3(e2, void 0, void 0, function() {
          var e3 = this;
          return __generator3(this, function(n2) {
            return [2, iteratorFromConcatenated(iteratorFromFunction(function() {
              return __awaiter3(e3, void 0, void 0, function() {
                var t5;
                return __generator3(this, function(e4) {
                  switch (e4.label) {
                    case 0:
                      return t5 = {}, [4, r2.iterator()];
                    case 1:
                      return [2, (t5.value = e4.sent(), t5.done = false, t5)];
                  }
                });
              });
            }).take(t4))];
          });
        });
      }, null != this.size && t4 > 0 ? this.size * t4 : 0 === t4 ? 0 : null != this.size && (void 0 === t4 || t4 < 0) ? 1 / 0 : null);
    }, t3.prototype.skip = function(t4) {
      var e2 = this, r2 = this;
      return datasetFromIteratorFn(function() {
        return __awaiter3(e2, void 0, void 0, function() {
          return __generator3(this, function(e3) {
            switch (e3.label) {
              case 0:
                return [4, r2.iterator()];
              case 1:
                return [2, e3.sent().skip(t4)];
            }
          });
        });
      }, null != this.size && t4 >= 0 && this.size >= t4 ? this.size - t4 : null != this.size && (this.size < t4 || void 0 === t4 || t4 < 0) ? 0 : null);
    }, t3.prototype.shuffle = function(t4, e2, r2) {
      var n2 = this;
      if (void 0 === r2 && (r2 = true), null == t4 || t4 < 0)
        throw null == this.size ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size (" + this.size + " elements)");
      var i2 = this, o2 = seedrandom_1(e2 || tt.now().toString());
      return datasetFromIteratorFn(function() {
        return __awaiter3(n2, void 0, void 0, function() {
          var e3;
          return __generator3(this, function(n3) {
            switch (n3.label) {
              case 0:
                return e3 = o2.int32(), r2 && (e3 += o2.int32()), [4, i2.iterator()];
              case 1:
                return [2, n3.sent().shuffle(t4, e3.toString())];
            }
          });
        });
      }, this.size);
    }, t3.prototype.take = function(t4) {
      var e2 = this, r2 = this;
      return datasetFromIteratorFn(function() {
        return __awaiter3(e2, void 0, void 0, function() {
          return __generator3(this, function(e3) {
            switch (e3.label) {
              case 0:
                return [4, r2.iterator()];
              case 1:
                return [2, e3.sent().take(t4)];
            }
          });
        });
      }, null != this.size && this.size > t4 ? t4 : null != this.size && this.size <= t4 ? this.size : null);
    }, t3.prototype.toArray = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          switch (t4.label) {
            case 0:
              if (this.size === 1 / 0)
                throw new Error("Can not convert infinite data stream to array.");
              return [4, this.iterator()];
            case 1:
              return [2, t4.sent().toArray()];
          }
        });
      });
    }, t3.prototype.toArrayForTest = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          switch (t4.label) {
            case 0:
              if (this.size === 1 / 0)
                throw new Error("Can not convert infinite data stream to array.");
              return [4, this.iterator()];
            case 1:
              return [2, t4.sent().toArrayForTest()];
          }
        });
      });
    }, t3.MAX_BUFFER_SIZE = 1e4, t3;
  }();
  function datasetFromIteratorFn(t3, e2) {
    return void 0 === e2 && (e2 = null), new (function(r2) {
      function n2() {
        var t4 = null !== r2 && r2.apply(this, arguments) || this;
        return t4.size = e2, t4;
      }
      return __extends2(n2, r2), n2.prototype.iterator = function() {
        return __awaiter3(this, void 0, void 0, function() {
          return __generator3(this, function(e3) {
            return [2, t3()];
          });
        });
      }, n2;
    }(Dataset))();
  }
  function deepBatchConcat(t3) {
    return null === t3 ? null : canTensorify(t3[0]) ? { value: batchConcat(t3), recurse: false } : { value: null, recurse: true };
  }
  function batchConcat(t3) {
    if (0 === t3.length)
      throw new Error("Can't make a batch of zero elements.");
    return t3[0] instanceof dt ? Tr(t3) : kn(t3);
  }
  var TextLineDataset = function(t3) {
    function e2(e3) {
      var r2 = t3.call(this) || this;
      return r2.input = e3, r2;
    }
    return __extends2(e2, t3), e2.prototype.iterator = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3;
        return __generator3(this, function(r2) {
          switch (r2.label) {
            case 0:
              return [4, this.input.iterator()];
            case 1:
              return t4 = r2.sent(), e3 = t4.decodeUTF8(), [2, e3.split("\n").map(function(t5) {
                return t5.endsWith("\r") && (t5 = t5.slice(0, -1)), t5;
              })];
          }
        });
      });
    }, e2;
  }(Dataset);
  var CODE_QUOTE = '"';
  var STATE_OUT = Symbol("out");
  var STATE_FIELD = Symbol("field");
  var STATE_QUOTE = Symbol("quote");
  var STATE_QUOTE_AFTER_QUOTE = Symbol("quoteafterquote");
  var STATE_WITHIN_QUOTE_IN_QUOTE = Symbol("quoteinquote");
  var CSVDataset = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.input = e3, n2.hasHeader = true, n2.fullColumnNames = null, n2.columnNamesValidated = false, n2.columnConfigs = null, n2.configuredColumnsOnly = false, n2.delimiter = ",", n2.delimWhitespace = false, n2.base = new TextLineDataset(e3), r2 || (r2 = {}), n2.hasHeader = false !== r2.hasHeader, n2.fullColumnNames = r2.columnNames, n2.columnConfigs = r2.columnConfigs, n2.configuredColumnsOnly = r2.configuredColumnsOnly, r2.delimWhitespace ? (tt.assert(null == r2.delimiter, function() {
        return "Delimiter should not be provided when delimWhitespace is true.";
      }), n2.delimWhitespace = true, n2.delimiter = " ") : n2.delimiter = r2.delimiter ? r2.delimiter : ",", n2;
    }
    return __extends2(e2, t3), e2.prototype.columnNames = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          switch (t4.label) {
            case 0:
              return this.columnNamesValidated ? [3, 2] : [4, this.setColumnNames()];
            case 1:
              t4.sent(), t4.label = 2;
            case 2:
              return [2, this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames];
          }
        });
      });
    }, e2.prototype.setColumnNames = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2, n2, i2, o2, a2 = this;
        return __generator3(this, function(s2) {
          switch (s2.label) {
            case 0:
              return [4, this.maybeReadHeaderLine()];
            case 1:
              if (t4 = s2.sent(), !this.fullColumnNames && !t4)
                throw new Error("Column names must be provided if there is no header line.");
              if (this.fullColumnNames && t4 && tt.assert(t4.length === this.fullColumnNames.length, function() {
                return "The length of provided columnNames (" + a2.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + t4.length.toString() + ").";
              }), this.fullColumnNames || (this.fullColumnNames = t4), e3 = this.fullColumnNames.reduce(function(t5, e4) {
                return t5[e4] = t5[e4] + 1 || 1, t5;
              }, {}), r2 = Object.keys(e3).filter(function(t5) {
                return e3[t5] > 1;
              }), tt.assert(0 === r2.length, function() {
                return "Duplicate column names found: " + r2.toString();
              }), this.columnConfigs) {
                for (n2 = 0, i2 = Object.keys(this.columnConfigs); n2 < i2.length; n2++)
                  if (o2 = i2[n2], -1 === this.fullColumnNames.indexOf(o2))
                    throw new Error('The key "' + o2 + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
              }
              return this.columnNamesValidated = true, [2];
          }
        });
      });
    }, e2.prototype.maybeReadHeaderLine = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3;
        return __generator3(this, function(r2) {
          switch (r2.label) {
            case 0:
              return this.hasHeader ? [4, this.base.iterator()] : [3, 3];
            case 1:
              return [4, r2.sent().next()];
            case 2:
              if ((t4 = r2.sent()).done)
                throw new Error("No data was found for CSV parsing.");
              return e3 = t4.value, [2, this.parseRow(e3, false)];
            case 3:
              return [2, null];
          }
        });
      });
    }, e2.prototype.iterator = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3 = this;
        return __generator3(this, function(r2) {
          switch (r2.label) {
            case 0:
              return this.columnNamesValidated ? [3, 2] : [4, this.setColumnNames()];
            case 1:
              r2.sent(), r2.label = 2;
            case 2:
              return [4, this.base.iterator()];
            case 3:
              return t4 = r2.sent(), this.hasHeader && (t4 = t4.skip(1)), [2, t4.map(function(t5) {
                return e3.makeDataElement(t5);
              })];
          }
        });
      });
    }, e2.prototype.makeDataElement = function(t4) {
      for (var e3 = this.parseRow(t4), r2 = {}, n2 = {}, i2 = 0; i2 < this.fullColumnNames.length; i2++) {
        var o2 = this.fullColumnNames[i2], a2 = this.columnConfigs ? this.columnConfigs[o2] : null;
        if (!this.configuredColumnsOnly || a2) {
          var s2 = e3[i2], u2 = null;
          if ("" === s2)
            if (a2 && void 0 !== a2.default)
              u2 = a2.default;
            else {
              if (a2 && (a2.required || a2.isLabel))
                throw new Error("Required column " + o2 + " is empty in this line: " + t4);
              u2 = void 0;
            }
          else {
            var c2 = Number(s2);
            if (isNaN(c2))
              u2 = a2 && "bool" === a2.dtype ? this.getBoolean(s2) : s2;
            else if (a2 && a2.dtype)
              switch (a2.dtype) {
                case "float32":
                  u2 = c2;
                  break;
                case "int32":
                  u2 = Math.floor(c2);
                  break;
                case "bool":
                  u2 = this.getBoolean(s2);
                  break;
                default:
                  u2 = c2;
              }
            else
              u2 = c2;
          }
          a2 && a2.isLabel ? n2[o2] = u2 : r2[o2] = u2;
        }
      }
      return 0 === Object.keys(n2).length ? r2 : { xs: r2, ys: n2 };
    }, e2.prototype.getBoolean = function(t4) {
      return "1" === t4 || "true" === t4.toLowerCase() ? 1 : 0;
    }, e2.prototype.parseRow = function(t4, e3) {
      void 0 === e3 && (e3 = true);
      for (var r2 = [], n2 = 0, i2 = t4.length, o2 = STATE_OUT, a2 = 0; a2 < i2; a2++)
        switch (o2) {
          case STATE_OUT:
            switch (t4.charAt(a2)) {
              case CODE_QUOTE:
                n2 = a2 + 1, o2 = STATE_QUOTE;
                break;
              case this.delimiter:
                if (n2 = a2 + 1, " " === this.delimiter && this.delimWhitespace)
                  break;
                r2.push(""), o2 = STATE_OUT;
                break;
              default:
                o2 = STATE_FIELD, n2 = a2;
            }
            break;
          case STATE_FIELD:
            switch (t4.charAt(a2)) {
              case this.delimiter:
                r2.push(t4.substring(n2, a2)), o2 = STATE_OUT, n2 = a2 + 1;
            }
            break;
          case STATE_QUOTE:
            switch (t4.charAt(a2)) {
              case CODE_QUOTE:
                o2 = STATE_QUOTE_AFTER_QUOTE;
            }
            break;
          case STATE_QUOTE_AFTER_QUOTE:
            switch (t4.charAt(a2)) {
              case this.delimiter:
                r2.push(t4.substring(n2, a2 - 1)), o2 = STATE_OUT, n2 = a2 + 1;
                break;
              case CODE_QUOTE:
                o2 = STATE_QUOTE;
                break;
              default:
                o2 = STATE_WITHIN_QUOTE_IN_QUOTE;
            }
            break;
          case STATE_WITHIN_QUOTE_IN_QUOTE:
            switch (t4.charAt(a2)) {
              case CODE_QUOTE:
                o2 = STATE_QUOTE;
            }
        }
      if (o2 === STATE_QUOTE_AFTER_QUOTE ? r2.push(t4.substring(n2, i2 - 1)) : r2.push(t4.substring(n2)), e3 && r2.length !== this.fullColumnNames.length)
        throw new Error("Invalid row in csv file. Should have " + this.fullColumnNames.length + " elements in a row, but got " + r2);
      return r2;
    }, e2;
  }(Dataset);
  var MicrophoneIterator = function(t3) {
    function e2(e3) {
      var r2 = t3.call(this) || this;
      r2.microphoneConfig = e3, r2.isClosed = false, r2.fftSize = e3.fftSize || 1024;
      var n2 = Math.log2(r2.fftSize);
      if (r2.fftSize < 0 || n2 < 4 || n2 > 14 || !Number.isInteger(n2))
        throw new Error("Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got " + r2.fftSize);
      if (r2.numFrames = e3.numFramesPerSpectrogram || 43, r2.sampleRateHz = e3.sampleRateHz, r2.columnTruncateLength = e3.columnTruncateLength || r2.fftSize, r2.audioTrackConstraints = e3.audioTrackConstraints, r2.smoothingTimeConstant = e3.smoothingTimeConstant || 0, r2.includeSpectrogram = false !== e3.includeSpectrogram, r2.includeWaveform = true === e3.includeWaveform, !r2.includeSpectrogram && !r2.includeWaveform)
        throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
      return r2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return "microphone";
    }, e2.create = function(t4) {
      return void 0 === t4 && (t4 = {}), __awaiter3(this, void 0, void 0, function() {
        var r2;
        return __generator3(this, function(n2) {
          switch (n2.label) {
            case 0:
              if (a().get("IS_NODE"))
                throw new Error("microphone API is only supported in browser environment.");
              return [4, (r2 = new e2(t4)).start()];
            case 1:
              return n2.sent(), [2, r2];
          }
        });
      });
    }, e2.prototype.start = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2, n2;
        return __generator3(this, function(i2) {
          switch (i2.label) {
            case 0:
              return i2.trys.push([0, 2, , 3]), t4 = this, [4, navigator.mediaDevices.getUserMedia({ audio: null == this.audioTrackConstraints || this.audioTrackConstraints, video: false })];
            case 1:
              return t4.stream = i2.sent(), [3, 3];
            case 2:
              throw e3 = i2.sent(), new Error("Error thrown while initializing video stream: " + e3.message);
            case 3:
              if (!this.stream)
                throw new Error("Could not obtain audio from microphone.");
              if (r2 = window.AudioContext || window.webkitAudioContext, this.audioContext = new r2(), this.sampleRateHz) {
                if (this.audioContext.sampleRate !== this.sampleRateHz)
                  throw new Error("Mismatch in sampling rate: Expected: " + this.sampleRateHz + "; Actual: " + this.audioContext.sampleRate);
              } else
                this.sampleRateHz = this.audioContext.sampleRate;
              return n2 = this.audioContext.createMediaStreamSource(this.stream), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2 * this.fftSize, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, n2.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize), [2];
          }
        });
      });
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2, n2, i2;
        return __generator3(this, function(o2) {
          switch (o2.label) {
            case 0:
              return this.isClosed ? [2, { value: null, done: true }] : [4, this.getAudioData()];
            case 1:
              return r2 = o2.sent(), this.includeSpectrogram && (n2 = this.flattenQueue(r2.freqDataQueue), t4 = this.getTensorFromAudioDataArray(n2, [this.numFrames, this.columnTruncateLength, 1])), this.includeWaveform && (i2 = this.flattenQueue(r2.timeDataQueue), e3 = this.getTensorFromAudioDataArray(i2, [this.numFrames * this.fftSize, 1])), [2, { value: { spectrogram: t4, waveform: e3 }, done: false }];
          }
        });
      });
    }, e2.prototype.capture = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          switch (t4.label) {
            case 0:
              return [4, this.next()];
            case 1:
              return [2, t4.sent().value];
          }
        });
      });
    }, e2.prototype.getAudioData = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2, n2 = this;
        return __generator3(this, function(i2) {
          return t4 = [], e3 = [], r2 = 0, [2, new Promise(function(i3) {
            var o2 = setInterval(function() {
              n2.includeSpectrogram && (n2.analyser.getFloatFrequencyData(n2.freqData), n2.freqData[0] === -1 / 0 && i3({ freqDataQueue: t4, timeDataQueue: e3 }), t4.push(n2.freqData.slice(0, n2.columnTruncateLength))), n2.includeWaveform && (n2.analyser.getFloatTimeDomainData(n2.timeData), e3.push(n2.timeData.slice())), ++r2 === n2.numFrames && (clearInterval(o2), i3({ freqDataQueue: t4, timeDataQueue: e3 }));
            }, n2.fftSize / n2.sampleRateHz * 1e3);
          })];
        });
      });
    }, e2.prototype.stop = function() {
      this.isClosed || (this.isClosed = true, this.analyser.disconnect(), this.audioContext.close(), null != this.stream && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop());
    }, e2.prototype.toArray = function() {
      throw new Error("Can not convert infinite audio stream to array.");
    }, e2.prototype.getSampleRate = function() {
      return this.sampleRateHz;
    }, e2.prototype.flattenQueue = function(t4) {
      var e3 = t4[0].length, r2 = new Float32Array(t4.length * e3);
      return t4.forEach(function(t5, n2) {
        return r2.set(t5, n2 * e3);
      }), r2;
    }, e2.prototype.getTensorFromAudioDataArray = function(t4, e3) {
      var r2 = new Float32Array(tt.sizeFromShape(e3));
      return r2.set(t4, r2.length - t4.length), kn(r2, e3);
    }, e2;
  }(LazyIterator);
  var WebcamIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      if (n2.webcamVideoElement = e3, n2.webcamConfig = r2, n2.isClosed = true, n2.resize = false, n2.needToResize())
        if (n2.resize = true, n2.cropSize = [n2.webcamConfig.resizeHeight, n2.webcamConfig.resizeWidth], n2.cropBoxInd = Dn([0], "int32"), n2.webcamConfig.centerCrop) {
          var i2 = 1 * n2.webcamConfig.resizeWidth / n2.webcamVideoElement.width, o2 = 1 * n2.webcamConfig.resizeHeight / n2.webcamVideoElement.height, a2 = (1 - i2) / 2, s2 = (1 - o2) / 2, u2 = a2 + i2, c2 = o2 + s2;
          n2.cropBox = Tn([s2, a2, c2, u2], [1, 4]);
        } else
          n2.cropBox = Tn([0, 0, 1, 1], [1, 4]);
      return n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return "webcam";
    }, e2.create = function(t4, r2) {
      return void 0 === r2 && (r2 = {}), __awaiter3(this, void 0, void 0, function() {
        var n2;
        return __generator3(this, function(i2) {
          switch (i2.label) {
            case 0:
              if (a().get("IS_NODE"))
                throw new Error("tf.data.webcam is only supported in browser environment.");
              if (!t4) {
                if (t4 = document.createElement("video"), !r2.resizeWidth || !r2.resizeHeight)
                  throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
                t4.width = r2.resizeWidth, t4.height = r2.resizeHeight;
              }
              return [4, (n2 = new e2(t4, r2)).start()];
            case 1:
              return i2.sent(), [2, n2];
          }
        });
      });
    }, e2.prototype.start = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2 = this;
        return __generator3(this, function(n2) {
          switch (n2.label) {
            case 0:
              this.webcamConfig.facingMode && tt.assert("user" === this.webcamConfig.facingMode || "environment" === this.webcamConfig.facingMode, function() {
                return "Invalid webcam facing mode: " + r2.webcamConfig.facingMode + ". Please provide 'user' or 'environment'";
              }), n2.label = 1;
            case 1:
              return n2.trys.push([1, 3, , 4]), t4 = this, [4, navigator.mediaDevices.getUserMedia({ video: { deviceId: this.webcamConfig.deviceId, facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user", width: this.webcamVideoElement.width, height: this.webcamVideoElement.height } })];
            case 2:
              return t4.stream = n2.sent(), [3, 4];
            case 3:
              throw (e3 = n2.sent()).message = "Error thrown while initializing video stream: " + e3.message, e3;
            case 4:
              if (!this.stream)
                throw new Error("Could not obtain video from webcam.");
              try {
                this.webcamVideoElement.srcObject = this.stream;
              } catch (t5) {
                console.log(t5), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
              }
              return this.webcamVideoElement.play(), this.isClosed = false, [2, new Promise(function(t5) {
                r2.webcamVideoElement.onloadedmetadata = function() {
                  t5();
                };
              })];
          }
        });
      });
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4;
        return __generator3(this, function(e3) {
          if (this.isClosed)
            return [2, { value: null, done: true }];
          try {
            t4 = Nf.fromPixels(this.webcamVideoElement);
          } catch (t5) {
            throw new Error("Error thrown converting video to pixels: " + JSON.stringify(t5));
          }
          if (!this.resize)
            return [2, { value: t4, done: false }];
          try {
            return [2, { value: this.cropAndResizeFrame(t4), done: false }];
          } catch (t5) {
            throw new Error("Error thrown cropping the video: " + t5.message);
          } finally {
            t4.dispose();
          }
          return [2];
        });
      });
    }, e2.prototype.needToResize = function() {
      return !(!this.webcamConfig.resizeWidth || !this.webcamConfig.resizeHeight || this.webcamVideoElement.width === this.webcamConfig.resizeWidth && this.webcamVideoElement.height === this.webcamConfig.resizeHeight);
    }, e2.prototype.cropAndResizeFrame = function(t4) {
      var e3 = this;
      return je(function() {
        var r2, n2 = t4.toFloat().expandDims(0), i2 = (r2 = vh.cropAndResize(n2, e3.cropBox, e3.cropBoxInd, e3.cropSize, "bilinear")).shape;
        return r2.reshape(i2.slice(1));
      });
    }, e2.prototype.capture = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          switch (t4.label) {
            case 0:
              return [4, this.next()];
            case 1:
              return [2, t4.sent().value];
          }
        });
      });
    }, e2.prototype.stop = function() {
      this.stream.getTracks().forEach(function(t4) {
        return t4.stop();
      });
      try {
        this.webcamVideoElement.srcObject = null;
      } catch (t4) {
        console.log(t4), this.webcamVideoElement.src = null;
      }
      this.isClosed = true;
    }, e2.prototype.toArray = function() {
      throw new Error("Can not convert infinite video stream to array.");
    }, e2;
  }(LazyIterator);
  var DataSource = function() {
    return function() {
    };
  }();
  var StringIterator = function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends2(e2, t3), e2.prototype.split = function(t4) {
      return new SplitIterator(this, t4);
    }, e2;
  }(LazyIterator);
  var SplitIterator = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.upstream = e3, n2.impl = new SplitIteratorImpl(e3, r2), n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.impl.summary();
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          return [2, this.impl.next()];
        });
      });
    }, e2;
  }(StringIterator);
  var SplitIteratorImpl = function(t3) {
    function e2(e3, r2) {
      var n2 = t3.call(this) || this;
      return n2.upstream = e3, n2.separator = r2, n2.carryover = "", n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> Split('" + this.separator + "')";
    }, e2.prototype.pump = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2, n2, i2;
        return __generator3(this, function(o2) {
          switch (o2.label) {
            case 0:
              return [4, this.upstream.next()];
            case 1:
              if ((t4 = o2.sent()).done)
                return "" === this.carryover ? [2, false] : (this.outputQueue.push(this.carryover), this.carryover = "", [2, true]);
              for ((e3 = t4.value.split(this.separator))[0] = this.carryover + e3[0], r2 = 0, n2 = e3.slice(0, -1); r2 < n2.length; r2++)
                i2 = n2[r2], this.outputQueue.push(i2);
              return this.carryover = e3[e3.length - 1], [2, true];
          }
        });
      });
    }, e2;
  }(OneToManyIterator);
  var ByteChunkIterator = function(t3) {
    function e2() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends2(e2, t3), e2.prototype.decodeUTF8 = function() {
      return new Utf8Iterator(this);
    }, e2;
  }(LazyIterator);
  var Utf8Iterator = function(t3) {
    function e2(e3) {
      var r2 = t3.call(this) || this;
      return r2.upstream = e3, r2.impl = new Utf8IteratorImpl(e3), r2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.impl.summary();
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          return [2, this.impl.next()];
        });
      });
    }, e2;
  }(StringIterator);
  var Utf8IteratorImpl = function(t3) {
    function e2(e3) {
      var r2 = t3.call(this) || this;
      if (r2.upstream = e3, a().get("IS_BROWSER"))
        r2.decoder = new TextDecoder("utf-8");
      else {
        var n2 = require_string_decoder().StringDecoder;
        r2.decoder = new n2("utf8");
      }
      return r2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return this.upstream.summary() + " -> Utf8";
    }, e2.prototype.pump = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2;
        return __generator3(this, function(n2) {
          switch (n2.label) {
            case 0:
              return [4, this.upstream.next()];
            case 1:
              return (t4 = n2.sent()).done ? [2, false] : (e3 = t4.value, r2 = a().get("IS_BROWSER") ? this.decoder.decode(e3, { stream: true }) : this.decoder.write(Buffer.from(e3.buffer)), this.outputQueue.push(r2), [2, true]);
          }
        });
      });
    }, e2;
  }(OneToManyIterator);
  var FileChunkIterator = function(t3) {
    function e2(e3, r2) {
      void 0 === r2 && (r2 = {});
      var n2 = t3.call(this) || this;
      return n2.file = e3, n2.options = r2, tt.assert(e3 instanceof Uint8Array || !!a().get("IS_BROWSER") && (e3 instanceof File || e3 instanceof Blob), function() {
        return "FileChunkIterator only supports File, Blob and Uint8Array right now.";
      }), n2.offset = r2.offset || 0, n2.chunkSize = r2.chunkSize || 1048576, n2;
    }
    return __extends2(e2, t3), e2.prototype.summary = function() {
      return "FileChunks " + this.file;
    }, e2.prototype.next = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4, e3, r2 = this;
        return __generator3(this, function(n2) {
          switch (n2.label) {
            case 0:
              return this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size) ? [2, { value: null, done: true }] : (t4 = new Promise(function(t5, e4) {
                var n3 = r2.offset + r2.chunkSize;
                if (r2.file instanceof Uint8Array)
                  t5(new Uint8Array(r2.file.slice(r2.offset, n3)));
                else {
                  var i2 = new FileReader();
                  i2.onload = function(r3) {
                    var n4 = i2.result;
                    if (n4 instanceof ArrayBuffer && (n4 = new Uint8Array(n4)), !(n4 instanceof Uint8Array))
                      return e4(new TypeError("FileReader returned unknown type."));
                    t5(n4);
                  }, i2.onabort = function(t6) {
                    return e4(new Error("Aborted"));
                  }, i2.onerror = function(t6) {
                    return e4(new Error(t6.type));
                  };
                  var o2 = r2.file.slice(r2.offset, n3);
                  i2.readAsArrayBuffer(o2);
                }
                r2.offset = n3;
              }), e3 = {}, [4, t4]);
            case 1:
              return [2, (e3.value = n2.sent(), e3.done = false, e3)];
          }
        });
      });
    }, e2;
  }(ByteChunkIterator);
  function urlChunkIterator(t3, e2) {
    return void 0 === e2 && (e2 = {}), __awaiter3(this, void 0, void 0, function() {
      var r2, n2, i2, o2, a2;
      return __generator3(this, function(s2) {
        switch (s2.label) {
          case 0:
            return "string" == typeof t3 ? r2 = t3 : (r2 = t3.url, n2 = getRequestInitFromRequest(t3)), [4, tt.fetch(r2, n2)];
          case 1:
            return (i2 = s2.sent()).ok ? (a2 = Uint8Array.bind, [4, i2.arrayBuffer()]) : [3, 3];
          case 2:
            return o2 = new (a2.apply(Uint8Array, [void 0, s2.sent()]))(), [2, new FileChunkIterator(o2, e2)];
          case 3:
            throw new Error(i2.statusText);
        }
      });
    });
  }
  var getRequestInitFromRequest = function(t3) {
    return { method: t3.method, headers: t3.headers, body: t3.body, mode: t3.mode, credentials: t3.credentials, cache: t3.cache, redirect: t3.redirect, referrer: t3.referrer, integrity: t3.integrity };
  };
  function isLocalPath(t3) {
    return "string" == typeof t3 && "file://" === t3.substr(0, 7);
  }
  var FileDataSource = function(t3) {
    function e2(e3, r2) {
      void 0 === r2 && (r2 = {});
      var n2 = t3.call(this) || this;
      return n2.input = e3, n2.options = r2, n2;
    }
    return __extends2(e2, t3), e2.prototype.iterator = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var t4;
        return __generator3(this, function(e3) {
          return isLocalPath(this.input) && a().get("IS_NODE") && (t4 = require_fs(), this.input = t4.readFileSync(this.input.substr(7))), [2, new FileChunkIterator(this.input, this.options)];
        });
      });
    }, e2;
  }(DataSource);
  var URLDataSource = function(t3) {
    function e2(e3, r2) {
      void 0 === r2 && (r2 = {});
      var n2 = t3.call(this) || this;
      return n2.url = e3, n2.fileOptions = r2, n2;
    }
    return __extends2(e2, t3), e2.prototype.iterator = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(t4) {
          return isLocalPath(this.url) ? [2, new FileDataSource(this.url, this.fileOptions).iterator()] : [2, urlChunkIterator(this.url, this.fileOptions)];
        });
      });
    }, e2;
  }(DataSource);

  // node_modules/@tensorflow/tfjs-core/dist/backends/backend.js
  var EPSILON_FLOAT32 = 1e-7;
  var EPSILON_FLOAT16 = 1e-4;
  var DataStorage = class {
    constructor(backend, dataMover) {
      this.backend = backend;
      this.dataMover = dataMover;
      this.data = /* @__PURE__ */ new WeakMap();
      this.dataIdsCount = 0;
    }
    get(dataId) {
      if (!this.data.has(dataId)) {
        this.dataMover.moveData(this.backend, dataId);
      }
      return this.data.get(dataId);
    }
    set(dataId, value) {
      this.dataIdsCount++;
      this.data.set(dataId, value);
    }
    has(dataId) {
      return this.data.has(dataId);
    }
    delete(dataId) {
      this.dataIdsCount--;
      return this.data.delete(dataId);
    }
    numDataIds() {
      return this.dataIdsCount;
    }
  };
  var KernelBackend = class {
    refCount(dataId) {
      return notYetImplemented("refCount");
    }
    incRef(dataId) {
      return notYetImplemented("incRef");
    }
    timerAvailable() {
      return true;
    }
    time(f2) {
      return notYetImplemented("time");
    }
    read(dataId) {
      return notYetImplemented("read");
    }
    readSync(dataId) {
      return notYetImplemented("readSync");
    }
    readToGPU(dataId, options) {
      return notYetImplemented("readToGPU");
    }
    numDataIds() {
      return notYetImplemented("numDataIds");
    }
    disposeData(dataId, force) {
      return notYetImplemented("disposeData");
    }
    write(values, shape, dtype) {
      return notYetImplemented("write");
    }
    move(dataId, values, shape, dtype, refCount) {
      return notYetImplemented("move");
    }
    createTensorFromGPUData(values, shape, dtype) {
      return notYetImplemented("createTensorFromGPUData");
    }
    memory() {
      return notYetImplemented("memory");
    }
    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */
    floatPrecision() {
      return notYetImplemented("floatPrecision");
    }
    /** Returns the smallest representable number.  */
    epsilon() {
      return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
    }
    dispose() {
      return notYetImplemented("dispose");
    }
  };
  function notYetImplemented(kernelName) {
    throw new Error(`'${kernelName}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
  }

  // node_modules/@tensorflow/tfjs-core/dist/util_base.js
  function shuffle(array) {
    let counter = array.length;
    let index = 0;
    while (counter > 0) {
      index = Math.random() * counter | 0;
      counter--;
      swap(array, counter, index);
    }
  }
  function shuffleCombo(array, array2) {
    if (array.length !== array2.length) {
      throw new Error(`Array sizes must match to be shuffled together First array length was ${array.length}Second array length was ${array2.length}`);
    }
    let counter = array.length;
    let index = 0;
    while (counter > 0) {
      index = Math.random() * counter | 0;
      counter--;
      swap(array, counter, index);
      swap(array2, counter, index);
    }
  }
  function clamp(min3, x2, max3) {
    return Math.max(min3, Math.min(x2, max3));
  }
  function nearestLargerEven(val) {
    return val % 2 === 0 ? val : val + 1;
  }
  function swap(object, left, right) {
    const temp = object[left];
    object[left] = object[right];
    object[right] = temp;
  }
  function sum(arr) {
    let sum4 = 0;
    for (let i2 = 0; i2 < arr.length; i2++) {
      sum4 += arr[i2];
    }
    return sum4;
  }
  function randUniform(a2, b2) {
    const r2 = Math.random();
    return b2 * r2 + (1 - r2) * a2;
  }
  function distSquared(a2, b2) {
    let result = 0;
    for (let i2 = 0; i2 < a2.length; i2++) {
      const diff = Number(a2[i2]) - Number(b2[i2]);
      result += diff * diff;
    }
    return result;
  }
  function assert2(expr, msg) {
    if (!expr) {
      throw new Error(typeof msg === "string" ? msg : msg());
    }
  }
  function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = "") {
    assert2(arraysEqual(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
  }
  function assertNonNull(a2) {
    assert2(a2 != null, () => `The input to the tensor constructor must be a non-null value.`);
  }
  function sizeFromShape(shape) {
    if (shape.length === 0) {
      return 1;
    }
    let size = shape[0];
    for (let i2 = 1; i2 < shape.length; i2++) {
      size *= shape[i2];
    }
    return size;
  }
  function isScalarShape(shape) {
    return shape.length === 0;
  }
  function arraysEqual(n1, n2) {
    if (n1 === n2) {
      return true;
    }
    if (n1 == null || n2 == null) {
      return false;
    }
    if (n1.length !== n2.length) {
      return false;
    }
    for (let i2 = 0; i2 < n1.length; i2++) {
      if (n1[i2] !== n2[i2]) {
        return false;
      }
    }
    return true;
  }
  function isInt(a2) {
    return a2 % 1 === 0;
  }
  function tanh(x2) {
    if (Math.tanh != null) {
      return Math.tanh(x2);
    }
    if (x2 === Infinity) {
      return 1;
    } else if (x2 === -Infinity) {
      return -1;
    } else {
      const e2x = Math.exp(2 * x2);
      return (e2x - 1) / (e2x + 1);
    }
  }
  function sizeToSquarishShape(size) {
    const width = Math.ceil(Math.sqrt(size));
    return [width, Math.ceil(size / width)];
  }
  function createShuffledIndices(n2) {
    const shuffledIndices = new Uint32Array(n2);
    for (let i2 = 0; i2 < n2; ++i2) {
      shuffledIndices[i2] = i2;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
  }
  function rightPad(a2, size) {
    if (size <= a2.length) {
      return a2;
    }
    return a2 + " ".repeat(size - a2.length);
  }
  function repeatedTry(checkFn, delayFn = (counter) => 0, maxCounter, scheduleFn) {
    return new Promise((resolve, reject) => {
      let tryCount = 0;
      const tryFn = () => {
        if (checkFn()) {
          resolve();
          return;
        }
        tryCount++;
        const nextBackoff = delayFn(tryCount);
        if (maxCounter != null && tryCount >= maxCounter) {
          reject();
          return;
        }
        if (scheduleFn != null) {
          scheduleFn(tryFn, nextBackoff);
        } else {
          setTimeout(tryFn, nextBackoff);
        }
      };
      tryFn();
    });
  }
  function inferFromImplicitShape(shape, size) {
    let shapeProd = 1;
    let implicitIdx = -1;
    for (let i2 = 0; i2 < shape.length; ++i2) {
      if (shape[i2] >= 0) {
        shapeProd *= shape[i2];
      } else if (shape[i2] === -1) {
        if (implicitIdx !== -1) {
          throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${implicitIdx} and dim ${i2}`);
        }
        implicitIdx = i2;
      } else if (shape[i2] < 0) {
        throw Error(`Shapes can not be < 0. Found ${shape[i2]} at dim ${i2}`);
      }
    }
    if (implicitIdx === -1) {
      if (size > 0 && size !== shapeProd) {
        throw Error(`Size(${size}) must match the product of shape ${shape}`);
      }
      return shape;
    }
    if (shapeProd === 0) {
      throw Error(`Cannot infer the missing size in [${shape}] when there are 0 elements`);
    }
    if (size % shapeProd !== 0) {
      throw Error(`The implicit shape can't be a fractional number. Got ${size} / ${shapeProd}`);
    }
    const newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
  }
  function parseAxisParam(axis, shape) {
    const rank = shape.length;
    axis = axis == null ? shape.map((s2, i2) => i2) : [].concat(axis);
    assert2(axis.every((ax) => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`);
    assert2(axis.every((ax) => isInt(ax)), () => `All values in axis param must be integers but got axis ${axis}`);
    return axis.map((a2) => a2 < 0 ? rank + a2 : a2);
  }
  function squeezeShape(shape, axis) {
    const newShape = [];
    const keptDims = [];
    const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
    const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape).sort();
    let j3 = 0;
    for (let i2 = 0; i2 < shape.length; ++i2) {
      if (axes != null) {
        if (axes[j3] === i2 && shape[i2] !== 1) {
          throw new Error(`Can't squeeze axis ${i2} since its dim '${shape[i2]}' is not 1`);
        }
        if ((axes[j3] == null || axes[j3] > i2) && shape[i2] === 1) {
          newShape.push(shape[i2]);
          keptDims.push(i2);
        }
        if (axes[j3] <= i2) {
          j3++;
        }
      }
      if (shape[i2] !== 1) {
        newShape.push(shape[i2]);
        keptDims.push(i2);
      }
    }
    return { newShape, keptDims };
  }
  function getTypedArrayFromDType(dtype, size) {
    let values = null;
    if (dtype == null || dtype === "float32") {
      values = new Float32Array(size);
    } else if (dtype === "int32") {
      values = new Int32Array(size);
    } else if (dtype === "bool") {
      values = new Uint8Array(size);
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
    return values;
  }
  function getArrayFromDType(dtype, size) {
    let values = null;
    if (dtype == null || dtype === "float32") {
      values = new Float32Array(size);
    } else if (dtype === "int32") {
      values = new Int32Array(size);
    } else if (dtype === "bool") {
      values = new Uint8Array(size);
    } else if (dtype === "string") {
      values = new Array(size);
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
    return values;
  }
  function checkConversionForErrors(vals, dtype) {
    for (let i2 = 0; i2 < vals.length; i2++) {
      const num = vals[i2];
      if (isNaN(num) || !isFinite(num)) {
        throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
      }
    }
  }
  function isValidDtype(dtype) {
    return dtype === "bool" || dtype === "complex64" || dtype === "float32" || dtype === "int32" || dtype === "string";
  }
  function hasEncodingLoss(oldType, newType) {
    if (newType === "complex64") {
      return false;
    }
    if (newType === "float32" && oldType !== "complex64") {
      return false;
    }
    if (newType === "int32" && oldType !== "float32" && oldType !== "complex64") {
      return false;
    }
    if (newType === "bool" && oldType === "bool") {
      return false;
    }
    return true;
  }
  function bytesPerElement(dtype) {
    if (dtype === "float32" || dtype === "int32") {
      return 4;
    } else if (dtype === "complex64") {
      return 8;
    } else if (dtype === "bool") {
      return 1;
    } else {
      throw new Error(`Unknown dtype ${dtype}`);
    }
  }
  function bytesFromStringArray(arr) {
    if (arr == null) {
      return 0;
    }
    let bytes = 0;
    arr.forEach((x2) => bytes += x2.length);
    return bytes;
  }
  function isString(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isBoolean(value) {
    return typeof value === "boolean";
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  function inferDtype(values) {
    if (Array.isArray(values)) {
      return inferDtype(values[0]);
    }
    if (values instanceof Float32Array) {
      return "float32";
    } else if (values instanceof Int32Array || values instanceof Uint8Array || values instanceof Uint8ClampedArray) {
      return "int32";
    } else if (isNumber(values)) {
      return "float32";
    } else if (isString(values)) {
      return "string";
    } else if (isBoolean(values)) {
      return "bool";
    }
    return "float32";
  }
  function isFunction(f2) {
    return !!(f2 && f2.constructor && f2.call && f2.apply);
  }
  function nearestDivisor(size, start) {
    for (let i2 = start; i2 < size; ++i2) {
      if (size % i2 === 0) {
        return i2;
      }
    }
    return size;
  }
  function computeStrides(shape) {
    const rank = shape.length;
    if (rank < 2) {
      return [];
    }
    const strides = new Array(rank - 1);
    strides[rank - 2] = shape[rank - 1];
    for (let i2 = rank - 3; i2 >= 0; --i2) {
      strides[i2] = strides[i2 + 1] * shape[i2 + 1];
    }
    return strides;
  }
  function createNestedArray(offset, shape, a2, isComplex = false) {
    const ret = new Array();
    if (shape.length === 1) {
      const d2 = shape[0] * (isComplex ? 2 : 1);
      for (let i2 = 0; i2 < d2; i2++) {
        ret[i2] = a2[offset + i2];
      }
    } else {
      const d2 = shape[0];
      const rest = shape.slice(1);
      const len = rest.reduce((acc, c2) => acc * c2) * (isComplex ? 2 : 1);
      for (let i2 = 0; i2 < d2; i2++) {
        ret[i2] = createNestedArray(offset + i2 * len, rest, a2, isComplex);
      }
    }
    return ret;
  }
  function toNestedArray(shape, a2, isComplex = false) {
    if (shape.length === 0) {
      return a2[0];
    }
    const size = shape.reduce((acc, c2) => acc * c2) * (isComplex ? 2 : 1);
    if (size === 0) {
      return [];
    }
    if (size !== a2.length) {
      throw new Error(`[${shape}] does not match the input size ${a2.length}${isComplex ? " for a complex tensor" : ""}.`);
    }
    return createNestedArray(0, shape, a2, isComplex);
  }
  function convertBackendValuesAndArrayBuffer(data, dtype) {
    if (Array.isArray(data)) {
      return data;
    }
    if (dtype === "float32") {
      return data instanceof Float32Array ? data : new Float32Array(data);
    } else if (dtype === "int32") {
      return data instanceof Int32Array ? data : new Int32Array(data);
    } else if (dtype === "bool" || dtype === "string") {
      return Uint8Array.from(new Int32Array(data));
    } else {
      throw new Error(`Unknown dtype ${dtype}`);
    }
  }
  function makeOnesTypedArray(size, dtype) {
    const array = makeZerosTypedArray(size, dtype);
    for (let i2 = 0; i2 < array.length; i2++) {
      array[i2] = 1;
    }
    return array;
  }
  function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === "float32" || dtype === "complex64") {
      return new Float32Array(size);
    } else if (dtype === "int32") {
      return new Int32Array(size);
    } else if (dtype === "bool") {
      return new Uint8Array(size);
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
  }
  function makeZerosNestedTypedArray(shape, dtype) {
    const size = shape.reduce((prev, curr) => prev * curr, 1);
    if (dtype == null || dtype === "float32") {
      return toNestedArray(shape, new Float32Array(size));
    } else if (dtype === "int32") {
      return toNestedArray(shape, new Int32Array(size));
    } else if (dtype === "bool") {
      return toNestedArray(shape, new Uint8Array(size));
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
  }
  function assertNonNegativeIntegerDimensions(shape) {
    shape.forEach((dimSize) => {
      assert2(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${shape}].`);
    });
  }
  function locToIndex(locs, rank, strides) {
    if (rank === 0) {
      return 0;
    } else if (rank === 1) {
      return locs[0];
    }
    let index = locs[locs.length - 1];
    for (let i2 = 0; i2 < locs.length - 1; ++i2) {
      index += strides[i2] * locs[i2];
    }
    return index;
  }
  function indexToLoc(index, rank, strides) {
    if (rank === 0) {
      return [];
    } else if (rank === 1) {
      return [index];
    }
    const locs = new Array(rank);
    for (let i2 = 0; i2 < locs.length - 1; ++i2) {
      locs[i2] = Math.floor(index / strides[i2]);
      index -= locs[i2] * strides[i2];
    }
    locs[locs.length - 1] = index;
    return locs;
  }
  function isPromise(object) {
    return object && object.then && typeof object.then === "function";
  }

  // node_modules/@tensorflow/tfjs-core/dist/environment.js
  var TENSORFLOWJS_FLAGS_PREFIX = "tfjsflags";
  var Environment = class {
    // tslint:disable-next-line: no-any
    constructor(global2) {
      this.global = global2;
      this.flags = {};
      this.flagRegistry = {};
      this.urlFlags = {};
      this.getQueryParams = getQueryParams;
      this.populateURLFlags();
    }
    setPlatform(platformName, platform) {
      if (this.platform != null) {
        if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
          console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${platformName}.`);
        }
      }
      this.platformName = platformName;
      this.platform = platform;
    }
    registerFlag(flagName, evaluationFn, setHook) {
      this.flagRegistry[flagName] = { evaluationFn, setHook };
      if (this.urlFlags[flagName] != null) {
        const flagValue = this.urlFlags[flagName];
        if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
          console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);
        }
        this.set(flagName, flagValue);
      }
    }
    async getAsync(flagName) {
      if (flagName in this.flags) {
        return this.flags[flagName];
      }
      this.flags[flagName] = await this.evaluateFlag(flagName);
      return this.flags[flagName];
    }
    get(flagName) {
      if (flagName in this.flags) {
        return this.flags[flagName];
      }
      const flagValue = this.evaluateFlag(flagName);
      if (isPromise(flagValue)) {
        throw new Error(`Flag ${flagName} cannot be synchronously evaluated. Please use getAsync() instead.`);
      }
      this.flags[flagName] = flagValue;
      return this.flags[flagName];
    }
    getNumber(flagName) {
      return this.get(flagName);
    }
    getBool(flagName) {
      return this.get(flagName);
    }
    getFlags() {
      return this.flags;
    }
    // For backwards compatibility.
    get features() {
      return this.flags;
    }
    set(flagName, value) {
      if (this.flagRegistry[flagName] == null) {
        throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
      }
      this.flags[flagName] = value;
      if (this.flagRegistry[flagName].setHook != null) {
        this.flagRegistry[flagName].setHook(value);
      }
    }
    evaluateFlag(flagName) {
      if (this.flagRegistry[flagName] == null) {
        throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
      }
      return this.flagRegistry[flagName].evaluationFn();
    }
    setFlags(flags) {
      this.flags = Object.assign({}, flags);
    }
    reset() {
      this.flags = {};
      this.urlFlags = {};
      this.populateURLFlags();
    }
    populateURLFlags() {
      if (typeof this.global === "undefined" || typeof this.global.location === "undefined" || typeof this.global.location.search === "undefined") {
        return;
      }
      const urlParams = this.getQueryParams(this.global.location.search);
      if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
        const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");
        keyValues.forEach((keyValue) => {
          const [key, value] = keyValue.split(":");
          this.urlFlags[key] = parseValue(key, value);
        });
      }
    }
  };
  function getQueryParams(queryString) {
    const params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s2, ...t3) => {
      decodeParam(params, t3[0], t3[1]);
      return t3.join("=");
    });
    return params;
  }
  function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || "");
  }
  function parseValue(flagName, value) {
    value = value.toLowerCase();
    if (value === "true" || value === "false") {
      return value === "true";
    } else if (`${+value}` === value) {
      return +value;
    }
    throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`);
  }
  function env() {
    return ENV;
  }
  var ENV = null;
  function setEnvironmentGlobal(environment) {
    ENV = environment;
  }

  // node_modules/@tensorflow/tfjs-core/dist/global_util.js
  var globalNameSpace;
  function getGlobalNamespace() {
    if (globalNameSpace == null) {
      let ns2;
      if (typeof window !== "undefined") {
        ns2 = window;
      } else if (typeof global !== "undefined") {
        ns2 = global;
      } else if (typeof process !== "undefined") {
        ns2 = process;
      } else if (typeof self !== "undefined") {
        ns2 = self;
      } else {
        throw new Error("Could not find a global object");
      }
      globalNameSpace = ns2;
    }
    return globalNameSpace;
  }
  function getGlobalMap() {
    const ns2 = getGlobalNamespace();
    if (ns2._tfGlobals == null) {
      ns2._tfGlobals = /* @__PURE__ */ new Map();
    }
    return ns2._tfGlobals;
  }
  function getGlobal(key, init) {
    const globalMap = getGlobalMap();
    if (globalMap.has(key)) {
      return globalMap.get(key);
    } else {
      const singleton = init();
      globalMap.set(key, singleton);
      return globalMap.get(key);
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/kernel_names.js
  var Abs = "Abs";
  var Acos = "Acos";
  var Acosh = "Acosh";
  var Add2 = "Add";
  var AddN = "AddN";
  var All = "All";
  var Any = "Any";
  var ArgMax = "ArgMax";
  var ArgMin = "ArgMin";
  var Asin = "Asin";
  var Asinh = "Asinh";
  var Atan = "Atan";
  var Atanh = "Atanh";
  var Atan2 = "Atan2";
  var AvgPool = "AvgPool";
  var AvgPoolGrad = "AvgPoolGrad";
  var AvgPool3D = "AvgPool3D";
  var AvgPool3DGrad = "AvgPool3DGrad";
  var BatchMatMul = "BatchMatMul";
  var BatchToSpaceND = "BatchToSpaceND";
  var Bincount = "Bincount";
  var BroadcastArgs = "BroadcastArgs";
  var Cast = "Cast";
  var Ceil = "Ceil";
  var ClipByValue = "ClipByValue";
  var Complex = "Complex";
  var ComplexAbs = "ComplexAbs";
  var Concat = "Concat";
  var Conv2D2 = "Conv2D";
  var Conv2DBackpropFilter = "Conv2DBackpropFilter";
  var Conv2DBackpropInput = "Conv2DBackpropInput";
  var Conv3D2 = "Conv3D";
  var Conv3DBackpropFilterV2 = "Conv3DBackpropFilterV2";
  var Conv3DBackpropInputV2 = "Conv3DBackpropInputV2";
  var Cos = "Cos";
  var Cosh = "Cosh";
  var Cumprod = "Cumprod";
  var Cumsum = "Cumsum";
  var CropAndResize = "CropAndResize";
  var DenseBincount = "DenseBincount";
  var DepthToSpace = "DepthToSpace";
  var DepthwiseConv2dNative = "DepthwiseConv2dNative";
  var DepthwiseConv2dNativeBackpropFilter = "DepthwiseConv2dNativeBackpropFilter";
  var DepthwiseConv2dNativeBackpropInput = "DepthwiseConv2dNativeBackpropInput";
  var Diag = "Diag";
  var Dilation2D = "Dilation2D";
  var RealDiv = "RealDiv";
  var Einsum = "Einsum";
  var Elu2 = "Elu";
  var EluGrad = "EluGrad";
  var Erf = "Erf";
  var Equal = "Equal";
  var Exp = "Exp";
  var ExpandDims = "ExpandDims";
  var Expm1 = "Expm1";
  var FFT = "FFT";
  var Fill = "Fill";
  var FlipLeftRight = "FlipLeftRight";
  var Floor = "Floor";
  var FloorDiv = "FloorDiv";
  var FusedBatchNorm = "FusedBatchNorm";
  var GatherV2 = "GatherV2";
  var GatherNd = "GatherNd";
  var Greater = "Greater";
  var GreaterEqual = "GreaterEqual";
  var Identity2 = "Identity";
  var IFFT = "IFFT";
  var Imag = "Imag";
  var IsFinite = "IsFinite";
  var IsInf = "IsInf";
  var IsNan = "IsNan";
  var LeakyRelu = "LeakyRelu";
  var Less = "Less";
  var LessEqual = "LessEqual";
  var LinSpace = "LinSpace";
  var Log = "Log";
  var Log1p = "Log1p";
  var LogicalAnd = "LogicalAnd";
  var LogicalNot = "LogicalNot";
  var LogicalOr = "LogicalOr";
  var LRN = "LRN";
  var LRNGrad = "LRNGrad";
  var Max = "Max";
  var Maximum2 = "Maximum";
  var MaxPool = "MaxPool";
  var MaxPoolGrad = "MaxPoolGrad";
  var MaxPool3D = "MaxPool3D";
  var MaxPool3DGrad = "MaxPool3DGrad";
  var MaxPoolWithArgmax = "MaxPoolWithArgmax";
  var Mean = "Mean";
  var Min = "Min";
  var Minimum2 = "Minimum";
  var MirrorPad = "MirrorPad";
  var Mod = "Mod";
  var Multinomial = "Multinomial";
  var Multiply2 = "Multiply";
  var Neg = "Neg";
  var NotEqual = "NotEqual";
  var NonMaxSuppressionV3 = "NonMaxSuppressionV3";
  var NonMaxSuppressionV4 = "NonMaxSuppressionV4";
  var NonMaxSuppressionV5 = "NonMaxSuppressionV5";
  var OnesLike = "OnesLike";
  var OneHot = "OneHot";
  var Pack = "Pack";
  var PadV2 = "PadV2";
  var Pow = "Pow";
  var Prelu = "Prelu";
  var Prod = "Prod";
  var RaggedGather = "RaggedGather";
  var RaggedRange = "RaggedRange";
  var RaggedTensorToTensor = "RaggedTensorToTensor";
  var Range = "Range";
  var Real = "Real";
  var Reciprocal = "Reciprocal";
  var Relu2 = "Relu";
  var Reshape2 = "Reshape";
  var ResizeNearestNeighbor = "ResizeNearestNeighbor";
  var ResizeNearestNeighborGrad = "ResizeNearestNeighborGrad";
  var ResizeBilinear = "ResizeBilinear";
  var ResizeBilinearGrad = "ResizeBilinearGrad";
  var Relu62 = "Relu6";
  var Reverse = "Reverse";
  var Round = "Round";
  var Rsqrt = "Rsqrt";
  var ScatterNd = "ScatterNd";
  var SearchSorted = "SearchSorted";
  var Select = "Select";
  var Selu2 = "Selu";
  var Slice = "Slice";
  var Sin = "Sin";
  var Sinh = "Sinh";
  var Sign = "Sign";
  var Sigmoid2 = "Sigmoid";
  var Softplus2 = "Softplus";
  var Sqrt = "Sqrt";
  var Sum = "Sum";
  var SpaceToBatchND = "SpaceToBatchND";
  var SplitV = "SplitV";
  var Softmax2 = "Softmax";
  var SparseFillEmptyRows = "SparseFillEmptyRows";
  var SparseReshape = "SparseReshape";
  var SparseSegmentMean = "SparseSegmentMean";
  var SparseSegmentSum = "SparseSegmentSum";
  var SparseToDense = "SparseToDense";
  var SquaredDifference = "SquaredDifference";
  var Square = "Square";
  var StridedSlice = "StridedSlice";
  var StringNGrams = "StringNGrams";
  var StringSplit = "StringSplit";
  var StringToHashBucketFast = "StringToHashBucketFast";
  var Sub = "Sub";
  var Tan = "Tan";
  var Tanh2 = "Tanh";
  var Tile = "Tile";
  var TopK = "TopK";
  var Transform = "Transform";
  var Transpose = "Transpose";
  var Unique = "Unique";
  var Unpack = "Unpack";
  var UnsortedSegmentSum = "UnsortedSegmentSum";
  var ZerosLike = "ZerosLike";
  var Step = "Step";
  var FromPixels = "FromPixels";
  var RotateWithOffset = "RotateWithOffset";
  var _FusedMatMul = "_FusedMatMul";
  var FusedConv2D = "FusedConv2D";
  var FusedDepthwiseConv2D = "FusedDepthwiseConv2D";

  // node_modules/@tensorflow/tfjs-core/dist/log.js
  function warn(...msg) {
    if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
      console.warn(...msg);
    }
  }
  function log(...msg) {
    if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
      console.log(...msg);
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/kernel_registry.js
  var kernelRegistry = getGlobal("kernelRegistry", () => /* @__PURE__ */ new Map());
  var gradRegistry = getGlobal("gradRegistry", () => /* @__PURE__ */ new Map());
  function getKernel(kernelName, backendName) {
    const key = makeKey(kernelName, backendName);
    return kernelRegistry.get(key);
  }
  function getGradient(kernelName) {
    return gradRegistry.get(kernelName);
  }
  function getKernelsForBackend(backendName) {
    const it3 = kernelRegistry.entries();
    const result = [];
    while (true) {
      const { done, value } = it3.next();
      if (done) {
        break;
      }
      const [key, config] = value;
      const [backend] = key.split("_");
      if (backend === backendName) {
        result.push(config);
      }
    }
    return result;
  }
  function registerKernel(config) {
    const { kernelName, backendName } = config;
    const key = makeKey(kernelName, backendName);
    if (kernelRegistry.has(key)) {
      warn(`The kernel '${kernelName}' for backend '${backendName}' is already registered`);
    }
    kernelRegistry.set(key, config);
  }
  function makeKey(kernelName, backendName) {
    return `${backendName}_${kernelName}`;
  }

  // node_modules/@tensorflow/tfjs-core/dist/util.js
  var util_exports = {};
  __export(util_exports, {
    arraysEqual: () => arraysEqual,
    assert: () => assert2,
    assertNonNegativeIntegerDimensions: () => assertNonNegativeIntegerDimensions,
    assertNonNull: () => assertNonNull,
    assertShapesMatch: () => assertShapesMatch,
    bytesFromStringArray: () => bytesFromStringArray,
    bytesPerElement: () => bytesPerElement,
    checkConversionForErrors: () => checkConversionForErrors,
    clamp: () => clamp,
    computeStrides: () => computeStrides,
    convertBackendValuesAndArrayBuffer: () => convertBackendValuesAndArrayBuffer,
    createScalarValue: () => createScalarValue,
    createShuffledIndices: () => createShuffledIndices,
    decodeString: () => decodeString,
    distSquared: () => distSquared,
    encodeString: () => encodeString,
    fetch: () => fetch3,
    fingerPrint64: () => fingerPrint64,
    flatten: () => flatten2,
    getArrayFromDType: () => getArrayFromDType,
    getTypedArrayFromDType: () => getTypedArrayFromDType,
    hasEncodingLoss: () => hasEncodingLoss,
    hexToLong: () => hexToLong,
    indexToLoc: () => indexToLoc,
    inferDtype: () => inferDtype,
    inferFromImplicitShape: () => inferFromImplicitShape,
    isBoolean: () => isBoolean,
    isFunction: () => isFunction,
    isInt: () => isInt,
    isNumber: () => isNumber,
    isPromise: () => isPromise,
    isScalarShape: () => isScalarShape,
    isString: () => isString,
    isTypedArray: () => isTypedArray,
    isValidDtype: () => isValidDtype,
    locToIndex: () => locToIndex,
    makeOnesTypedArray: () => makeOnesTypedArray,
    makeZerosNestedTypedArray: () => makeZerosNestedTypedArray,
    makeZerosTypedArray: () => makeZerosTypedArray,
    nearestDivisor: () => nearestDivisor,
    nearestLargerEven: () => nearestLargerEven,
    now: () => now,
    parseAxisParam: () => parseAxisParam,
    randUniform: () => randUniform,
    repeatedTry: () => repeatedTry,
    rightPad: () => rightPad,
    shuffle: () => shuffle,
    shuffleCombo: () => shuffleCombo,
    sizeFromShape: () => sizeFromShape,
    sizeToSquarishShape: () => sizeToSquarishShape,
    squeezeShape: () => squeezeShape,
    sum: () => sum,
    swap: () => swap,
    tanh: () => tanh,
    toNestedArray: () => toNestedArray,
    toTypedArray: () => toTypedArray
  });

  // node_modules/@tensorflow/tfjs-core/dist/hash_util.js
  var LongExports = __toESM(require_long());
  var Long = (
    // tslint:disable-next-line
    LongExports.default || LongExports
  );
  function hexToLong(hex) {
    return Long.fromString(hex, true, 16);
  }
  var k0 = hexToLong("c3a5c85c97cb3127");
  var k1 = hexToLong("b492b66fbe98f273");
  var k2 = hexToLong("9ae16a3b2f90404f");
  function shiftMix(val) {
    return val.xor(val.shru(47));
  }
  function fetch2(s2, offset, numBytes) {
    const bytes = s2.slice(offset, offset + numBytes);
    return Long.fromBytes(Array.from(bytes), true, true);
  }
  function fetch64(s2, offset) {
    return fetch2(s2, offset, 8);
  }
  function fetch32(s2, offset) {
    return fetch2(s2, offset, 4);
  }
  function rotate64(val, shift) {
    return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));
  }
  function hashLen16(u2, v2, mul2 = hexToLong("9ddfea08eb382d69")) {
    let a2 = u2.xor(v2).mul(mul2);
    a2 = a2.xor(a2.shru(47));
    let b2 = v2.xor(a2).mul(mul2);
    b2 = b2.xor(b2.shru(47));
    b2 = b2.mul(mul2);
    return b2;
  }
  function weakHashLen32WithSeeds(w2, x2, y2, z3, a2, b2) {
    a2 = a2.add(w2);
    b2 = rotate64(b2.add(a2).add(z3), 21);
    const c2 = a2;
    a2 = a2.add(x2);
    a2 = a2.add(y2);
    b2 = b2.add(rotate64(a2, 44));
    return [a2.add(z3), b2.add(c2)];
  }
  function weakHashLen32WithSeedsStr(s2, offset, a2, b2) {
    return weakHashLen32WithSeeds(fetch64(s2, offset), fetch64(s2, offset + 8), fetch64(s2, offset + 16), fetch64(s2, offset + 24), a2, b2);
  }
  function hashLen0to16(s2, len = s2.length) {
    if (len >= 8) {
      const mul2 = k2.add(len * 2);
      const a2 = fetch64(s2, 0).add(k2);
      const b2 = fetch64(s2, len - 8);
      const c2 = rotate64(b2, 37).mul(mul2).add(a2);
      const d2 = rotate64(a2, 25).add(b2).mul(mul2);
      return hashLen16(c2, d2, mul2);
    }
    if (len >= 4) {
      const mul2 = k2.add(len * 2);
      const a2 = fetch32(s2, 0);
      return hashLen16(a2.shl(3).add(len), fetch32(s2, len - 4), mul2);
    }
    if (len > 0) {
      const a2 = s2[0];
      const b2 = s2[len >> 1];
      const c2 = s2[len - 1];
      const y2 = a2 + (b2 << 8);
      const z3 = len + (c2 << 2);
      return shiftMix(k2.mul(y2).xor(k0.mul(z3))).mul(k2);
    }
    return k2;
  }
  function hashLen17to32(s2, len = s2.length) {
    const mul2 = k2.add(len * 2);
    const a2 = fetch64(s2, 0).mul(k1);
    const b2 = fetch64(s2, 8);
    const c2 = fetch64(s2, len - 8).mul(mul2);
    const d2 = fetch64(s2, len - 16).mul(k2);
    return hashLen16(rotate64(a2.add(b2), 43).add(rotate64(c2, 30)).add(d2), a2.add(rotate64(b2.add(k2), 18)).add(c2), mul2);
  }
  function hashLen33to64(s2, len = s2.length) {
    const mul2 = k2.add(len * 2);
    const a2 = fetch64(s2, 0).mul(k2);
    const b2 = fetch64(s2, 8);
    const c2 = fetch64(s2, len - 8).mul(mul2);
    const d2 = fetch64(s2, len - 16).mul(k2);
    const y2 = rotate64(a2.add(b2), 43).add(rotate64(c2, 30)).add(d2);
    const z3 = hashLen16(y2, a2.add(rotate64(b2.add(k2), 18)).add(c2), mul2);
    const e2 = fetch64(s2, 16).mul(mul2);
    const f2 = fetch64(s2, 24);
    const g2 = y2.add(fetch64(s2, len - 32)).mul(mul2);
    const h = z3.add(fetch64(s2, len - 24)).mul(mul2);
    return hashLen16(rotate64(e2.add(f2), 43).add(rotate64(g2, 30)).add(h), e2.add(rotate64(f2.add(a2), 18)).add(g2), mul2);
  }
  function fingerPrint64(s2, len = s2.length) {
    const seed = Long.fromNumber(81, true);
    if (len <= 32) {
      if (len <= 16) {
        return hashLen0to16(s2, len);
      } else {
        return hashLen17to32(s2, len);
      }
    } else if (len <= 64) {
      return hashLen33to64(s2, len);
    }
    let x2 = seed;
    let y2 = seed.mul(k1).add(113);
    let z3 = shiftMix(y2.mul(k2).add(113)).mul(k2);
    let v2 = [Long.UZERO, Long.UZERO];
    let w2 = [Long.UZERO, Long.UZERO];
    x2 = x2.mul(k2).add(fetch64(s2, 0));
    let offset = 0;
    const end = (len - 1 >> 6) * 64;
    const last64 = end + (len - 1 & 63) - 63;
    do {
      x2 = rotate64(x2.add(y2).add(v2[0]).add(fetch64(s2, offset + 8)), 37).mul(k1);
      y2 = rotate64(y2.add(v2[1]).add(fetch64(s2, offset + 48)), 42).mul(k1);
      x2 = x2.xor(w2[1]);
      y2 = y2.add(v2[0]).add(fetch64(s2, offset + 40));
      z3 = rotate64(z3.add(w2[0]), 33).mul(k1);
      v2 = weakHashLen32WithSeedsStr(s2, offset, v2[1].mul(k1), x2.add(w2[0]));
      w2 = weakHashLen32WithSeedsStr(s2, offset + 32, z3.add(w2[1]), y2.add(fetch64(s2, offset + 16)));
      [z3, x2] = [x2, z3];
      offset += 64;
    } while (offset !== end);
    const mul2 = k1.add(z3.and(255).shl(1));
    offset = last64;
    w2[0] = w2[0].add(len - 1 & 63);
    v2[0] = v2[0].add(w2[0]);
    w2[0] = w2[0].add(v2[0]);
    x2 = rotate64(x2.add(y2).add(v2[0]).add(fetch64(s2, offset + 8)), 37).mul(mul2);
    y2 = rotate64(y2.add(v2[1]).add(fetch64(s2, offset + 48)), 42).mul(mul2);
    x2 = x2.xor(w2[1].mul(9));
    y2 = y2.add(v2[0].mul(9).add(fetch64(s2, offset + 40)));
    z3 = rotate64(z3.add(w2[0]), 33).mul(mul2);
    v2 = weakHashLen32WithSeedsStr(s2, offset, v2[1].mul(mul2), x2.add(w2[0]));
    w2 = weakHashLen32WithSeedsStr(s2, offset + 32, z3.add(w2[1]), y2.add(fetch64(s2, offset + 16)));
    [z3, x2] = [x2, z3];
    return hashLen16(hashLen16(v2[0], w2[0], mul2).add(shiftMix(y2).mul(k0)).add(z3), hashLen16(v2[1], w2[1], mul2).add(x2), mul2);
  }

  // node_modules/@tensorflow/tfjs-core/dist/util.js
  function createScalarValue(value, dtype) {
    if (dtype === "string") {
      return encodeString(value);
    }
    return toTypedArray([value], dtype);
  }
  function noConversionNeeded(a2, dtype) {
    return a2 instanceof Float32Array && dtype === "float32" || a2 instanceof Int32Array && dtype === "int32" || a2 instanceof Uint8Array && dtype === "bool";
  }
  function toTypedArray(a2, dtype) {
    if (dtype === "string") {
      throw new Error("Cannot convert a string[] to a TypedArray");
    }
    if (Array.isArray(a2)) {
      a2 = flatten2(a2);
    }
    if (env().getBool("DEBUG")) {
      checkConversionForErrors(a2, dtype);
    }
    if (noConversionNeeded(a2, dtype)) {
      return a2;
    }
    if (dtype == null || dtype === "float32" || dtype === "complex64") {
      return new Float32Array(a2);
    } else if (dtype === "int32") {
      return new Int32Array(a2);
    } else if (dtype === "bool") {
      const bool = new Uint8Array(a2.length);
      for (let i2 = 0; i2 < bool.length; ++i2) {
        if (Math.round(a2[i2]) !== 0) {
          bool[i2] = 1;
        }
      }
      return bool;
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
  }
  function now() {
    return env().platform.now();
  }
  function fetch3(path, requestInits) {
    return env().platform.fetch(path, requestInits);
  }
  function encodeString(s2, encoding = "utf-8") {
    encoding = encoding || "utf-8";
    return env().platform.encode(s2, encoding);
  }
  function decodeString(bytes, encoding = "utf-8") {
    encoding = encoding || "utf-8";
    return env().platform.decode(bytes, encoding);
  }
  function isTypedArray(a2) {
    return env().platform.isTypedArray(a2);
  }
  function flatten2(arr, result = [], skipTypedArray = false) {
    if (result == null) {
      result = [];
    }
    if (typeof arr === "boolean" || typeof arr === "number" || typeof arr === "string" || isPromise(arr) || arr == null || isTypedArray(arr) && skipTypedArray) {
      result.push(arr);
    } else if (Array.isArray(arr) || isTypedArray(arr)) {
      for (let i2 = 0; i2 < arr.length; ++i2) {
        flatten2(arr[i2], result, skipTypedArray);
      }
    } else {
      let maxIndex = -1;
      for (const key of Object.keys(arr)) {
        if (/^([1-9]+[0-9]*|0)$/.test(key)) {
          maxIndex = Math.max(maxIndex, Number(key));
        }
      }
      for (let i2 = 0; i2 <= maxIndex; i2++) {
        flatten2(arr[i2], result, skipTypedArray);
      }
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-core/dist/profiler.js
  var Profiler = class {
    constructor(backendTimer, logger) {
      this.backendTimer = backendTimer;
      this.logger = logger;
      if (logger == null) {
        this.logger = new Logger();
      }
    }
    profileKernel(kernelName, inputs, f2) {
      let outputs;
      const holdResultWrapperFn = () => {
        outputs = f2();
      };
      let timer;
      const start = now();
      if (this.backendTimer.timerAvailable()) {
        timer = this.backendTimer.time(holdResultWrapperFn);
      } else {
        holdResultWrapperFn();
        for (const output of outputs) {
          output.dataSync();
        }
        timer = Promise.resolve({ kernelMs: now() - start });
      }
      if (env().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
        for (let i2 = 0; i2 < outputs.length; i2++) {
          const output = outputs[i2];
          output.data().then((tensorVals) => {
            checkComputationForErrors(tensorVals, output.dtype, kernelName);
          });
        }
      }
      const kernelProfile = {
        kernelName,
        outputs,
        inputs,
        timeMs: timer.then((timing) => timing.kernelMs),
        extraInfo: timer.then((timing) => timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : "")
      };
      return kernelProfile;
    }
    logKernelProfile(kernelProfile) {
      const { kernelName, outputs, timeMs, inputs, extraInfo } = kernelProfile;
      outputs.forEach((result) => {
        Promise.all([result.data(), timeMs, extraInfo]).then((valueContainer) => {
          this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
        });
      });
    }
  };
  function checkComputationForErrors(vals, dtype, kernelName) {
    if (dtype !== "float32") {
      return false;
    }
    for (let i2 = 0; i2 < vals.length; i2++) {
      const num = vals[i2];
      if (isNaN(num) || !isFinite(num)) {
        console.warn(`Found ${num} in the result of '${kernelName}'`);
        return true;
      }
    }
    return false;
  }
  var Logger = class {
    logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {
      const time = typeof timeMs === "number" ? rightPad(`${timeMs}ms`, 9) : timeMs["error"];
      const paddedName = rightPad(name, 25);
      const rank = result.rank;
      const size = result.size;
      const shape = rightPad(result.shape.toString(), 14);
      let inputShapesDescription = "";
      for (const name2 in inputs) {
        const input2 = inputs[name2];
        if (input2 != null) {
          const inputShape = input2.shape || result.shape;
          const inputRank = inputShape.length;
          inputShapesDescription += `${name2}: ${inputRank}D ${inputRank > 0 ? inputShape : ""} `;
        }
      }
      console.log(`%c${paddedName}	%c${time}	%c${rank}D ${shape}	%c${size}	%c${inputShapesDescription}	%c${extraInfo}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/tape.js
  function getFilteredNodesXToY(tape, xs2, y2) {
    const tensorsFromX = {};
    const nodesFromX = {};
    for (let i2 = 0; i2 < xs2.length; i2++) {
      tensorsFromX[xs2[i2].id] = true;
    }
    for (let i2 = 0; i2 < tape.length; i2++) {
      const node = tape[i2];
      const nodeInputs = node.inputs;
      for (const inputName in nodeInputs) {
        const input2 = nodeInputs[inputName];
        let anyInputFromX = false;
        for (let j3 = 0; j3 < xs2.length; j3++) {
          if (tensorsFromX[input2.id]) {
            node.outputs.forEach((output) => tensorsFromX[output.id] = true);
            anyInputFromX = true;
            nodesFromX[node.id] = true;
            break;
          }
        }
        if (anyInputFromX) {
          break;
        }
      }
    }
    const tensorsLeadToY = {};
    tensorsLeadToY[y2.id] = true;
    const nodesToY = {};
    for (let i2 = tape.length - 1; i2 >= 0; i2--) {
      const node = tape[i2];
      const nodeInputs = node.inputs;
      for (let j3 = 0; j3 < node.outputs.length; j3++) {
        if (tensorsLeadToY[node.outputs[j3].id]) {
          for (const inputName in nodeInputs) {
            tensorsLeadToY[nodeInputs[inputName].id] = true;
            nodesToY[node.id] = true;
          }
          break;
        }
      }
    }
    const filteredTape = [];
    for (let i2 = 0; i2 < tape.length; i2++) {
      const node = tape[i2];
      if (nodesFromX[node.id] && nodesToY[node.id]) {
        const prunedInputs = {};
        for (const inputName in node.inputs) {
          const nodeInput = node.inputs[inputName];
          if (tensorsFromX[nodeInput.id]) {
            prunedInputs[inputName] = nodeInput;
          }
        }
        const prunedNode = Object.assign({}, node);
        prunedNode.inputs = prunedInputs;
        prunedNode.outputs = node.outputs;
        filteredTape.push(prunedNode);
      }
    }
    return filteredTape;
  }
  function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy2, add4) {
    for (let i2 = filteredTape.length - 1; i2 >= 0; i2--) {
      const node = filteredTape[i2];
      const dys = [];
      node.outputs.forEach((o2) => {
        const gradTensor = tensorAccumulatedGradientMap[o2.id];
        if (gradTensor != null) {
          dys.push(gradTensor);
        } else {
          dys.push(null);
        }
      });
      if (node.gradient == null) {
        throw new Error(`Cannot compute gradient: gradient function not found for ${node.kernelName}.`);
      }
      const inputGradients = node.gradient(dys);
      for (const inputName in node.inputs) {
        if (!(inputName in inputGradients)) {
          throw new Error(`Cannot backprop through input ${inputName}. Available gradients found: ${Object.keys(inputGradients)}.`);
        }
        const dx = tidy2(() => inputGradients[inputName]());
        if (dx.dtype !== "float32") {
          throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
        }
        const x2 = node.inputs[inputName];
        if (!arraysEqual(dx.shape, x2.shape)) {
          throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input '${inputName}' has shape '${dx.shape}', which does not match the shape of the input '${x2.shape}'`);
        }
        if (tensorAccumulatedGradientMap[x2.id] == null) {
          tensorAccumulatedGradientMap[x2.id] = dx;
        } else {
          const curGradient = tensorAccumulatedGradientMap[x2.id];
          tensorAccumulatedGradientMap[x2.id] = add4(curGradient, dx);
          curGradient.dispose();
        }
      }
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/tensor_format.js
  var FORMAT_LIMIT_NUM_VALS = 20;
  var FORMAT_NUM_FIRST_LAST_VALS = 3;
  var FORMAT_NUM_SIG_DIGITS = 7;
  function tensorToString(vals, shape, dtype, verbose) {
    const strides = computeStrides(shape);
    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
    const rank = shape.length;
    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
    const lines = ["Tensor"];
    if (verbose) {
      lines.push(`  dtype: ${dtype}`);
      lines.push(`  rank: ${rank}`);
      lines.push(`  shape: [${shape}]`);
      lines.push(`  values:`);
    }
    lines.push(valsLines.map((l3) => "    " + l3).join("\n"));
    return lines.join("\n");
  }
  function computeMaxSizePerColumn(vals, shape, dtype, strides) {
    const n2 = sizeFromShape(shape);
    const numCols = strides[strides.length - 1];
    const padPerCol = new Array(numCols).fill(0);
    const rank = shape.length;
    const valuesOrTuples = dtype === "complex64" ? createComplexTuples(vals) : vals;
    if (rank > 1) {
      for (let row = 0; row < n2 / numCols; row++) {
        const offset = row * numCols;
        for (let j3 = 0; j3 < numCols; j3++) {
          padPerCol[j3] = Math.max(padPerCol[j3], valToString(valuesOrTuples[offset + j3], 0, dtype).length);
        }
      }
    }
    return padPerCol;
  }
  function valToString(val, pad2, dtype) {
    let valStr;
    if (Array.isArray(val)) {
      valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;
    } else if (isString(val)) {
      valStr = `'${val}'`;
    } else if (dtype === "bool") {
      valStr = boolNumToString(val);
    } else {
      valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
    }
    return rightPad(valStr, pad2);
  }
  function boolNumToString(v2) {
    return v2 === 0 ? "false" : "true";
  }
  function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {
    const storagePerElement = dtype === "complex64" ? 2 : 1;
    const size = shape[0];
    const rank = shape.length;
    if (rank === 0) {
      if (dtype === "complex64") {
        const complexTuple = createComplexTuples(vals);
        return [valToString(complexTuple[0], 0, dtype)];
      }
      if (dtype === "bool") {
        return [boolNumToString(vals[0])];
      }
      return [vals[0].toString()];
    }
    if (rank === 1) {
      if (size > FORMAT_LIMIT_NUM_VALS) {
        const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
        let firstVals = Array.from(vals.slice(0, firstValsSize));
        let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));
        if (dtype === "complex64") {
          firstVals = createComplexTuples(firstVals);
          lastVals = createComplexTuples(lastVals);
        }
        return [
          "[" + firstVals.map((x2, i2) => valToString(x2, padPerCol[i2], dtype)).join(", ") + ", ..., " + lastVals.map((x2, i2) => valToString(x2, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i2], dtype)).join(", ") + "]"
        ];
      }
      const displayVals = dtype === "complex64" ? createComplexTuples(vals) : Array.from(vals);
      return [
        "[" + displayVals.map((x2, i2) => valToString(x2, padPerCol[i2], dtype)).join(", ") + "]"
      ];
    }
    const subshape = shape.slice(1);
    const substrides = strides.slice(1);
    const stride = strides[0] * storagePerElement;
    const lines = [];
    if (size > FORMAT_LIMIT_NUM_VALS) {
      for (let i2 = 0; i2 < FORMAT_NUM_FIRST_LAST_VALS; i2++) {
        const start = i2 * stride;
        const end = start + stride;
        lines.push(...subTensorToString(
          vals.slice(start, end),
          subshape,
          dtype,
          substrides,
          padPerCol,
          false
          /* isLast */
        ));
      }
      lines.push("...");
      for (let i2 = size - FORMAT_NUM_FIRST_LAST_VALS; i2 < size; i2++) {
        const start = i2 * stride;
        const end = start + stride;
        lines.push(...subTensorToString(
          vals.slice(start, end),
          subshape,
          dtype,
          substrides,
          padPerCol,
          i2 === size - 1
          /* isLast */
        ));
      }
    } else {
      for (let i2 = 0; i2 < size; i2++) {
        const start = i2 * stride;
        const end = start + stride;
        lines.push(...subTensorToString(
          vals.slice(start, end),
          subshape,
          dtype,
          substrides,
          padPerCol,
          i2 === size - 1
          /* isLast */
        ));
      }
    }
    const sep = rank === 2 ? "," : "";
    lines[0] = "[" + (size > 0 ? lines[0] + sep : "");
    for (let i2 = 1; i2 < lines.length - 1; i2++) {
      lines[i2] = " " + lines[i2] + sep;
    }
    let newLineSep = ",\n";
    for (let i2 = 2; i2 < rank; i2++) {
      newLineSep += "\n";
    }
    lines[lines.length - 1] = " " + lines[lines.length - 1] + "]" + (isLast ? "" : newLineSep);
    return lines;
  }
  function createComplexTuples(vals) {
    const complexTuples = [];
    for (let i2 = 0; i2 < vals.length; i2 += 2) {
      complexTuples.push([vals[i2], vals[i2 + 1]]);
    }
    return complexTuples;
  }

  // node_modules/@tensorflow/tfjs-core/dist/tensor.js
  var TensorBuffer = class {
    constructor(shape, dtype, values) {
      this.dtype = dtype;
      this.shape = shape.slice();
      this.size = sizeFromShape(shape);
      if (values != null) {
        const n2 = values.length;
        assert2(n2 === this.size, () => `Length of values '${n2}' does not match the size inferred by the shape '${this.size}'.`);
      }
      if (dtype === "complex64") {
        throw new Error(`complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).`);
      }
      this.values = values || getArrayFromDType(dtype, this.size);
      this.strides = computeStrides(shape);
    }
    /**
     * Sets a value in the buffer at a given location.
     *
     * @param value The value to set.
     * @param locs  The location indices.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */
    set(value, ...locs) {
      if (locs.length === 0) {
        locs = [0];
      }
      assert2(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must match the rank (${this.rank})`);
      const index = this.locToIndex(locs);
      this.values[index] = value;
    }
    /**
     * Returns the value in the buffer at the provided location.
     *
     * @param locs The location indices.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */
    get(...locs) {
      if (locs.length === 0) {
        locs = [0];
      }
      let i2 = 0;
      for (const loc of locs) {
        if (loc < 0 || loc >= this.shape[i2]) {
          const msg = `Requested out of range element at ${locs}.   Buffer shape=${this.shape}`;
          throw new Error(msg);
        }
        i2++;
      }
      let index = locs[locs.length - 1];
      for (let i3 = 0; i3 < locs.length - 1; ++i3) {
        index += this.strides[i3] * locs[i3];
      }
      return this.values[index];
    }
    locToIndex(locs) {
      if (this.rank === 0) {
        return 0;
      } else if (this.rank === 1) {
        return locs[0];
      }
      let index = locs[locs.length - 1];
      for (let i2 = 0; i2 < locs.length - 1; ++i2) {
        index += this.strides[i2] * locs[i2];
      }
      return index;
    }
    indexToLoc(index) {
      if (this.rank === 0) {
        return [];
      } else if (this.rank === 1) {
        return [index];
      }
      const locs = new Array(this.shape.length);
      for (let i2 = 0; i2 < locs.length - 1; ++i2) {
        locs[i2] = Math.floor(index / this.strides[i2]);
        index -= locs[i2] * this.strides[i2];
      }
      locs[locs.length - 1] = index;
      return locs;
    }
    get rank() {
      return this.shape.length;
    }
    /**
     * Creates an immutable `tf.Tensor` object from the buffer.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */
    toTensor() {
      return trackerFn().makeTensor(this.values, this.shape, this.dtype);
    }
  };
  var trackerFn = null;
  var opHandler = null;
  var deprecationWarningFn = null;
  function setTensorTracker(fn2) {
    trackerFn = fn2;
  }
  function setOpHandler(handler) {
    opHandler = handler;
  }
  function setDeprecationWarningFn(fn2) {
    deprecationWarningFn = fn2;
  }
  var Tensor = class {
    constructor(shape, dtype, dataId, id) {
      this.kept = false;
      this.isDisposedInternal = false;
      this.shape = shape.slice();
      this.dtype = dtype || "float32";
      this.size = sizeFromShape(shape);
      this.strides = computeStrides(shape);
      this.dataId = dataId;
      this.id = id;
      this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    get rank() {
      return this.shape.length;
    }
    /**
     * Returns a promise of `tf.TensorBuffer` that holds the underlying data.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    async buffer() {
      const vals = await this.data();
      return opHandler.buffer(this.shape, this.dtype, vals);
    }
    /**
     * Returns a `tf.TensorBuffer` that holds the underlying data.
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    bufferSync() {
      return opHandler.buffer(this.shape, this.dtype, this.dataSync());
    }
    /**
     * Returns the tensor data as a nested array. The transfer of data is done
     * asynchronously.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    async array() {
      const vals = await this.data();
      return toNestedArray(this.shape, vals, this.dtype === "complex64");
    }
    /**
     * Returns the tensor data as a nested array. The transfer of data is done
     * synchronously.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    arraySync() {
      return toNestedArray(this.shape, this.dataSync(), this.dtype === "complex64");
    }
    /**
     * Asynchronously downloads the values from the `tf.Tensor`. Returns a
     * promise of `TypedArray` that resolves when the computation has finished.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    async data() {
      this.throwIfDisposed();
      const data = trackerFn().read(this.dataId);
      if (this.dtype === "string") {
        const bytes = await data;
        try {
          return bytes.map((b2) => decodeString(b2));
        } catch (_a2) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return data;
    }
    /**
     * Copy the tensor's data to a new GPU resource. Comparing to the `dataSync()`
     * and `data()`, this method prevents data from being downloaded to CPU.
     *
     * For WebGL backend, the data will be stored on a densely packed texture.
     * This means that the texture will use the RGBA channels to store value.
     *
     * For WebGPU backend, the data will be stored on a buffer. There is no
     * parameter, so can not use a user-defined size to create the buffer.
     *
     * @param options:
     *     For WebGL,
     *         - customTexShape: Optional. If set, will use the user defined
     *     texture shape to create the texture.
     *
     * @returns For WebGL backend, a GPUData contains the new texture and
     *     its information.
     *     {
     *        tensorRef: The tensor that is associated with this texture,
     *        texture: WebGLTexture,
     *        texShape: [number, number] // [height, width]
     *     }
     *
     *     For WebGPU backend, a GPUData contains the new buffer and
     *     its information.
     *     {
     *        tensorRef: The tensor that is associated with this buffer,
     *        buffer: GPUBuffer,
     *        bufSize: number
     *     }
     *
     *     Remember to dispose the GPUData after it is used by
     *     `res.tensorRef.dispose()`.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    dataToGPU(options) {
      this.throwIfDisposed();
      return trackerFn().readToGPU(this.dataId, options);
    }
    /**
     * Synchronously downloads the values from the `tf.Tensor`. This blocks the
     * UI thread until the values are ready, which can cause performance issues.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    dataSync() {
      this.throwIfDisposed();
      const data = trackerFn().readSync(this.dataId);
      if (this.dtype === "string") {
        try {
          return data.map((b2) => decodeString(b2));
        } catch (_a2) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return data;
    }
    /** Returns the underlying bytes of the tensor's data. */
    async bytes() {
      this.throwIfDisposed();
      const data = await trackerFn().read(this.dataId);
      if (this.dtype === "string") {
        return data;
      } else {
        return new Uint8Array(data.buffer);
      }
    }
    /**
     * Disposes `tf.Tensor` from memory.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    dispose() {
      if (this.isDisposed) {
        return;
      }
      trackerFn().disposeTensor(this);
      this.isDisposedInternal = true;
    }
    get isDisposed() {
      return this.isDisposedInternal;
    }
    throwIfDisposed() {
      if (this.isDisposed) {
        throw new Error(`Tensor is disposed.`);
      }
    }
    /**
     * Prints the `tf.Tensor`. See `tf.print` for details.
     *
     * @param verbose Whether to print verbose information about the tensor,
     *    including dtype and size.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    print(verbose = false) {
      return opHandler.print(this, verbose);
    }
    /**
     * Returns a copy of the tensor. See `tf.clone` for details.
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    clone() {
      this.throwIfDisposed();
      return opHandler.clone(this);
    }
    /**
     * Returns a human-readable description of the tensor. Useful for logging.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    toString(verbose = false) {
      const vals = this.dataSync();
      return tensorToString(vals, this.shape, this.dtype, verbose);
    }
    cast(dtype) {
      this.throwIfDisposed();
      return opHandler.cast(this, dtype);
    }
    variable(trainable = true, name, dtype) {
      this.throwIfDisposed();
      return trackerFn().makeVariable(this, trainable, name, dtype);
    }
  };
  Object.defineProperty(Tensor, Symbol.hasInstance, {
    value: (instance) => {
      return !!instance && instance.data != null && instance.dataSync != null && instance.throwIfDisposed != null;
    }
  });
  function getGlobalTensorClass() {
    return getGlobal("Tensor", () => {
      return Tensor;
    });
  }
  getGlobalTensorClass();
  var Variable = class extends Tensor {
    constructor(initialValue, trainable, name, tensorId) {
      super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
      this.trainable = trainable;
      this.name = name;
    }
    /**
     * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have
     * the same shape and dtype as the old `tf.Tensor`.
     *
     * @param newValue New tensor to be assigned to this variable.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    assign(newValue) {
      if (newValue.dtype !== this.dtype) {
        throw new Error(`dtype of the new value (${newValue.dtype}) and previous value (${this.dtype}) must match`);
      }
      if (!arraysEqual(newValue.shape, this.shape)) {
        throw new Error(`shape of the new value (${newValue.shape}) and previous value (${this.shape}) must match`);
      }
      trackerFn().disposeTensor(this);
      this.dataId = newValue.dataId;
      trackerFn().incRef(
        this,
        null
        /* backend */
      );
    }
    dispose() {
      trackerFn().disposeVariable(this);
      this.isDisposedInternal = true;
    }
  };
  Object.defineProperty(Variable, Symbol.hasInstance, {
    value: (instance) => {
      return instance instanceof Tensor && instance.assign != null && instance.assign instanceof Function;
    }
  });

  // node_modules/@tensorflow/tfjs-core/dist/types.js
  var Rank;
  (function(Rank2) {
    Rank2["R0"] = "R0";
    Rank2["R1"] = "R1";
    Rank2["R2"] = "R2";
    Rank2["R3"] = "R3";
    Rank2["R4"] = "R4";
    Rank2["R5"] = "R5";
    Rank2["R6"] = "R6";
  })(Rank || (Rank = {}));
  var UpcastInt32AndMap;
  (function(UpcastInt32AndMap2) {
    UpcastInt32AndMap2["float32"] = "float32";
    UpcastInt32AndMap2["int32"] = "int32";
    UpcastInt32AndMap2["bool"] = "int32";
    UpcastInt32AndMap2["complex64"] = "complex64";
  })(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
  var UpcastBoolAndMap;
  (function(UpcastBoolAndMap2) {
    UpcastBoolAndMap2["float32"] = "float32";
    UpcastBoolAndMap2["int32"] = "int32";
    UpcastBoolAndMap2["bool"] = "bool";
    UpcastBoolAndMap2["complex64"] = "complex64";
  })(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
  var UpcastFloat32AndMap;
  (function(UpcastFloat32AndMap2) {
    UpcastFloat32AndMap2["float32"] = "float32";
    UpcastFloat32AndMap2["int32"] = "float32";
    UpcastFloat32AndMap2["bool"] = "float32";
    UpcastFloat32AndMap2["complex64"] = "complex64";
  })(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
  var UpcastComplex64AndMap;
  (function(UpcastComplex64AndMap2) {
    UpcastComplex64AndMap2["float32"] = "complex64";
    UpcastComplex64AndMap2["int32"] = "complex64";
    UpcastComplex64AndMap2["bool"] = "complex64";
    UpcastComplex64AndMap2["complex64"] = "complex64";
  })(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
  var upcastTypeMap = {
    "float32": UpcastFloat32AndMap,
    "int32": UpcastInt32AndMap,
    "bool": UpcastBoolAndMap,
    "complex64": UpcastComplex64AndMap
  };
  function upcastType(typeA, typeB) {
    if (typeA === "string" || typeB === "string") {
      if (typeA === "string" && typeB === "string") {
        return "string";
      }
      throw new Error(`Can not upcast ${typeA} with ${typeB}`);
    }
    return upcastTypeMap[typeA][typeB];
  }
  function sumOutType(type) {
    return upcastType(type, "int32");
  }

  // node_modules/@tensorflow/tfjs-core/dist/tensor_util.js
  function makeTypesMatch(a2, b2) {
    if (a2.dtype === b2.dtype) {
      return [a2, b2];
    }
    const dtype = upcastType(a2.dtype, b2.dtype);
    return [a2.cast(dtype), b2.cast(dtype)];
  }
  function assertTypesMatch(a2, b2) {
    assert2(a2.dtype === b2.dtype, () => `The dtypes of the first(${a2.dtype}) and second(${b2.dtype}) input must match`);
  }
  function getTensorsInContainer(result) {
    const list = [];
    const seen = /* @__PURE__ */ new Set();
    walkTensorContainer(result, list, seen);
    return list;
  }
  function walkTensorContainer(container, list, seen) {
    if (container == null) {
      return;
    }
    if (container instanceof Tensor) {
      list.push(container);
      return;
    }
    if (!isIterable2(container)) {
      return;
    }
    const iterable = container;
    for (const k4 in iterable) {
      const val = iterable[k4];
      if (!seen.has(val)) {
        seen.add(val);
        walkTensorContainer(val, list, seen);
      }
    }
  }
  function isIterable2(obj) {
    return Array.isArray(obj) || typeof obj === "object";
  }

  // node_modules/@tensorflow/tfjs-core/dist/engine.js
  function isRegisteredKernelInvocation(kernelInvocation) {
    return kernelInvocation.kernelName != null;
  }
  var EngineState = class {
    constructor() {
      this.registeredVariables = {};
      this.nextTapeNodeId = 0;
      this.numBytes = 0;
      this.numTensors = 0;
      this.numStringTensors = 0;
      this.numDataBuffers = 0;
      this.gradientDepth = 0;
      this.kernelDepth = 0;
      this.scopeStack = [];
      this.numDataMovesStack = [];
      this.nextScopeId = 0;
      this.tensorInfo = /* @__PURE__ */ new WeakMap();
      this.profiling = false;
      this.activeProfile = {
        newBytes: 0,
        newTensors: 0,
        peakBytes: 0,
        kernels: [],
        result: null,
        get kernelNames() {
          return Array.from(new Set(this.kernels.map((k4) => k4.name)));
        }
      };
    }
    dispose() {
      for (const variableName in this.registeredVariables) {
        this.registeredVariables[variableName].dispose();
      }
    }
  };
  var Engine = class {
    constructor(ENV5) {
      this.ENV = ENV5;
      this.registry = {};
      this.registryFactory = {};
      this.pendingBackendInitId = 0;
      this.state = new EngineState();
    }
    async ready() {
      if (this.pendingBackendInit != null) {
        return this.pendingBackendInit.then(() => {
        });
      }
      if (this.backendInstance != null) {
        return;
      }
      const sortedBackends = this.getSortedBackends();
      for (let i2 = 0; i2 < sortedBackends.length; i2++) {
        const backendName = sortedBackends[i2];
        const success = await this.initializeBackend(backendName).success;
        if (success) {
          await this.setBackend(backendName);
          return;
        }
      }
      throw new Error(`Could not initialize any backends, all backend initializations failed.`);
    }
    get backend() {
      if (this.pendingBackendInit != null) {
        throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      }
      if (this.backendInstance == null) {
        const { name, asyncInit } = this.initializeBackendsAndReturnBest();
        if (asyncInit) {
          throw new Error(`The highest priority backend '${name}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        }
        this.setBackend(name);
      }
      return this.backendInstance;
    }
    backendNames() {
      return Object.keys(this.registryFactory);
    }
    findBackend(backendName) {
      if (!(backendName in this.registry)) {
        if (backendName in this.registryFactory) {
          const { asyncInit } = this.initializeBackend(backendName);
          if (asyncInit) {
            return null;
          }
        } else {
          return null;
        }
      }
      return this.registry[backendName];
    }
    findBackendFactory(backendName) {
      if (!(backendName in this.registryFactory)) {
        return null;
      }
      return this.registryFactory[backendName].factory;
    }
    registerBackend(backendName, factory, priority = 1) {
      if (backendName in this.registryFactory) {
        warn(`${backendName} backend was already registered. Reusing existing backend factory.`);
        return false;
      }
      this.registryFactory[backendName] = { factory, priority };
      return true;
    }
    async setBackend(backendName) {
      if (this.registryFactory[backendName] == null) {
        throw new Error(`Backend name '${backendName}' not found in registry`);
      }
      this.backendName = backendName;
      if (this.registry[backendName] == null) {
        this.backendInstance = null;
        const { success, asyncInit } = this.initializeBackend(backendName);
        const result = asyncInit ? await success : success;
        if (!result) {
          return false;
        }
      }
      this.backendInstance = this.registry[backendName];
      this.setupRegisteredKernels();
      this.profiler = new Profiler(this.backendInstance);
      return true;
    }
    setupRegisteredKernels() {
      const kernels = getKernelsForBackend(this.backendName);
      kernels.forEach((kernel) => {
        if (kernel.setupFunc != null) {
          kernel.setupFunc(this.backendInstance);
        }
      });
    }
    disposeRegisteredKernels(backendName) {
      const kernels = getKernelsForBackend(backendName);
      kernels.forEach((kernel) => {
        if (kernel.disposeFunc != null) {
          kernel.disposeFunc(this.registry[backendName]);
        }
      });
    }
    /**
     * Initializes a backend by looking up the backend name in the factory
     * registry and calling the factory method. Returns a boolean representing
     * whether the initialization of the backend suceeded. Throws an error if
     * there is no backend in the factory registry.
     */
    initializeBackend(backendName) {
      const registryFactoryEntry = this.registryFactory[backendName];
      if (registryFactoryEntry == null) {
        throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
      }
      try {
        const backend = registryFactoryEntry.factory();
        if (backend && !(backend instanceof KernelBackend) && typeof backend.then === "function") {
          const promiseId = ++this.pendingBackendInitId;
          const success = backend.then((backendInstance) => {
            if (promiseId < this.pendingBackendInitId) {
              return false;
            }
            this.registry[backendName] = backendInstance;
            this.pendingBackendInit = null;
            return true;
          }).catch((err) => {
            if (promiseId < this.pendingBackendInitId) {
              return false;
            }
            this.pendingBackendInit = null;
            warn(`Initialization of backend ${backendName} failed`);
            warn(err.stack || err.message);
            return false;
          });
          this.pendingBackendInit = success;
          return { success, asyncInit: true };
        } else {
          this.registry[backendName] = backend;
          return { success: true, asyncInit: false };
        }
      } catch (err) {
        warn(`Initialization of backend ${backendName} failed`);
        warn(err.stack || err.message);
        return { success: false, asyncInit: false };
      }
    }
    removeBackend(backendName) {
      if (!(backendName in this.registryFactory)) {
        throw new Error(`${backendName} backend not found in registry`);
      }
      if (this.backendName === backendName && this.pendingBackendInit != null) {
        this.pendingBackendInitId++;
      }
      if (backendName in this.registry) {
        this.disposeRegisteredKernels(backendName);
        this.registry[backendName].dispose();
        delete this.registry[backendName];
      }
      delete this.registryFactory[backendName];
      if (this.backendName === backendName) {
        this.pendingBackendInit = null;
        this.backendName = null;
        this.backendInstance = null;
      }
    }
    getSortedBackends() {
      if (Object.keys(this.registryFactory).length === 0) {
        throw new Error("No backend found in registry.");
      }
      return Object.keys(this.registryFactory).sort((a2, b2) => {
        return this.registryFactory[b2].priority - this.registryFactory[a2].priority;
      });
    }
    initializeBackendsAndReturnBest() {
      const sortedBackends = this.getSortedBackends();
      for (let i2 = 0; i2 < sortedBackends.length; i2++) {
        const backendName = sortedBackends[i2];
        const { success, asyncInit } = this.initializeBackend(backendName);
        if (asyncInit || success) {
          return { name: backendName, asyncInit };
        }
      }
      throw new Error(`Could not initialize any backends, all backend initializations failed.`);
    }
    moveData(backend, dataId) {
      const info = this.state.tensorInfo.get(dataId);
      const srcBackend = info.backend;
      const values = this.readSync(dataId);
      const refCount = srcBackend.refCount(dataId);
      srcBackend.disposeData(dataId, true);
      info.backend = backend;
      backend.move(dataId, values, info.shape, info.dtype, refCount);
      if (this.shouldCheckForMemLeaks()) {
        this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
      }
    }
    tidy(nameOrFn, fn2) {
      let name = null;
      if (fn2 == null) {
        if (typeof nameOrFn !== "function") {
          throw new Error("Please provide a function to tidy()");
        }
        fn2 = nameOrFn;
      } else {
        if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
          throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
        }
        if (typeof fn2 !== "function") {
          throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
        }
        name = nameOrFn;
      }
      let result;
      return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {
        result = fn2();
        if (result instanceof Promise) {
          console.error("Cannot return a Promise inside of tidy.");
        }
        return result;
      });
    }
    scopedRun(start, end, f2) {
      start();
      try {
        const res = f2();
        end();
        return res;
      } catch (ex) {
        end();
        throw ex;
      }
    }
    nextTensorId() {
      return Engine.nextTensorId++;
    }
    nextVariableId() {
      return Engine.nextVariableId++;
    }
    /**
     * This method is called instead of the public-facing tensor.clone() when
     * saving a tensor for backwards pass. It makes sure to add the clone
     * operation to the tape regardless of being called inside a kernel
     * execution.
     */
    clone(x2) {
      const y2 = ENGINE.runKernel(Identity2, { x: x2 });
      const inputs = { x: x2 };
      const grad = (dy) => ({
        x: () => {
          const dtype = "float32";
          const gradInputs = { x: dy };
          const attrs = { dtype };
          return ENGINE.runKernel(
            Cast,
            gradInputs,
            // tslint:disable-next-line: no-unnecessary-type-assertion
            attrs
          );
        }
      });
      const saved = [];
      this.addTapeNode(this.state.activeScope.name, inputs, [y2], grad, saved, {});
      return y2;
    }
    /**
     * Execute a kernel with the given name and return the output tensor.
     *
     * @param kernelName The name of the kernel to execute.
     * @param inputs A map of input names to tensors.
     * @param attrs A map of attribute names to their values. An attribute is a
     *     primitive (non-tensor) input to the kernel.
     * @param inputsToSave A list of tensors, inputs to save for the backprop
     *     computation.
     * @param outputsToSave A list of booleans, specifying which output to save
     *     for the backprop computation. These are booleans since the output
     * tensors are not visible to the user.
     */
    runKernel(kernelName, inputs, attrs) {
      if (this.backendName == null) {
        this.backend;
      }
      const hasKernel = getKernel(kernelName, this.backendName) != null;
      if (!hasKernel) {
        throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);
      }
      return this.runKernelFunc({ kernelName, inputs, attrs });
    }
    shouldCheckForMemLeaks() {
      return this.ENV.getBool("IS_TEST");
    }
    checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
      const numDataIdsAfter = this.backend.numDataIds();
      let numOutputDataIds = 0;
      outInfos.forEach((info) => {
        numOutputDataIds += info.dtype === "complex64" ? 3 : 1;
      });
      const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
      const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
      if (dataIdsLeaked > 0) {
        throw new Error(`Backend '${this.backendName}' has an internal memory leak (${dataIdsLeaked} data ids) after running '${kernelName}'`);
      }
    }
    /**
     * Internal helper method to execute a kernel Func
     *
     * Use `runKernel` to execute kernels from outside of engine.
     */
    runKernelFunc(kernelParams) {
      let outputs;
      let saved = [];
      const isTapeOn = this.isTapeOn();
      const startingBytecount = this.state.numBytes;
      const startingNumTensors = this.state.numTensors;
      if (this.shouldCheckForMemLeaks()) {
        this.state.numDataMovesStack.push(0);
      }
      let kernelFunc;
      if (this.backendName == null) {
        this.backend;
      }
      let out;
      const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ? kernelParams.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
      if (isRegisteredKernelInvocation(kernelParams)) {
        const { kernelName, inputs: inputs2, attrs: attrs2 } = kernelParams;
        if (this.backendName == null) {
          this.backend;
        }
        const kernel = getKernel(kernelName, this.backendName);
        assert2(kernel != null, () => `Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`);
        kernelFunc = () => {
          const numDataIdsBefore = this.backend.numDataIds();
          out = kernel.kernelFunc({ inputs: inputs2, attrs: attrs2, backend: this.backend });
          const outInfos = Array.isArray(out) ? out : [out];
          if (this.shouldCheckForMemLeaks()) {
            this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
          }
          const outTensors = outInfos.map((outInfo) => {
            if (outInfo.rank != null) {
              return outInfo;
            }
            return this.makeTensorFromTensorInfo(outInfo);
          });
          if (isTapeOn) {
            const tensorsToSave = this.getTensorsForGradient(kernelName, inputs2, outTensors);
            saved = this.saveTensorsForBackwardMode(tensorsToSave);
          }
          return outTensors;
        };
      } else {
        const { forwardFunc } = kernelParams;
        const saveFunc = (tensors) => {
          if (!isTapeOn) {
            return;
          }
          saved = tensors.map((tensor2) => this.keep(this.clone(tensor2)));
        };
        kernelFunc = () => {
          const numDataIdsBefore = this.backend.numDataIds();
          out = this.tidy(() => forwardFunc(this.backend, saveFunc));
          const outs = Array.isArray(out) ? out : [out];
          if (this.shouldCheckForMemLeaks()) {
            this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
          }
          return outs;
        };
      }
      const { inputs, attrs } = kernelParams;
      const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ? null : kernelParams.backwardsFunc;
      let kernelProfile;
      this.scopedRun(
        // Stop recording to a tape when running a kernel.
        () => this.state.kernelDepth++,
        () => this.state.kernelDepth--,
        () => {
          if (!this.ENV.getBool("DEBUG") && !this.state.profiling) {
            outputs = kernelFunc();
          } else {
            kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, () => kernelFunc());
            if (this.ENV.getBool("DEBUG")) {
              this.profiler.logKernelProfile(kernelProfile);
            }
            outputs = kernelProfile.outputs;
          }
        }
      );
      if (isTapeOn) {
        this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
      }
      if (this.state.profiling) {
        this.state.activeProfile.kernels.push({
          name: kernelOrScopeName,
          bytesAdded: this.state.numBytes - startingBytecount,
          totalBytesSnapshot: this.state.numBytes,
          tensorsAdded: this.state.numTensors - startingNumTensors,
          totalTensorsSnapshot: this.state.numTensors,
          inputShapes: Object.keys(inputs).map((key) => inputs[key] != null ? inputs[key].shape : null),
          outputShapes: outputs.map((item) => item.shape),
          kernelTimeMs: kernelProfile.timeMs,
          extraInfo: kernelProfile.extraInfo
        });
      }
      return Array.isArray(out) ? outputs : outputs[0];
    }
    /**
     * Saves tensors used in forward mode for use in backward mode.
     *
     * @param tensors the list of tensors to save.
     */
    saveTensorsForBackwardMode(tensors) {
      const saved = tensors.map((tensor2) => this.keep(this.clone(tensor2)));
      return saved;
    }
    /**
     * Returns a list of tensors to save for a given gradient calculation.
     *
     * @param kernelName name of kernel to look up gradient for.
     * @param inputs a map of input tensors.
     * @param outputs an array of output tensors from forward mode of kernel.
     */
    getTensorsForGradient(kernelName, inputs, outputs) {
      const gradConfig = getGradient(kernelName);
      if (gradConfig != null) {
        const inputsToSave = gradConfig.inputsToSave || [];
        const outputsToSave = gradConfig.outputsToSave || [];
        let inputTensorsToSave;
        if (gradConfig.saveAllInputs) {
          assert2(Array.isArray(inputs), () => "saveAllInputs is true, expected inputs to be an array.");
          inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
        } else {
          inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
        }
        const outputTensorsToSave = outputs.filter((_3, i2) => outputsToSave[i2]);
        return inputTensorsToSave.concat(outputTensorsToSave);
      }
      return [];
    }
    /**
     * Internal method used by public APIs for tensor creation. Makes a new
     * tensor with the provided shape, dtype and values. It always
     * creates a new data id and writes the values to the underlying backend.
     */
    makeTensor(values, shape, dtype, backend) {
      if (values == null) {
        throw new Error("Values passed to engine.makeTensor() are null");
      }
      dtype = dtype || "float32";
      backend = backend || this.backend;
      let backendVals = values;
      if (dtype === "string" && isString(values[0])) {
        backendVals = values.map((d2) => encodeString(d2));
      }
      const dataId = backend.write(backendVals, shape, dtype);
      const t3 = new Tensor(shape, dtype, dataId, this.nextTensorId());
      this.trackTensor(t3, backend);
      if (dtype === "string") {
        const info = this.state.tensorInfo.get(dataId);
        const newBytes = bytesFromStringArray(backendVals);
        this.state.numBytes += newBytes - info.bytes;
        info.bytes = newBytes;
      }
      return t3;
    }
    /**
     * Internal method used by backends. Makes a new tensor
     * that is a wrapper around an existing data id. It doesn't create
     * a new data id, only increments the ref count used in memory tracking.
     * @deprecated
     */
    makeTensorFromDataId(dataId, shape, dtype, backend) {
      dtype = dtype || "float32";
      const tensorInfo = { dataId, shape, dtype };
      return this.makeTensorFromTensorInfo(tensorInfo, backend);
    }
    /**
     * Internal method used by backends. Makes a new tensor that is a wrapper
     * around an existing data id in TensorInfo. It doesn't create a new data id,
     * only increments the ref count used in memory tracking.
     */
    makeTensorFromTensorInfo(tensorInfo, backend) {
      const { dataId, shape, dtype } = tensorInfo;
      const t3 = new Tensor(shape, dtype, dataId, this.nextTensorId());
      this.trackTensor(t3, backend);
      return t3;
    }
    makeVariable(initialValue, trainable = true, name, dtype) {
      name = name || this.nextVariableId().toString();
      if (dtype != null && dtype !== initialValue.dtype) {
        initialValue = initialValue.cast(dtype);
      }
      const v2 = new Variable(initialValue, trainable, name, this.nextTensorId());
      if (this.state.registeredVariables[v2.name] != null) {
        throw new Error(`Variable with name ${v2.name} was already registered`);
      }
      this.state.registeredVariables[v2.name] = v2;
      this.incRef(v2, this.backend);
      return v2;
    }
    trackTensor(a2, backend) {
      this.state.numTensors++;
      if (a2.dtype === "string") {
        this.state.numStringTensors++;
      }
      let bytes = 0;
      if (a2.dtype !== "complex64" && a2.dtype !== "string") {
        bytes = a2.size * bytesPerElement(a2.dtype);
      }
      this.state.numBytes += bytes;
      if (!this.state.tensorInfo.has(a2.dataId)) {
        this.state.numDataBuffers++;
        this.state.tensorInfo.set(a2.dataId, {
          backend: backend || this.backend,
          dtype: a2.dtype,
          shape: a2.shape,
          bytes
        });
      }
      if (!(a2 instanceof Variable)) {
        this.track(a2);
      }
    }
    // Track the tensor by dataId and increase the refCount for the dataId in the
    // backend.
    // TODO(pyu10055): This is currently used by makeVariable method, to increase
    // refCount on the backend for the dataId. It can potentially be replaced with
    // Identity op indead of calling backend directly.
    incRef(a2, backend) {
      this.trackTensor(a2, backend);
      this.backend.incRef(a2.dataId);
    }
    removeDataId(dataId, backend) {
      if (this.state.tensorInfo.has(dataId) && this.state.tensorInfo.get(dataId).backend === backend) {
        this.state.tensorInfo.delete(dataId);
        this.state.numDataBuffers--;
      }
    }
    disposeTensor(a2) {
      if (!this.state.tensorInfo.has(a2.dataId)) {
        return;
      }
      const info = this.state.tensorInfo.get(a2.dataId);
      this.state.numTensors--;
      if (a2.dtype === "string") {
        this.state.numStringTensors--;
        this.state.numBytes -= info.bytes;
      }
      if (a2.dtype !== "complex64" && a2.dtype !== "string") {
        const bytes = a2.size * bytesPerElement(a2.dtype);
        this.state.numBytes -= bytes;
      }
      if (info.backend.disposeData(a2.dataId)) {
        this.removeDataId(a2.dataId, info.backend);
      }
    }
    disposeVariables() {
      for (const varName in this.state.registeredVariables) {
        const v2 = this.state.registeredVariables[varName];
        this.disposeVariable(v2);
      }
    }
    disposeVariable(v2) {
      this.disposeTensor(v2);
      if (this.state.registeredVariables[v2.name] != null) {
        delete this.state.registeredVariables[v2.name];
      }
    }
    memory() {
      const info = this.backend.memory();
      info.numTensors = this.state.numTensors;
      info.numDataBuffers = this.state.numDataBuffers;
      info.numBytes = this.state.numBytes;
      if (this.state.numStringTensors > 0) {
        info.unreliable = true;
        if (info.reasons == null) {
          info.reasons = [];
        }
        info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
      }
      return info;
    }
    async profile(query) {
      this.state.profiling = true;
      const startBytes = this.state.numBytes;
      const startNumTensors = this.state.numTensors;
      this.state.activeProfile.kernels = [];
      this.state.activeProfile.result = await query();
      this.state.profiling = false;
      this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((d2) => d2.totalBytesSnapshot));
      this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
      this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
      for (const kernel of this.state.activeProfile.kernels) {
        kernel.kernelTimeMs = await kernel.kernelTimeMs;
        kernel.extraInfo = await kernel.extraInfo;
      }
      return this.state.activeProfile;
    }
    isTapeOn() {
      return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
      const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };
      const gradConfig = getGradient(kernelName);
      if (gradConfig != null) {
        gradientsFunc = gradConfig.gradFunc;
      }
      if (gradientsFunc != null) {
        tapeNode.gradient = (dys) => {
          dys = dys.map((dy, i2) => {
            if (dy == null) {
              const output = outputs[i2];
              const vals = makeZerosTypedArray(output.size, output.dtype);
              return this.makeTensor(vals, output.shape, output.dtype);
            }
            return dy;
          });
          return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
        };
      }
      this.state.activeTape.push(tapeNode);
    }
    keep(result) {
      result.kept = true;
      return result;
    }
    startTape() {
      if (this.state.gradientDepth === 0) {
        this.state.activeTape = [];
      }
      this.state.gradientDepth++;
    }
    endTape() {
      this.state.gradientDepth--;
    }
    /**
     * Start a scope. Use this with endScope() to achieve the same functionality
     * as scope() without the need for a function closure.
     */
    startScope(name) {
      const scopeInfo = {
        track: [],
        name: "unnamed scope",
        id: this.state.nextScopeId++
      };
      if (name) {
        scopeInfo.name = name;
      }
      this.state.scopeStack.push(scopeInfo);
      this.state.activeScope = scopeInfo;
    }
    /**
     * End a scope. Use this with startScope() to achieve the same functionality
     * as scope() without the need for a function closure.
     */
    endScope(result) {
      const tensorsToTrackInParent = getTensorsInContainer(result);
      const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map((t3) => t3.id));
      for (let i2 = 0; i2 < this.state.activeScope.track.length; i2++) {
        const tensor2 = this.state.activeScope.track[i2];
        if (!tensor2.kept && !tensorsToTrackInParentSet.has(tensor2.id)) {
          tensor2.dispose();
        }
      }
      const oldScope = this.state.scopeStack.pop();
      this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
      tensorsToTrackInParent.forEach((tensor2) => {
        if (!tensor2.kept && tensor2.scopeId === oldScope.id) {
          this.track(tensor2);
        }
      });
    }
    /**
     * Returns gradients of `f` with respect to each of the `xs`. The gradients
     * returned are of the same length as `xs`, but some might be null if `f`
     * was not a function of that `x`. It also takes optional dy to multiply the
     * gradient, which defaults to `1`.
     */
    gradients(f2, xs2, dy, allowNoGradients = false) {
      assert2(xs2.length > 0, () => "gradients() received an empty list of xs.");
      if (dy != null && dy.dtype !== "float32") {
        throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
      }
      const y2 = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", f2));
      assert2(y2 instanceof Tensor, () => "The result y returned by f() must be a tensor.");
      const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs2, y2);
      if (!allowNoGradients && filteredTape.length === 0 && xs2.length > 0) {
        throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
      }
      return this.tidy("backward", () => {
        const accumulatedGradientMap = {};
        accumulatedGradientMap[y2.id] = dy == null ? ones(y2.shape) : dy;
        backpropagateGradients(
          accumulatedGradientMap,
          filteredTape,
          // Pass the tidy function to avoid circular dep with `tape.ts`.
          (f3) => this.tidy(f3),
          // Pass an add function to avoide a circular dep with `tape.ts`.
          add
        );
        const grads = xs2.map((x2) => accumulatedGradientMap[x2.id]);
        if (this.state.gradientDepth === 0) {
          this.state.activeTape.forEach((node) => {
            for (const tensor2 of node.saved) {
              tensor2.dispose();
            }
          });
          this.state.activeTape = null;
        }
        return { value: y2, grads };
      });
    }
    customGrad(f2) {
      assert2(isFunction(f2), () => "The f passed in customGrad(f) must be a function.");
      return (...inputs) => {
        assert2(inputs.every((t3) => t3 instanceof Tensor), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
        let res;
        const inputMap = {};
        inputs.forEach((input2, i2) => {
          inputMap[i2] = input2;
        });
        const forwardFunc = (_3, save) => {
          res = f2(...[...inputs, save]);
          assert2(res.value instanceof Tensor, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor");
          assert2(isFunction(res.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.");
          return res.value;
        };
        const backwardsFunc = (dy, saved) => {
          const gradRes = res.gradFunc(dy, saved);
          const grads = Array.isArray(gradRes) ? gradRes : [gradRes];
          assert2(grads.length === inputs.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).");
          assert2(grads.every((t3) => t3 instanceof Tensor), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
          const gradMap = {};
          grads.forEach((grad, i2) => {
            gradMap[i2] = () => grad;
          });
          return gradMap;
        };
        return this.runKernelFunc({
          forwardFunc,
          backwardsFunc,
          inputs: inputMap
        });
      };
    }
    readSync(dataId) {
      const info = this.state.tensorInfo.get(dataId);
      return info.backend.readSync(dataId);
    }
    read(dataId) {
      const info = this.state.tensorInfo.get(dataId);
      return info.backend.read(dataId);
    }
    readToGPU(dataId, options) {
      const info = this.state.tensorInfo.get(dataId);
      return info.backend.readToGPU(dataId, options);
    }
    async time(query) {
      const start = now();
      const timingInfo = await this.backend.time(query);
      timingInfo.wallMs = now() - start;
      return timingInfo;
    }
    /**
     * Tracks a Tensor in the current scope to be automatically cleaned up
     * when the current scope ends, and returns the value.
     *
     * @param result The Tensor to track in the current scope.
     */
    track(result) {
      if (this.state.activeScope != null) {
        result.scopeId = this.state.activeScope.id;
        this.state.activeScope.track.push(result);
      }
      return result;
    }
    get registeredVariables() {
      return this.state.registeredVariables;
    }
    /**
     * Resets the engine state. Removes all backends but does not remove
     * registered backend factories.
     */
    reset() {
      this.pendingBackendInitId++;
      this.state.dispose();
      this.ENV.reset();
      this.state = new EngineState();
      for (const backendName in this.registry) {
        this.disposeRegisteredKernels(backendName);
        this.registry[backendName].dispose();
        delete this.registry[backendName];
      }
      this.backendName = null;
      this.backendInstance = null;
      this.pendingBackendInit = null;
    }
  };
  Engine.nextTensorId = 0;
  Engine.nextVariableId = 0;
  function ones(shape) {
    const values = makeOnesTypedArray(sizeFromShape(shape), "float32");
    return ENGINE.makeTensor(values, shape, "float32");
  }
  function getOrMakeEngine() {
    const ns2 = getGlobalNamespace();
    if (ns2._tfengine == null) {
      const environment = new Environment(ns2);
      ns2._tfengine = new Engine(environment);
    }
    setEnvironmentGlobal(ns2._tfengine.ENV);
    setTensorTracker(() => ns2._tfengine);
    return ns2._tfengine;
  }
  var ENGINE = getOrMakeEngine();
  function add(a2, b2) {
    const inputs = { a: a2, b: b2 };
    return ENGINE.runKernel(Add2, inputs);
  }

  // node_modules/@tensorflow/tfjs-core/dist/device_util.js
  var device_util_exports = {};
  __export(device_util_exports, {
    isBrowser: () => isBrowser,
    isMobile: () => isMobile,
    mockIsMobile: () => mockIsMobile
  });
  function _isNavigatorDefined() {
    return typeof navigator !== "undefined" && navigator != null;
  }
  var isMobileMockValue;
  function mockIsMobile(value) {
    isMobileMockValue = value;
  }
  function isMobile(nav) {
    if (isMobileMockValue !== void 0) {
      return isMobileMockValue;
    }
    if (nav || _isNavigatorDefined()) {
      if (!nav) {
        nav = navigator;
      }
      if (nav.product === "ReactNative") {
        return true;
      }
      const a2 = nav.userAgent || nav.vendor || // tslint:disable-next-line:no-any
      (typeof window !== "undefined" ? window.opera : "");
      if (!a2) {
        const navAny = nav;
        return navAny.userAgentData && navAny.userAgentData.mobile;
      }
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a2) || // tslint:disable-next-line:max-line-length
      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a2.substr(0, 4));
    }
    return false;
  }
  function isBrowser() {
    return typeof window !== "undefined" && window.document != null || //@ts-ignore
    typeof WorkerGlobalScope !== "undefined";
  }

  // node_modules/@tensorflow/tfjs-core/dist/flags.js
  var ENV2 = env();
  ENV2.registerFlag("DEBUG", () => false, (debugValue) => {
    if (debugValue) {
      console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
    }
  });
  ENV2.registerFlag("IS_BROWSER", () => isBrowser());
  ENV2.registerFlag("IS_NODE", () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined");
  ENV2.registerFlag("IS_CHROME", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
  ENV2.registerFlag("PROD", () => false);
  ENV2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => ENV2.getBool("DEBUG"));
  ENV2.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
  ENV2.registerFlag("IS_TEST", () => false);
  ENV2.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => true);
  ENV2.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
  ENV2.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false);
  ENV2.registerFlag("USE_SETTIMEOUTCUSTOM", () => false);

  // node_modules/@tensorflow/tfjs-core/dist/tensor_util_env.js
  function inferShape(val, dtype) {
    let firstElem = val;
    if (isTypedArray(val)) {
      return dtype === "string" ? [] : [val.length];
    }
    const isObject = typeof val === "object";
    if (isObject) {
      if ("texture" in val) {
        const usedChannels = val.channels || "RGBA";
        return [val.height, val.width * usedChannels.length];
      } else if ("buffer" in val && !(val.buffer instanceof ArrayBuffer)) {
        return [val.buffer.size / (dtype == null ? 4 : bytesPerElement(dtype))];
      }
    }
    if (!Array.isArray(val)) {
      return [];
    }
    const shape = [];
    while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== "string") {
      shape.push(firstElem.length);
      firstElem = firstElem[0];
    }
    if (Array.isArray(val) && env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
      deepAssertShapeConsistency(val, shape, []);
    }
    return shape;
  }
  function deepAssertShapeConsistency(val, shape, indices) {
    indices = indices || [];
    if (!Array.isArray(val) && !isTypedArray(val)) {
      assert2(shape.length === 0, () => `Element arr[${indices.join("][")}] is a primitive, but should be an array/TypedArray of ${shape[0]} elements`);
      return;
    }
    assert2(shape.length > 0, () => `Element arr[${indices.join("][")}] should be a primitive, but is an array of ${val.length} elements`);
    assert2(val.length === shape[0], () => `Element arr[${indices.join("][")}] should have ${shape[0]} elements, but has ${val.length} elements`);
    const subShape = shape.slice(1);
    for (let i2 = 0; i2 < val.length; ++i2) {
      deepAssertShapeConsistency(val[i2], subShape, indices.concat(i2));
    }
  }
  function assertDtype(expectedDtype, actualDType, argName, functionName) {
    if (expectedDtype === "string_or_numeric") {
      return;
    }
    if (expectedDtype == null) {
      throw new Error(`Expected dtype cannot be null.`);
    }
    if (expectedDtype !== "numeric" && expectedDtype !== actualDType || expectedDtype === "numeric" && actualDType === "string") {
      throw new Error(`Argument '${argName}' passed to '${functionName}' must be ${expectedDtype} tensor, but got ${actualDType} tensor`);
    }
  }
  function convertToTensor(x2, argName, functionName, parseAsDtype = "numeric") {
    if (x2 instanceof Tensor) {
      assertDtype(parseAsDtype, x2.dtype, argName, functionName);
      return x2;
    }
    let inferredDtype = inferDtype(x2);
    if (inferredDtype !== "string" && ["bool", "int32", "float32"].indexOf(parseAsDtype) >= 0) {
      inferredDtype = parseAsDtype;
    }
    assertDtype(parseAsDtype, inferredDtype, argName, functionName);
    if (x2 == null || !isTypedArray(x2) && !Array.isArray(x2) && typeof x2 !== "number" && typeof x2 !== "boolean" && typeof x2 !== "string") {
      const type = x2 == null ? "null" : x2.constructor.name;
      throw new Error(`Argument '${argName}' passed to '${functionName}' must be a Tensor or TensorLike, but got '${type}'`);
    }
    const inferredShape = inferShape(x2, inferredDtype);
    if (!isTypedArray(x2) && !Array.isArray(x2)) {
      x2 = [x2];
    }
    const skipTypedArray = true;
    const values = inferredDtype !== "string" ? toTypedArray(x2, inferredDtype) : flatten2(x2, [], skipTypedArray);
    return ENGINE.makeTensor(values, inferredShape, inferredDtype);
  }
  function convertToTensorArray(arg, argName, functionName, parseAsDtype = "numeric") {
    if (!Array.isArray(arg)) {
      throw new Error(`Argument ${argName} passed to ${functionName} must be a \`Tensor[]\` or \`TensorLike[]\``);
    }
    const tensors = arg;
    return tensors.map((t3, i2) => convertToTensor(t3, `${argName}[${i2}]`, functionName, parseAsDtype));
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/operation.js
  var OP_SCOPE_SUFFIX = "__op";
  function op(f2) {
    const keys = Object.keys(f2);
    if (keys.length !== 1) {
      throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${keys.length} keys.`);
    }
    let opName = keys[0];
    const fn2 = f2[opName];
    if (opName.endsWith("_")) {
      opName = opName.substring(0, opName.length - 1);
    }
    opName = opName + OP_SCOPE_SUFFIX;
    const f22 = (...args) => {
      ENGINE.startScope(opName);
      try {
        const result = fn2(...args);
        if (isPromise(result)) {
          console.error("Cannot return a Promise inside of tidy.");
        }
        ENGINE.endScope(result);
        return result;
      } catch (ex) {
        ENGINE.endScope(null);
        throw ex;
      }
    };
    Object.defineProperty(f22, "name", { value: opName, configurable: true });
    return f22;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/complex.js
  function complex_(real4, imag3) {
    const $real = convertToTensor(real4, "real", "complex");
    const $imag = convertToTensor(imag3, "imag", "complex");
    assertShapesMatch($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, must match in call to tf.complex().`);
    const inputs = { real: $real, imag: $imag };
    return ENGINE.runKernel(Complex, inputs);
  }
  var complex = /* @__PURE__ */ op({ complex_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor_ops_util.js
  function makeTensor(values, shape, inferredShape, dtype) {
    if (dtype == null) {
      dtype = inferDtype(values);
    } else if (dtype === "complex64") {
      throw new Error(`Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).`);
    }
    if (typeof values === "object" && ("texture" in values || "buffer" in values && !(values.buffer instanceof ArrayBuffer))) {
      if (dtype !== "float32" && dtype !== "int32") {
        throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${dtype}.`);
      }
      return ENGINE.backend.createTensorFromGPUData(values, shape || inferredShape, dtype);
    }
    if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== "number" && typeof values !== "boolean" && typeof values !== "string") {
      throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    }
    if (shape != null) {
      assertNonNegativeIntegerDimensions(shape);
      const providedSize = sizeFromShape(shape);
      const inferredSize = sizeFromShape(inferredShape);
      assert2(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ${providedSize} values but has ${inferredSize}`);
      for (let i2 = 0; i2 < inferredShape.length; ++i2) {
        const inferred = inferredShape[i2];
        const flatDimsDontMatch = i2 === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i2)) : true;
        assert2(inferredShape[i2] === shape[i2] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape (${inferredShape}) does not match the provided shape (${shape}). `);
      }
    }
    if (!isTypedArray(values) && !Array.isArray(values)) {
      values = [values];
    }
    shape = shape || inferredShape;
    values = dtype !== "string" ? toTypedArray(values, dtype) : flatten2(values, [], true);
    return ENGINE.makeTensor(values, shape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor.js
  function tensor(values, shape, dtype) {
    const inferredShape = inferShape(values, dtype);
    return makeTensor(values, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/types.js
  var DTYPE_VALUE_SIZE_MAP = {
    "float32": 4,
    "float16": 2,
    "int32": 4,
    "uint16": 2,
    "uint8": 1,
    "bool": 1,
    "complex64": 8
  };

  // node_modules/@tensorflow/tfjs-core/dist/io/io_utils.js
  var NUM_BYTES_STRING_LENGTH = 4;
  async function encodeWeights(tensors, group) {
    const specs = [];
    const dataPromises = [];
    const names = Array.isArray(tensors) ? tensors.map((tensor2) => tensor2.name) : Object.keys(tensors);
    for (let i2 = 0; i2 < names.length; ++i2) {
      const name = names[i2];
      const t3 = Array.isArray(tensors) ? tensors[i2].tensor : tensors[name];
      if (t3.dtype !== "float32" && t3.dtype !== "int32" && t3.dtype !== "bool" && t3.dtype !== "string" && t3.dtype !== "complex64") {
        throw new Error(`Unsupported dtype in weight '${name}': ${t3.dtype}`);
      }
      const spec = { name, shape: t3.shape, dtype: t3.dtype };
      if (t3.dtype === "string") {
        const utf8bytes = new Promise(async (resolve) => {
          const vals = await t3.bytes();
          const totalNumBytes = vals.reduce((p2, c2) => p2 + c2.length, 0) + NUM_BYTES_STRING_LENGTH * vals.length;
          const bytes = new Uint8Array(totalNumBytes);
          let offset = 0;
          for (let i3 = 0; i3 < vals.length; i3++) {
            const val = vals[i3];
            const bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);
            bytes.set(bytesOfLength, offset);
            offset += NUM_BYTES_STRING_LENGTH;
            bytes.set(val, offset);
            offset += val.length;
          }
          resolve(bytes);
        });
        dataPromises.push(utf8bytes);
      } else {
        dataPromises.push(t3.data());
      }
      if (group != null) {
        spec.group = group;
      }
      specs.push(spec);
    }
    const tensorValues = await Promise.all(dataPromises);
    return { data: concatenateTypedArrays(tensorValues), specs };
  }
  function decodeWeights(buffer2, specs) {
    const out = {};
    let float16Decode;
    let offset = 0;
    for (const spec of specs) {
      const name = spec.name;
      const dtype = spec.dtype;
      const shape = spec.shape;
      const size = sizeFromShape(shape);
      let values;
      if ("quantization" in spec) {
        const quantization = spec.quantization;
        if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
          if (!("min" in quantization && "scale" in quantization)) {
            throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} doesn't have corresponding metadata min and scale.`);
          }
        } else if (quantization.dtype === "float16") {
          if (dtype !== "float32") {
            throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} which only supports weights of type float32 not ${dtype}.`);
          }
        } else {
          throw new Error(`Weight ${spec.name} has unknown quantization dtype ${quantization.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
        }
        const quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
        const byteBuffer = buffer2.slice(offset, offset + size * quantizationSizeFactor);
        const quantizedArray = quantization.dtype === "uint8" ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);
        if (dtype === "float32") {
          if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
            values = new Float32Array(quantizedArray.length);
            for (let i2 = 0; i2 < quantizedArray.length; i2++) {
              const v2 = quantizedArray[i2];
              values[i2] = v2 * quantization.scale + quantization.min;
            }
          } else if (quantization.dtype === "float16") {
            if (float16Decode === void 0) {
              float16Decode = getFloat16Decoder();
            }
            values = float16Decode(quantizedArray);
          } else {
            throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type float32.`);
          }
        } else if (dtype === "int32") {
          if (quantization.dtype !== "uint8" && quantization.dtype !== "uint16") {
            throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type int32.`);
          }
          values = new Int32Array(quantizedArray.length);
          for (let i2 = 0; i2 < quantizedArray.length; i2++) {
            const v2 = quantizedArray[i2];
            values[i2] = Math.round(v2 * quantization.scale + quantization.min);
          }
        } else {
          throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
        }
        offset += size * quantizationSizeFactor;
      } else if (dtype === "string") {
        const size2 = sizeFromShape(spec.shape);
        values = [];
        for (let i2 = 0; i2 < size2; i2++) {
          const byteLength = new Uint32Array(buffer2.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];
          offset += NUM_BYTES_STRING_LENGTH;
          const bytes = new Uint8Array(buffer2.slice(offset, offset + byteLength));
          values.push(bytes);
          offset += byteLength;
        }
      } else {
        const dtypeFactor = DTYPE_VALUE_SIZE_MAP[dtype];
        const byteBuffer = buffer2.slice(offset, offset + size * dtypeFactor);
        if (dtype === "float32") {
          values = new Float32Array(byteBuffer);
        } else if (dtype === "int32") {
          values = new Int32Array(byteBuffer);
        } else if (dtype === "bool") {
          values = new Uint8Array(byteBuffer);
        } else if (dtype === "complex64") {
          values = new Float32Array(byteBuffer);
          const real4 = new Float32Array(values.length / 2);
          const image2 = new Float32Array(values.length / 2);
          for (let i2 = 0; i2 < real4.length; i2++) {
            real4[i2] = values[i2 * 2];
            image2[i2] = values[i2 * 2 + 1];
          }
          const realTensor = tensor(real4, shape, "float32");
          const imageTensor = tensor(image2, shape, "float32");
          out[name] = complex(realTensor, imageTensor);
          realTensor.dispose();
          imageTensor.dispose();
        } else {
          throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
        }
        offset += size * dtypeFactor;
      }
      if (dtype !== "complex64") {
        out[name] = tensor(values, shape, dtype);
      }
    }
    return out;
  }
  function concatenateTypedArrays(xs2) {
    if (xs2 === null) {
      throw new Error(`Invalid input value: ${JSON.stringify(xs2)}`);
    }
    let totalByteLength = 0;
    const normalizedXs = [];
    xs2.forEach((x2) => {
      totalByteLength += x2.byteLength;
      normalizedXs.push(x2.byteLength === x2.buffer.byteLength ? x2 : new x2.constructor(x2));
      if (!(x2 instanceof Float32Array || x2 instanceof Int32Array || x2 instanceof Uint8Array)) {
        throw new Error(`Unsupported TypedArray subtype: ${x2.constructor.name}`);
      }
    });
    const y2 = new Uint8Array(totalByteLength);
    let offset = 0;
    normalizedXs.forEach((x2) => {
      y2.set(new Uint8Array(x2.buffer), offset);
      offset += x2.byteLength;
    });
    return y2.buffer;
  }
  var useNodeBuffer = typeof Buffer !== "undefined" && (typeof Blob === "undefined" || typeof atob === "undefined" || typeof btoa === "undefined");
  function stringByteLength(str) {
    if (useNodeBuffer) {
      return Buffer.byteLength(str);
    }
    return new Blob([str]).size;
  }
  function arrayBufferToBase64String(buffer2) {
    if (useNodeBuffer) {
      return Buffer.from(buffer2).toString("base64");
    }
    const buf = new Uint8Array(buffer2);
    let s2 = "";
    for (let i2 = 0, l3 = buf.length; i2 < l3; i2++) {
      s2 += String.fromCharCode(buf[i2]);
    }
    return btoa(s2);
  }
  function base64StringToArrayBuffer(str) {
    if (useNodeBuffer) {
      const buf = Buffer.from(str, "base64");
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    const s2 = atob(str);
    const buffer2 = new Uint8Array(s2.length);
    for (let i2 = 0; i2 < s2.length; ++i2) {
      buffer2.set([s2.charCodeAt(i2)], i2);
    }
    return buffer2.buffer;
  }
  function concatenateArrayBuffers(buffers) {
    if (buffers.length === 1) {
      return buffers[0];
    }
    let totalByteLength = 0;
    buffers.forEach((buffer2) => {
      totalByteLength += buffer2.byteLength;
    });
    const temp = new Uint8Array(totalByteLength);
    let offset = 0;
    buffers.forEach((buffer2) => {
      temp.set(new Uint8Array(buffer2), offset);
      offset += buffer2.byteLength;
    });
    return temp.buffer;
  }
  function basename(path) {
    const SEPARATOR = "/";
    path = path.trim();
    while (path.endsWith(SEPARATOR)) {
      path = path.slice(0, path.length - 1);
    }
    const items = path.split(SEPARATOR);
    return items[items.length - 1];
  }
  function getModelJSONForModelArtifacts(artifacts, manifest) {
    const result = {
      modelTopology: artifacts.modelTopology,
      format: artifacts.format,
      generatedBy: artifacts.generatedBy,
      convertedBy: artifacts.convertedBy,
      weightsManifest: manifest
    };
    if (artifacts.signature != null) {
      result.signature = artifacts.signature;
    }
    if (artifacts.userDefinedMetadata != null) {
      result.userDefinedMetadata = artifacts.userDefinedMetadata;
    }
    if (artifacts.modelInitializer != null) {
      result.modelInitializer = artifacts.modelInitializer;
    }
    if (artifacts.initializerSignature != null) {
      result.initializerSignature = artifacts.initializerSignature;
    }
    if (artifacts.trainingConfig != null) {
      result.trainingConfig = artifacts.trainingConfig;
    }
    return result;
  }
  function getModelArtifactsForJSONSync(modelJSON, weightSpecs, weightData) {
    const modelArtifacts = {
      modelTopology: modelJSON.modelTopology,
      format: modelJSON.format,
      generatedBy: modelJSON.generatedBy,
      convertedBy: modelJSON.convertedBy
    };
    if (modelJSON.trainingConfig != null) {
      modelArtifacts.trainingConfig = modelJSON.trainingConfig;
    }
    if (modelJSON.weightsManifest != null) {
      if (!weightSpecs) {
        throw new Error("modelJSON has weightsManifest but weightSpecs is null");
      }
      if (!weightData) {
        throw new Error("modelJSON has weightsManifest but weightData is null");
      }
      modelArtifacts.weightSpecs = weightSpecs;
      modelArtifacts.weightData = weightData;
    }
    if (modelJSON.signature != null) {
      modelArtifacts.signature = modelJSON.signature;
    }
    if (modelJSON.userDefinedMetadata != null) {
      modelArtifacts.userDefinedMetadata = modelJSON.userDefinedMetadata;
    }
    if (modelJSON.modelInitializer != null) {
      modelArtifacts.modelInitializer = modelJSON.modelInitializer;
    }
    if (modelJSON.initializerSignature != null) {
      modelArtifacts.initializerSignature = modelJSON.initializerSignature;
    }
    return modelArtifacts;
  }
  async function getModelArtifactsForJSON(modelJSON, loadWeights2) {
    let weightSpecs;
    let weightData;
    if (modelJSON.weightsManifest != null) {
      [weightSpecs, weightData] = await loadWeights2(modelJSON.weightsManifest);
    }
    return getModelArtifactsForJSONSync(modelJSON, weightSpecs, weightData);
  }
  function getModelArtifactsInfoForJSON(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("Expected JSON model topology, received ArrayBuffer.");
    }
    return {
      dateSaved: /* @__PURE__ */ new Date(),
      modelTopologyType: "JSON",
      modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
      weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
      weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength
    };
  }
  function getWeightSpecs(weightsManifest) {
    const weightSpecs = [];
    for (const entry of weightsManifest) {
      weightSpecs.push(...entry.weights);
    }
    return weightSpecs;
  }
  function computeFloat16MantisaTable() {
    const convertMantissa = (i2) => {
      let m2 = i2 << 13;
      let e2 = 0;
      while ((m2 & 8388608) === 0) {
        e2 -= 8388608;
        m2 <<= 1;
      }
      m2 &= ~8388608;
      e2 += 947912704;
      return m2 | e2;
    };
    const mantisaTable = new Uint32Array(2048);
    mantisaTable[0] = 0;
    for (let i2 = 1; i2 < 1024; i2++) {
      mantisaTable[i2] = convertMantissa(i2);
    }
    for (let i2 = 1024; i2 < 2048; i2++) {
      mantisaTable[i2] = 939524096 + (i2 - 1024 << 13);
    }
    return mantisaTable;
  }
  function computeFloat16ExponentTable() {
    const exponentTable = new Uint32Array(64);
    exponentTable[0] = 0;
    exponentTable[31] = 1199570944;
    exponentTable[32] = 2147483648;
    exponentTable[63] = 3347054592;
    for (let i2 = 1; i2 < 31; i2++) {
      exponentTable[i2] = i2 << 23;
    }
    for (let i2 = 33; i2 < 63; i2++) {
      exponentTable[i2] = 2147483648 + (i2 - 32 << 23);
    }
    return exponentTable;
  }
  function computeFloat16OffsetTable() {
    const offsetTable = new Uint32Array(64);
    for (let i2 = 0; i2 < 64; i2++) {
      offsetTable[i2] = 1024;
    }
    offsetTable[0] = offsetTable[32] = 0;
    return offsetTable;
  }
  function getFloat16Decoder() {
    const mantisaTable = computeFloat16MantisaTable();
    const exponentTable = computeFloat16ExponentTable();
    const offsetTable = computeFloat16OffsetTable();
    return (quantizedArray) => {
      const buffer2 = new ArrayBuffer(4 * quantizedArray.length);
      const bufferUint32View = new Uint32Array(buffer2);
      for (let index = 0; index < quantizedArray.length; index++) {
        const float16Bits = quantizedArray[index];
        const float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 1023)] + exponentTable[float16Bits >> 10];
        bufferUint32View[index] = float32Bits;
      }
      return new Float32Array(buffer2);
    };
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/router_registry.js
  var IORouterRegistry = class {
    constructor() {
      this.saveRouters = [];
      this.loadRouters = [];
    }
    static getInstance() {
      if (IORouterRegistry.instance == null) {
        IORouterRegistry.instance = new IORouterRegistry();
      }
      return IORouterRegistry.instance;
    }
    /**
     * Register a save-handler router.
     *
     * @param saveRouter A function that maps a URL-like string onto an instance
     * of `IOHandler` with the `save` method defined or `null`.
     */
    static registerSaveRouter(saveRouter) {
      IORouterRegistry.getInstance().saveRouters.push(saveRouter);
    }
    /**
     * Register a load-handler router.
     *
     * @param loadRouter A function that maps a URL-like string onto an instance
     * of `IOHandler` with the `load` method defined or `null`.
     */
    static registerLoadRouter(loadRouter) {
      IORouterRegistry.getInstance().loadRouters.push(loadRouter);
    }
    /**
     * Look up IOHandler for saving, given a URL-like string.
     *
     * @param url
     * @returns If only one match is found, an instance of IOHandler with the
     * `save` method defined. If no match is found, `null`.
     * @throws Error, if more than one match is found.
     */
    static getSaveHandlers(url) {
      return IORouterRegistry.getHandlers(url, "save");
    }
    /**
     * Look up IOHandler for loading, given a URL-like string.
     *
     * @param url
     * @param loadOptions Optional, custom load options.
     * @returns All valid handlers for `url`, given the currently registered
     *   handler routers.
     */
    static getLoadHandlers(url, loadOptions) {
      return IORouterRegistry.getHandlers(url, "load", loadOptions);
    }
    static getHandlers(url, handlerType, loadOptions) {
      const validHandlers = [];
      const routers = handlerType === "load" ? IORouterRegistry.getInstance().loadRouters : IORouterRegistry.getInstance().saveRouters;
      routers.forEach((router) => {
        const handler = router(url, loadOptions);
        if (handler !== null) {
          validHandlers.push(handler);
        }
      });
      return validHandlers;
    }
  };
  var registerSaveRouter = (loudRouter) => IORouterRegistry.registerSaveRouter(loudRouter);
  var registerLoadRouter = (loudRouter) => IORouterRegistry.registerLoadRouter(loudRouter);
  var getSaveHandlers = (url) => IORouterRegistry.getSaveHandlers(url);
  var getLoadHandlers = (url, loadOptions) => IORouterRegistry.getLoadHandlers(url, loadOptions);

  // node_modules/@tensorflow/tfjs-core/dist/io/indexed_db.js
  var DATABASE_NAME = "tensorflowjs";
  var DATABASE_VERSION = 1;
  var MODEL_STORE_NAME = "models_store";
  var INFO_STORE_NAME = "model_info_store";
  function getIndexedDBFactory() {
    if (!env().getBool("IS_BROWSER")) {
      throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    }
    const theWindow = typeof window === "undefined" ? self : window;
    const factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
    if (factory == null) {
      throw new Error("The current browser does not appear to support IndexedDB.");
    }
    return factory;
  }
  function setUpDatabase(openRequest) {
    const db = openRequest.result;
    db.createObjectStore(MODEL_STORE_NAME, { keyPath: "modelPath" });
    db.createObjectStore(INFO_STORE_NAME, { keyPath: "modelPath" });
  }
  var BrowserIndexedDB = class {
    constructor(modelPath) {
      this.indexedDB = getIndexedDBFactory();
      if (modelPath == null || !modelPath) {
        throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
      }
      this.modelPath = modelPath;
    }
    async save(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      }
      return this.databaseAction(this.modelPath, modelArtifacts);
    }
    async load() {
      return this.databaseAction(this.modelPath);
    }
    /**
     * Perform database action to put model artifacts into or read model artifacts
     * from IndexedDB object store.
     *
     * Whether the action is put or get depends on whether `modelArtifacts` is
     * specified. If it is specified, the action will be put; otherwise the action
     * will be get.
     *
     * @param modelPath A unique string path for the model.
     * @param modelArtifacts If specified, it will be the model artifacts to be
     *   stored in IndexedDB.
     * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`
     *   of `ModelArtifacts`, if the action is get.
     */
    databaseAction(modelPath, modelArtifacts) {
      return new Promise((resolve, reject) => {
        const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
        openRequest.onsuccess = () => {
          const db = openRequest.result;
          if (modelArtifacts == null) {
            const modelTx = db.transaction(MODEL_STORE_NAME, "readonly");
            const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
            const getRequest = modelStore.get(this.modelPath);
            getRequest.onsuccess = () => {
              if (getRequest.result == null) {
                db.close();
                return reject(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
              } else {
                resolve(getRequest.result.modelArtifacts);
              }
            };
            getRequest.onerror = (error) => {
              db.close();
              return reject(getRequest.error);
            };
            modelTx.oncomplete = () => db.close();
          } else {
            const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
            const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
            let infoStore = infoTx.objectStore(INFO_STORE_NAME);
            const putInfoRequest = infoStore.put({ modelPath: this.modelPath, modelArtifactsInfo });
            let modelTx;
            putInfoRequest.onsuccess = () => {
              modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
              const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
              const putModelRequest = modelStore.put({
                modelPath: this.modelPath,
                modelArtifacts,
                modelArtifactsInfo
              });
              putModelRequest.onsuccess = () => resolve({ modelArtifactsInfo });
              putModelRequest.onerror = (error) => {
                infoStore = infoTx.objectStore(INFO_STORE_NAME);
                const deleteInfoRequest = infoStore.delete(this.modelPath);
                deleteInfoRequest.onsuccess = () => {
                  db.close();
                  return reject(putModelRequest.error);
                };
                deleteInfoRequest.onerror = (error2) => {
                  db.close();
                  return reject(putModelRequest.error);
                };
              };
            };
            putInfoRequest.onerror = (error) => {
              db.close();
              return reject(putInfoRequest.error);
            };
            infoTx.oncomplete = () => {
              if (modelTx == null) {
                db.close();
              } else {
                modelTx.oncomplete = () => db.close();
              }
            };
          }
        };
        openRequest.onerror = (error) => reject(openRequest.error);
      });
    }
  };
  BrowserIndexedDB.URL_SCHEME = "indexeddb://";
  var indexedDBRouter = (url) => {
    if (!env().getBool("IS_BROWSER")) {
      return null;
    } else {
      if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
        return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
      } else {
        return null;
      }
    }
  };
  IORouterRegistry.registerSaveRouter(indexedDBRouter);
  IORouterRegistry.registerLoadRouter(indexedDBRouter);
  function browserIndexedDB(modelPath) {
    return new BrowserIndexedDB(modelPath);
  }
  function maybeStripScheme(key) {
    return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;
  }
  var BrowserIndexedDBManager = class {
    constructor() {
      this.indexedDB = getIndexedDBFactory();
    }
    async listModels() {
      return new Promise((resolve, reject) => {
        const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
        openRequest.onsuccess = () => {
          const db = openRequest.result;
          const tx = db.transaction(INFO_STORE_NAME, "readonly");
          const store = tx.objectStore(INFO_STORE_NAME);
          const getAllInfoRequest = store.getAll();
          getAllInfoRequest.onsuccess = () => {
            const out = {};
            for (const item of getAllInfoRequest.result) {
              out[item.modelPath] = item.modelArtifactsInfo;
            }
            resolve(out);
          };
          getAllInfoRequest.onerror = (error) => {
            db.close();
            return reject(getAllInfoRequest.error);
          };
          tx.oncomplete = () => db.close();
        };
        openRequest.onerror = (error) => reject(openRequest.error);
      });
    }
    async removeModel(path) {
      path = maybeStripScheme(path);
      return new Promise((resolve, reject) => {
        const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
        openRequest.onsuccess = () => {
          const db = openRequest.result;
          const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
          const infoStore = infoTx.objectStore(INFO_STORE_NAME);
          const getInfoRequest = infoStore.get(path);
          let modelTx;
          getInfoRequest.onsuccess = () => {
            if (getInfoRequest.result == null) {
              db.close();
              return reject(new Error(`Cannot find model with path '${path}' in IndexedDB.`));
            } else {
              const deleteInfoRequest = infoStore.delete(path);
              const deleteModelData = () => {
                modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
                const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                const deleteModelRequest = modelStore.delete(path);
                deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);
                deleteModelRequest.onerror = (error) => reject(getInfoRequest.error);
              };
              deleteInfoRequest.onsuccess = deleteModelData;
              deleteInfoRequest.onerror = (error) => {
                deleteModelData();
                db.close();
                return reject(getInfoRequest.error);
              };
            }
          };
          getInfoRequest.onerror = (error) => {
            db.close();
            return reject(getInfoRequest.error);
          };
          infoTx.oncomplete = () => {
            if (modelTx == null) {
              db.close();
            } else {
              modelTx.oncomplete = () => db.close();
            }
          };
        };
        openRequest.onerror = (error) => reject(openRequest.error);
      });
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/io/local_storage.js
  var PATH_SEPARATOR = "/";
  var PATH_PREFIX = "tensorflowjs_models";
  var INFO_SUFFIX = "info";
  var MODEL_TOPOLOGY_SUFFIX = "model_topology";
  var WEIGHT_SPECS_SUFFIX = "weight_specs";
  var WEIGHT_DATA_SUFFIX = "weight_data";
  var MODEL_METADATA_SUFFIX = "model_metadata";
  function getModelKeys(path) {
    return {
      info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
      topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
      weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
      weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),
      modelMetadata: [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)
    };
  }
  function removeItems(keys) {
    for (const key of Object.values(keys)) {
      window.localStorage.removeItem(key);
    }
  }
  function getModelPathFromKey(key) {
    const items = key.split(PATH_SEPARATOR);
    if (items.length < 3) {
      throw new Error(`Invalid key format: ${key}`);
    }
    return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
  }
  function maybeStripScheme2(key) {
    return key.startsWith(BrowserLocalStorage.URL_SCHEME) ? key.slice(BrowserLocalStorage.URL_SCHEME.length) : key;
  }
  var BrowserLocalStorage = class {
    constructor(modelPath) {
      if (!env().getBool("IS_BROWSER") || typeof window === "undefined" || typeof window.localStorage === "undefined") {
        throw new Error("The current environment does not support local storage.");
      }
      this.LS = window.localStorage;
      if (modelPath == null || !modelPath) {
        throw new Error("For local storage, modelPath must not be null, undefined or empty.");
      }
      this.modelPath = modelPath;
      this.keys = getModelKeys(this.modelPath);
    }
    /**
     * Save model artifacts to browser local storage.
     *
     * See the documentation to `browserLocalStorage` for details on the saved
     * artifacts.
     *
     * @param modelArtifacts The model artifacts to be stored.
     * @returns An instance of SaveResult.
     */
    async save(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      } else {
        const topology = JSON.stringify(modelArtifacts.modelTopology);
        const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
        const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
        try {
          this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
          this.LS.setItem(this.keys.topology, topology);
          this.LS.setItem(this.keys.weightSpecs, weightSpecs);
          this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(modelArtifacts.weightData));
          const metadata = {
            format: modelArtifacts.format,
            generatedBy: modelArtifacts.generatedBy,
            convertedBy: modelArtifacts.convertedBy,
            signature: modelArtifacts.signature != null ? modelArtifacts.signature : void 0,
            userDefinedMetadata: modelArtifacts.userDefinedMetadata != null ? modelArtifacts.userDefinedMetadata : void 0,
            modelInitializer: modelArtifacts.modelInitializer != null ? modelArtifacts.modelInitializer : void 0,
            initializerSignature: modelArtifacts.initializerSignature != null ? modelArtifacts.initializerSignature : void 0,
            trainingConfig: modelArtifacts.trainingConfig != null ? modelArtifacts.trainingConfig : void 0
          };
          this.LS.setItem(this.keys.modelMetadata, JSON.stringify(metadata));
          return { modelArtifactsInfo };
        } catch (err) {
          removeItems(this.keys);
          throw new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);
        }
      }
    }
    /**
     * Load a model from local storage.
     *
     * See the documentation to `browserLocalStorage` for details on the saved
     * artifacts.
     *
     * @returns The loaded model (if loading succeeds).
     */
    async load() {
      const info = JSON.parse(this.LS.getItem(this.keys.info));
      if (info == null) {
        throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
      }
      if (info.modelTopologyType !== "JSON") {
        throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
      }
      const out = {};
      const topology = JSON.parse(this.LS.getItem(this.keys.topology));
      if (topology == null) {
        throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
      }
      out.modelTopology = topology;
      const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
      if (weightSpecs == null) {
        throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
      }
      out.weightSpecs = weightSpecs;
      const metadataString = this.LS.getItem(this.keys.modelMetadata);
      if (metadataString != null) {
        const metadata = JSON.parse(metadataString);
        out.format = metadata.format;
        out.generatedBy = metadata.generatedBy;
        out.convertedBy = metadata.convertedBy;
        if (metadata.signature != null) {
          out.signature = metadata.signature;
        }
        if (metadata.userDefinedMetadata != null) {
          out.userDefinedMetadata = metadata.userDefinedMetadata;
        }
        if (metadata.modelInitializer != null) {
          out.modelInitializer = metadata.modelInitializer;
        }
        if (metadata.initializerSignature != null) {
          out.initializerSignature = metadata.initializerSignature;
        }
        if (metadata.trainingConfig != null) {
          out.trainingConfig = metadata.trainingConfig;
        }
      }
      const weightDataBase64 = this.LS.getItem(this.keys.weightData);
      if (weightDataBase64 == null) {
        throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
      }
      out.weightData = base64StringToArrayBuffer(weightDataBase64);
      return out;
    }
  };
  BrowserLocalStorage.URL_SCHEME = "localstorage://";
  var localStorageRouter = (url) => {
    if (!env().getBool("IS_BROWSER")) {
      return null;
    } else {
      if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
        return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
      } else {
        return null;
      }
    }
  };
  IORouterRegistry.registerSaveRouter(localStorageRouter);
  IORouterRegistry.registerLoadRouter(localStorageRouter);
  function browserLocalStorage(modelPath) {
    return new BrowserLocalStorage(modelPath);
  }
  var BrowserLocalStorageManager = class {
    constructor() {
      assert2(env().getBool("IS_BROWSER"), () => "Current environment is not a web browser");
      assert2(typeof window === "undefined" || typeof window.localStorage !== "undefined", () => "Current browser does not appear to support localStorage");
      this.LS = window.localStorage;
    }
    async listModels() {
      const out = {};
      const prefix = PATH_PREFIX + PATH_SEPARATOR;
      const suffix = PATH_SEPARATOR + INFO_SUFFIX;
      for (let i2 = 0; i2 < this.LS.length; ++i2) {
        const key = this.LS.key(i2);
        if (key.startsWith(prefix) && key.endsWith(suffix)) {
          const modelPath = getModelPathFromKey(key);
          out[modelPath] = JSON.parse(this.LS.getItem(key));
        }
      }
      return out;
    }
    async removeModel(path) {
      path = maybeStripScheme2(path);
      const keys = getModelKeys(path);
      if (this.LS.getItem(keys.info) == null) {
        throw new Error(`Cannot find model at path '${path}'`);
      }
      const info = JSON.parse(this.LS.getItem(keys.info));
      removeItems(keys);
      return info;
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/io/model_management.js
  var URL_SCHEME_SUFFIX = "://";
  var ModelStoreManagerRegistry = class {
    constructor() {
      this.managers = {};
    }
    static getInstance() {
      if (ModelStoreManagerRegistry.instance == null) {
        ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();
      }
      return ModelStoreManagerRegistry.instance;
    }
    /**
     * Register a save-handler router.
     *
     * @param saveRouter A function that maps a URL-like string onto an instance
     * of `IOHandler` with the `save` method defined or `null`.
     */
    static registerManager(scheme, manager) {
      assert2(scheme != null, () => "scheme must not be undefined or null.");
      if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
        scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
      }
      assert2(scheme.length > 0, () => "scheme must not be an empty string.");
      const registry = ModelStoreManagerRegistry.getInstance();
      assert2(registry.managers[scheme] == null, () => `A model store manager is already registered for scheme '${scheme}'.`);
      registry.managers[scheme] = manager;
    }
    static getManager(scheme) {
      const manager = ModelStoreManagerRegistry.getInstance().managers[scheme];
      if (manager == null) {
        throw new Error(`Cannot find model manager for scheme '${scheme}'`);
      }
      return manager;
    }
    static getSchemes() {
      return Object.keys(ModelStoreManagerRegistry.getInstance().managers);
    }
  };
  function parseURL(url) {
    if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
      throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ModelStoreManagerRegistry.getSchemes().join(",")}`);
    }
    return {
      scheme: url.split(URL_SCHEME_SUFFIX)[0],
      path: url.split(URL_SCHEME_SUFFIX)[1]
    };
  }
  async function cloneModelInternal(sourceURL, destURL, deleteSource = false) {
    assert2(sourceURL !== destURL, () => `Old path and new path are the same: '${sourceURL}'`);
    const loadHandlers = IORouterRegistry.getLoadHandlers(sourceURL);
    assert2(loadHandlers.length > 0, () => `Copying failed because no load handler is found for source URL ${sourceURL}.`);
    assert2(loadHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) load handlers for source URL ${sourceURL}.`);
    const loadHandler = loadHandlers[0];
    const saveHandlers = IORouterRegistry.getSaveHandlers(destURL);
    assert2(saveHandlers.length > 0, () => `Copying failed because no save handler is found for destination URL ${destURL}.`);
    assert2(saveHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) save handlers for destination URL ${destURL}.`);
    const saveHandler = saveHandlers[0];
    const sourceScheme = parseURL(sourceURL).scheme;
    const sourcePath = parseURL(sourceURL).path;
    const sameMedium = sourceScheme === parseURL(sourceURL).scheme;
    const modelArtifacts = await loadHandler.load();
    if (deleteSource && sameMedium) {
      await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
    }
    const saveResult = await saveHandler.save(modelArtifacts);
    if (deleteSource && !sameMedium) {
      await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
    }
    return saveResult.modelArtifactsInfo;
  }
  async function listModels() {
    const schemes = ModelStoreManagerRegistry.getSchemes();
    const out = {};
    for (const scheme of schemes) {
      const schemeOut = await ModelStoreManagerRegistry.getManager(scheme).listModels();
      for (const path in schemeOut) {
        const url = scheme + URL_SCHEME_SUFFIX + path;
        out[url] = schemeOut[path];
      }
    }
    return out;
  }
  async function removeModel(url) {
    const schemeAndPath = parseURL(url);
    const manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
    return manager.removeModel(schemeAndPath.path);
  }
  async function copyModel(sourceURL, destURL) {
    const deleteSource = false;
    return cloneModelInternal(sourceURL, destURL, deleteSource);
  }
  async function moveModel(sourceURL, destURL) {
    const deleteSource = true;
    return cloneModelInternal(sourceURL, destURL, deleteSource);
  }

  // node_modules/@tensorflow/tfjs-core/dist/platforms/platform_browser.js
  var PlatformBrowser = class {
    constructor() {
      this.messageName = "setTimeoutCustom";
      this.functionRefs = [];
      this.handledMessageCount = 0;
      this.hasEventListener = false;
    }
    fetch(path, init) {
      return fetch(path, init);
    }
    now() {
      return performance.now();
    }
    encode(text, encoding) {
      if (encoding !== "utf-8" && encoding !== "utf8") {
        throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);
      }
      if (this.textEncoder == null) {
        this.textEncoder = new TextEncoder();
      }
      return this.textEncoder.encode(text);
    }
    decode(bytes, encoding) {
      return new TextDecoder(encoding).decode(bytes);
    }
    // If the setTimeout nesting level is greater than 5 and timeout is less
    // than 4ms, timeout will be clamped to 4ms, which hurts the perf.
    // Interleaving window.postMessage and setTimeout will trick the browser and
    // avoid the clamp.
    setTimeoutCustom(functionRef, delay) {
      if (typeof window === "undefined" || !env().getBool("USE_SETTIMEOUTCUSTOM")) {
        setTimeout(functionRef, delay);
        return;
      }
      this.functionRefs.push(functionRef);
      setTimeout(() => {
        window.postMessage({ name: this.messageName, index: this.functionRefs.length - 1 }, "*");
      }, delay);
      if (!this.hasEventListener) {
        this.hasEventListener = true;
        window.addEventListener("message", (event) => {
          if (event.source === window && event.data.name === this.messageName) {
            event.stopPropagation();
            const functionRef2 = this.functionRefs[event.data.index];
            functionRef2();
            this.handledMessageCount++;
            if (this.handledMessageCount === this.functionRefs.length) {
              this.functionRefs = [];
              this.handledMessageCount = 0;
            }
          }
        }, true);
      }
    }
    isTypedArray(a2) {
      return a2 instanceof Float32Array || a2 instanceof Int32Array || a2 instanceof Uint8Array || a2 instanceof Uint8ClampedArray;
    }
  };
  if (env().get("IS_BROWSER")) {
    env().setPlatform("browser", new PlatformBrowser());
    try {
      ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());
    } catch (err) {
    }
    try {
      ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());
    } catch (err) {
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/platforms/platform_node.js
  var getNodeFetch = {
    // tslint:disable-next-line:no-require-imports
    importFetch: () => require_browser2()
  };
  var systemFetch;
  var PlatformNode = class {
    constructor() {
      this.util = require_util();
      this.textEncoder = new this.util.TextEncoder();
    }
    fetch(path, requestInits) {
      if (env().global.fetch != null) {
        return env().global.fetch(path, requestInits);
      }
      if (systemFetch == null) {
        systemFetch = getNodeFetch.importFetch();
      }
      return systemFetch(path, requestInits);
    }
    now() {
      const time = process.hrtime();
      return time[0] * 1e3 + time[1] / 1e6;
    }
    encode(text, encoding) {
      if (encoding !== "utf-8" && encoding !== "utf8") {
        throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);
      }
      return this.textEncoder.encode(text);
    }
    decode(bytes, encoding) {
      if (bytes.length === 0) {
        return "";
      }
      return new this.util.TextDecoder(encoding).decode(bytes);
    }
    isTypedArray(a2) {
      return this.util.types.isFloat32Array(a2) || this.util.types.isInt32Array(a2) || this.util.types.isUint8Array(a2) || this.util.types.isUint8ClampedArray(a2);
    }
  };
  if (env().get("IS_NODE") && !env().get("IS_BROWSER")) {
    env().setPlatform("node", new PlatformNode());
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/buffer.js
  function buffer(shape, dtype = "float32", values) {
    dtype = dtype || "float32";
    assertNonNegativeIntegerDimensions(shape);
    return new TensorBuffer(shape, dtype, values);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/cast.js
  function cast_(x2, dtype) {
    const $x = convertToTensor(x2, "x", "cast");
    if (!isValidDtype(dtype)) {
      throw new Error(`Failed to cast to unknown dtype ${dtype}`);
    }
    if (dtype === "string" && $x.dtype !== "string" || dtype !== "string" && $x.dtype === "string") {
      throw new Error("Only strings can be casted to strings");
    }
    const inputs = { x: $x };
    const attrs = { dtype };
    return ENGINE.runKernel(Cast, inputs, attrs);
  }
  var cast = /* @__PURE__ */ op({ cast_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/clone.js
  function clone_(x2) {
    const $x = convertToTensor(x2, "x", "clone", "string_or_numeric");
    const inputs = { x: $x };
    return ENGINE.runKernel(Identity2, inputs);
  }
  var clone = /* @__PURE__ */ op({ clone_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/print.js
  function print(x2, verbose = false) {
    console.log(x2.toString(verbose));
  }

  // node_modules/@tensorflow/tfjs-core/dist/base_side_effects.js
  getOrMakeEngine();
  var opHandler2 = {
    buffer,
    cast,
    clone,
    print
  };
  setOpHandler(opHandler2);

  // node_modules/@tensorflow/tfjs-core/dist/globals.js
  function deprecationWarn(msg) {
    if (env().getBool("DEPRECATION_WARNINGS_ENABLED")) {
      console.warn(msg + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
    }
  }
  setDeprecationWarningFn(deprecationWarn);
  function engine() {
    return ENGINE;
  }
  function tidy(nameOrFn, fn2) {
    return ENGINE.tidy(nameOrFn, fn2);
  }
  function dispose(container) {
    const tensors = getTensorsInContainer(container);
    tensors.forEach((tensor2) => tensor2.dispose());
  }
  function keep(result) {
    return ENGINE.keep(result);
  }
  function registerBackend(name, factory, priority = 1) {
    return ENGINE.registerBackend(name, factory, priority);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/add.js
  function add_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "add");
    let $b = convertToTensor(b2, "b", "add");
    [$a2, $b] = makeTypesMatch($a2, $b);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(Add2, inputs);
  }
  var add2 = /* @__PURE__ */ op({ add_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/floorDiv.js
  function floorDiv_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "floorDiv");
    let $b = convertToTensor(b2, "b", "floorDiv");
    [$a2, $b] = makeTypesMatch($a2, $b);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(FloorDiv, inputs);
  }
  var floorDiv = /* @__PURE__ */ op({ floorDiv_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/div.js
  function div_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "div");
    let $b = convertToTensor(b2, "b", "div");
    [$a2, $b] = makeTypesMatch($a2, $b);
    if ($a2.dtype === "int32" && $b.dtype === "int32") {
      return floorDiv($a2, $b);
    }
    const inputs = { a: $a2, b: $b };
    const attrs = {};
    return ENGINE.runKernel(RealDiv, inputs, attrs);
  }
  var div = /* @__PURE__ */ op({ div_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/mul.js
  function mul_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "mul");
    let $b = convertToTensor(b2, "b", "mul");
    [$a2, $b] = makeTypesMatch($a2, $b);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(Multiply2, inputs);
  }
  var mul = /* @__PURE__ */ op({ mul_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/abs.js
  function abs_(x2) {
    const $x = convertToTensor(x2, "x", "abs");
    if ($x.dtype === "complex64") {
      const inputs = { x: $x };
      return ENGINE.runKernel(ComplexAbs, inputs);
    } else {
      const inputs = { x: $x };
      return ENGINE.runKernel(Abs, inputs);
    }
  }
  var abs = /* @__PURE__ */ op({ abs_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/acos.js
  function acos_(x2) {
    const $x = convertToTensor(x2, "x", "acos");
    const inputs = { x: $x };
    return ENGINE.runKernel(Acos, inputs);
  }
  var acos = /* @__PURE__ */ op({ acos_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/acosh.js
  function acosh_(x2) {
    const $x = convertToTensor(x2, "x", "acosh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Acosh, inputs);
  }
  var acosh = /* @__PURE__ */ op({ acosh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/add_n.js
  function addN_(tensors) {
    assert2(Array.isArray(tensors), () => "The argument passed to tf.addN() must be a list of tensors");
    assert2(tensors.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${tensors.length}`);
    const $tensors = tensors.map((t3, i2) => convertToTensor(t3, `tensors${i2}`, "addN"));
    const firstTensor = $tensors[0];
    $tensors.forEach((t3) => {
      if (t3.dtype !== firstTensor.dtype) {
        throw new Error("All tensors passed to tf.addN() must have the same dtype");
      }
    });
    $tensors.forEach((t3) => {
      if (!arraysEqual(t3.shape, firstTensor.shape)) {
        throw new Error("All tensors passed to tf.addN() must have the same shape");
      }
    });
    const inputs = $tensors;
    return ENGINE.runKernel(AddN, inputs);
  }
  var addN = /* @__PURE__ */ op({ addN_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/all.js
  function all_(x2, axis = null, keepDims = false) {
    const $x = convertToTensor(x2, "x", "all", "bool");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(All, inputs, attrs);
  }
  var all = /* @__PURE__ */ op({ all_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/any.js
  function any_(x2, axis = null, keepDims = false) {
    const $x = convertToTensor(x2, "x", "any", "bool");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Any, inputs, attrs);
  }
  var any = /* @__PURE__ */ op({ any_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/arg_max.js
  function argMax_(x2, axis = 0) {
    const $x = convertToTensor(x2, "x", "argMax");
    const inputs = { x: $x };
    const attrs = { axis };
    return ENGINE.runKernel(ArgMax, inputs, attrs);
  }
  var argMax = /* @__PURE__ */ op({ argMax_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/arg_min.js
  function argMin_(x2, axis = 0) {
    const $x = convertToTensor(x2, "x", "argMin");
    const inputs = { x: $x };
    const attrs = { axis };
    return ENGINE.runKernel(ArgMin, inputs, attrs);
  }
  var argMin = /* @__PURE__ */ op({ argMin_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/asin.js
  function asin_(x2) {
    const $x = convertToTensor(x2, "x", "asin");
    const inputs = { x: $x };
    return ENGINE.runKernel(Asin, inputs);
  }
  var asin = /* @__PURE__ */ op({ asin_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/asinh.js
  function asinh_(x2) {
    const $x = convertToTensor(x2, "x", "asinh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Asinh, inputs);
  }
  var asinh = /* @__PURE__ */ op({ asinh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/atan.js
  function atan_(x2) {
    const $x = convertToTensor(x2, "x", "atan");
    const inputs = { x: $x };
    return ENGINE.runKernel(Atan, inputs);
  }
  var atan = /* @__PURE__ */ op({ atan_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/atan2.js
  function atan2_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "atan2");
    let $b = convertToTensor(b2, "b", "atan2");
    [$a2, $b] = makeTypesMatch($a2, $b);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(Atan2, inputs);
  }
  var atan2 = /* @__PURE__ */ op({ atan2_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/atanh.js
  function atanh_(x2) {
    const $x = convertToTensor(x2, "x", "atanh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Atanh, inputs);
  }
  var atanh = /* @__PURE__ */ op({ atanh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv_util.js
  function computeDilation2DInfo(inputShape, filterShape, strides, pad2, dataFormat = "NHWC", dilations) {
    const inputChannels = inputShape[3];
    const $filterShape = [...filterShape, inputChannels];
    const $dataFormat = convertConv2DDataFormat(dataFormat);
    return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad2, null, null, $dataFormat);
  }
  function computePool2DInfo(inShape, filterSize, strides, dilations, pad2, roundingMode, dataFormat = "channelsLast") {
    const [filterHeight, filterWidth] = parseTupleParam(filterSize);
    let filterShape;
    if (dataFormat === "channelsLast") {
      filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
    } else if (dataFormat === "channelsFirst") {
      filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad2, roundingMode, false, dataFormat);
  }
  function computePool3DInfo(inShape, filterSize, strides, dilations, pad2, roundingMode, dataFormat = "NDHWC") {
    const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);
    let filterShape;
    let $dataFormat;
    if (dataFormat === "NDHWC") {
      $dataFormat = "channelsLast";
      filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];
    } else if (dataFormat === "NCDHW") {
      $dataFormat = "channelsFirst";
      filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    return computeConv3DInfo(inShape, filterShape, strides, dilations, pad2, false, $dataFormat, roundingMode);
  }
  function computeConv2DInfo(inShape, filterShape, strides, dilations, pad2, roundingMode, depthwise = false, dataFormat = "channelsLast") {
    let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];
    if (dataFormat === "channelsLast") {
      [batchSize, inHeight, inWidth, inChannels] = inShape;
    } else if (dataFormat === "channelsFirst") {
      [batchSize, inChannels, inHeight, inWidth] = inShape;
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    const [filterHeight, filterWidth, , filterChannels] = filterShape;
    const [strideHeight, strideWidth] = parseTupleParam(strides);
    const [dilationHeight, dilationWidth] = parseTupleParam(dilations);
    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad2, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    let outShape;
    if (dataFormat === "channelsFirst") {
      outShape = [batchSize, outChannels, outHeight, outWidth];
    } else if (dataFormat === "channelsLast") {
      outShape = [batchSize, outHeight, outWidth, outChannels];
    }
    return {
      batchSize,
      dataFormat,
      inHeight,
      inWidth,
      inChannels,
      outHeight,
      outWidth,
      outChannels,
      padInfo,
      strideHeight,
      strideWidth,
      filterHeight,
      filterWidth,
      effectiveFilterHeight,
      effectiveFilterWidth,
      dilationHeight,
      dilationWidth,
      inShape,
      outShape,
      filterShape
    };
  }
  function computeConv3DInfo(inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast", roundingMode) {
    let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];
    if (dataFormat === "channelsLast") {
      [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
    } else if (dataFormat === "channelsFirst") {
      [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
    const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
    const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
    const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);
    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    let outShape;
    if (dataFormat === "channelsFirst") {
      outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
    } else if (dataFormat === "channelsLast") {
      outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
    }
    return {
      batchSize,
      dataFormat,
      inDepth,
      inHeight,
      inWidth,
      inChannels,
      outDepth,
      outHeight,
      outWidth,
      outChannels,
      padInfo,
      strideDepth,
      strideHeight,
      strideWidth,
      filterDepth,
      filterHeight,
      filterWidth,
      effectiveFilterDepth,
      effectiveFilterHeight,
      effectiveFilterWidth,
      dilationDepth,
      dilationHeight,
      dilationWidth,
      inShape,
      outShape,
      filterShape
    };
  }
  function computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {
    if (zeroPad == null) {
      zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    const inputRows = inShape[0];
    const inputCols = inShape[1];
    const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    return [outputRows, outputCols];
  }
  function computeOutputShape4D(inShape, filterShape, outChannels, strides, zeroPad, roundingMode) {
    if (zeroPad == null) {
      zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
    }
    const outShape = [0, 0, 0, outChannels];
    for (let index = 0; index < 3; index++) {
      if (inShape[index] + 2 * zeroPad >= filterShape[index]) {
        outShape[index] = round((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1, roundingMode);
      }
    }
    return outShape;
  }
  function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {
    const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
  }
  function parseTupleParam(param) {
    if (typeof param === "number") {
      return [param, param, param];
    }
    if (param.length === 2) {
      return [param[0], param[1], 1];
    }
    return param;
  }
  function parse3TupleParam(param) {
    return typeof param === "number" ? [param, param, param] : param;
  }
  function getEffectiveFilterSize(filterSize, dilation) {
    if (dilation <= 1) {
      return filterSize;
    }
    return filterSize + (filterSize - 1) * (dilation - 1);
  }
  function getPadAndOutInfo(pad2, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
    let padInfo;
    let outHeight;
    let outWidth;
    if (typeof pad2 === "number") {
      const padType = pad2 === 0 ? "VALID" : "NUMBER";
      padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, type: padType };
      const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad2, roundingMode);
      outHeight = outShape[0];
      outWidth = outShape[1];
    } else if (pad2 === "same") {
      outHeight = Math.ceil(inHeight / strideHeight);
      outWidth = Math.ceil(inWidth / strideWidth);
      const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
      const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
      const top = Math.floor(padAlongHeight / 2);
      const bottom = padAlongHeight - top;
      const left = Math.floor(padAlongWidth / 2);
      const right = padAlongWidth - left;
      padInfo = { top, bottom, left, right, type: "SAME" };
    } else if (pad2 === "valid") {
      padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" };
      outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
      outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    } else if (typeof pad2 === "object") {
      const top = dataFormat === "channelsLast" ? pad2[1][0] : pad2[2][0];
      const bottom = dataFormat === "channelsLast" ? pad2[1][1] : pad2[2][1];
      const left = dataFormat === "channelsLast" ? pad2[2][0] : pad2[3][0];
      const right = dataFormat === "channelsLast" ? pad2[2][1] : pad2[3][1];
      const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? "VALID" : "EXPLICIT";
      padInfo = { top, bottom, left, right, type: padType };
      outHeight = round((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
      outWidth = round((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
    } else {
      throw Error(`Unknown padding parameter: ${pad2}`);
    }
    return { padInfo, outHeight, outWidth };
  }
  function get3DPadAndOutInfo(pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
    let padInfo;
    let outDepth;
    let outHeight;
    let outWidth;
    if (pad2 === "valid") {
      pad2 = 0;
    }
    if (typeof pad2 === "number") {
      const padType = pad2 === 0 ? "VALID" : "NUMBER";
      padInfo = {
        top: pad2,
        bottom: pad2,
        left: pad2,
        right: pad2,
        front: pad2,
        back: pad2,
        type: padType
      };
      const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], [filterDepth, filterHeight, filterWidth], 1, [strideDepth, strideHeight, strideWidth], pad2, roundingMode);
      outDepth = outShape[0];
      outHeight = outShape[1];
      outWidth = outShape[2];
    } else if (pad2 === "same") {
      outDepth = Math.ceil(inDepth / strideDepth);
      outHeight = Math.ceil(inHeight / strideHeight);
      outWidth = Math.ceil(inWidth / strideWidth);
      const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
      const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
      const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
      const front = Math.floor(padAlongDepth / 2);
      const back = padAlongDepth - front;
      const top = Math.floor(padAlongHeight / 2);
      const bottom = padAlongHeight - top;
      const left = Math.floor(padAlongWidth / 2);
      const right = padAlongWidth - left;
      padInfo = { top, bottom, left, right, front, back, type: "SAME" };
    } else {
      throw Error(`Unknown padding parameter: ${pad2}`);
    }
    return { padInfo, outDepth, outHeight, outWidth };
  }
  function round(value, roundingMode) {
    if (!roundingMode) {
      return Math.trunc(value);
    }
    switch (roundingMode) {
      case "round":
        return Math.round(value);
      case "ceil":
        return Math.ceil(value);
      case "floor":
        return Math.floor(value);
      default:
        throw new Error(`Unknown roundingMode ${roundingMode}`);
    }
  }
  function tupleValuesAreOne(param) {
    const [dimA, dimB, dimC] = parseTupleParam(param);
    return dimA === 1 && dimB === 1 && dimC === 1;
  }
  function eitherStridesOrDilationsAreOne(strides, dilations) {
    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
  }
  function stridesOrDilationsArePositive(values) {
    return parseTupleParam(values).every((value) => value > 0);
  }
  function convertConv2DDataFormat(dataFormat) {
    if (dataFormat === "NHWC") {
      return "channelsLast";
    } else if (dataFormat === "NCHW") {
      return "channelsFirst";
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
  }
  function checkPadOnDimRoundingMode(opDesc, pad2, dimRoundingMode) {
    if (dimRoundingMode != null) {
      if (typeof pad2 === "string") {
        throw Error(`Error in ${opDesc}: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${pad2}.`);
      } else if (typeof pad2 === "number") {
        assert2(isInt(pad2), () => `Error in ${opDesc}: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${pad2}.`);
      } else if (typeof pad2 === "object") {
        pad2.forEach((p2) => {
          p2.forEach((v2) => {
            assert2(isInt(v2), () => `Error in ${opDesc}: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${v2}.`);
          });
        });
      } else {
        throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad2}`);
      }
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/reshape.js
  function reshape_(x2, shape) {
    const $x = convertToTensor(x2, "x", "reshape", "string_or_numeric");
    const inputs = { x: $x };
    const attrs = { shape };
    return ENGINE.runKernel(Reshape2, inputs, attrs);
  }
  var reshape2 = /* @__PURE__ */ op({ reshape_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/avg_pool.js
  function avgPool_(x2, filterSize, strides, pad2, dimRoundingMode) {
    const $x = convertToTensor(x2, "x", "avgPool", "float32");
    const dilations = 1;
    assert2(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert2(x4D.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);
    checkPadOnDimRoundingMode("avgPool", pad2, dimRoundingMode);
    const inputs = { x: x4D };
    const attrs = { filterSize, strides, pad: pad2, dimRoundingMode };
    let res = ENGINE.runKernel(AvgPool, inputs, attrs);
    res = cast(res, $x.dtype);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var avgPool = /* @__PURE__ */ op({ avgPool_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/avg_pool_3d.js
  function avgPool3d_(x2, filterSize, strides, pad2, dimRoundingMode, dataFormat = "NDHWC") {
    const $x = convertToTensor(x2, "x", "avgPool3d", "float32");
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
      reshapedTo5D = true;
      x5D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert2(x5D.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
    assert2(dataFormat === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
    assert2(typeof strides === "number" && strides > 0 || Array.isArray(strides) && strides[0] > 0 && strides[1] > 0 && strides[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${strides}'`);
    checkPadOnDimRoundingMode("avgPool3d", pad2, dimRoundingMode);
    const inputs = { x: x5D };
    const attrs = { filterSize, strides, pad: pad2, dimRoundingMode, dataFormat };
    let res = ENGINE.runKernel(AvgPool3D, inputs, attrs);
    res = cast(res, x5D.dtype);
    if (reshapedTo5D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  var avgPool3d = /* @__PURE__ */ op({ avgPool3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat.js
  function concat_(tensors, axis = 0) {
    assert2(tensors.length >= 1, () => "Pass at least one tensor to concat");
    const $tensors = convertToTensorArray(tensors, "tensors", "concat", "string_or_numeric");
    if ($tensors[0].dtype === "complex64") {
      $tensors.forEach((tensor2) => {
        if (tensor2.dtype !== "complex64") {
          throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${tensor2.dtype}. `);
        }
      });
    }
    if ($tensors.length === 1) {
      return clone($tensors[0]);
    }
    const inputs = $tensors;
    const attr = { axis };
    return ENGINE.runKernel(Concat, inputs, attr);
  }
  var concat = /* @__PURE__ */ op({ concat_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/mat_mul.js
  function matMul_(a2, b2, transposeA = false, transposeB = false) {
    let $a2 = convertToTensor(a2, "a", "matMul");
    let $b = convertToTensor(b2, "b", "matMul");
    [$a2, $b] = makeTypesMatch($a2, $b);
    const inputs = { a: $a2, b: $b };
    const attrs = { transposeA, transposeB };
    return ENGINE.runKernel(BatchMatMul, inputs, attrs);
  }
  var matMul = /* @__PURE__ */ op({ matMul_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sigmoid.js
  function sigmoid_(x2) {
    const $x = convertToTensor(x2, "x", "sigmoid", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sigmoid2, inputs);
  }
  var sigmoid = /* @__PURE__ */ op({ sigmoid_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice.js
  function slice_(x2, begin, size) {
    const $x = convertToTensor(x2, "x", "slice", "string_or_numeric");
    if ($x.rank === 0) {
      throw new Error("Slicing scalar is not possible");
    }
    const inputs = { x: $x };
    const attrs = { begin, size };
    return ENGINE.runKernel(Slice, inputs, attrs);
  }
  var slice = /* @__PURE__ */ op({ slice_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/tanh.js
  function tanh_(x2) {
    const $x = convertToTensor(x2, "x", "tanh", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Tanh2, inputs);
  }
  var tanh2 = /* @__PURE__ */ op({ tanh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/basic_lstm_cell.js
  function basicLSTMCell_(forgetBias, lstmKernel, lstmBias, data, c2, h) {
    const $forgetBias = convertToTensor(forgetBias, "forgetBias", "basicLSTMCell");
    const $lstmKernel = convertToTensor(lstmKernel, "lstmKernel", "basicLSTMCell");
    const $lstmBias = convertToTensor(lstmBias, "lstmBias", "basicLSTMCell");
    const $data = convertToTensor(data, "data", "basicLSTMCell");
    const $c2 = convertToTensor(c2, "c", "basicLSTMCell");
    const $h2 = convertToTensor(h, "h", "basicLSTMCell");
    const combined = concat([$data, $h2], 1);
    const weighted = matMul(combined, $lstmKernel);
    const res = add2(weighted, $lstmBias);
    const batchSize = res.shape[0];
    const sliceCols = res.shape[1] / 4;
    const sliceSize = [batchSize, sliceCols];
    const i2 = slice(res, [0, 0], sliceSize);
    const j3 = slice(res, [0, sliceCols], sliceSize);
    const f2 = slice(res, [0, sliceCols * 2], sliceSize);
    const o2 = slice(res, [0, sliceCols * 3], sliceSize);
    const newC = add2(mul(sigmoid(i2), tanh2(j3)), mul($c2, sigmoid(add2($forgetBias, f2))));
    const newH = mul(tanh2(newC), sigmoid(o2));
    return [newC, newH];
  }
  var basicLSTMCell = /* @__PURE__ */ op({ basicLSTMCell_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/batch_to_space_nd.js
  function batchToSpaceND_(x2, blockShape, crops) {
    const $x = convertToTensor(x2, "x", "batchToSpaceND");
    const prod3 = blockShape.reduce((a2, b2) => a2 * b2);
    assert2($x.rank >= 1 + blockShape.length, () => `input rank is ${$x.rank} but should be > than blockShape.length ${blockShape.length}`);
    assert2(crops.length === blockShape.length, () => `crops.length is ${crops.length} but should be equal to blockShape.length  ${blockShape.length}`);
    assert2($x.shape[0] % prod3 === 0, () => `input tensor batch is ${$x.shape[0]} but is not divisible by the product of the elements of blockShape ${blockShape.join(" * ")} === ${prod3}`);
    const inputs = { x: $x };
    const attrs = { blockShape, crops };
    return ENGINE.runKernel(BatchToSpaceND, inputs, attrs);
  }
  var batchToSpaceND = /* @__PURE__ */ op({ batchToSpaceND_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm_util.js
  function xAs4D(x2) {
    let x4D;
    if (x2.rank === 0 || x2.rank === 1) {
      x4D = reshape2(x2, [1, 1, 1, x2.size]);
    } else if (x2.rank === 2) {
      x4D = reshape2(x2, [1, 1, x2.shape[0], x2.shape[1]]);
    } else if (x2.rank === 3) {
      x4D = reshape2(x2, [1, x2.shape[0], x2.shape[1], x2.shape[2]]);
    } else {
      x4D = x2;
    }
    return x4D;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm.js
  function batchNorm_(x2, mean2, variance, offset, scale, varianceEpsilon) {
    if (varianceEpsilon == null) {
      varianceEpsilon = 1e-3;
    }
    const $x = convertToTensor(x2, "x", "batchNorm");
    const $mean = convertToTensor(mean2, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale != null) {
      $scale = convertToTensor(scale, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert2($mean.rank === $variance.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
    assert2($offset == null || $mean.rank === $offset.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
    assert2($scale == null || $mean.rank === $scale.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    const x4D = xAs4D($x);
    const inputs = {
      x: x4D,
      scale: $scale,
      offset: $offset,
      mean: $mean,
      variance: $variance
    };
    const attrs = { varianceEpsilon };
    const res = ENGINE.runKernel(FusedBatchNorm, inputs, attrs);
    return reshape2(res, $x.shape);
  }
  var batchNorm = /* @__PURE__ */ op({ batchNorm_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm2d.js
  function batchNorm2d_(x2, mean2, variance, offset, scale, varianceEpsilon) {
    const $x = convertToTensor(x2, "x", "batchNorm");
    const $mean = convertToTensor(mean2, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale != null) {
      $scale = convertToTensor(scale, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert2($x.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${$x.rank}.`);
    assert2($mean.rank === 2 || $mean.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${$mean.rank}.`);
    assert2($variance.rank === 2 || $variance.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${$variance.rank}.`);
    if ($scale != null) {
      assert2($scale.rank === 2 || $scale.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
      assert2($offset.rank === 2 || $offset.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${$offset.rank}.`);
    }
    return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
  }
  var batchNorm2d = /* @__PURE__ */ op({ batchNorm2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm3d.js
  function batchNorm3d_(x2, mean2, variance, offset, scale, varianceEpsilon) {
    const $x = convertToTensor(x2, "x", "batchNorm");
    const $mean = convertToTensor(mean2, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale != null) {
      $scale = convertToTensor(scale, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert2($x.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${$x.rank}.`);
    assert2($mean.rank === 3 || $mean.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${$mean.rank}.`);
    assert2($variance.rank === 3 || $variance.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${$variance.rank}.`);
    if ($scale != null) {
      assert2($scale.rank === 3 || $scale.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
      assert2($offset.rank === 3 || $offset.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${$offset.rank}.`);
    }
    return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
  }
  var batchNorm3d = /* @__PURE__ */ op({ batchNorm3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm4d.js
  function batchNorm4d_(x2, mean2, variance, offset, scale, varianceEpsilon) {
    const $x = convertToTensor(x2, "x", "batchNorm");
    const $mean = convertToTensor(mean2, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale != null) {
      $scale = convertToTensor(scale, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert2($x.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${$x.rank}.`);
    assert2($mean.rank === 4 || $mean.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${$mean.rank}.`);
    assert2($variance.rank === 4 || $variance.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${$variance.rank}.`);
    if ($scale != null) {
      assert2($scale.rank === 4 || $scale.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
      assert2($offset.rank === 4 || $offset.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${$offset.rank}.`);
    }
    return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
  }
  var batchNorm4d = /* @__PURE__ */ op({ batchNorm4d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/bincount.js
  function bincount_(x2, weights, size) {
    const $x = convertToTensor(x2, "x", "bincount");
    const $weights = convertToTensor(weights, "weights", "bincount");
    assert2($x.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${$x.dtype}`);
    assert2(size >= 0, () => `size must be non-negative, but got ${size}.`);
    assert2($weights.size === $x.size || $weights.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${$x.shape}, weights shape: ${$weights.shape}.`);
    const inputs = { x: $x, weights: $weights };
    const attrs = { size };
    return ENGINE.runKernel(Bincount, inputs, attrs);
  }
  var bincount = /* @__PURE__ */ op({ bincount_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/broadcast_args.js
  function broadcastArgs_(s0, s1) {
    const shape1Input = convertToTensor(s0, "s0", "broadcastArgs", "int32");
    const shape2Input = convertToTensor(s1, "s1", "broadcastArgs", "int32");
    if (shape1Input.rank !== 1) {
      throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${shape1Input.rank}`);
    }
    if (shape2Input.rank !== 1) {
      throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${shape2Input.rank}`);
    }
    const inputs = { s0: shape1Input, s1: shape2Input };
    return ENGINE.runKernel(BroadcastArgs, inputs);
  }
  var broadcastArgs = /* @__PURE__ */ op({ broadcastArgs_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/broadcast_to.js
  function broadcastTo_(x2, shape) {
    let input2 = convertToTensor(x2, "broadcastTo", "x");
    const xShape = input2.shape;
    assertNonNegativeIntegerDimensions(shape);
    if (shape.length < input2.rank) {
      throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input2.rank}.`);
    }
    if (shape.length > input2.rank) {
      const newShape = input2.shape.slice();
      while (newShape.length < shape.length) {
        newShape.unshift(1);
      }
      input2 = reshape2(input2, newShape);
    }
    const inputShape = input2.shape;
    const reps = Array.from(shape);
    for (let i2 = shape.length - 1; i2 >= 0; i2--) {
      if (inputShape[i2] === shape[i2]) {
        reps[i2] = 1;
      } else if (input2.shape[i2] !== 1) {
        throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);
      }
    }
    const axes = reps.map((n2, i2) => n2 > 1 ? i2 : -1).filter((i2) => i2 >= 0);
    if (axes.length === 0) {
      return clone(input2);
    }
    const inputs = { x: input2 };
    const attrs = { reps };
    return ENGINE.runKernel(Tile, inputs, attrs);
  }
  var broadcastTo = /* @__PURE__ */ op({ broadcastTo_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/ceil.js
  function ceil_(x2) {
    const $x = convertToTensor(x2, "x", "ceil", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Ceil, inputs);
  }
  var ceil = /* @__PURE__ */ op({ ceil_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/fill.js
  function fill(shape, value, dtype) {
    assertNonNegativeIntegerDimensions(shape);
    const attrs = { shape, value, dtype };
    return ENGINE.runKernel(Fill, {}, attrs);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/clip_by_value.js
  function clipByValue_(x2, clipValueMin, clipValueMax) {
    const $x = convertToTensor(x2, "x", "clipByValue");
    assert2(clipValueMin <= clipValueMax, () => `Error in clip: min (${clipValueMin}) must be less than or equal to max (${clipValueMax}).`);
    if (clipValueMin === clipValueMax) {
      return fill($x.shape, clipValueMin, $x.dtype);
    }
    const inputs = { x: $x };
    const attrs = { clipValueMin, clipValueMax };
    return ENGINE.runKernel(ClipByValue, inputs, attrs);
  }
  var clipByValue = /* @__PURE__ */ op({ clipByValue_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat_1d.js
  function concat1d_(tensors) {
    return concat(
      tensors,
      0
      /* axis */
    );
  }
  var concat1d = /* @__PURE__ */ op({ concat1d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat_2d.js
  function concat2d_(tensors, axis) {
    return concat(tensors, axis);
  }
  var concat2d = /* @__PURE__ */ op({ concat2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat_3d.js
  function concat3d_(tensors, axis) {
    return concat(tensors, axis);
  }
  var concat3d = /* @__PURE__ */ op({ concat3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat_4d.js
  function concat4d_(tensors, axis) {
    return concat(tensors, axis);
  }
  var concat4d = /* @__PURE__ */ op({ concat4d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv2d.js
  function conv2d_(x2, filter, strides, pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
    const $x = convertToTensor(x2, "x", "conv2d", "float32");
    const $filter = convertToTensor(filter, "filter", "conv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert2(x4D.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert2($filter.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    checkPadOnDimRoundingMode("conv2d", pad2, dimRoundingMode);
    const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
    assert2(inDepth === $filter.shape[2], () => `Error in conv2d: depth of input (${inDepth}) must match input depth for filter ${$filter.shape[2]}.`);
    assert2(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    assert2(stridesOrDilationsArePositive(dilations), () => "Error in conv2D: Dilated rates should be larger than 0.");
    assert2(stridesOrDilationsArePositive(strides), () => "Error in conv2D: Strides should be larger than 0.");
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad: pad2, dataFormat, dilations, dimRoundingMode };
    const res = ENGINE.runKernel(Conv2D2, inputs, attrs);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var conv2d = /* @__PURE__ */ op({ conv2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv1d.js
  function conv1d_(x2, filter, stride, pad2, dataFormat = "NWC", dilation = 1, dimRoundingMode) {
    const $x = convertToTensor(x2, "x", "conv1d");
    const $filter = convertToTensor(filter, "filter", "conv1d");
    let x3D = $x;
    let reshapedTo3D = false;
    if ($x.rank === 2) {
      reshapedTo3D = true;
      x3D = reshape2($x, [1, $x.shape[0], $x.shape[1]]);
    }
    assert2(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);
    assert2($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${$filter.rank}.`);
    checkPadOnDimRoundingMode("conv1d", pad2, dimRoundingMode);
    assert2(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match input depth for filter ${$filter.shape[1]}.`);
    assert2(eitherStridesOrDilationsAreOne(stride, dilation), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${stride} and dilation '${dilation}'`);
    assert2(stridesOrDilationsArePositive(dilation), () => "Error in conv1D: Dilated rates should be larger than 0.");
    assert2(stridesOrDilationsArePositive(stride), () => "Error in conv1D: Stride should be larger than 0.");
    assert2(dataFormat === "NWC", () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);
    const filter4D = reshape2($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);
    const input4D = reshape2(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);
    const strides = [1, stride];
    const dilations = [1, dilation];
    const conv2dDataFormat = "NHWC";
    const res = conv2d(input4D, filter4D, strides, pad2, conv2dDataFormat, dilations, dimRoundingMode);
    if (reshapedTo3D) {
      return reshape2(res, [res.shape[2], res.shape[3]]);
    }
    return reshape2(res, [res.shape[0], res.shape[2], res.shape[3]]);
  }
  var conv1d = /* @__PURE__ */ op({ conv1d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv2d_backprop_input.js
  function conv2DBackpropInput_(xShape, dy, filter, strides, pad2, dataFormat = "NHWC", dimRoundingMode) {
    assert2(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
    let xShape4D = xShape;
    let dy4D = dy;
    let reshapedTo4D = false;
    if (dy.rank === 3) {
      reshapedTo4D = true;
      dy4D = reshape2(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
      xShape4D = [1, xShape[0], xShape[1], xShape[2]];
    }
    assert2(xShape4D.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${xShape4D.length}.`);
    assert2(dy4D.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${dy4D.rank}`);
    assert2(filter.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${filter.rank}`);
    const inDepth = dataFormat === "NHWC" ? xShape4D[3] : xShape4D[1];
    const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
    assert2(inDepth === filter.shape[2], () => `Error in conv2dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter.shape[2]}.`);
    assert2(outDepth === filter.shape[3], () => `Error in conv2dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter.shape[3]}.`);
    checkPadOnDimRoundingMode("conv2dDerInput", pad2, dimRoundingMode);
    const inputs = { dy: dy4D, filter };
    const attrs = { strides, pad: pad2, dataFormat, dimRoundingMode, inputShape: xShape4D };
    const res = ENGINE.runKernel(Conv2DBackpropInput, inputs, attrs);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var conv2DBackpropInput = /* @__PURE__ */ op({ conv2DBackpropInput_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv2d_transpose.js
  function conv2dTranspose_(x2, filter, outputShape, strides, pad2, dimRoundingMode) {
    const $x = convertToTensor(x2, "x", "conv2dTranspose");
    const $filter = convertToTensor(filter, "filter", "conv2dTranspose");
    return conv2DBackpropInput(outputShape, $x, $filter, strides, pad2, "NHWC", dimRoundingMode);
  }
  var conv2dTranspose = /* @__PURE__ */ op({ conv2dTranspose_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv3d.js
  function conv3d_(x2, filter, strides, pad2, dataFormat = "NDHWC", dilations = [1, 1, 1]) {
    const $x = convertToTensor(x2, "x", "conv3d");
    const $filter = convertToTensor(filter, "filter", "conv3d");
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
      reshapedTo5D = true;
      x5D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert2(x5D.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`);
    assert2($filter.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${$filter.rank}.`);
    assert2(x5D.shape[4] === $filter.shape[3], () => `Error in conv3d: depth of input (${x5D.shape[4]}) must match input depth for filter ${$filter.shape[3]}.`);
    assert2(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    assert2(dataFormat === "NDHWC", () => `Error in conv3d: got dataFormat of ${dataFormat} but only NDHWC is currently supported.`);
    assert2(stridesOrDilationsArePositive(dilations), () => "Error in conv3D: Dilated rates should be larger than 0.");
    assert2(stridesOrDilationsArePositive(strides), () => "Error in conv3D: Strides should be larger than 0.");
    const inputs = { x: x5D, filter: $filter };
    const attrs = { strides, pad: pad2, dataFormat, dilations };
    const res = ENGINE.runKernel(Conv3D2, inputs, attrs);
    if (reshapedTo5D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  var conv3d = /* @__PURE__ */ op({ conv3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv3d_backprop_input.js
  function conv3DBackpropInput_(xShape, dy, filter, strides, pad2) {
    assert2(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
    let xShape5D = xShape;
    let dy5D = dy;
    let reshapedTo5D = false;
    if (dy.rank === 4) {
      reshapedTo5D = true;
      dy5D = reshape2(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
      xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];
    }
    const inDepth = xShape5D[4];
    const outDepth = dy5D.shape[4];
    assert2(xShape5D.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${xShape5D.length}.`);
    assert2(dy5D.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${dy5D.rank}`);
    assert2(filter.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${filter.rank}`);
    assert2(inDepth === filter.shape[3], () => `Error in conv3dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter.shape[3]}.`);
    assert2(outDepth === filter.shape[4], () => `Error in conv3dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter.shape[4]}.`);
    const inputs = { dy: dy5D, filter };
    const attrs = { pad: pad2, strides, inputShape: xShape5D };
    const res = ENGINE.runKernel(Conv3DBackpropInputV2, inputs, attrs);
    if (reshapedTo5D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  var conv3DBackpropInput = /* @__PURE__ */ op({ conv3DBackpropInput_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv3d_transpose.js
  function conv3dTranspose_(x2, filter, outputShape, strides, pad2) {
    const $x = convertToTensor(x2, "x", "conv3dTranspose");
    const $filter = convertToTensor(filter, "filter", "conv3dTranspose");
    return conv3DBackpropInput(outputShape, $x, $filter, strides, pad2);
  }
  var conv3dTranspose = /* @__PURE__ */ op({ conv3dTranspose_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/cos.js
  function cos_(x2) {
    const $x = convertToTensor(x2, "x", "cos", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Cos, inputs);
  }
  var cos = /* @__PURE__ */ op({ cos_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/cosh.js
  function cosh_(x2) {
    const $x = convertToTensor(x2, "x", "cosh", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Cosh, inputs);
  }
  var cosh = /* @__PURE__ */ op({ cosh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/cumprod.js
  function cumprod_(x2, axis = 0, exclusive = false, reverse3 = false) {
    const $x = convertToTensor(x2, "x", "cumprod");
    const inputs = { x: $x };
    const attrs = { axis, exclusive, reverse: reverse3 };
    return ENGINE.runKernel(Cumprod, inputs, attrs);
  }
  var cumprod = /* @__PURE__ */ op({ cumprod_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/cumsum.js
  function cumsum_(x2, axis = 0, exclusive = false, reverse3 = false) {
    const $x = convertToTensor(x2, "x", "cumsum");
    const inputs = { x: $x };
    const attrs = { axis, exclusive, reverse: reverse3 };
    return ENGINE.runKernel(Cumsum, inputs, attrs);
  }
  var cumsum = /* @__PURE__ */ op({ cumsum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/dense_bincount.js
  function denseBincount_(x2, weights, size, binaryOutput = false) {
    const $x = convertToTensor(x2, "x", "denseBincount");
    const $weights = convertToTensor(weights, "weights", "denseBincount");
    assert2($x.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${$x.dtype}`);
    assert2($x.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${$x.rank}.`);
    assert2(size >= 0, () => `size must be non-negative, but got ${size}.`);
    assert2($weights.size === $x.size || $weights.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${$x.shape}, weights shape: ${$weights.shape}.`);
    const inputs = { x: $x, weights: $weights };
    const attrs = { size, binaryOutput };
    return ENGINE.runKernel(DenseBincount, inputs, attrs);
  }
  var denseBincount = /* @__PURE__ */ op({ denseBincount_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/depth_to_space.js
  function depthToSpace_(x2, blockSize, dataFormat = "NHWC") {
    const $x = convertToTensor(x2, "x", "depthToSpace", "float32");
    const inputHeight = dataFormat === "NHWC" ? $x.shape[1] : $x.shape[2];
    const inputWidth = dataFormat === "NHWC" ? $x.shape[2] : $x.shape[3];
    const inputDepth = dataFormat === "NHWC" ? $x.shape[3] : $x.shape[1];
    assert2(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
    assert2(inputHeight * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputHeight} and ${blockSize}  for depthToSpace with input shape
    ${$x.shape}`);
    assert2(inputWidth * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputWidth} and ${blockSize} for depthToSpace with input shape
        ${$x.shape}`);
    assert2(inputDepth % (blockSize * blockSize) === 0, () => `Dimension size must be evenly divisible by ${blockSize * blockSize} but is ${inputDepth} for depthToSpace with input shape ${$x.shape}`);
    const inputs = { x: $x };
    const attrs = { blockSize, dataFormat };
    return ENGINE.runKernel(DepthToSpace, inputs, attrs);
  }
  var depthToSpace = /* @__PURE__ */ op({ depthToSpace_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/depthwise_conv2d.js
  function depthwiseConv2d_(x2, filter, strides, pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
    const $x = convertToTensor(x2, "x", "depthwiseConv2d", "float32");
    const $filter = convertToTensor(filter, "filter", "depthwiseConv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert2(x4D.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert2($filter.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    const inChannels = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
    assert2(inChannels === $filter.shape[2], () => `Error in depthwiseConv2d: number of input channels (${inChannels}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
    checkPadOnDimRoundingMode("depthwiseConv2d", pad2, dimRoundingMode);
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad: pad2, dataFormat, dilations, dimRoundingMode };
    const res = ENGINE.runKernel(DepthwiseConv2dNative, inputs, attrs);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var depthwiseConv2d = /* @__PURE__ */ op({ depthwiseConv2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/diag.js
  function diag_(x2) {
    const $x = convertToTensor(x2, "x", "diag");
    const inputs = { x: $x };
    return ENGINE.runKernel(Diag, inputs);
  }
  var diag = /* @__PURE__ */ op({ diag_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/dilation2d.js
  function dilation2d_(x2, filter, strides, pad2, dilations = [1, 1], dataFormat = "NHWC") {
    const $x = convertToTensor(x2, "x", "dilation2d");
    const $filter = convertToTensor(filter, "filter", "dilation2d");
    assert2($x.rank === 3 || $x.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${$x.rank}.`);
    assert2($filter.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${$filter.rank}.`);
    assert2(dataFormat === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${dataFormat}`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      x4D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      reshapedTo4D = true;
    }
    assert2(x4D.shape[3] === $filter.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${x4D.shape[3]} vs ${$filter.shape[2]}`);
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad: pad2, dilations };
    const res = ENGINE.runKernel(Dilation2D, inputs, attrs);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var dilation2d = /* @__PURE__ */ op({ dilation2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/broadcast_util.js
  var broadcast_util_exports = {};
  __export(broadcast_util_exports, {
    assertAndGetBroadcastShape: () => assertAndGetBroadcastShape,
    getBroadcastDims: () => getBroadcastDims,
    getReductionAxes: () => getReductionAxes
  });
  function getBroadcastDims(inShape, outShape) {
    const inRank = inShape.length;
    const dims = [];
    for (let i2 = 0; i2 < inRank; i2++) {
      const dim = inRank - 1 - i2;
      const a2 = inShape[dim] || 1;
      const b2 = outShape[outShape.length - 1 - i2] || 1;
      if (b2 > 1 && a2 === 1) {
        dims.unshift(dim);
      }
    }
    return dims;
  }
  function getReductionAxes(inShape, outShape) {
    const result = [];
    for (let i2 = 0; i2 < outShape.length; i2++) {
      const inDim = inShape[inShape.length - i2 - 1];
      const outAxis = outShape.length - i2 - 1;
      const outDim = outShape[outAxis];
      if (inDim == null || inDim === 1 && outDim > 1) {
        result.unshift(outAxis);
      }
    }
    return result;
  }
  function assertAndGetBroadcastShape(shapeA, shapeB) {
    const result = [];
    const l3 = Math.max(shapeA.length, shapeB.length);
    for (let i2 = 0; i2 < l3; i2++) {
      let a2 = shapeA[shapeA.length - i2 - 1];
      if (a2 == null) {
        a2 = 1;
      }
      let b2 = shapeB[shapeB.length - i2 - 1];
      if (b2 == null) {
        b2 = 1;
      }
      if (a2 === 1) {
        result.unshift(b2);
      } else if (b2 === 1) {
        result.unshift(a2);
      } else if (a2 !== b2) {
        const errMsg = `Operands could not be broadcast together with shapes ${shapeA} and ${shapeB}.`;
        throw Error(errMsg);
      } else {
        result.unshift(a2);
      }
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/equal.js
  function equal_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "equal", "string_or_numeric");
    let $b = convertToTensor(b2, "b", "equal", "string_or_numeric");
    [$a2, $b] = makeTypesMatch($a2, $b);
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(Equal, inputs);
  }
  var equal = /* @__PURE__ */ op({ equal_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/where.js
  function where_(condition, a2, b2) {
    const $a2 = convertToTensor(a2, "a", "where");
    const $b = convertToTensor(b2, "b", "where");
    const $condition = convertToTensor(condition, "condition", "where", "bool");
    const broadcastShape = assertAndGetBroadcastShape(assertAndGetBroadcastShape($condition.shape, $a2.shape), $b.shape);
    const $broadcastedCondition = broadcastTo($condition, broadcastShape);
    const $broadcastedA = broadcastTo($a2, broadcastShape);
    const $broadcastedB = broadcastTo($b, broadcastShape);
    const inputs = {
      condition: $broadcastedCondition,
      t: $broadcastedA,
      e: $broadcastedB
    };
    return ENGINE.runKernel(Select, inputs);
  }
  var where = /* @__PURE__ */ op({ where_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/zeros_like.js
  function zerosLike_(x2) {
    const $x = convertToTensor(x2, "x", "zerosLike");
    const inputs = { x: $x };
    return ENGINE.runKernel(ZerosLike, inputs);
  }
  var zerosLike = /* @__PURE__ */ op({ zerosLike_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/div_no_nan.js
  function divNoNan_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "div");
    let $b = convertToTensor(b2, "b", "div");
    [$a2, $b] = makeTypesMatch($a2, $b);
    const divResult = div($a2, $b);
    const zeros3 = zerosLike(divResult);
    const bEqualsZero = equal($b, zeros3);
    return where(bEqualsZero, zeros3, divResult);
  }
  var divNoNan = /* @__PURE__ */ op({ divNoNan_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/dot.js
  function dot_(t1, t22) {
    const $t1 = convertToTensor(t1, "t1", "dot");
    const $t22 = convertToTensor(t22, "t2", "dot");
    assert2(($t1.rank === 1 || $t1.rank === 2) && ($t22.rank === 1 || $t22.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${$t1.rank} and ${$t22.rank}.`);
    const t1Inner = $t1.rank === 1 ? $t1.size : $t1.shape[1];
    const t2Inner = $t22.rank === 1 ? $t22.size : $t22.shape[0];
    assert2(t1Inner === t2Inner, () => `Error in dot: inner dimensions of inputs must match, but got ${t1Inner} and ${t2Inner}.`);
    if ($t1.rank === 1 && $t22.rank === 1) {
      const t12D = reshape2($t1, [1, -1]);
      const t22D = reshape2($t22, [-1, 1]);
      const t1t2 = matMul(t12D, t22D);
      return reshape2(t1t2, []);
    } else if ($t1.rank === 1 && $t22.rank === 2) {
      const t12D = reshape2($t1, [1, -1]);
      const t22D = reshape2($t22, [$t22.shape[0], $t22.shape[1]]);
      const t1t2 = matMul(t12D, t22D);
      return reshape2(t1t2, [t1t2.size]);
    } else if ($t1.rank === 2 && $t22.rank === 1) {
      const t22D = reshape2($t22, [-1, 1]);
      const t1t2 = matMul($t1, t22D);
      return reshape2(t1t2, [t1t2.size]);
    } else {
      const t22D = reshape2($t22, [$t22.shape[0], $t22.shape[1]]);
      const t1t2 = matMul($t1, t22D);
      return t1t2;
    }
  }
  var dot2 = /* @__PURE__ */ op({ dot_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/einsum.js
  function einsum_(equation, ...tensors) {
    const $tensors = tensors.map((t3, i2) => convertToTensor(t3, `tensors${i2}`, "einsum"));
    const attrs = { equation };
    return ENGINE.runKernel(Einsum, $tensors, attrs);
  }
  var einsum = /* @__PURE__ */ op({ einsum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/elu.js
  function elu_(x2) {
    const $x = convertToTensor(x2, "x", "elu", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Elu2, inputs);
  }
  var elu = /* @__PURE__ */ op({ elu_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/erf.js
  function erf_(x2) {
    let $x = convertToTensor(x2, "x", "erf");
    assert2($x.dtype === "int32" || $x.dtype === "float32", () => "Input dtype must be `int32` or `float32`.");
    if ($x.dtype === "int32") {
      $x = cast($x, "float32");
    }
    const inputs = { x: $x };
    return ENGINE.runKernel(Erf, inputs);
  }
  var erf = /* @__PURE__ */ op({ erf_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/axis_util.js
  function axesAreInnerMostDims(axes, rank) {
    for (let i2 = 0; i2 < axes.length; ++i2) {
      if (axes[axes.length - i2 - 1] !== rank - 1 - i2) {
        return false;
      }
    }
    return true;
  }
  function combineLocations(outputLoc, reduceLoc, axes) {
    const rank = outputLoc.length + reduceLoc.length;
    const loc = [];
    let outIdx = 0;
    let reduceIdx = 0;
    for (let dim = 0; dim < rank; dim++) {
      if (axes.indexOf(dim) === -1) {
        loc.push(outputLoc[outIdx++]);
      } else {
        loc.push(reduceLoc[reduceIdx++]);
      }
    }
    return loc;
  }
  function computeOutAndReduceShapes(aShape, axes) {
    const outShape = [];
    const rank = aShape.length;
    for (let dim = 0; dim < rank; dim++) {
      if (axes.indexOf(dim) === -1) {
        outShape.push(aShape[dim]);
      }
    }
    const reduceShape = axes.map((dim) => aShape[dim]);
    return [outShape, reduceShape];
  }
  function expandShapeToKeepDim(shape, axes) {
    const reduceSubShape = axes.map((x2) => 1);
    return combineLocations(shape, reduceSubShape, axes);
  }
  function assertAxesAreInnerMostDims(msg, axes, rank) {
    assert2(axesAreInnerMostDims(axes, rank), () => `${msg} supports only inner-most axes for now. Got axes ${axes} and rank-${rank} input.`);
  }
  function getAxesPermutation(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
      return null;
    }
    const result = [];
    for (let i2 = 0; i2 < rank; ++i2) {
      if (axes.indexOf(i2) === -1) {
        result.push(i2);
      }
    }
    axes.forEach((axis) => result.push(axis));
    return result;
  }
  function getUndoAxesPermutation(axes) {
    return axes.map((axis, i2) => [i2, axis]).sort((a2, b2) => a2[1] - b2[1]).map((x2) => x2[0]);
  }
  function getInnerMostAxes(numAxes, rank) {
    const res = [];
    for (let i2 = rank - numAxes; i2 < rank; ++i2) {
      res.push(i2);
    }
    return res;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/max.js
  function max_(x2, axis = null, keepDims = false) {
    const $x = convertToTensor(x2, "x", "max");
    const inputs = { x: $x };
    const attrs = { reductionIndices: axis, keepDims };
    return ENGINE.runKernel(Max, inputs, attrs);
  }
  var max = /* @__PURE__ */ op({ max_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/min.js
  function min_(x2, axis = null, keepDims = false) {
    const $x = convertToTensor(x2, "x", "min");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Min, inputs, attrs);
  }
  var min = /* @__PURE__ */ op({ min_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/pow.js
  function pow_(base, exp4) {
    let $base = convertToTensor(base, "base", "pow");
    let $exp = convertToTensor(exp4, "exp", "pow");
    [$base, $exp] = makeTypesMatch($base, $exp);
    const inputs = { a: $base, b: $exp };
    return ENGINE.runKernel(Pow, inputs);
  }
  var pow = /* @__PURE__ */ op({ pow_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/scalar.js
  function scalar(value, dtype) {
    if ((isTypedArray(value) && dtype !== "string" || Array.isArray(value)) && dtype !== "complex64") {
      throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    }
    if (dtype === "string" && isTypedArray(value) && !(value instanceof Uint8Array)) {
      throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    }
    const shape = [];
    const inferredShape = [];
    return makeTensor(value, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/sqrt.js
  function sqrt_(x2) {
    const $x = convertToTensor(x2, "x", "sqrt", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sqrt, inputs);
  }
  var sqrt = /* @__PURE__ */ op({ sqrt_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/square.js
  function square_(x2) {
    const $x = convertToTensor(x2, "x", "square");
    const attrs = {};
    return ENGINE.runKernel("Square", { x: $x }, attrs);
  }
  var square2 = /* @__PURE__ */ op({ square_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sum.js
  function sum_(x2, axis = null, keepDims = false) {
    let $x = convertToTensor(x2, "x", "sum");
    if ($x.dtype === "bool") {
      $x = cast($x, "int32");
    }
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Sum, inputs, attrs);
  }
  var sum2 = /* @__PURE__ */ op({ sum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/norm.js
  function norm_(x2, ord = "euclidean", axis = null, keepDims = false) {
    x2 = convertToTensor(x2, "x", "norm");
    const norm2 = normImpl(x2, ord, axis);
    let keepDimsShape = norm2.shape;
    if (keepDims) {
      const axes = parseAxisParam(axis, x2.shape);
      keepDimsShape = expandShapeToKeepDim(norm2.shape, axes);
    }
    return reshape2(norm2, keepDimsShape);
  }
  function normImpl(x2, p2, axis = null) {
    if (x2.rank === 0) {
      return abs(x2);
    }
    if (x2.rank !== 1 && axis === null) {
      return normImpl(reshape2(x2, [-1]), p2, axis);
    }
    if (x2.rank === 1 || typeof axis === "number" || Array.isArray(axis) && axis.length === 1) {
      if (p2 === 1) {
        return sum2(abs(x2), axis);
      }
      if (p2 === Infinity) {
        return max(abs(x2), axis);
      }
      if (p2 === -Infinity) {
        return min(abs(x2), axis);
      }
      if (p2 === "euclidean" || p2 === 2) {
        return sqrt(sum2(pow(abs(x2), scalar(2, "int32")), axis));
      }
      throw new Error(`Error in norm: invalid ord value: ${p2}`);
    }
    if (Array.isArray(axis) && axis.length === 2) {
      if (p2 === 1) {
        return max(sum2(abs(x2), axis[0]), axis[1] - 1);
      }
      if (p2 === Infinity) {
        return max(sum2(abs(x2), axis[1]), axis[0]);
      }
      if (p2 === -Infinity) {
        return min(sum2(abs(x2), axis[1]), axis[0]);
      }
      if (p2 === "fro" || p2 === "euclidean") {
        return sqrt(sum2(square2(x2), axis));
      }
      throw new Error(`Error in norm: invalid ord value: ${p2}`);
    }
    throw new Error(`Error in norm: invalid axis: ${axis}`);
  }
  var norm = /* @__PURE__ */ op({ norm_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/euclidean_norm.js
  function euclideanNorm_(x2, axis = null, keepDims = false) {
    return norm(x2, "euclidean", axis, keepDims);
  }
  var euclideanNorm = /* @__PURE__ */ op({ euclideanNorm_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/exp.js
  function exp_(x2) {
    const $x = convertToTensor(x2, "x", "exp");
    const inputs = { x: $x };
    return ENGINE.runKernel(Exp, inputs);
  }
  var exp = /* @__PURE__ */ op({ exp_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/expand_dims.js
  function expandDims_(x2, axis = 0) {
    const $x = convertToTensor(x2, "x", "expandDims", "string_or_numeric");
    assert2(axis <= $x.rank, () => "Axis must be <= rank of the tensor");
    const inputs = { input: $x };
    const attrs = { dim: axis };
    return ENGINE.runKernel(ExpandDims, inputs, attrs);
  }
  var expandDims = /* @__PURE__ */ op({ expandDims_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/expm1.js
  function expm1_(x2) {
    const $x = convertToTensor(x2, "x", "expm1");
    const inputs = { x: $x };
    return ENGINE.runKernel(Expm1, inputs);
  }
  var expm1 = /* @__PURE__ */ op({ expm1_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/tile.js
  function tile_(x2, reps) {
    const $x = convertToTensor(x2, "x", "tile", "string_or_numeric");
    assert2($x.rank === reps.length, () => `Error in transpose: rank of input ${$x.rank} must match length of reps ${reps}.`);
    const inputs = { x: $x };
    const attrs = { reps };
    return ENGINE.runKernel(Tile, inputs, attrs);
  }
  var tile = /* @__PURE__ */ op({ tile_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/eye.js
  function eye_(numRows, numColumns, batchShape, dtype = "float32") {
    if (numColumns == null) {
      numColumns = numRows;
    }
    const buff = buffer([numRows, numColumns], dtype);
    const n2 = numRows <= numColumns ? numRows : numColumns;
    for (let i2 = 0; i2 < n2; ++i2) {
      buff.set(1, i2, i2);
    }
    const out = reshape2(buff.toTensor(), [numRows, numColumns]);
    if (batchShape == null) {
      return out;
    } else {
      if (batchShape.length === 1) {
        return tile(expandDims(out, 0), [batchShape[0], 1, 1]);
      } else if (batchShape.length === 2) {
        return tile(expandDims(expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
      } else if (batchShape.length === 3) {
        return tile(expandDims(expandDims(expandDims(out, 0), 0), 0), [
          batchShape[0],
          batchShape[1],
          batchShape[2],
          1,
          1
        ]);
      } else {
        throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${batchShape.length}D.`);
      }
    }
  }
  var eye = /* @__PURE__ */ op({ eye_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/floor.js
  function floor_(x2) {
    const $x = convertToTensor(x2, "x", "floor", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Floor, inputs);
  }
  var floor = /* @__PURE__ */ op({ floor_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/gather.js
  function gather_(x2, indices, axis = 0, batchDims = 0) {
    const $x = convertToTensor(x2, "x", "gather");
    const $indices = convertToTensor(indices, "indices", "gather", "int32");
    const inputs = { x: $x, indices: $indices };
    const attrs = { axis, batchDims };
    return ENGINE.runKernel(GatherV2, inputs, attrs);
  }
  var gather = /* @__PURE__ */ op({ gather_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/greater.js
  function greater_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "greater", "string_or_numeric");
    let $b = convertToTensor(b2, "b", "greater", "string_or_numeric");
    [$a2, $b] = makeTypesMatch($a2, $b);
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(Greater, inputs);
  }
  var greater = /* @__PURE__ */ op({ greater_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/greater_equal.js
  function greaterEqual_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "greaterEqual", "string_or_numeric");
    let $b = convertToTensor(b2, "b", "greaterEqual", "string_or_numeric");
    [$a2, $b] = makeTypesMatch($a2, $b);
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(GreaterEqual, inputs);
  }
  var greaterEqual = /* @__PURE__ */ op({ greaterEqual_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/imag.js
  function imag_(input2) {
    const $input = convertToTensor(input2, "input", "imag");
    const inputs = { input: $input };
    return ENGINE.runKernel(Imag, inputs);
  }
  var imag = /* @__PURE__ */ op({ imag_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/is_finite.js
  function isFinite_(x2) {
    const $x = convertToTensor(x2, "x", "isFinite");
    const inputs = { x: $x };
    return ENGINE.runKernel(IsFinite, inputs);
  }
  var isFinite2 = /* @__PURE__ */ op({ isFinite_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/is_inf.js
  function isInf_(x2) {
    const $x = convertToTensor(x2, "x", "isInf");
    const inputs = { x: $x };
    return ENGINE.runKernel(IsInf, inputs);
  }
  var isInf = /* @__PURE__ */ op({ isInf_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/is_nan.js
  function isNaN_(x2) {
    const $x = convertToTensor(x2, "x", "isNaN");
    const inputs = { x: $x };
    return ENGINE.runKernel(IsNan, inputs);
  }
  var isNaN2 = /* @__PURE__ */ op({ isNaN_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/leaky_relu.js
  function leakyRelu_(x2, alpha = 0.2) {
    const $x = convertToTensor(x2, "x", "leakyRelu");
    const inputs = { x: $x };
    const attrs = { alpha };
    return ENGINE.runKernel(LeakyRelu, inputs, attrs);
  }
  var leakyRelu = /* @__PURE__ */ op({ leakyRelu_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/less.js
  function less_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "less", "string_or_numeric");
    let $b = convertToTensor(b2, "b", "less", "string_or_numeric");
    [$a2, $b] = makeTypesMatch($a2, $b);
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(Less, inputs);
  }
  var less2 = /* @__PURE__ */ op({ less_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/less_equal.js
  function lessEqual_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "lessEqual", "string_or_numeric");
    let $b = convertToTensor(b2, "b", "lessEqual", "string_or_numeric");
    [$a2, $b] = makeTypesMatch($a2, $b);
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(LessEqual, inputs);
  }
  var lessEqual = /* @__PURE__ */ op({ lessEqual_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/linspace.js
  function linspace(start, stop, num) {
    if (num <= 0) {
      throw new Error("The number of values should be positive.");
    }
    const attrs = { start, stop, num };
    return ENGINE.runKernel(LinSpace, {}, attrs);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/local_response_normalization.js
  function localResponseNormalization_(x2, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
    const $x = convertToTensor(x2, "x", "localResponseNormalization");
    assert2($x.rank === 4 || $x.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${$x.rank}.`);
    assert2(isInt(depthRadius), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${depthRadius}.`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    const inputs = { x: x4D };
    const attrs = { depthRadius, bias, alpha, beta };
    const res = ENGINE.runKernel(LRN, inputs, attrs);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    } else {
      return res;
    }
  }
  var localResponseNormalization = /* @__PURE__ */ op({ localResponseNormalization_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/log.js
  function log_(x2) {
    const $x = convertToTensor(x2, "x", "log", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Log, inputs);
  }
  var log2 = /* @__PURE__ */ op({ log_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/log1p.js
  function log1p_(x2) {
    const $x = convertToTensor(x2, "x", "log1p");
    const inputs = { x: $x };
    return ENGINE.runKernel(Log1p, inputs);
  }
  var log1p = /* @__PURE__ */ op({ log1p_ });

  // node_modules/@tensorflow/tfjs-core/dist/gradients.js
  function variableGrads(f2, varList) {
    assert2(isFunction(f2), () => "The f passed in variableGrads(f) must be a function");
    assert2(varList == null || Array.isArray(varList) && varList.every((v2) => v2 instanceof Variable), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
    const specifiedVarList = varList != null;
    if (!specifiedVarList) {
      varList = [];
      for (const varName in ENGINE.registeredVariables) {
        varList.push(ENGINE.registeredVariables[varName]);
      }
    }
    const specifiedNonTrainable = specifiedVarList ? varList.filter((variable2) => !variable2.trainable) : null;
    const originalVarCount = varList.length;
    varList = varList.filter((variable2) => variable2.trainable);
    assert2(varList.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${originalVarCount} variables is trainable.`);
    const allowNoGradients = true;
    const { value, grads } = ENGINE.gradients(f2, varList, null, allowNoGradients);
    assert2(grads.some((g2) => g2 != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().");
    assert2(value.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${value.rank} tensor`);
    const namedGrads = {};
    varList.forEach((v2, i2) => {
      if (grads[i2] != null) {
        namedGrads[v2.name] = grads[i2];
      }
    });
    if (specifiedNonTrainable != null) {
      specifiedNonTrainable.forEach((v2) => namedGrads[v2.name] = null);
    }
    return { value, grads: namedGrads };
  }
  function customGrad(f2) {
    return ENGINE.customGrad(f2);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/neg.js
  function neg_(x2) {
    const $x = convertToTensor(x2, "x", "neg");
    const inputs = { x: $x };
    return ENGINE.runKernel(Neg, inputs);
  }
  var neg = /* @__PURE__ */ op({ neg_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/softplus.js
  function softplus_(x2) {
    const $x = convertToTensor(x2, "x", "softplus");
    const inputs = { x: $x };
    return ENGINE.runKernel(Softplus2, inputs);
  }
  var softplus = /* @__PURE__ */ op({ softplus_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/log_sigmoid.js
  function logSigmoid_(x2) {
    const $x = convertToTensor(x2, "x", "logSigmoid");
    const customOp = customGrad((x3) => {
      const value = neg(softplus(neg(x3)));
      const gradFunc = (dy) => {
        const derX = mul(dy, sigmoid(neg(x3)));
        return derX;
      };
      return { value, gradFunc };
    });
    return customOp($x);
  }
  var logSigmoid = /* @__PURE__ */ op({ logSigmoid_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sub.js
  function sub_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "sub");
    let $b = convertToTensor(b2, "b", "sub");
    [$a2, $b] = makeTypesMatch($a2, $b);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(Sub, inputs);
  }
  var sub = /* @__PURE__ */ op({ sub_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/log_softmax.js
  function logSoftmax_(logits, axis = -1) {
    const $logits = convertToTensor(logits, "logits", "logSoftmax");
    if (axis === -1) {
      axis = $logits.rank - 1;
    }
    if (axis !== $logits.rank - 1) {
      throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and axis was ${axis}`);
    }
    const customOp = customGrad((logits2, save) => {
      const keepDims = true;
      const xMax = max(logits2, axis, true);
      const shifted = sub(logits2, xMax);
      const value = sub(cast(shifted, "float32"), log2(sum2(exp(shifted), axis, keepDims)));
      save([value]);
      const gradFunc = (dy, saved) => {
        const [value2] = saved;
        const keepDims2 = true;
        const softmax3 = exp(value2);
        return sub(dy, mul(sum2(dy, axis, keepDims2), softmax3));
      };
      return { value, gradFunc };
    });
    return customOp($logits);
  }
  var logSoftmax = /* @__PURE__ */ op({ logSoftmax_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/log_sum_exp.js
  function logSumExp_(x2, axis = null, keepDims = false) {
    const $x = convertToTensor(x2, "x", "logSumExp");
    const axes = parseAxisParam(axis, $x.shape);
    const xMax = max(
      $x,
      axes,
      true
      /* keepDims */
    );
    const a2 = sub($x, xMax);
    const b2 = exp(a2);
    const c2 = sum2(b2, axes);
    const d2 = log2(c2);
    const res = add2(reshape2(xMax, d2.shape), d2);
    if (keepDims) {
      const newShape = expandShapeToKeepDim(res.shape, axes);
      return reshape2(res, newShape);
    }
    return res;
  }
  var logSumExp = /* @__PURE__ */ op({ logSumExp_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/logical_and.js
  function logicalAnd_(a2, b2) {
    const $a2 = convertToTensor(a2, "a", "logicalAnd", "bool");
    const $b = convertToTensor(b2, "b", "logicalAnd", "bool");
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(LogicalAnd, inputs);
  }
  var logicalAnd = /* @__PURE__ */ op({ logicalAnd_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/logical_not.js
  function logicalNot_(x2) {
    const $x = convertToTensor(x2, "x", "logicalNot", "bool");
    const inputs = { x: $x };
    return ENGINE.runKernel(LogicalNot, inputs);
  }
  var logicalNot = /* @__PURE__ */ op({ logicalNot_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/logical_or.js
  function logicalOr_(a2, b2) {
    const $a2 = convertToTensor(a2, "a", "logicalOr", "bool");
    const $b = convertToTensor(b2, "b", "logicalOr", "bool");
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(LogicalOr, inputs);
  }
  var logicalOr = /* @__PURE__ */ op({ logicalOr_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/logical_xor.js
  function logicalXor_(a2, b2) {
    const $a2 = convertToTensor(a2, "a", "logicalXor", "bool");
    const $b = convertToTensor(b2, "b", "logicalXor", "bool");
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    return logicalAnd(logicalOr(a2, b2), logicalNot(logicalAnd(a2, b2)));
  }
  var logicalXor = /* @__PURE__ */ op({ logicalXor_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/search_sorted.js
  var INT32_MAX = 2147483648;
  function searchSorted_(sortedSequence, values, side = "left") {
    const $sortedSequence = convertToTensor(sortedSequence, "sortedSequence", "searchSorted");
    const $values = convertToTensor(values, "values", "searchSorted");
    const sequenceSize = $sortedSequence.shape[$sortedSequence.shape.length - 1];
    const valuesSize = $values.shape[$values.shape.length - 1];
    const $sortedSequence2D = reshape2($sortedSequence, [-1, sequenceSize]);
    const $values2D = reshape2($values, [-1, valuesSize]);
    if ($sortedSequence2D.rank < 2) {
      throw new Error(`Sorted input argument must be at least 2-dimensional`);
    }
    if ($sortedSequence2D.shape[0] !== $values2D.shape[0]) {
      throw new Error(`Leading dimension of 'sortedSequence' and 'values' must match.`);
    }
    if (sizeFromShape($values2D.shape) >= INT32_MAX) {
      throw new Error(`values tensor size must less than ${INT32_MAX}`);
    }
    if ($sortedSequence2D.shape[1] >= INT32_MAX) {
      throw new Error(`trailing dim_size must less than ${INT32_MAX} for int32 output type, was ${$sortedSequence2D.shape[1]}`);
    }
    const inputs = {
      sortedSequence: $sortedSequence2D,
      values: $values2D
    };
    const attrs = { side };
    return ENGINE.runKernel(SearchSorted, inputs, attrs);
  }
  var searchSorted = /* @__PURE__ */ op({ searchSorted_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/lower_bound.js
  function lowerBound(sortedSequence, values) {
    return searchSorted(sortedSequence, values, "left");
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/max_pool.js
  function maxPool_(x2, filterSize, strides, pad2, dimRoundingMode) {
    const $x = convertToTensor(x2, "x", "maxPool");
    const dilations = 1;
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert2(x4D.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);
    assert2(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    checkPadOnDimRoundingMode("maxPool", pad2, dimRoundingMode);
    const inputs = { x: x4D };
    const attrs = { filterSize, strides, pad: pad2, dimRoundingMode };
    const res = ENGINE.runKernel(MaxPool, inputs, attrs);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var maxPool = /* @__PURE__ */ op({ maxPool_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/max_pool_3d.js
  function maxPool3d_(x2, filterSize = [1, 1, 1], strides, pad2, dimRoundingMode, dataFormat = "NDHWC") {
    const $x = convertToTensor(x2, "x", "maxPool3d");
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
      reshapedTo5D = true;
      x5D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert2(x5D.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
    assert2(dataFormat === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
    checkPadOnDimRoundingMode("maxPool3d", pad2, dimRoundingMode);
    const inputs = { x: x5D };
    const attrs = { filterSize, strides, pad: pad2, dimRoundingMode, dataFormat };
    const res = ENGINE.runKernel(MaxPool3D, inputs, attrs);
    if (reshapedTo5D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  var maxPool3d = /* @__PURE__ */ op({ maxPool3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/max_pool_with_argmax.js
  function maxPoolWithArgmax_(x2, filterSize, strides, pad2, includeBatchInIndex = false) {
    const $x = convertToTensor(x2, "x", "maxPoolWithArgmax");
    const inputs = { x: $x };
    const attrs = { filterSize, strides, pad: pad2, includeBatchInIndex };
    const result = ENGINE.runKernel(MaxPoolWithArgmax, inputs, attrs);
    return { result: result[0], indexes: result[1] };
  }
  var maxPoolWithArgmax = /* @__PURE__ */ op({ maxPoolWithArgmax_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/maximum.js
  function maximum_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "maximum");
    let $b = convertToTensor(b2, "b", "maximum");
    [$a2, $b] = makeTypesMatch($a2, $b);
    if ($a2.dtype === "bool") {
      $a2 = cast($a2, "int32");
      $b = cast($b, "int32");
    }
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(Maximum2, inputs);
  }
  var maximum = /* @__PURE__ */ op({ maximum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/mean.js
  function mean_(x2, axis = null, keepDims = false) {
    const $x = convertToTensor(x2, "x", "mean");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Mean, inputs, attrs);
  }
  var mean = /* @__PURE__ */ op({ mean_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/zeros.js
  function zeros(shape, dtype = "float32") {
    assertNonNegativeIntegerDimensions(shape);
    if (dtype === "complex64") {
      const real4 = zeros(shape, "float32");
      const imag3 = zeros(shape, "float32");
      return complex(real4, imag3);
    }
    const values = makeZerosTypedArray(sizeFromShape(shape), dtype);
    return ENGINE.makeTensor(values, shape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/ones.js
  function ones2(shape, dtype = "float32") {
    assertNonNegativeIntegerDimensions(shape);
    if (dtype === "complex64") {
      const real4 = ones2(shape, "float32");
      const imag3 = zeros(shape, "float32");
      return complex(real4, imag3);
    }
    const values = makeOnesTypedArray(sizeFromShape(shape), dtype);
    return ENGINE.makeTensor(values, shape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/meshgrid.js
  function meshgrid(x2, y2, { indexing = "xy" } = {}) {
    if (indexing !== "xy" && indexing !== "ij") {
      throw new TypeError(`${indexing} is not a valid third argument to meshgrid`);
    }
    if (x2 === void 0) {
      return [];
    }
    let $x = convertToTensor(x2, "x", "meshgrid", x2 instanceof Tensor ? x2.dtype : "float32");
    if (y2 === void 0) {
      return [$x];
    }
    let $y = convertToTensor(y2, "y", "meshgrid", y2 instanceof Tensor ? y2.dtype : "float32");
    const w2 = sizeFromShape($x.shape);
    const h = sizeFromShape($y.shape);
    if (indexing === "xy") {
      $x = reshape2($x, [1, -1]);
      $y = reshape2($y, [-1, 1]);
      return [
        matMul(ones2([h, 1], $x.dtype), $x),
        matMul($y, ones2([1, w2], $y.dtype))
      ];
    }
    $x = reshape2($x, [-1, 1]);
    $y = reshape2($y, [1, -1]);
    return [
      matMul($x, ones2([1, h], $x.dtype)),
      matMul(ones2([w2, 1], $y.dtype), $y)
    ];
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/minimum.js
  function minimum_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "minimum");
    let $b = convertToTensor(b2, "b", "minimum");
    [$a2, $b] = makeTypesMatch($a2, $b);
    if ($a2.dtype === "bool") {
      $a2 = cast($a2, "int32");
      $b = cast($b, "int32");
    }
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(Minimum2, inputs);
  }
  var minimum = /* @__PURE__ */ op({ minimum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/mirror_pad.js
  function mirrorPad_(x2, paddings, mode) {
    assert2(mode === "reflect" || mode === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${mode}.`);
    const $x = convertToTensor(x2, "x", "mirrorPad");
    if ($x.rank === 0) {
      throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
    }
    assert2(paddings.length === $x.rank, () => `Padding doesn't match input. Must be ${$x.rank}. Got ${paddings.length}.`);
    const shapeOffset = mode === "reflect" ? 1 : 0;
    for (let i2 = 0; i2 < $x.rank; i2++) {
      assert2(paddings[i2].length === 2, () => `Invalid number of paddings. Must be length of 2 each.`);
      assert2(paddings[i2][0] >= 0 && paddings[i2][0] <= $x.shape[i2] - shapeOffset && paddings[i2][1] >= 0 && paddings[i2][1] <= $x.shape[i2] - shapeOffset, () => `Padding in dimension ${i2} cannot be greater than or equal to ${$x.shape[i2] - shapeOffset} or less than 0 for input of shape ${$x.shape}`);
    }
    const attrs = { paddings, mode };
    const inputs = { x: $x };
    return ENGINE.runKernel(MirrorPad, inputs, attrs);
  }
  var mirrorPad = /* @__PURE__ */ op({ mirrorPad_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/mod.js
  function mod_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "mod");
    let $b = convertToTensor(b2, "b", "mod");
    [$a2, $b] = makeTypesMatch($a2, $b);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(Mod, inputs);
  }
  var mod = /* @__PURE__ */ op({ mod_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/moments.js
  function moments_(x2, axis = null, keepDims = false) {
    x2 = convertToTensor(x2, "x", "moments");
    const axes = parseAxisParam(axis, x2.shape);
    const xMean = mean(x2, axes, keepDims);
    let keepDimsShape = xMean.shape;
    if (!keepDims) {
      keepDimsShape = expandShapeToKeepDim(xMean.shape, axes);
    }
    const devSquared = square2(sub(cast(x2, "float32"), reshape2(xMean, keepDimsShape)));
    const variance = mean(devSquared, axes, keepDims);
    return { mean: xMean, variance };
  }
  var moments = /* @__PURE__ */ op({ moments_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/multi_rnn_cell.js
  function multiRNNCell_(lstmCells, data, c2, h) {
    const $data = convertToTensor(data, "data", "multiRNNCell");
    const $c2 = convertToTensorArray(c2, "c", "multiRNNCell");
    const $h2 = convertToTensorArray(h, "h", "multiRNNCell");
    let input2 = $data;
    const newStates = [];
    for (let i2 = 0; i2 < lstmCells.length; i2++) {
      const output = lstmCells[i2](input2, $c2[i2], $h2[i2]);
      newStates.push(output[0]);
      newStates.push(output[1]);
      input2 = output[1];
    }
    const newC = [];
    const newH = [];
    for (let i2 = 0; i2 < newStates.length; i2 += 2) {
      newC.push(newStates[i2]);
      newH.push(newStates[i2 + 1]);
    }
    return [newC, newH];
  }
  var multiRNNCell = /* @__PURE__ */ op({ multiRNNCell_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/multinomial.js
  function multinomial_(logits, numSamples, seed, normalized = false) {
    const $logits = convertToTensor(logits, "logits", "multinomial");
    const numOutcomes = $logits.size;
    const origRank = $logits.rank;
    if (numOutcomes < 2) {
      throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${numOutcomes}.`);
    }
    if (origRank > 2) {
      throw new Error(`Rank of probabilities must be 1 or 2, but is ${origRank}`);
    }
    seed = seed || Math.random();
    const logits2D = origRank === 1 ? reshape2($logits, [1, -1]) : $logits;
    const inputs = { logits: logits2D };
    const attrs = { numSamples, seed, normalized };
    const res = ENGINE.runKernel(Multinomial, inputs, attrs);
    return origRank === 1 ? reshape2(res, [res.size]) : res;
  }
  var multinomial = /* @__PURE__ */ op({ multinomial_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/not_equal.js
  function notEqual_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "notEqual", "string_or_numeric");
    let $b = convertToTensor(b2, "b", "notEqual", "string_or_numeric");
    [$a2, $b] = makeTypesMatch($a2, $b);
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    return ENGINE.runKernel(NotEqual, inputs);
  }
  var notEqual = /* @__PURE__ */ op({ notEqual_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/one_hot.js
  function oneHot_(indices, depth, onValue = 1, offValue = 0, dtype = "int32") {
    if (depth < 2) {
      throw new Error(`Error in oneHot: depth must be >=2, but it is ${depth}`);
    }
    const $indices = convertToTensor(indices, "indices", "oneHot", "int32");
    const inputs = { indices: $indices };
    const attrs = { dtype, depth, onValue, offValue };
    return ENGINE.runKernel(OneHot, inputs, attrs);
  }
  var oneHot = /* @__PURE__ */ op({ oneHot_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/ones_like.js
  function onesLike_(x2) {
    const $x = convertToTensor(x2, "x", "onesLike");
    const inputs = { x: $x };
    return ENGINE.runKernel(OnesLike, inputs);
  }
  var onesLike = /* @__PURE__ */ op({ onesLike_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/outer_product.js
  function outerProduct_(v1, v2) {
    const $v1 = convertToTensor(v1, "v1", "outerProduct");
    const $v2 = convertToTensor(v2, "v2", "outerProduct");
    assert2($v1.rank === 1 && $v2.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${$v1.rank} and ${$v2.rank}.`);
    const v12D = reshape2($v1, [-1, 1]);
    const v22D = reshape2($v2, [1, -1]);
    return matMul(v12D, v22D);
  }
  var outerProduct = /* @__PURE__ */ op({ outerProduct_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/pad.js
  function pad_(x2, paddings, constantValue = 0) {
    const $x = convertToTensor(x2, "x", "pad");
    if ($x.rank === 0) {
      throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    }
    const attrs = { paddings, constantValue };
    const inputs = { x: $x };
    return ENGINE.runKernel(PadV2, inputs, attrs);
  }
  var pad = /* @__PURE__ */ op({ pad_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/pad1d.js
  function pad1d_(x2, paddings, constantValue = 0) {
    assert2(paddings.length === 2, () => "Invalid number of paddings. Must be length of 2.");
    return pad(x2, [paddings], constantValue);
  }
  var pad1d = /* @__PURE__ */ op({ pad1d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/pad2d.js
  function pad2d_(x2, paddings, constantValue = 0) {
    assert2(paddings.length === 2 && paddings[0].length === 2 && paddings[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
    return pad(x2, paddings, constantValue);
  }
  var pad2d = /* @__PURE__ */ op({ pad2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/pad3d.js
  function pad3d_(x2, paddings, constantValue = 0) {
    assert2(paddings.length === 3 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
    return pad(x2, paddings, constantValue);
  }
  var pad3d = /* @__PURE__ */ op({ pad3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/pad4d.js
  function pad4d_(x2, paddings, constantValue = 0) {
    assert2(paddings.length === 4 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2 && paddings[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
    return pad(x2, paddings, constantValue);
  }
  var pad4d = /* @__PURE__ */ op({ pad4d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/space_to_batch_nd.js
  function spaceToBatchND_(x2, blockShape, paddings) {
    const $x = convertToTensor(x2, "x", "spaceToBatchND");
    assert2($x.rank >= 1 + blockShape.length, () => `input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`);
    assert2(paddings.length === blockShape.length, () => `paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`);
    assert2($x.shape.reduce((a2, b2, i2) => {
      if (i2 > 0 && i2 <= blockShape.length) {
        return a2 && (b2 + paddings[i2 - 1][0] + paddings[i2 - 1][1]) % blockShape[i2 - 1] === 0;
      }
      return a2;
    }, true), () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);
    const inputs = { x: $x };
    const attrs = { blockShape, paddings };
    return ENGINE.runKernel(SpaceToBatchND, inputs, attrs);
  }
  var spaceToBatchND = /* @__PURE__ */ op({ spaceToBatchND_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/pool.js
  function pool_(input2, windowShape, poolingType, pad2, dilations, strides, dimRoundingMode) {
    if (dilations == null) {
      dilations = [1, 1];
    }
    if (strides == null) {
      strides = 1;
    }
    if (pad2 === 0) {
      pad2 = "valid";
    }
    const $x = convertToTensor(input2, "x", "maxPool");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert2(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in pool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = computePool2DInfo(x4D.shape, windowShape, strides, dilations, pad2);
    const dilation = [convInfo.dilationHeight, convInfo.dilationWidth];
    let basePadding;
    if (pad2 === "same") {
      basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);
    } else {
      basePadding = [[0, 0], [0, 0]];
    }
    const isDilationOne = dilation[0] === 1 && dilation[1] === 1;
    const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding);
    const convertedPad = isDilationOne ? pad2 : "valid";
    const convertedX = isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);
    const forwardOp = poolingType === "avg" ? () => avgPool(convertedX, windowShape, strides, convertedPad, dimRoundingMode) : () => maxPool(convertedX, windowShape, strides, convertedPad, dimRoundingMode);
    const y2 = forwardOp();
    const res = isDilationOne ? y2 : batchToSpaceND(y2, dilation, adjustedCrops);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  function requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {
    const padStart = basePadding.map((b2) => b2[0]);
    const origPadEnd = basePadding.map((b2) => b2[1]);
    const fullInputShape = inputShape.concat(padStart, origPadEnd);
    const padEndExtra = blockShape.map((b2, i2) => (b2 - fullInputShape[i2] % b2) % b2);
    const padEnd = origPadEnd.map((s2, i2) => s2 + padEndExtra[i2]);
    const paddings = blockShape.map((_3, i2) => [padStart[i2], padEnd[i2]]);
    const crops = blockShape.map((_3, i2) => [0, padEndExtra[i2]]);
    return [paddings, crops];
  }
  function withSpaceToBatchBasePaddings(filterShape, dilation) {
    const dilatedFilterShape = filterShape.map((s2, i2) => {
      return s2 + (s2 - 1) * (dilation[i2] - 1);
    });
    const padExtraShape = dilatedFilterShape.map((s2) => s2 - 1);
    const padExtraStart = padExtraShape.map((s2) => Math.floor(s2 / 2));
    const padExtraEnd = padExtraShape.map((s2, i2) => s2 - padExtraStart[i2]);
    return padExtraShape.map((_3, i2) => {
      return [padExtraStart[i2], padExtraEnd[i2]];
    });
  }
  var pool = /* @__PURE__ */ op({ pool_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/prelu.js
  function prelu_(x2, alpha) {
    const $x = convertToTensor(x2, "x", "prelu");
    const $alpha = convertToTensor(alpha, "alpha", "prelu");
    const inputs = { x: $x, alpha: $alpha };
    return ENGINE.runKernel(Prelu, inputs);
  }
  var prelu = /* @__PURE__ */ op({ prelu_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/prod.js
  function prod_(x2, axis = null, keepDims = false) {
    let $x = convertToTensor(x2, "x", "prod");
    if ($x.dtype === "bool") {
      $x = cast($x, "int32");
    }
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Prod, inputs, attrs);
  }
  var prod = /* @__PURE__ */ op({ prod_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/ragged_gather.js
  function raggedGather_(paramsNestedSplits, paramsDenseValues, indices, outputRaggedRank) {
    const $paramsNestedSplits = paramsNestedSplits.map((t3, i2) => convertToTensor(t3, `tensors${i2}`, "raggedGather", "int32"));
    const $paramsDenseValues = convertToTensor(paramsDenseValues, "paramsDenseValues", "raggedGather");
    const $indices = convertToTensor(indices, "indices", "raggedGather", "int32");
    const inputs = {
      paramsNestedSplits: $paramsNestedSplits,
      paramsDenseValues: $paramsDenseValues,
      indices: $indices
    };
    const attrs = { outputRaggedRank };
    const result = ENGINE.runKernel(RaggedGather, inputs, attrs);
    return {
      outputNestedSplits: result.slice(0, result.length - 1),
      outputDenseValues: result[result.length - 1]
    };
  }
  var raggedGather = /* @__PURE__ */ op({ raggedGather_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/ragged_range.js
  function raggedRange_(starts, limits, deltas) {
    const $starts = convertToTensor(starts, "starts", "raggedRange");
    const $limits = convertToTensor(limits, "limits", "raggedRange", $starts.dtype);
    const $deltas = convertToTensor(deltas, "deltas", "raggedRange", $starts.dtype);
    const inputs = {
      starts: $starts,
      limits: $limits,
      deltas: $deltas
    };
    const result = ENGINE.runKernel(RaggedRange, inputs);
    return {
      rtNestedSplits: result[0],
      rtDenseValues: result[1]
    };
  }
  var raggedRange = /* @__PURE__ */ op({ raggedRange_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/ragged_tensor_to_tensor.js
  function raggedTensorToTensor_(shape, values, defaultValue, rowPartitionTensors, rowPartitionTypes) {
    const $shape = convertToTensor(shape, "shape", "raggedTensorToTensor", "int32");
    const $values = convertToTensor(values, "values", "raggedTensorToTensor");
    const $defaultValue = convertToTensor(defaultValue, "defaultValue", "raggedTensorToTensor", $values.dtype);
    const $rowPartitionTensors = rowPartitionTensors.map((t3, i2) => convertToTensor(t3, `tensors${i2}`, "raggedTensorToTensor", "int32"));
    const inputs = {
      shape: $shape,
      values: $values,
      defaultValue: $defaultValue,
      rowPartitionTensors: $rowPartitionTensors
    };
    const attrs = { rowPartitionTypes };
    return ENGINE.runKernel(RaggedTensorToTensor, inputs, attrs);
  }
  var raggedTensorToTensor = /* @__PURE__ */ op({ raggedTensorToTensor_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/rand.js
  function rand_(shape, randFunction, dtype) {
    assertNonNegativeIntegerDimensions(shape);
    const size = sizeFromShape(shape);
    let values = null;
    if (dtype == null || dtype === "float32") {
      values = new Float32Array(size);
    } else if (dtype === "int32") {
      values = new Int32Array(size);
    } else if (dtype === "bool") {
      values = new Uint8Array(size);
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
    for (let i2 = 0; i2 < size; i2++) {
      values[i2] = randFunction();
    }
    return ENGINE.makeTensor(values, shape, dtype);
  }
  var rand = /* @__PURE__ */ op({ rand_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/rand_util.js
  var seedrandom2 = __toESM(require_seedrandom2());
  var MPRandGauss = class {
    constructor(mean2, stdDeviation, dtype, truncated, seed) {
      this.mean = mean2;
      this.stdDev = stdDeviation;
      this.dtype = dtype;
      this.nextVal = NaN;
      this.truncated = truncated;
      if (this.truncated) {
        this.upper = this.mean + this.stdDev * 2;
        this.lower = this.mean - this.stdDev * 2;
      }
      const seedValue = seed ? seed : Math.random();
      this.random = seedrandom2.alea(seedValue.toString());
    }
    /** Returns next sample from a Gaussian distribution. */
    nextValue() {
      if (!isNaN(this.nextVal)) {
        const value = this.nextVal;
        this.nextVal = NaN;
        return value;
      }
      let resultX, resultY;
      let isValid = false;
      while (!isValid) {
        let v1, v2, s2;
        do {
          v1 = 2 * this.random() - 1;
          v2 = 2 * this.random() - 1;
          s2 = v1 * v1 + v2 * v2;
        } while (s2 >= 1 || s2 === 0);
        const mul2 = Math.sqrt(-2 * Math.log(s2) / s2);
        resultX = this.mean + this.stdDev * v1 * mul2;
        resultY = this.mean + this.stdDev * v2 * mul2;
        if (!this.truncated || this.isValidTruncated(resultX)) {
          isValid = true;
        }
      }
      if (!this.truncated || this.isValidTruncated(resultY)) {
        this.nextVal = this.convertValue(resultY);
      }
      return this.convertValue(resultX);
    }
    /** Handles proper rounding for non-floating-point numbers. */
    convertValue(value) {
      if (this.dtype == null || this.dtype === "float32") {
        return value;
      }
      return Math.round(value);
    }
    /** Returns true if less than 2-standard-deviations from the mean. */
    isValidTruncated(value) {
      return value <= this.upper && value >= this.lower;
    }
  };
  var RandGamma = class {
    constructor(alpha, beta, dtype, seed) {
      this.alpha = alpha;
      this.beta = 1 / beta;
      this.dtype = dtype;
      const seedValue = seed ? seed : Math.random();
      this.randu = seedrandom2.alea(seedValue.toString());
      this.randn = new MPRandGauss(0, 1, dtype, false, this.randu());
      if (alpha < 1) {
        this.d = alpha + 2 / 3;
      } else {
        this.d = alpha - 1 / 3;
      }
      this.c = 1 / Math.sqrt(9 * this.d);
    }
    /** Returns next sample from a gamma distribution. */
    nextValue() {
      let x2, v0, v1, x3, u2, v2;
      while (true) {
        do {
          x3 = this.randn.nextValue();
          v2 = 1 + this.c * x3;
        } while (v2 <= 0);
        v2 *= v2 * v2;
        x2 = x3 * x3;
        v0 = 1 - 0.331 * x2 * x2;
        v1 = 0.5 * x2 + this.d * (1 - v2 + Math.log(v2));
        u2 = this.randu();
        if (u2 < v0 || Math.log(u2) < v1) {
          break;
        }
      }
      v2 = 1 / this.beta * this.d * v2;
      if (this.alpha < 1) {
        v2 *= Math.pow(this.randu(), 1 / this.alpha);
      }
      return this.convertValue(v2);
    }
    /** Handles proper rounding for non-floating-point numbers. */
    convertValue(value) {
      if (this.dtype === "float32") {
        return value;
      }
      return Math.round(value);
    }
  };
  var UniformRandom = class {
    constructor(min3 = 0, max3 = 1, dtype, seed) {
      this.canReturnFloat = () => this.dtype == null || this.dtype === "float32";
      this.min = min3;
      this.range = max3 - min3;
      this.dtype = dtype;
      if (seed == null) {
        seed = Math.random();
      }
      if (typeof seed === "number") {
        seed = seed.toString();
      }
      if (!this.canReturnFloat() && this.range <= 1) {
        throw new Error(`The difference between ${min3} - ${max3} <= 1 and dtype is not float`);
      }
      this.random = seedrandom2.alea(seed);
    }
    convertValue(value) {
      if (this.canReturnFloat()) {
        return value;
      }
      return Math.round(value);
    }
    nextValue() {
      return this.convertValue(this.min + this.range * this.random());
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/random_gamma.js
  function randomGamma_(shape, alpha, beta = 1, dtype = "float32", seed) {
    assertNonNegativeIntegerDimensions(shape);
    if (beta == null) {
      beta = 1;
    }
    if (dtype == null) {
      dtype = "float32";
    }
    if (dtype !== "float32" && dtype !== "int32") {
      throw new Error(`Unsupported data type ${dtype}`);
    }
    const rgamma = new RandGamma(alpha, beta, dtype, seed);
    const res = buffer(shape, dtype);
    for (let i2 = 0; i2 < res.values.length; i2++) {
      res.values[i2] = rgamma.nextValue();
    }
    return res.toTensor();
  }
  var randomGamma = /* @__PURE__ */ op({ randomGamma_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/random_normal.js
  function randomNormal_(shape, mean2 = 0, stdDev = 1, dtype, seed) {
    assertNonNegativeIntegerDimensions(shape);
    if (dtype != null && dtype === "bool") {
      throw new Error(`Unsupported data type ${dtype}`);
    }
    const randGauss = new MPRandGauss(mean2, stdDev, dtype, false, seed);
    const res = buffer(shape, dtype);
    for (let i2 = 0; i2 < res.values.length; i2++) {
      res.values[i2] = randGauss.nextValue();
    }
    return res.toTensor();
  }
  var randomNormal = /* @__PURE__ */ op({ randomNormal_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/random_standard_normal.js
  function randomStandardNormal_(shape, dtype, seed) {
    if (dtype != null && dtype === "bool") {
      throw new Error(`Unsupported data type ${dtype}`);
    }
    return randomNormal(shape, 0, 1, dtype, seed);
  }
  var randomStandardNormal = /* @__PURE__ */ op({ randomStandardNormal_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/random_uniform.js
  function randomUniform_(shape, minval = 0, maxval = 1, dtype = "float32", seed) {
    assertNonNegativeIntegerDimensions(shape);
    const res = buffer(shape, dtype);
    const random = new UniformRandom(minval, maxval, null, seed);
    for (let i2 = 0; i2 < res.values.length; i2++) {
      res.values[i2] = random.nextValue();
    }
    return res.toTensor();
  }
  var randomUniform = /* @__PURE__ */ op({ randomUniform_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/range.js
  function range2(start, stop, step3 = 1, dtype = "float32") {
    if (step3 === 0) {
      throw new Error("Cannot have a step of zero");
    }
    const attrs = { start, stop, step: step3, dtype };
    return ENGINE.runKernel(Range, {}, attrs);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/real.js
  function real_(input2) {
    const $input = convertToTensor(input2, "input", "real");
    const inputs = { input: $input };
    return ENGINE.runKernel(Real, inputs);
  }
  var real = /* @__PURE__ */ op({ real_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/reciprocal.js
  function reciprocal_(x2) {
    const $x = convertToTensor(x2, "x", "reciprocal");
    const inputs = { x: $x };
    return ENGINE.runKernel(Reciprocal, inputs);
  }
  var reciprocal = /* @__PURE__ */ op({ reciprocal_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/relu.js
  function relu_(x2) {
    const $x = convertToTensor(x2, "x", "relu");
    const inputs = { x: $x };
    return ENGINE.runKernel(Relu2, inputs);
  }
  var relu = /* @__PURE__ */ op({ relu_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/relu6.js
  function relu6_(x2) {
    const $x = convertToTensor(x2, "x", "relu6");
    const inputs = { x: $x };
    return ENGINE.runKernel(Relu62, inputs);
  }
  var relu6 = /* @__PURE__ */ op({ relu6_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/reverse.js
  function reverse_(x2, axis) {
    const $x = convertToTensor(x2, "x", "reverse");
    const inputs = { x: $x };
    const attrs = { dims: axis };
    return ENGINE.runKernel(Reverse, inputs, attrs);
  }
  var reverse = /* @__PURE__ */ op({ reverse_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/reverse_1d.js
  function reverse1d_(x2) {
    const $x = convertToTensor(x2, "x", "reverse");
    assert2($x.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${$x.rank}.`);
    return reverse($x, 0);
  }
  var reverse1d = /* @__PURE__ */ op({ reverse1d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/reverse_2d.js
  function reverse2d_(x2, axis) {
    const $x = convertToTensor(x2, "x", "reverse");
    assert2($x.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${$x.rank}.`);
    return reverse($x, axis);
  }
  var reverse2d = /* @__PURE__ */ op({ reverse2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/reverse_3d.js
  function reverse3d_(x2, axis) {
    const $x = convertToTensor(x2, "x", "reverse");
    assert2($x.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${$x.rank}.`);
    return reverse($x, axis);
  }
  var reverse3d = /* @__PURE__ */ op({ reverse3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/reverse_4d.js
  function reverse4d_(x2, axis) {
    const $x = convertToTensor(x2, "x", "reverse");
    assert2($x.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${$x.rank}.`);
    return reverse($x, axis);
  }
  var reverse4d = /* @__PURE__ */ op({ reverse4d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/round.js
  function round_(x2) {
    const $x = convertToTensor(x2, "x", "round");
    const inputs = { x: $x };
    return ENGINE.runKernel(Round, inputs);
  }
  var round2 = /* @__PURE__ */ op({ round_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/rsqrt.js
  function rsqrt_(x2) {
    const $x = convertToTensor(x2, "x", "rsqrt", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Rsqrt, inputs);
  }
  var rsqrt = /* @__PURE__ */ op({ rsqrt_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/selu.js
  function selu_(x2) {
    const $x = convertToTensor(x2, "x", "selu");
    const inputs = { x: $x };
    return ENGINE.runKernel(Selu2, inputs);
  }
  var selu = /* @__PURE__ */ op({ selu_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/separable_conv2d.js
  function separableConv2d_(x2, depthwiseFilter, pointwiseFilter, strides, pad2, dilation = [1, 1], dataFormat = "NHWC") {
    const $x = convertToTensor(x2, "x", "separableConv2d");
    const $depthwiseFilter = convertToTensor(depthwiseFilter, "depthwiseFilter", "separableConv2d");
    const $pointwiseFilter = convertToTensor(pointwiseFilter, "pointwiseFilter", "separableConv2d");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    if (dataFormat === "NCHW") {
      throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    }
    assert2(x4D.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert2($depthwiseFilter.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
    assert2($pointwiseFilter.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
    assert2($pointwiseFilter.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${$pointwiseFilter.shape[0]}.`);
    assert2($pointwiseFilter.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);
    const inChannels = $depthwiseFilter.shape[2];
    const channelMultiplier = $depthwiseFilter.shape[3];
    assert2($pointwiseFilter.shape[2] === inChannels * channelMultiplier, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${inChannels * channelMultiplier}, but got ${$pointwiseFilter.shape[2]}.`);
    const depthwise = depthwiseConv2d(x4D, $depthwiseFilter, strides, pad2, dataFormat, dilation);
    const pointwiseStride = 1;
    const res = conv2d(depthwise, $pointwiseFilter, pointwiseStride, "valid", dataFormat);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var separableConv2d = /* @__PURE__ */ op({ separableConv2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/setdiff1d_async.js
  async function setdiff1dAsync_(x2, y2) {
    const $x = convertToTensor(x2, "x", "setdiff1d");
    const $y = convertToTensor(y2, "y", "setdiff1d");
    assert2($x.dtype === $y.dtype, () => `x and y should have the same dtype, but got x (${$x.dtype}) and y (${$y.dtype}).`);
    assert2($x.rank === 1, () => `x should be 1D tensor, but got x (${$x.shape}).`);
    assert2($y.rank === 1, () => `y should be 1D tensor, but got y (${$y.shape}).`);
    const xVals = await $x.data();
    const yVals = await $y.data();
    const ySet = new Set(yVals);
    let outputSize = 0;
    for (let i2 = 0; i2 < xVals.length; i2++) {
      if (!ySet.has(xVals[i2])) {
        outputSize++;
      }
    }
    const buffer2 = new TensorBuffer([outputSize], $x.dtype);
    const indices = new TensorBuffer([outputSize], "int32");
    for (let i2 = 0, p2 = 0; i2 < xVals.length; i2++) {
      if (!ySet.has(xVals[i2])) {
        buffer2.values[p2] = xVals[i2];
        indices.values[p2] = i2;
        p2++;
      }
    }
    return [buffer2.toTensor(), indices.toTensor()];
  }
  var setdiff1dAsync = setdiff1dAsync_;

  // node_modules/@tensorflow/tfjs-core/dist/ops/sign.js
  function sign_(x2) {
    const $x = convertToTensor(x2, "x", "sign");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sign, inputs);
  }
  var sign = /* @__PURE__ */ op({ sign_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sin.js
  function sin_(x2) {
    const $x = convertToTensor(x2, "x", "sin", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sin, inputs);
  }
  var sin = /* @__PURE__ */ op({ sin_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sinh.js
  function sinh_(x2) {
    const $x = convertToTensor(x2, "x", "sinh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sinh, inputs);
  }
  var sinh = /* @__PURE__ */ op({ sinh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice1d.js
  function slice1d_(x2, begin, size) {
    const $x = convertToTensor(x2, "x", "slice1d");
    assert2($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, [begin], [size]);
  }
  var slice1d = /* @__PURE__ */ op({ slice1d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice2d.js
  function slice2d_(x2, begin, size) {
    const $x = convertToTensor(x2, "x", "slice2d");
    assert2($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, begin, size);
  }
  var slice2d = /* @__PURE__ */ op({ slice2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice3d.js
  function slice3d_(x2, begin, size) {
    const $x = convertToTensor(x2, "x", "slice3d");
    assert2($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, begin, size);
  }
  var slice3d = /* @__PURE__ */ op({ slice3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice4d.js
  function slice4d_(x2, begin, size) {
    const $x = convertToTensor(x2, "x", "slice4d");
    assert2($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, begin, size);
  }
  var slice4d = /* @__PURE__ */ op({ slice4d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/softmax.js
  function softmax_(logits, dim = -1) {
    const $logits = convertToTensor(logits, "logits", "softmax", "float32");
    if (dim === -1) {
      dim = $logits.rank - 1;
    }
    if (dim !== $logits.rank - 1) {
      throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and dim was ${dim}`);
    }
    const inputs = { logits: $logits };
    const attrs = { dim };
    return ENGINE.runKernel(Softmax2, inputs, attrs);
  }
  var softmax = /* @__PURE__ */ op({ softmax_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/spectral/fft.js
  function fft_(input2) {
    assert2(input2.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${input2.dtype}.`);
    const inputs = { input: input2 };
    return ENGINE.runKernel(FFT, inputs);
  }
  var fft = /* @__PURE__ */ op({ fft_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/spectral/ifft.js
  function ifft_(input2) {
    assert2(input2.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${input2.dtype}.`);
    const inputs = { input: input2 };
    return ENGINE.runKernel(IFFT, inputs);
  }
  var ifft = /* @__PURE__ */ op({ ifft_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/spectral/irfft.js
  function irfft_(input2) {
    const innerDimensionSize = input2.shape[input2.shape.length - 1];
    const batch = input2.size / innerDimensionSize;
    let ret;
    if (innerDimensionSize <= 2) {
      const complexInput = reshape2(input2, [batch, innerDimensionSize]);
      ret = ifft(complexInput);
    } else {
      const outputShape = [batch, 2 * (innerDimensionSize - 1)];
      const realInput = reshape2(real(input2), [batch, innerDimensionSize]);
      const imagInput = reshape2(imag(input2), [batch, innerDimensionSize]);
      const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);
      const imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));
      const r2 = concat([realInput, realConjugate], 1);
      const i2 = concat([imagInput, imagConjugate], 1);
      const complexInput = reshape2(complex(r2, i2), [outputShape[0], outputShape[1]]);
      ret = ifft(complexInput);
    }
    ret = real(ret);
    if (input2.rank === 3 && input2.shape[0] !== 0) {
      const temp = ret;
      const batch2 = input2.shape[0];
      ret = reshape2(ret, [batch2, ret.shape[0] / batch2, ret.shape[1]]);
      temp.dispose();
    }
    return ret;
  }
  var irfft = /* @__PURE__ */ op({ irfft_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/split.js
  function split_(x2, numOrSizeSplits, axis = 0) {
    const $x = convertToTensor(x2, "x", "split");
    const inputs = { x: $x };
    const attr = { numOrSizeSplits, axis };
    return ENGINE.runKernel(SplitV, inputs, attr);
  }
  var split = /* @__PURE__ */ op({ split_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/spectral/rfft.js
  function rfft_(input2, fftLength) {
    assert2(input2.dtype === "float32", () => `The dtype for rfft() must be real value but got ${input2.dtype}`);
    let innerDimensionSize = input2.shape[input2.shape.length - 1];
    const batch = input2.size / innerDimensionSize;
    let adjustedInput;
    if (fftLength != null && fftLength < innerDimensionSize) {
      const begin = input2.shape.map((v2) => 0);
      const size = input2.shape.map((v2) => v2);
      size[input2.shape.length - 1] = fftLength;
      adjustedInput = slice(input2, begin, size);
      innerDimensionSize = fftLength;
    } else if (fftLength != null && fftLength > innerDimensionSize) {
      const zerosShape = input2.shape.map((v2) => v2);
      zerosShape[input2.shape.length - 1] = fftLength - innerDimensionSize;
      adjustedInput = concat([input2, zeros(zerosShape)], input2.shape.length - 1);
      innerDimensionSize = fftLength;
    } else {
      adjustedInput = input2;
    }
    const zerosInput = zerosLike(adjustedInput);
    const complexInput = reshape2(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);
    const ret = fft(complexInput);
    const half = Math.floor(innerDimensionSize / 2) + 1;
    const realValues = real(ret);
    const imagValues = imag(ret);
    const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);
    const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);
    const outputShape = adjustedInput.shape.slice();
    outputShape[adjustedInput.shape.length - 1] = half;
    return reshape2(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);
  }
  var rfft = /* @__PURE__ */ op({ rfft_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/squared_difference.js
  function squaredDifference_(a2, b2) {
    let $a2 = convertToTensor(a2, "a", "squaredDifference");
    let $b = convertToTensor(b2, "b", "squaredDifference");
    [$a2, $b] = makeTypesMatch($a2, $b);
    assertAndGetBroadcastShape($a2.shape, $b.shape);
    const inputs = { a: $a2, b: $b };
    const attrs = {};
    return ENGINE.runKernel(SquaredDifference, inputs, attrs);
  }
  var squaredDifference = /* @__PURE__ */ op({ squaredDifference_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/squeeze.js
  function squeeze_(x2, axis) {
    const $x = convertToTensor(x2, "x", "squeeze", "string_or_numeric");
    return reshape2($x, squeezeShape($x.shape, axis).newShape);
  }
  var squeeze = /* @__PURE__ */ op({ squeeze_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/stack.js
  function stack_(tensors, axis = 0) {
    const $tensors = convertToTensorArray(tensors, "tensors", "stack", "string_or_numeric");
    assert2($tensors.length >= 1, () => "Pass at least one tensor to tf.stack");
    if ($tensors.length > 0) {
      assert2(axis <= $tensors[0].rank, () => "Axis must be <= rank of the tensor");
    }
    const inputs = $tensors;
    const attrs = { axis };
    return ENGINE.runKernel(Pack, inputs, attrs);
  }
  var stack = /* @__PURE__ */ op({ stack_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/step.js
  function step_(x2, alpha = 0) {
    const $x = convertToTensor(x2, "x", "step");
    const inputs = { x: $x };
    const attrs = { alpha };
    return ENGINE.runKernel(Step, inputs, attrs);
  }
  var step = /* @__PURE__ */ op({ step_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/strided_slice.js
  function stridedSlice_(x2, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {
    const $x = convertToTensor(x2, "x", "stridedSlice", "string_or_numeric");
    const inputs = { x: $x };
    const attrs = {
      begin,
      end,
      strides,
      beginMask,
      endMask,
      ellipsisMask,
      newAxisMask,
      shrinkAxisMask
    };
    return ENGINE.runKernel(StridedSlice, inputs, attrs);
  }
  var stridedSlice = /* @__PURE__ */ op({ stridedSlice_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/tan.js
  function tan_(x2) {
    const $x = convertToTensor(x2, "x", "tan", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Tan, inputs);
  }
  var tan = /* @__PURE__ */ op({ tan_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor1d.js
  function tensor1d(values, dtype) {
    assertNonNull(values);
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 1) {
      throw new Error("tensor1d() requires values to be a flat/TypedArray");
    }
    const shape = null;
    return makeTensor(values, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor2d.js
  function tensor2d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 2) {
      throw new Error("tensor2d() requires shape to have two numbers");
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 2 && inferredShape.length !== 1) {
      throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    }
    return makeTensor(values, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor3d.js
  function tensor3d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 3) {
      throw new Error("tensor3d() requires shape to have three numbers");
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 3 && inferredShape.length !== 1) {
      throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
    }
    return makeTensor(values, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor4d.js
  function tensor4d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 4) {
      throw new Error("tensor4d() requires shape to have four numbers");
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 4 && inferredShape.length !== 1) {
      throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
    }
    return makeTensor(values, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor5d.js
  function tensor5d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 5) {
      throw new Error("tensor5d() requires shape to have five numbers");
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 5 && inferredShape.length !== 1) {
      throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
    }
    return makeTensor(values, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor6d.js
  function tensor6d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 6) {
      throw new Error("tensor6d() requires shape to have six numbers");
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 6 && inferredShape.length !== 1) {
      throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
    }
    shape = shape || inferredShape;
    return makeTensor(values, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/topk.js
  function topk_(x2, k4 = 1, sorted = true) {
    const $x = convertToTensor(x2, "x", "topk");
    if ($x.rank === 0) {
      throw new Error("topk() expects the input to be of rank 1 or higher");
    }
    const lastDim = $x.shape[$x.shape.length - 1];
    if (k4 < 0) {
      throw new Error(`'k' passed to topk() must be >= 0 but got ${k4}`);
    }
    if (k4 > lastDim) {
      throw new Error(`'k' passed to topk() must be <= the last dimension (${lastDim}) but got ${k4}`);
    }
    const inputs = { x: $x };
    const attrs = { k: k4, sorted };
    const [values, indices] = ENGINE.runKernel(TopK, inputs, attrs);
    return { values, indices };
  }
  var topk = /* @__PURE__ */ op({ topk_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/truncated_normal.js
  function truncatedNormal_(shape, mean2 = 0, stdDev = 1, dtype, seed) {
    assertNonNegativeIntegerDimensions(shape);
    if (dtype != null && dtype === "bool") {
      throw new Error(`Unsupported data type $ { dtype }`);
    }
    const randGauss = new MPRandGauss(mean2, stdDev, dtype, true, seed);
    const res = buffer(shape, dtype);
    for (let i2 = 0; i2 < res.values.length; i2++) {
      res.values[i2] = randGauss.nextValue();
    }
    return res.toTensor();
  }
  var truncatedNormal = /* @__PURE__ */ op({ truncatedNormal_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/unique.js
  function unique_(x2, axis = 0) {
    const $x = convertToTensor(x2, "x", "unique", "string_or_numeric");
    assert2($x.rank > 0, () => "The input tensor must be at least 1D");
    const inputs = { x: $x };
    const attrs = { axis };
    const [values, indices] = ENGINE.runKernel(Unique, inputs, attrs);
    return { values, indices };
  }
  var unique2 = /* @__PURE__ */ op({ unique_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/unsorted_segment_sum.js
  function unsortedSegmentSum_(x2, segmentIds, numSegments) {
    const $x = convertToTensor(x2, "x", "unsortedSegmentSum");
    const $segmentIds = convertToTensor(segmentIds, "segmentIds", "unsortedSegmentSum", "int32");
    assert2(isInt(numSegments), () => "numSegments must be of dtype int");
    const inputs = { x: $x, segmentIds: $segmentIds };
    const attrs = { numSegments };
    return ENGINE.runKernel(UnsortedSegmentSum, inputs, attrs);
  }
  var unsortedSegmentSum = /* @__PURE__ */ op({ unsortedSegmentSum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/unstack.js
  function unstack_(x2, axis = 0) {
    const $x = convertToTensor(x2, "x", "unstack", "string_or_numeric");
    assert2(axis >= -$x.shape.length && axis < $x.shape.length, () => `Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`);
    const inputs = { value: $x };
    const attrs = { axis };
    return ENGINE.runKernel(Unpack, inputs, attrs);
  }
  var unstack = /* @__PURE__ */ op({ unstack_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/upper_bound.js
  function upperBound(sortedSequence, values) {
    return searchSorted(sortedSequence, values, "right");
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/variable.js
  function variable(initialValue, trainable = true, name, dtype) {
    return ENGINE.makeVariable(initialValue, trainable, name, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/where_impl.js
  function whereImpl(condShape, condVals) {
    const indices = [];
    for (let i2 = 0; i2 < condVals.length; i2++) {
      if (condVals[i2]) {
        indices.push(i2);
      }
    }
    const inBuffer = buffer(condShape, "int32");
    const out = buffer([indices.length, condShape.length], "int32");
    for (let i2 = 0; i2 < indices.length; i2++) {
      const loc = inBuffer.indexToLoc(indices[i2]);
      const offset = i2 * condShape.length;
      out.values.set(loc, offset);
    }
    return out.toTensor();
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/where_async.js
  async function whereAsync_(condition) {
    const $condition = convertToTensor(condition, "condition", "whereAsync", "bool");
    const vals = await $condition.data();
    const res = whereImpl($condition.shape, vals);
    if (condition !== $condition) {
      $condition.dispose();
    }
    return res;
  }
  var whereAsync = whereAsync_;

  // node_modules/@tensorflow/tfjs-core/dist/ops/boolean_mask.js
  async function booleanMaskAsync_(tensor2, mask, axis) {
    const $tensor = convertToTensor(tensor2, "tensor", "boolMask");
    const $mask = convertToTensor(mask, "mask", "boolMask", "bool");
    const axisFrom = axis == null ? 0 : axis;
    const maskDim = $mask.rank;
    const tensorShape = $tensor.shape;
    assert2(maskDim > 0, () => "mask cannot be scalar");
    assertShapesMatch(tensorShape.slice(axisFrom, axisFrom + maskDim), $mask.shape, `mask's shape must match the first K dimensions of tensor's shape,`);
    let leadingSize = 1;
    for (let i2 = axisFrom; i2 < axisFrom + maskDim; i2++) {
      leadingSize *= tensorShape[i2];
    }
    const targetTensorShape = tensorShape.slice(0, axisFrom).concat([leadingSize], tensorShape.slice(axisFrom + maskDim));
    const reshapedTensor = reshape2($tensor, targetTensorShape);
    const reshapedMask = reshape2($mask, [-1]);
    const positivePositions = await whereAsync(reshapedMask);
    const indices = squeeze(positivePositions, [1]);
    const res = gather(reshapedTensor, indices, axisFrom);
    if (tensor2 !== $tensor) {
      $tensor.dispose();
    }
    if (mask !== $mask) {
      $mask.dispose();
    }
    indices.dispose();
    reshapedTensor.dispose();
    reshapedMask.dispose();
    positivePositions.dispose();
    return res;
  }
  var booleanMaskAsync = booleanMaskAsync_;

  // node_modules/@tensorflow/tfjs-core/dist/ops/transpose.js
  function transpose_(x2, perm, conjugate) {
    const $x = convertToTensor(x2, "x", "transpose");
    if (perm == null) {
      perm = $x.shape.map((s2, i2) => i2).reverse();
    }
    assert2($x.rank === perm.length, () => `Error in transpose: rank of input ${$x.rank} must match length of perm ${perm}.`);
    perm.forEach((axis) => {
      assert2(axis >= 0 && axis < $x.rank, () => `All entries in 'perm' must be between 0 and ${$x.rank - 1} but got ${perm}`);
    });
    if ($x.rank <= 1) {
      return $x.clone();
    }
    const inputs = { x: $x };
    const attrs = { perm };
    if ($x.dtype === "complex64") {
      return tidy(() => {
        let $real = real($x);
        let $imag = imag($x);
        $real = ENGINE.runKernel(Transpose, { x: $real }, attrs);
        $imag = ENGINE.runKernel(Transpose, { x: $imag }, attrs);
        if (conjugate) {
          $imag = neg($imag);
        }
        return complex($real, $imag);
      });
    }
    return ENGINE.runKernel(Transpose, inputs, attrs);
  }
  var transpose = /* @__PURE__ */ op({ transpose_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/moving_average.js
  function movingAverage_(v2, x2, decay, step3, zeroDebias = true) {
    const $v = convertToTensor(v2, "v", "movingAverage");
    const $x = convertToTensor(x2, "x", "movingAverage");
    const $decay = convertToTensor(decay, "decay", "movingAverage");
    assertTypesMatch($v, $x);
    assert2(arraysEqual($v.shape, $x.shape), () => "Shape mismatch in v and x");
    const one = scalar(1);
    const oneMinusDecay = sub(one, $decay);
    let update = mul(sub($x, $v), oneMinusDecay);
    if (zeroDebias) {
      assert2(step3 != null, () => "When using zeroDebias: true, step is required.");
      const $step = convertToTensor(step3, "step", "movingAverage");
      update = div(update, sub(one, pow($decay, $step)));
    }
    return add2($v, update);
  }
  var movingAverage = /* @__PURE__ */ op({ movingAverage_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/scatter_nd_util.js
  function validateUpdateShape(shape, indices, updates) {
    const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
    const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
    const shapeError = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${updates.shape}, indices.shape: ${indices.shape}, shape: ${shape}, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
    if (updates.rank < batchDim) {
      throw new Error(shapeError + ` update.rank < ${batchDim}. `);
    }
    if (shape.length < sliceDim + (updates.rank - batchDim)) {
      throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
    }
    if (updates.rank !== batchDim + shape.length - sliceDim) {
      throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
    }
    for (let d2 = 0; d2 < batchDim; ++d2) {
      if (updates.shape[d2] !== indices.shape[d2]) {
        throw new Error(shapeError + ` updates.shape[${d2}] (${updates.shape[d2]}) != indices.shape[${d2}] (${indices.shape[d2]}).`);
      }
    }
    for (let d2 = 0; d2 < updates.rank - batchDim; ++d2) {
      if (updates.shape[d2 + batchDim] !== shape[d2 + sliceDim]) {
        throw new Error(shapeError + ` updates.shape[${d2 + batchDim}] (${updates.shape[d2 + batchDim]}) != shape[${d2 + batchDim}] (${shape[d2 + batchDim]})`);
      }
    }
  }
  function validateInput(updates, indices, shape) {
    if (indices.rank < 1) {
      throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);
    }
    if (updates.rank < 1) {
      throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${updates.rank}.`);
    }
    if (indices.dtype !== "int32") {
      throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
    }
    if (shape.length < 1) {
      throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
    }
    if (shape.length === 0) {
      if (indices.size === 0) {
        throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
      }
      if (updates.size === 0) {
        throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
      }
    }
    validateUpdateShape(shape, indices, updates);
  }
  function calculateShapes(updates, indices, shape) {
    const indicesRank = indices.shape.length;
    const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
    const totalNd = shape.length;
    let sliceSize = 1;
    for (let i2 = sliceRank; i2 < totalNd; ++i2) {
      sliceSize *= shape[i2];
    }
    const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
    const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;
    const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];
    const outputSize = sizeFromShape(shape);
    return { sliceRank, numUpdates, sliceSize, strides, outputSize };
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/scatter_nd.js
  function scatterND_(indices, updates, shape) {
    assertNonNegativeIntegerDimensions(shape);
    const $indices = convertToTensor(indices, "indices", "scatterND", "int32");
    const $updates = convertToTensor(updates, "updates", "scatterND");
    validateInput($updates, $indices, shape);
    const inputs = { indices: $indices, updates: $updates };
    const attrs = { shape };
    return ENGINE.runKernel(ScatterNd, inputs, attrs);
  }
  var scatterND = /* @__PURE__ */ op({ scatterND_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sparse_to_dense_util.js
  function validateInput2(sparseIndices, sparseValues, outputShape, defaultValues) {
    if (sparseIndices.dtype !== "int32") {
      throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${sparseIndices.dtype}.`);
    }
    if (sparseIndices.rank > 2) {
      throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${sparseIndices.shape}.`);
    }
    const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;
    const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;
    if (outputShape.length !== numDims) {
      throw new Error(`outputShape has incorrect number of elements:, ${outputShape.length}, should be: ${numDims}.`);
    }
    const numValues = sparseValues.size;
    if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {
      throw new Error(`sparseValues has incorrect shape ${sparseValues.shape}, should be [] or [${numElems}]`);
    }
    if (sparseValues.dtype !== defaultValues.dtype) {
      throw new Error("sparseValues.dtype must match defaultValues.dtype");
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/sparse_to_dense.js
  function sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {
    assertNonNegativeIntegerDimensions(outputShape);
    const $sparseIndices = convertToTensor(sparseIndices, "sparseIndices", "sparseToDense", "int32");
    const $sparseValues = convertToTensor(sparseValues, "sparseValues", "sparseToDense", "string_or_numeric");
    const $defaultValue = convertToTensor(defaultValue, "defaultValue", "sparseToDense", $sparseValues.dtype);
    validateInput2($sparseIndices, $sparseValues, outputShape, $defaultValue);
    const inputs = {
      sparseIndices: $sparseIndices,
      sparseValues: $sparseValues,
      defaultValue: $defaultValue
    };
    const attrs = { outputShape };
    return ENGINE.runKernel(SparseToDense, inputs, attrs);
  }
  var sparseToDense = /* @__PURE__ */ op({ sparseToDense_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/gather_nd.js
  function gatherND_(x2, indices) {
    const $indices = convertToTensor(indices, "indices", "gatherND", "int32");
    const $x = convertToTensor(x2, "x", "gatherND", "string_or_numeric");
    const inputs = { params: $x, indices: $indices };
    return ENGINE.runKernel(GatherNd, inputs);
  }
  var gatherND = /* @__PURE__ */ op({ gatherND_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/dropout_util.js
  function getNoiseShape(x2, noiseShape) {
    if (noiseShape == null) {
      return x2.shape.slice();
    }
    if (arraysEqual(x2.shape, noiseShape)) {
      return noiseShape;
    }
    if (x2.shape.length === noiseShape.length) {
      const newDimension = [];
      for (let i2 = 0; i2 < x2.shape.length; i2++) {
        if (noiseShape[i2] == null && x2.shape[i2] != null) {
          newDimension.push(x2.shape[i2]);
        } else {
          newDimension.push(noiseShape[i2]);
        }
      }
      return newDimension;
    }
    return noiseShape;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/dropout.js
  function dropout_(x2, rate, noiseShape, seed) {
    const $x = convertToTensor(x2, "x", "dropout");
    assert2($x.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${$x.dtype} tensor instead.`);
    assert2(rate >= 0 && rate < 1, () => `rate must be a float in the range [0, 1), but got ${rate}.`);
    if (rate === 0) {
      return x2 instanceof Tensor ? $x.clone() : $x;
    }
    const $noiseShape = getNoiseShape($x, noiseShape);
    const keepProb = 1 - rate;
    const multiplier = div(floor(add2(randomUniform($noiseShape, 0, 1, "float32", seed), keepProb)), keepProb);
    return mul($x, multiplier);
  }
  var dropout = /* @__PURE__ */ op({ dropout_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/signal_ops_util.js
  function enclosingPowerOfTwo(value) {
    return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2))));
  }
  function cosineWindow(windowLength, a2, b2) {
    const even = 1 - windowLength % 2;
    const newValues = new Float32Array(windowLength);
    for (let i2 = 0; i2 < windowLength; ++i2) {
      const cosArg = 2 * Math.PI * i2 / (windowLength + even - 1);
      newValues[i2] = a2 - b2 * Math.cos(cosArg);
    }
    return tensor1d(newValues, "float32");
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/in_top_k.js
  async function inTopKAsync_(predictions, targets, k4 = 1) {
    const $predictions = convertToTensor(predictions, "predictions", "inTopK");
    const $targets = convertToTensor(targets, "targets", "inTopK");
    assert2($predictions.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${$predictions.rank}`);
    assert2($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${$predictions.rank} and targets rank ${$targets.rank}`);
    assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, except the last dimension.`);
    const lastDim = $predictions.shape[$predictions.shape.length - 1];
    assert2(k4 > 0 && k4 <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${lastDim}), but got ${k4}`);
    const predictionsVals = await $predictions.data();
    const targetsVals = await $targets.data();
    const [batch, size] = [predictionsVals.length / lastDim, lastDim];
    const precision2 = getTypedArrayFromDType("bool", batch);
    for (let b2 = 0; b2 < batch; b2++) {
      const offset = b2 * size;
      const vals = predictionsVals.subarray(offset, offset + size);
      const valAndInd = [];
      for (let i2 = 0; i2 < vals.length; i2++) {
        valAndInd.push({ value: vals[i2], index: i2 });
      }
      valAndInd.sort((a2, b3) => b3.value - a2.value);
      precision2[b2] = 0;
      for (let i2 = 0; i2 < k4; i2++) {
        if (valAndInd[i2].index === targetsVals[b2]) {
          precision2[b2] = 1;
          break;
        }
      }
    }
    if (predictions !== $predictions) {
      $predictions.dispose();
    }
    if (targets !== $targets) {
      $targets.dispose();
    }
    return tensor(precision2, $targets.shape, "bool");
  }
  var inTopKAsync = inTopKAsync_;

  // node_modules/@tensorflow/tfjs-core/dist/ops/fused_ops.js
  var fused_ops_exports = {};
  __export(fused_ops_exports, {
    conv2d: () => conv2d2,
    depthwiseConv2d: () => depthwiseConv2d2,
    matMul: () => matMul2
  });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv2d_backprop_filter.js
  function conv2DBackpropFilter_(x2, dy, filterShape, strides, pad2, dataFormat = "NHWC", dimRoundingMode) {
    let x4D = x2;
    if (x2.rank === 3) {
      x4D = reshape2(x2, [1, x2.shape[0], x2.shape[1], x2.shape[2]]);
    }
    let dy4D = dy;
    if (dy4D.rank === 3) {
      dy4D = reshape2(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    assert2(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${x4D.shape}.`);
    assert2(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${dy4D.shape}.`);
    assert2(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${filterShape}.`);
    const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
    const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
    assert2(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must match input depth in filter (${filterShape[2]}.`);
    assert2(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must match output depth for filter (${filterShape[3]}).`);
    checkPadOnDimRoundingMode("conv2dDerFilter", pad2, dimRoundingMode);
    const inputs = { x: x4D, dy: dy4D };
    const attrs = { strides, pad: pad2, dataFormat, dimRoundingMode, filterShape };
    return ENGINE.runKernel(Conv2DBackpropFilter, inputs, attrs);
  }
  var conv2DBackpropFilter = /* @__PURE__ */ op({ conv2DBackpropFilter_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/fused_util.js
  function getFusedDyActivation(dy, y2, activation2) {
    if (activation2 == null || activation2 === "linear") {
      return dy;
    }
    if (activation2 === "relu") {
      return mul(dy, step(y2));
    }
    throw new Error(`Cannot compute gradient for fused activation ${activation2}.`);
  }
  function getFusedBiasGradient(bias, dyActivation) {
    let res = dyActivation;
    const reduceAxes = getReductionAxes(bias.shape, dyActivation.shape);
    if (reduceAxes.length > 0) {
      res = sum2(res, reduceAxes);
    }
    return reshape2(res, bias.shape);
  }
  function applyActivation(x2, activation2, preluActivationWeights, leakyreluAlpha) {
    if (activation2 === "linear") {
      return x2;
    } else if (activation2 === "relu") {
      return relu(x2);
    } else if (activation2 === "elu") {
      return elu(x2);
    } else if (activation2 === "relu6") {
      return relu6(x2);
    } else if (activation2 === "prelu") {
      return prelu(x2, preluActivationWeights);
    } else if (activation2 === "leakyrelu") {
      return leakyRelu(x2, leakyreluAlpha);
    } else if (activation2 === "sigmoid") {
      return sigmoid(x2);
    }
    throw new Error(`Unknown fused activation ${activation2}.`);
  }
  var shouldFuse = (gradientDepth, activation2) => {
    const gradientMode = gradientDepth > 0;
    return !gradientMode || activation2 === "linear";
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/fused/conv2d.js
  function fusedConv2d_({ x: x2, filter, strides, pad: pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation: activation2 = "linear", preluActivationWeights, leakyreluAlpha }) {
    activation2 = activation2 || "linear";
    if (shouldFuse(ENGINE.state.gradientDepth, activation2) === false) {
      assert2(dataFormat === "NHWC", () => `Error in fused conv2d: got dataFormat of ${dataFormat} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
      let result = conv2d(x2, filter, strides, pad2, dataFormat, dilations, dimRoundingMode);
      if (bias != null) {
        result = add2(result, bias);
      }
      return applyActivation(result, activation2, preluActivationWeights, leakyreluAlpha);
    }
    const $x = convertToTensor(x2, "x", "conv2d", "float32");
    const $filter = convertToTensor(filter, "filter", "conv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert2(x4D.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert2($filter.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    checkPadOnDimRoundingMode("fused conv2d", pad2, dimRoundingMode);
    const inputChannels = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
    assert2($filter.shape[2] === inputChannels, () => `Error in conv2d: depth of input (${inputChannels}) must match input depth for filter ${$filter.shape[2]}.`);
    assert2(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad2, dimRoundingMode);
    let $bias;
    if (bias != null) {
      $bias = convertToTensor(bias, "bias", "fused conv2d");
      [$bias] = makeTypesMatch($bias, $x);
      if (dataFormat === "NHWC") {
        assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
      } else {
        assert2($bias.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${$bias.shape.length}.`);
        assert2($bias.shape.length === 0 || $bias.shape[0] === convInfo.outChannels || $bias.shape[0] === 1, () => `Error in fused conv2d: bias shape (${$bias.shape}) is not compatible with the number of output channels (${convInfo.outChannels})`);
      }
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
      const alphaShape = preluActivationWeights.shape;
      assert2(alphaShape.length <= 1 || alphaShape.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${alphaShape.length}.`);
      if (alphaShape.length === 1) {
        assert2(alphaShape[0] === 1 || alphaShape[0] === convInfo.outChannels, () => `Error in fused conv2d: PReLU activation weights (${alphaShape}) is not compatible with the number of output channels (${convInfo.outChannels}).`);
      } else if (alphaShape.length === 3) {
        try {
          assertAndGetBroadcastShape(alphaShape, convInfo.outShape);
        } catch (e2) {
          const errMsg = `Error in fused conv2d: PReLU activation weights (${alphaShape}) is not compatible with the output shape of the conv2d (${convInfo.outShape}).`;
          throw Error(errMsg);
        }
      }
      $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused conv2d");
    }
    const grad = (dy, saved) => {
      assert2(dataFormat === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${dataFormat} but only NHWC is currently supported.`);
      const [$filter2, x4D2, y2, $bias2] = saved;
      const dyActivation = getFusedDyActivation(dy, y2, activation2);
      assert2(tupleValuesAreOne(dilations), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
      const xDer = conv2DBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad2);
      const filterDer = conv2DBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad2);
      const der = [xDer, filterDer];
      if ($bias2 != null) {
        const biasDer = getFusedBiasGradient($bias2, dyActivation);
        der.push(biasDer);
      }
      return der;
    };
    const inputs = {
      x: x4D,
      filter: $filter,
      bias: $bias,
      preluActivationWeights: $preluActivationWeights
    };
    const attrs = {
      strides,
      pad: pad2,
      dataFormat,
      dilations,
      dimRoundingMode,
      activation: activation2,
      leakyreluAlpha
    };
    if (bias == null) {
      const customOp = customGrad((x4D2, filter2, save) => {
        let res = (
          // tslint:disable-next-line: no-unnecessary-type-assertion
          ENGINE.runKernel(FusedConv2D, inputs, attrs)
        );
        save([filter2, x4D2, res]);
        if (reshapedTo4D) {
          res = reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad };
      });
      return customOp(x4D, $filter);
    } else {
      const customOpWithBias = customGrad((x4D2, filter2, bias2, save) => {
        let res = ENGINE.runKernel(FusedConv2D, inputs, attrs);
        save([filter2, x4D2, res, bias2]);
        if (reshapedTo4D) {
          res = reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad };
      });
      return customOpWithBias(x4D, $filter, $bias);
    }
  }
  var conv2d2 = /* @__PURE__ */ op({ fusedConv2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/depthwise_conv2d_native_backprop_filter.js
  function depthwiseConv2dNativeBackpropFilter_(x2, dy, filterShape, strides, pad2, dilations = [1, 1], dimRoundingMode) {
    let x4D = x2;
    if (x2.rank === 3) {
      x4D = reshape2(x2, [1, x2.shape[0], x2.shape[1], x2.shape[2]]);
    }
    let dy4D = dy;
    if (dy4D.rank === 3) {
      dy4D = reshape2(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    const inputs = { x: x4D, dy: dy4D };
    const attrs = { strides, pad: pad2, dimRoundingMode, dilations, filterShape };
    return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter, inputs, attrs);
  }
  var depthwiseConv2dNativeBackpropFilter = op({ depthwiseConv2dNativeBackpropFilter_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/depthwise_conv2d_native_backprop_input.js
  function depthwiseConv2dNativeBackpropInput_(xShape, dy, filter, strides, pad2, dilations = [1, 1], dimRoundingMode) {
    let dy4D = dy;
    let reshapedTo4D = false;
    if (dy.rank === 3) {
      reshapedTo4D = true;
      dy4D = reshape2(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    const inputs = { dy: dy4D, filter };
    const attrs = { strides, pad: pad2, dimRoundingMode, dilations, inputShape: xShape };
    const res = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput, inputs, attrs)
    );
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var depthwiseConv2dNativeBackpropInput = op({ depthwiseConv2dNativeBackpropInput_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/fused/depthwise_conv2d.js
  function fusedDepthwiseConv2d_({ x: x2, filter, strides, pad: pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation: activation2 = "linear", preluActivationWeights, leakyreluAlpha }) {
    if (shouldFuse(ENGINE.state.gradientDepth, activation2) === false) {
      let result = depthwiseConv2d(x2, filter, strides, pad2, dataFormat, dilations, dimRoundingMode);
      if (bias != null) {
        result = add2(result, bias);
      }
      return applyActivation(result, activation2, preluActivationWeights, leakyreluAlpha);
    }
    const $x = convertToTensor(x2, "x", "depthwiseConv2d", "float32");
    const $filter = convertToTensor(filter, "filter", "depthwiseConv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape2($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert2(x4D.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert2($filter.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    assert2(x4D.shape[3] === $filter.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
    if (dilations == null) {
      dilations = [1, 1];
    }
    assert2(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    checkPadOnDimRoundingMode("fused depthwiseConv2d", pad2, dimRoundingMode);
    const convInfo = computeConv2DInfo(
      x4D.shape,
      $filter.shape,
      strides,
      dilations,
      pad2,
      dimRoundingMode,
      true
      /* depthwise */
    );
    let $bias;
    if (bias != null) {
      $bias = convertToTensor(bias, "bias", "fused conv2d");
      [$bias] = makeTypesMatch($bias, $x);
      assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
      $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused depthwiseConv2d");
    }
    const grad = (dy, saved) => {
      assert2(tupleValuesAreOne(dilations), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${dilations}'`);
      const [$filter2, x4D2, y2, bias2] = saved;
      const dyActivation = getFusedDyActivation(dy, y2, activation2);
      const xDer = depthwiseConv2dNativeBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad2, dilations, dimRoundingMode);
      const filterDer = depthwiseConv2dNativeBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad2, dilations, dimRoundingMode);
      if (bias2 != null) {
        const biasDer = getFusedBiasGradient($bias, dyActivation);
        return [xDer, filterDer, biasDer];
      }
      return [xDer, filterDer];
    };
    const inputs = {
      x: x4D,
      filter: $filter,
      bias: $bias,
      preluActivationWeights: $preluActivationWeights
    };
    const attrs = {
      strides,
      pad: pad2,
      dataFormat,
      dilations,
      dimRoundingMode,
      activation: activation2,
      leakyreluAlpha
    };
    if (bias == null) {
      const customOp = customGrad((x4D2, filter2, save) => {
        let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
        save([filter2, x4D2, res]);
        if (reshapedTo4D) {
          res = reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad };
      });
      return customOp(x4D, $filter);
    } else {
      const customOpWithBias = customGrad((x4D2, filter2, bias2, save) => {
        let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
        save([filter2, x4D2, res, bias2]);
        if (reshapedTo4D) {
          res = reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad };
      });
      return customOpWithBias(x4D, $filter, $bias);
    }
  }
  var depthwiseConv2d2 = /* @__PURE__ */ op({ fusedDepthwiseConv2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/fused/mat_mul.js
  function fusedMatMul_({ a: a2, b: b2, transposeA = false, transposeB = false, bias, activation: activation2 = "linear", preluActivationWeights, leakyreluAlpha = 0.2 }) {
    if (shouldFuse(ENGINE.state.gradientDepth, activation2) === false) {
      let result = matMul(a2, b2, transposeA, transposeB);
      if (bias != null) {
        result = add2(result, bias);
      }
      return applyActivation(result, activation2, preluActivationWeights, leakyreluAlpha);
    }
    let $a2 = convertToTensor(a2, "a", "fused matMul");
    let $b = convertToTensor(b2, "b", "fused matMul");
    [$a2, $b] = makeTypesMatch($a2, $b);
    const innerShapeA = transposeA ? $a2.shape[$a2.rank - 2] : $a2.shape[$a2.rank - 1];
    const innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
    const outerShapeA = transposeA ? $a2.shape[$a2.rank - 1] : $a2.shape[$a2.rank - 2];
    const outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
    const outerDimsA = $a2.shape.slice(0, -2);
    const outerDimsB = $b.shape.slice(0, -2);
    const batchDimA = sizeFromShape(outerDimsA);
    const batchDimB = sizeFromShape(outerDimsB);
    assert2(innerShapeA === innerShapeB, () => `Error in fused matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${$a2.shape} and ${$b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
    const outShapeOuterDims = assertAndGetBroadcastShape($a2.shape.slice(0, -2), $b.shape.slice(0, -2));
    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
    const a3D = transposeA ? reshape2($a2, [batchDimA, innerShapeA, outerShapeA]) : reshape2($a2, [batchDimA, outerShapeA, innerShapeA]);
    const b3D = transposeB ? reshape2($b, [batchDimB, outerShapeB, innerShapeB]) : reshape2($b, [batchDimB, innerShapeB, outerShapeB]);
    let $bias;
    if (bias != null) {
      $bias = convertToTensor(bias, "bias", "fused matMul");
      [$bias] = makeTypesMatch($bias, $a2);
      assertAndGetBroadcastShape(outShape, $bias.shape);
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
      $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused matMul");
    }
    const grad = (dy, saved) => {
      const [a3D2, b3D2, y2, $bias2] = saved;
      const dyActivation = getFusedDyActivation(reshape2(dy, y2.shape), y2, activation2);
      let aDer;
      let bDer;
      if (!transposeA && !transposeB) {
        aDer = matMul(dyActivation, b3D2, false, true);
        bDer = matMul(a3D2, dyActivation, true, false);
      } else if (!transposeA && transposeB) {
        aDer = matMul(dyActivation, b3D2, false, false);
        bDer = matMul(dyActivation, a3D2, true, false);
      } else if (transposeA && !transposeB) {
        aDer = matMul(b3D2, dyActivation, false, true);
        bDer = matMul(a3D2, dyActivation, false, false);
      } else {
        aDer = matMul(b3D2, dyActivation, true, true);
        bDer = matMul(dyActivation, a3D2, true, true);
      }
      if (bias != null) {
        const biasDer = getFusedBiasGradient($bias2, dyActivation);
        return [aDer, bDer, biasDer];
      } else {
        return [aDer, bDer];
      }
    };
    const inputs = {
      a: a3D,
      b: b3D,
      bias: $bias,
      preluActivationWeights: $preluActivationWeights
    };
    const attrs = { transposeA, transposeB, activation: activation2, leakyreluAlpha };
    if (bias == null) {
      const customOp = customGrad((a3D2, b3D2, save) => {
        const res = (
          // tslint:disable-next-line: no-unnecessary-type-assertion
          ENGINE.runKernel(_FusedMatMul, inputs, attrs)
        );
        save([a3D2, b3D2, res]);
        return { value: reshape2(res, outShape), gradFunc: grad };
      });
      return customOp(a3D, b3D);
    } else {
      const customOpWithBias = customGrad((a3D2, b3D2, $bias2, save) => {
        const res = (
          // tslint:disable-next-line: no-unnecessary-type-assertion
          ENGINE.runKernel(_FusedMatMul, inputs, attrs)
        );
        save([a3D2, b3D2, res, $bias2]);
        return { value: reshape2(res, outShape), gradFunc: grad };
      });
      return customOpWithBias(a3D, b3D, $bias);
    }
  }
  var matMul2 = /* @__PURE__ */ op({ fusedMatMul_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/signal/hamming_window.js
  function hammingWindow_(windowLength) {
    return cosineWindow(windowLength, 0.54, 0.46);
  }
  var hammingWindow = /* @__PURE__ */ op({ hammingWindow_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/signal/hann_window.js
  function hannWindow_(windowLength) {
    return cosineWindow(windowLength, 0.5, 0.5);
  }
  var hannWindow = /* @__PURE__ */ op({ hannWindow_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/signal/frame.js
  function frame_(signal2, frameLength, frameStep, padEnd = false, padValue = 0) {
    let start = 0;
    const output = [];
    while (start + frameLength <= signal2.size) {
      output.push(slice(signal2, start, frameLength));
      start += frameStep;
    }
    if (padEnd) {
      while (start < signal2.size) {
        const padLen = start + frameLength - signal2.size;
        const pad2 = concat([
          slice(signal2, start, frameLength - padLen),
          fill([padLen], padValue)
        ]);
        output.push(pad2);
        start += frameStep;
      }
    }
    if (output.length === 0) {
      return tensor2d([], [0, frameLength]);
    }
    return reshape2(concat(output), [output.length, frameLength]);
  }
  var frame = /* @__PURE__ */ op({ frame_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/signal/stft.js
  function stft_(signal2, frameLength, frameStep, fftLength, windowFn = hannWindow) {
    if (fftLength == null) {
      fftLength = enclosingPowerOfTwo(frameLength);
    }
    const framedSignal = frame(signal2, frameLength, frameStep);
    const windowedSignal = mul(framedSignal, windowFn(frameLength));
    return rfft(windowedSignal, fftLength);
  }
  var stft = /* @__PURE__ */ op({ stft_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/crop_and_resize.js
  function cropAndResize_(image2, boxes, boxInd, cropSize, method = "bilinear", extrapolationValue = 0) {
    const $image = convertToTensor(image2, "image", "cropAndResize");
    const $boxes = convertToTensor(boxes, "boxes", "cropAndResize", "float32");
    const $boxInd = convertToTensor(boxInd, "boxInd", "cropAndResize", "int32");
    const numBoxes = $boxes.shape[0];
    assert2($image.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${$image.rank}.`);
    assert2($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] but had shape ${$boxes.shape}.`);
    assert2($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] but had shape ${$boxes.shape}.`);
    assert2(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${cropSize.length}.`);
    assert2(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);
    assert2(method === "bilinear" || method === "nearest", () => `method must be bilinear or nearest, but was ${method}`);
    const inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };
    const attrs = { method, extrapolationValue, cropSize };
    const res = ENGINE.runKernel(CropAndResize, inputs, attrs);
    return res;
  }
  var cropAndResize = /* @__PURE__ */ op({ cropAndResize_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/flip_left_right.js
  function flipLeftRight_(image2) {
    const $image = convertToTensor(image2, "image", "flipLeftRight", "float32");
    assert2($image.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${$image.rank}.`);
    const inputs = { image: $image };
    const res = ENGINE.runKernel(FlipLeftRight, inputs, {});
    return res;
  }
  var flipLeftRight = /* @__PURE__ */ op({ flipLeftRight_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/grayscale_to_rgb.js
  function grayscaleToRGB_(image2) {
    const $image = convertToTensor(image2, "image", "grayscaleToRGB");
    const lastDimsIdx = $image.rank - 1;
    const lastDims = $image.shape[lastDimsIdx];
    assert2($image.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${$image.rank}.`);
    assert2(lastDims === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${lastDims}.`);
    const reps = new Array($image.rank);
    reps.fill(1, 0, lastDimsIdx);
    reps[lastDimsIdx] = 3;
    return tile($image, reps);
  }
  var grayscaleToRGB = /* @__PURE__ */ op({ grayscaleToRGB_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/rotate_with_offset.js
  function rotateWithOffset_(image2, radians, fillValue = 0, center = 0.5) {
    const $image = convertToTensor(image2, "image", "rotateWithOffset", "float32");
    assert2($image.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${$image.rank}.`);
    const inputs = { image: $image };
    const attrs = { radians, fillValue, center };
    const res = ENGINE.runKernel(RotateWithOffset, inputs, attrs);
    return res;
  }
  var rotateWithOffset = /* @__PURE__ */ op({ rotateWithOffset_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/nonmax_util.js
  function nonMaxSuppSanityCheck(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
    if (iouThreshold == null) {
      iouThreshold = 0.5;
    }
    if (scoreThreshold == null) {
      scoreThreshold = Number.NEGATIVE_INFINITY;
    }
    if (softNmsSigma == null) {
      softNmsSigma = 0;
    }
    const numBoxes = boxes.shape[0];
    maxOutputSize = Math.min(maxOutputSize, numBoxes);
    assert2(0 <= iouThreshold && iouThreshold <= 1, () => `iouThreshold must be in [0, 1], but was '${iouThreshold}'`);
    assert2(boxes.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${boxes.rank}'`);
    assert2(boxes.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`);
    assert2(scores.rank === 1, () => "scores must be a 1D tensor");
    assert2(scores.shape[0] === numBoxes, () => `scores has incompatible shape with boxes. Expected ${numBoxes}, but was ${scores.shape[0]}`);
    assert2(0 <= softNmsSigma && softNmsSigma <= 1, () => `softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`);
    return { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression.js
  function nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression", "float32");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppression", "float32");
    const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
    maxOutputSize = inputs.maxOutputSize;
    iouThreshold = inputs.iouThreshold;
    scoreThreshold = inputs.scoreThreshold;
    const attrs = { maxOutputSize, iouThreshold, scoreThreshold };
    return ENGINE.runKernel(NonMaxSuppressionV3, { boxes: $boxes, scores: $scores }, attrs);
  }
  var nonMaxSuppression = /* @__PURE__ */ op({ nonMaxSuppression_ });

  // node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_util.js
  function binaryInsert(arr, element, comparator) {
    const index = binarySearch(arr, element, comparator);
    const insertionPoint = index < 0 ? -(index + 1) : index;
    arr.splice(insertionPoint, 0, element);
  }
  function binarySearch(arr, target, comparator) {
    return binarySearch_(arr, target, comparator || defaultComparator);
  }
  function defaultComparator(a2, b2) {
    return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
  }
  function binarySearch_(arr, target, comparator) {
    let left = 0;
    let right = arr.length;
    let middle = 0;
    let found = false;
    while (left < right) {
      middle = left + (right - left >>> 1);
      const compareResult = comparator(target, arr[middle]);
      if (compareResult > 0) {
        left = middle + 1;
      } else {
        right = middle;
        found = !compareResult;
      }
    }
    return found ? left : -left - 1;
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_impl.js
  function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    return nonMaxSuppressionImpl_(
      boxes,
      scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      0
      /* softNmsSigma */
    );
  }
  function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
    return nonMaxSuppressionImpl_(
      boxes,
      scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      0,
      false,
      padToMaxOutputSize,
      true
      /* returnValidOutputs */
    );
  }
  function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
    return nonMaxSuppressionImpl_(
      boxes,
      scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      softNmsSigma,
      true
      /* returnScoresTensor */
    );
  }
  function nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {
    const candidates = [];
    for (let i2 = 0; i2 < scores.length; i2++) {
      if (scores[i2] > scoreThreshold) {
        candidates.push({ score: scores[i2], boxIndex: i2, suppressBeginIndex: 0 });
      }
    }
    candidates.sort(ascendingComparator);
    const scale = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0;
    const selectedIndices = [];
    const selectedScores = [];
    while (selectedIndices.length < maxOutputSize && candidates.length > 0) {
      const candidate = candidates.pop();
      const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;
      if (originalScore < scoreThreshold) {
        break;
      }
      let ignoreCandidate = false;
      for (let j3 = selectedIndices.length - 1; j3 >= suppressBeginIndex; --j3) {
        const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j3]);
        if (iou >= iouThreshold) {
          ignoreCandidate = true;
          break;
        }
        candidate.score = candidate.score * suppressWeight(iouThreshold, scale, iou);
        if (candidate.score <= scoreThreshold) {
          break;
        }
      }
      candidate.suppressBeginIndex = selectedIndices.length;
      if (!ignoreCandidate) {
        if (candidate.score === originalScore) {
          selectedIndices.push(boxIndex);
          selectedScores.push(candidate.score);
        } else if (candidate.score > scoreThreshold) {
          binaryInsert(candidates, candidate, ascendingComparator);
        }
      }
    }
    const validOutputs = selectedIndices.length;
    const elemsToPad = maxOutputSize - validOutputs;
    if (padToMaxOutputSize && elemsToPad > 0) {
      selectedIndices.push(...new Array(elemsToPad).fill(0));
      selectedScores.push(...new Array(elemsToPad).fill(0));
    }
    const result = { selectedIndices };
    if (returnScoresTensor) {
      result["selectedScores"] = selectedScores;
    }
    if (returnValidOutputs) {
      result["validOutputs"] = validOutputs;
    }
    return result;
  }
  function intersectionOverUnion(boxes, i2, j3) {
    const iCoord = boxes.subarray(i2 * 4, i2 * 4 + 4);
    const jCoord = boxes.subarray(j3 * 4, j3 * 4 + 4);
    const yminI = Math.min(iCoord[0], iCoord[2]);
    const xminI = Math.min(iCoord[1], iCoord[3]);
    const ymaxI = Math.max(iCoord[0], iCoord[2]);
    const xmaxI = Math.max(iCoord[1], iCoord[3]);
    const yminJ = Math.min(jCoord[0], jCoord[2]);
    const xminJ = Math.min(jCoord[1], jCoord[3]);
    const ymaxJ = Math.max(jCoord[0], jCoord[2]);
    const xmaxJ = Math.max(jCoord[1], jCoord[3]);
    const areaI = (ymaxI - yminI) * (xmaxI - xminI);
    const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
    if (areaI <= 0 || areaJ <= 0) {
      return 0;
    }
    const intersectionYmin = Math.max(yminI, yminJ);
    const intersectionXmin = Math.max(xminI, xminJ);
    const intersectionYmax = Math.min(ymaxI, ymaxJ);
    const intersectionXmax = Math.min(xmaxI, xmaxJ);
    const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
    return intersectionArea / (areaI + areaJ - intersectionArea);
  }
  function suppressWeight(iouThreshold, scale, iou) {
    const weight = Math.exp(scale * iou * iou);
    return iou <= iouThreshold ? weight : 0;
  }
  function ascendingComparator(c1, c2) {
    return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_async.js
  async function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
    const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
    maxOutputSize = inputs.maxOutputSize;
    iouThreshold = inputs.iouThreshold;
    scoreThreshold = inputs.scoreThreshold;
    const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
    const boxesVals = boxesAndScores[0];
    const scoresVals = boxesAndScores[1];
    const { selectedIndices } = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    if ($boxes !== boxes) {
      $boxes.dispose();
    }
    if ($scores !== scores) {
      $scores.dispose();
    }
    return tensor1d(selectedIndices, "int32");
  }
  var nonMaxSuppressionAsync = nonMaxSuppressionAsync_;

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score.js
  function nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
    const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    maxOutputSize = params.maxOutputSize;
    iouThreshold = params.iouThreshold;
    scoreThreshold = params.scoreThreshold;
    softNmsSigma = params.softNmsSigma;
    const inputs = { boxes: $boxes, scores: $scores };
    const attrs = { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
    const result = ENGINE.runKernel(NonMaxSuppressionV5, inputs, attrs);
    return { selectedIndices: result[0], selectedScores: result[1] };
  }
  var nonMaxSuppressionWithScore = /* @__PURE__ */ op({ nonMaxSuppressionWithScore_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score_async.js
  async function nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
    const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    maxOutputSize = params.maxOutputSize;
    iouThreshold = params.iouThreshold;
    scoreThreshold = params.scoreThreshold;
    softNmsSigma = params.softNmsSigma;
    const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
    const boxesVals = boxesAndScores[0];
    const scoresVals = boxesAndScores[1];
    const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    if ($boxes !== boxes) {
      $boxes.dispose();
    }
    if ($scores !== scores) {
      $scores.dispose();
    }
    return {
      selectedIndices: tensor1d(selectedIndices, "int32"),
      selectedScores: tensor1d(selectedScores)
    };
  }
  var nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded.js
  function nonMaxSuppressionPadded_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
    const params = nonMaxSuppSanityCheck(
      $boxes,
      $scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      null
      /* softNmsSigma */
    );
    const $maxOutputSize = params.maxOutputSize;
    const $iouThreshold = params.iouThreshold;
    const $scoreThreshold = params.scoreThreshold;
    const inputs = { boxes: $boxes, scores: $scores };
    const attrs = {
      maxOutputSize: $maxOutputSize,
      iouThreshold: $iouThreshold,
      scoreThreshold: $scoreThreshold,
      padToMaxOutputSize
    };
    const result = ENGINE.runKernel(NonMaxSuppressionV4, inputs, attrs);
    return { selectedIndices: result[0], validOutputs: result[1] };
  }
  var nonMaxSuppressionPadded = /* @__PURE__ */ op({ nonMaxSuppressionPadded_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded_async.js
  async function nonMaxSuppressionPaddedAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
    const params = nonMaxSuppSanityCheck(
      $boxes,
      $scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      null
      /* softNmsSigma */
    );
    const $maxOutputSize = params.maxOutputSize;
    const $iouThreshold = params.iouThreshold;
    const $scoreThreshold = params.scoreThreshold;
    const [boxesVals, scoresVals] = await Promise.all([$boxes.data(), $scores.data()]);
    const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl(boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold, padToMaxOutputSize);
    if ($boxes !== boxes) {
      $boxes.dispose();
    }
    if ($scores !== scores) {
      $scores.dispose();
    }
    return {
      selectedIndices: tensor1d(selectedIndices, "int32"),
      validOutputs: scalar(validOutputs, "int32")
    };
  }
  var nonMaxSuppressionPaddedAsync = nonMaxSuppressionPaddedAsync_;

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/resize_bilinear.js
  function resizeBilinear_(images, size, alignCorners = false, halfPixelCenters = false) {
    const $images = convertToTensor(images, "images", "resizeBilinear");
    assert2($images.rank === 3 || $images.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${$images.rank}.`);
    assert2(size.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${size}.`);
    assert2(halfPixelCenters === false || alignCorners === false, () => `Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.`);
    let batchImages = $images;
    let reshapedTo4D = false;
    if ($images.rank === 3) {
      reshapedTo4D = true;
      batchImages = reshape2($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
    }
    const [] = size;
    const inputs = { images: batchImages };
    const attrs = { alignCorners, halfPixelCenters, size };
    const res = ENGINE.runKernel(ResizeBilinear, inputs, attrs);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var resizeBilinear = /* @__PURE__ */ op({ resizeBilinear_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/resize_nearest_neighbor.js
  function resizeNearestNeighbor_(images, size, alignCorners = false, halfPixelCenters = false) {
    const $images = convertToTensor(images, "images", "resizeNearestNeighbor");
    assert2($images.rank === 3 || $images.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${$images.rank}.`);
    assert2(size.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${size}.`);
    assert2($images.dtype === "float32" || $images.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype");
    assert2(halfPixelCenters === false || alignCorners === false, () => `Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.`);
    let batchImages = $images;
    let reshapedTo4D = false;
    if ($images.rank === 3) {
      reshapedTo4D = true;
      batchImages = reshape2($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
    }
    const [] = size;
    const inputs = { images: batchImages };
    const attrs = { alignCorners, halfPixelCenters, size };
    const res = ENGINE.runKernel(ResizeNearestNeighbor, inputs, attrs);
    if (reshapedTo4D) {
      return reshape2(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var resizeNearestNeighbor = /* @__PURE__ */ op({ resizeNearestNeighbor_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/threshold.js
  function threshold_(image2, method = "binary", inverted = false, threshValue = 0.5) {
    const $image = convertToTensor(image2, "image", "threshold");
    const RED_INTENCITY_COEF = 0.2989;
    const GREEN_INTENCITY_COEF = 0.587;
    const BLUE_INTENCITY_COEF = 0.114;
    const totalPixelsInImage = $image.shape[0] * $image.shape[1];
    let $threshold = mul(tensor1d([threshValue]), 255);
    let r2, g2, b2, grayscale;
    assert2($image.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${$image.rank}.`);
    assert2($image.shape[2] === 3 || $image.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${$image.shape[2]}.`);
    assert2($image.dtype === "int32" || $image.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${$image.dtype}.`);
    assert2(method === "otsu" || method === "binary", () => `Method must be binary or otsu, but was ${method}`);
    if ($image.shape[2] === 3) {
      [r2, g2, b2] = split($image, [1, 1, 1], -1);
      const $r2 = mul(r2, RED_INTENCITY_COEF);
      const $g = mul(g2, GREEN_INTENCITY_COEF);
      const $b = mul(b2, BLUE_INTENCITY_COEF);
      grayscale = add2(add2($r2, $g), $b);
    } else {
      grayscale = image2;
    }
    if (method === "otsu") {
      const $histogram = bincount(cast(round2(grayscale), "int32"), tensor([]), 256);
      $threshold = otsu($histogram, totalPixelsInImage);
    }
    const invCondition = inverted ? lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);
    const result = cast(mul(invCondition, 255), "int32");
    return result;
  }
  function otsu(histogram, total) {
    let bestThresh = tensor1d([-1]);
    let bestInBetVar = tensor1d([0]);
    let cInBetVar = tensor1d([0]);
    let classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;
    for (let index = 0; index < histogram.size - 1; index++) {
      classFirst = slice(histogram, 0, index + 1);
      classSecond = slice(histogram, index + 1);
      weightForeground = div(sum2(classFirst), total);
      weightBack = div(sum2(classSecond), total);
      const meanFirstDivA = sum2(mul(classFirst, range2(0, classFirst.size)));
      meanFirst = div(meanFirstDivA, sum2(classFirst));
      const meanSecFill = fill(classSecond.shape, classFirst.size);
      const meanSecAdd = add2(range2(0, classSecond.size), meanSecFill);
      const meanSecMul = mul(classSecond, meanSecAdd);
      meanSec = div(sum2(meanSecMul), sum2(classSecond));
      const cInBetVarSubA = sub(meanFirst, meanSec);
      const cInBetVarSubB = sub(meanFirst, meanSec);
      const cInBetVarMul = mul(weightForeground, weightBack);
      cInBetVar = mul(mul(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);
      const condition = greater(cInBetVar, bestInBetVar);
      bestInBetVar = where(condition, cInBetVar, bestInBetVar);
      bestThresh = where(condition, tensor1d([index]), bestThresh);
    }
    return bestThresh;
  }
  var threshold = /* @__PURE__ */ op({ threshold_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/transform.js
  function transform_(image2, transforms, interpolation = "nearest", fillMode = "constant", fillValue = 0, outputShape) {
    const $image = convertToTensor(image2, "image", "transform", "float32");
    const $transforms = convertToTensor(transforms, "transforms", "transform", "float32");
    assert2($image.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${$image.rank}.`);
    assert2($transforms.rank === 2 && ($transforms.shape[0] === $image.shape[0] || $transforms.shape[0] === 1) && $transforms.shape[1] === 8, () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);
    assert2(outputShape == null || outputShape.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${outputShape}.`);
    const inputs = { image: $image, transforms: $transforms };
    const attrs = { interpolation, fillMode, fillValue, outputShape };
    return ENGINE.runKernel(Transform, inputs, attrs);
  }
  var transform = /* @__PURE__ */ op({ transform_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/linalg/band_part.js
  function bandPart_(a2, numLower, numUpper) {
    assert2(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);
    assert2(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);
    const $a2 = convertToTensor(a2, "a", "bandPart");
    assert2($a2.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a2.rank}.`);
    const shape = $a2.shape;
    const [M2, N3] = $a2.shape.slice(-2);
    if (!(numLower <= M2)) {
      throw new Error(`bandPart(): numLower (${numLower}) must not be greater than the number of rows (${M2}).`);
    }
    if (!(numUpper <= N3)) {
      throw new Error(`bandPart(): numUpper (${numUpper}) must not be greater than the number of columns (${N3}).`);
    }
    if (numLower < 0) {
      numLower = M2;
    }
    if (numUpper < 0) {
      numUpper = N3;
    }
    const i2 = reshape2(range2(0, M2, 1, "int32"), [-1, 1]);
    const j3 = range2(0, N3, 1, "int32");
    const ij = sub(i2, j3);
    const inBand = logicalAnd(lessEqual(ij, scalar(+numLower, "int32")), greaterEqual(ij, scalar(-numUpper, "int32")));
    const zero = zeros([M2, N3], $a2.dtype);
    return reshape2(stack(unstack(reshape2($a2, [-1, M2, N3])).map((mat) => where(inBand, mat, zero))), shape);
  }
  var bandPart = /* @__PURE__ */ op({ bandPart_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/linalg/gram_schmidt.js
  function gramSchmidt_(xs2) {
    let inputIsTensor2D;
    if (Array.isArray(xs2)) {
      inputIsTensor2D = false;
      assert2(xs2 != null && xs2.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
      const dim = xs2[0].shape[0];
      for (let i2 = 1; i2 < xs2.length; ++i2) {
        assert2(xs2[i2].shape[0] === dim, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${xs2[i2].shape[0]} vs. ${dim})`);
      }
    } else {
      inputIsTensor2D = true;
      xs2 = split(xs2, xs2.shape[0], 0).map((x2) => squeeze(x2, [0]));
    }
    assert2(xs2.length <= xs2[0].shape[0], () => `Gram-Schmidt: Number of vectors (${xs2.length}) exceeds number of dimensions (${xs2[0].shape[0]}).`);
    const ys2 = [];
    const xs1d = xs2;
    for (let i2 = 0; i2 < xs2.length; ++i2) {
      ys2.push(ENGINE.tidy(() => {
        let x2 = xs1d[i2];
        if (i2 > 0) {
          for (let j3 = 0; j3 < i2; ++j3) {
            const proj = mul(sum2(mul(ys2[j3], x2)), ys2[j3]);
            x2 = sub(x2, proj);
          }
        }
        return div(x2, norm(x2, "euclidean"));
      }));
    }
    if (inputIsTensor2D) {
      return stack(ys2, 0);
    } else {
      return ys2;
    }
  }
  var gramSchmidt = /* @__PURE__ */ op({ gramSchmidt_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/linalg/qr.js
  function qr_(x2, fullMatrices = false) {
    assert2(x2.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${x2.rank}`);
    if (x2.rank === 2) {
      return qr2d(x2, fullMatrices);
    } else {
      const outerDimsProd = x2.shape.slice(0, x2.shape.length - 2).reduce((value, prev) => value * prev);
      const x2ds = unstack(reshape2(x2, [
        outerDimsProd,
        x2.shape[x2.shape.length - 2],
        x2.shape[x2.shape.length - 1]
      ]), 0);
      const q2ds = [];
      const r2ds = [];
      x2ds.forEach((x2d) => {
        const [q2d, r2d] = qr2d(x2d, fullMatrices);
        q2ds.push(q2d);
        r2ds.push(r2d);
      });
      const q3 = reshape2(stack(q2ds, 0), x2.shape);
      const r2 = reshape2(stack(r2ds, 0), x2.shape);
      return [q3, r2];
    }
  }
  function qr2d(x2, fullMatrices = false) {
    return ENGINE.tidy(() => {
      assert2(x2.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${x2.shape.length}D Tensor.`);
      const m2 = x2.shape[0];
      const n2 = x2.shape[1];
      let q3 = eye(m2);
      let r2 = clone(x2);
      const one2D = tensor2d([[1]], [1, 1]);
      let w2 = clone(one2D);
      const iters = m2 >= n2 ? n2 : m2;
      for (let j3 = 0; j3 < iters; ++j3) {
        const rTemp = r2;
        const wTemp = w2;
        const qTemp = q3;
        [w2, r2, q3] = ENGINE.tidy(() => {
          const rjEnd1 = slice(r2, [j3, j3], [m2 - j3, 1]);
          const normX = norm(rjEnd1);
          const rjj = slice(r2, [j3, j3], [1, 1]);
          const s2 = where(greater(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));
          const u1 = sub(rjj, mul(s2, normX));
          const wPre = div(rjEnd1, u1);
          if (wPre.shape[0] === 1) {
            w2 = clone(one2D);
          } else {
            w2 = concat([
              one2D,
              slice(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])
            ], 0);
          }
          const tau = neg(div(matMul(s2, u1), normX));
          const rjEndAll = slice(r2, [j3, 0], [m2 - j3, n2]);
          const tauTimesW = mul(tau, w2);
          const wT = transpose(w2);
          if (j3 === 0) {
            r2 = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
          } else {
            const rTimesTau = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
            r2 = concat([slice(r2, [0, 0], [j3, n2]), rTimesTau], 0);
          }
          const tawTimesWT = transpose(tauTimesW);
          const qAllJEnd = slice(q3, [0, j3], [m2, q3.shape[1] - j3]);
          if (j3 === 0) {
            q3 = sub(qAllJEnd, matMul(matMul(qAllJEnd, w2), tawTimesWT));
          } else {
            const qTimesTau = sub(qAllJEnd, matMul(matMul(qAllJEnd, w2), tawTimesWT));
            q3 = concat([slice(q3, [0, 0], [m2, j3]), qTimesTau], 1);
          }
          return [w2, r2, q3];
        });
        dispose([rTemp, wTemp, qTemp]);
      }
      if (!fullMatrices && m2 > n2) {
        q3 = slice(q3, [0, 0], [m2, n2]);
        r2 = slice(r2, [0, 0], [n2, n2]);
      }
      return [q3, r2];
    });
  }
  var qr2 = /* @__PURE__ */ op({ qr_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/loss_ops_utils.js
  var Reduction;
  (function(Reduction2) {
    Reduction2[Reduction2["NONE"] = 0] = "NONE";
    Reduction2[Reduction2["MEAN"] = 1] = "MEAN";
    Reduction2[Reduction2["SUM"] = 2] = "SUM";
    Reduction2[Reduction2["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
  })(Reduction || (Reduction = {}));

  // node_modules/@tensorflow/tfjs-core/dist/ops/losses/compute_weighted_loss.js
  function computeWeightedLoss_(losses2, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $losses = convertToTensor(losses2, "losses", "computeWeightedLoss");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "computeWeightedLoss");
    }
    const weightedLoss = $weights == null ? $losses : mul($losses, $weights);
    if (reduction2 === Reduction.NONE) {
      return weightedLoss;
    }
    if (reduction2 === Reduction.SUM) {
      return sum2(weightedLoss);
    }
    if (reduction2 === Reduction.MEAN) {
      if ($weights == null) {
        return mean(weightedLoss);
      } else {
        const broadcastFactor = $losses.size / $weights.size;
        const result = div(sum2(weightedLoss), sum2($weights));
        return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) : result;
      }
    }
    if (reduction2 === Reduction.SUM_BY_NONZERO_WEIGHTS) {
      if ($weights == null) {
        return div(sum2(weightedLoss), scalar($losses.size));
      } else {
        const broadcastedWeights = mul($weights, ones2($losses.shape));
        const numNonZeros = cast(sum2(notEqual(broadcastedWeights, scalar(0))), "float32");
        return div(sum2(weightedLoss), numNonZeros);
      }
    }
    throw Error(`Unknown reduction: ${reduction2}`);
  }
  var computeWeightedLoss2 = /* @__PURE__ */ op({ computeWeightedLoss_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/losses/absolute_difference.js
  function absoluteDifference_(labels, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, "labels", "absoluteDifference");
    const $predictions = convertToTensor(predictions, "predictions", "absoluteDifference");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "absoluteDifference");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in absoluteDifference: ");
    const losses2 = abs(sub($labels, $predictions));
    return computeWeightedLoss2(losses2, $weights, reduction2);
  }
  var absoluteDifference = /* @__PURE__ */ op({ absoluteDifference_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/losses/cosine_distance.js
  function cosineDistance_(labels, predictions, axis, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, "labels", "cosineDistance");
    const $predictions = convertToTensor(predictions, "predictions", "cosineDistance");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "cosineDistance");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in cosineDistance: ");
    const one = scalar(1);
    const losses2 = sub(one, sum2(mul($labels, $predictions), axis, true));
    return computeWeightedLoss2(losses2, $weights, reduction2);
  }
  var cosineDistance = /* @__PURE__ */ op({ cosineDistance_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/losses/hinge_loss.js
  function hingeLoss_(labels, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    let $labels = convertToTensor(labels, "labels", "hingeLoss");
    const $predictions = convertToTensor(predictions, "predictions", "hingeLoss");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "hingeLoss");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in hingeLoss: ");
    const one = scalar(1);
    $labels = sub(mul(scalar(2), $labels), one);
    const losses2 = relu(sub(one, mul($labels, $predictions)));
    return computeWeightedLoss2(losses2, $weights, reduction2);
  }
  var hingeLoss = /* @__PURE__ */ op({ hingeLoss_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/losses/huber_loss.js
  function huberLoss_(labels, predictions, weights, delta = 1, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, "labels", "huberLoss");
    const $predictions = convertToTensor(predictions, "predictions", "huberLoss");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "huberLoss");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in huberLoss: ");
    const deltaScalar = scalar(delta);
    const error = abs(sub($predictions, $labels));
    const quadratic = minimum(error, deltaScalar);
    const linear = sub(error, quadratic);
    const losses2 = add2(mul(scalar(0.5), square2(quadratic)), mul(deltaScalar, linear));
    return computeWeightedLoss2(losses2, $weights, reduction2);
  }
  var huberLoss = /* @__PURE__ */ op({ huberLoss_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/losses/log_loss.js
  function logLoss_(labels, predictions, weights, epsilon2 = 1e-7, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, "labels", "logLoss");
    const $predictions = convertToTensor(predictions, "predictions", "logLoss");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "logLoss");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in logLoss: ");
    const one = scalar(1);
    const epsilonScalar = scalar(epsilon2);
    const l12 = neg(mul($labels, log2(add2($predictions, epsilonScalar))));
    const l22 = mul(sub(one, $labels), log2(add2(sub(one, $predictions), epsilonScalar)));
    const losses2 = sub(l12, l22);
    return computeWeightedLoss2(losses2, $weights, reduction2);
  }
  var logLoss = /* @__PURE__ */ op({ logLoss_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/losses/mean_squared_error.js
  function meanSquaredError_(labels, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, "labels", "meanSquaredError");
    const $predictions = convertToTensor(predictions, "predictions", "meanSquaredError");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "meanSquaredError");
    }
    assertShapesMatch($labels.shape, $predictions.shape, "Error in meanSquaredError: ");
    const losses2 = squaredDifference($labels, $predictions);
    return computeWeightedLoss2(losses2, $weights, reduction2);
  }
  var meanSquaredError2 = /* @__PURE__ */ op({ meanSquaredError_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/losses/sigmoid_cross_entropy.js
  function sigmoidCrossEntropyWithLogits_(labels, logits) {
    const $labels = convertToTensor(labels, "labels", "sigmoidCrossEntropyWithLogits");
    const $logits = convertToTensor(logits, "logits", "sigmoidCrossEntropyWithLogits");
    assertShapesMatch($labels.shape, $logits.shape, "Error in sigmoidCrossEntropyWithLogits: ");
    const maxOutput = relu($logits);
    const outputXTarget = mul($logits, $labels);
    const sigmoidOutput = log1p(exp(neg(abs($logits))));
    return add2(sub(maxOutput, outputXTarget), sigmoidOutput);
  }
  function sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing = 0, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    let $multiClassLabels = convertToTensor(multiClassLabels, "multiClassLabels", "sigmoidCrossEntropy");
    const $logits = convertToTensor(logits, "logits", "sigmoidCrossEntropy");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "sigmoidCrossEntropy");
    }
    assertShapesMatch($multiClassLabels.shape, $logits.shape, "Error in sigmoidCrossEntropy: ");
    if (labelSmoothing > 0) {
      const labelSmoothingScalar = scalar(labelSmoothing);
      const one = scalar(1);
      const half = scalar(0.5);
      $multiClassLabels = add2(mul($multiClassLabels, sub(one, labelSmoothingScalar)), mul(half, labelSmoothingScalar));
    }
    const losses2 = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);
    return computeWeightedLoss2(losses2, $weights, reduction2);
  }
  var sigmoidCrossEntropy = /* @__PURE__ */ op({ sigmoidCrossEntropy_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/losses/softmax_cross_entropy.js
  function softmaxCrossEntropyWithLogits_(labels, logits, dim = -1) {
    if (dim === -1) {
      dim = logits.rank - 1;
    }
    if (dim !== logits.rank - 1) {
      throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${logits.rank} and dim was ${dim}`);
    }
    const customOp = customGrad((labels2, logits2, save) => {
      const keepDims = true;
      const lse = logSumExp(logits2, [dim], keepDims);
      const logResult = sub(cast(logits2, "float32"), lse);
      save([labels2, logResult]);
      const costVector = neg(mul(logResult, labels2));
      const value = sum2(costVector, [dim]);
      const gradFunc = (dy, saved) => {
        const [labels3, logResult2] = saved;
        const dyShape = expandShapeToKeepDim(dy.shape, [dim]);
        return [
          mul(reshape2(dy, dyShape), sub(cast(labels3, "float32"), exp(logResult2))),
          mul(reshape2(dy, dyShape), sub(exp(logResult2), cast(labels3, "float32")))
        ];
      };
      return { value, gradFunc };
    });
    return customOp(labels, logits);
  }
  function softmaxCrossEntropy_(onehotLabels, logits, weights, labelSmoothing = 0, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    let $onehotLabels = convertToTensor(onehotLabels, "onehotLabels", "softmaxCrossEntropy");
    const $logits = convertToTensor(logits, "logits", "softmaxCrossEntropy");
    let $weights = null;
    if (weights != null) {
      $weights = convertToTensor(weights, "weights", "softmaxCrossEntropy");
    }
    assertShapesMatch($onehotLabels.shape, $logits.shape, "Error in softmaxCrossEntropy: ");
    if (labelSmoothing > 0) {
      const labelSmoothingScalar = scalar(labelSmoothing);
      const one = scalar(1);
      const numClasses = scalar($onehotLabels.shape[1]);
      $onehotLabels = add2(mul($onehotLabels, sub(one, labelSmoothingScalar)), div(labelSmoothingScalar, numClasses));
    }
    const losses2 = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);
    return computeWeightedLoss2(losses2, $weights, reduction2);
  }
  var softmaxCrossEntropy = /* @__PURE__ */ op({ softmaxCrossEntropy_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_fill_empty_rows.js
  function sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {
    const $indices = convertToTensor(indices, "indices", "sparseFillEmptyRows", "int32");
    const $values = convertToTensor(values, "values", "sparseFillEmptyRows");
    const $denseShape = convertToTensor(denseShape, "denseShape", "sparseFillEmptyRows", "int32");
    const $defaultValue = convertToTensor(defaultValue, "defaultValue", "sparseFillEmptyRows", $values.dtype);
    if ($indices.rank !== 2) {
      throw new Error(`Indices should be Tensor2D but received shape
        ${$indices.shape}`);
    }
    if ($values.rank !== 1) {
      throw new Error(`Values should be Tensor1D but received shape ${$values.shape}`);
    }
    if ($denseShape.rank !== 1) {
      throw new Error(`Dense shape should be Tensor1D but received shape ${$denseShape.shape}`);
    }
    if ($defaultValue.rank !== 0) {
      throw new Error(`Default value should be a scalar but received shape ${$defaultValue.shape}`);
    }
    const inputs = {
      indices: $indices,
      values: $values,
      denseShape: $denseShape,
      defaultValue: $defaultValue
    };
    const result = ENGINE.runKernel(SparseFillEmptyRows, inputs);
    return {
      outputIndices: result[0],
      outputValues: result[1],
      emptyRowIndicator: result[2],
      reverseIndexMap: result[3]
    };
  }
  var sparseFillEmptyRows = /* @__PURE__ */ op({ sparseFillEmptyRows_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape.js
  function sparseReshape_(inputIndices, inputShape, newShape) {
    const $inputIndices = convertToTensor(inputIndices, "inputIndices", "sparseReshape", "int32");
    const $inputShape = convertToTensor(inputShape, "inputShape", "sparseReshape", "int32");
    const $newShape = convertToTensor(newShape, "newShape", "sparseReshape", "int32");
    if ($inputIndices.rank !== 2) {
      throw new Error(`Input indices should be Tensor2D but received shape
        ${$inputIndices.shape}`);
    }
    if ($inputShape.rank !== 1) {
      throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);
    }
    if ($newShape.rank !== 1) {
      throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);
    }
    const inputs = {
      inputIndices: $inputIndices,
      inputShape: $inputShape,
      newShape: $newShape
    };
    const result = ENGINE.runKernel(SparseReshape, inputs);
    return { outputIndices: result[0], outputShape: result[1] };
  }
  var sparseReshape = /* @__PURE__ */ op({ sparseReshape_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_mean.js
  function sparseSegmentMean_(data, indices, segmentIds) {
    const $data = convertToTensor(data, "data", "sparseSegmentMean");
    const $indices = convertToTensor(indices, "indices", "sparseSegmentMean", "int32");
    const $segmentIds = convertToTensor(segmentIds, "segmentIds", "sparseSegmentMean", "int32");
    if ($data.rank < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if ($indices.rank !== 1) {
      throw new Error(`Indices should be Tensor1D but received shape
          ${$indices.shape}`);
    }
    if ($segmentIds.rank !== 1) {
      throw new Error(`Segment ids should be Tensor1D but received shape
          ${$segmentIds.shape}`);
    }
    const inputs = {
      data: $data,
      indices: $indices,
      segmentIds: $segmentIds
    };
    return ENGINE.runKernel(SparseSegmentMean, inputs);
  }
  var sparseSegmentMean = /* @__PURE__ */ op({ sparseSegmentMean_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_sum.js
  function sparseSegmentSum_(data, indices, segmentIds) {
    const $data = convertToTensor(data, "data", "sparseSegmentSum");
    const $indices = convertToTensor(indices, "indices", "sparseSegmentSum", "int32");
    const $segmentIds = convertToTensor(segmentIds, "segmentIds", "sparseSegmentSum", "int32");
    if ($data.rank < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if ($indices.rank !== 1) {
      throw new Error(`Indices should be Tensor1D but received shape
         ${$indices.shape}`);
    }
    if ($segmentIds.rank !== 1) {
      throw new Error(`Segment ids should be Tensor1D but received shape
         ${$segmentIds.shape}`);
    }
    const inputs = {
      data: $data,
      indices: $indices,
      segmentIds: $segmentIds
    };
    return ENGINE.runKernel(SparseSegmentSum, inputs);
  }
  var sparseSegmentSum = /* @__PURE__ */ op({ sparseSegmentSum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/string/string_n_grams.js
  function stringNGrams_(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
    const $data = convertToTensor(data, "data", "stringNGrams", "string");
    if ($data.dtype !== "string") {
      throw new Error("Data must be of datatype string");
    }
    if ($data.shape.length !== 1) {
      throw new Error(`Data must be a vector, saw: ${$data.shape}`);
    }
    const $dataSplits = convertToTensor(dataSplits, "dataSplits", "stringNGrams");
    if ($dataSplits.dtype !== "int32") {
      throw new Error("Data splits must be of datatype int32");
    }
    const attrs = {
      separator,
      nGramWidths,
      leftPad,
      rightPad: rightPad2,
      padWidth,
      preserveShortSequences
    };
    const inputs = { data: $data, dataSplits: $dataSplits };
    const result = ENGINE.runKernel(StringNGrams, inputs, attrs);
    return { nGrams: result[0], nGramsSplits: result[1] };
  }
  var stringNGrams = /* @__PURE__ */ op({ stringNGrams_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/string/string_split.js
  function stringSplit_(input2, delimiter, skipEmpty = true) {
    const $input = convertToTensor(input2, "input", "stringSplit", "string");
    const $delimiter = convertToTensor(delimiter, "delimiter", "stringSplit", "string");
    if ($input.rank !== 1) {
      throw new Error(`Input should be Tensor1D but received shape ${$input.shape}`);
    }
    if ($delimiter.rank !== 0) {
      throw new Error(`Delimiter should be a scalar but received shape ${$delimiter.shape}`);
    }
    const attrs = { skipEmpty };
    const inputs = { input: $input, delimiter: $delimiter };
    const result = ENGINE.runKernel(StringSplit, inputs, attrs);
    return { indices: result[0], values: result[1], shape: result[2] };
  }
  var stringSplit = /* @__PURE__ */ op({ stringSplit_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/string/string_to_hash_bucket_fast.js
  function stringToHashBucketFast_(input2, numBuckets) {
    const $input = convertToTensor(input2, "input", "stringToHashBucketFast", "string");
    const attrs = { numBuckets };
    if (numBuckets <= 0) {
      throw new Error(`Number of buckets must be at least 1`);
    }
    const inputs = { input: $input };
    return ENGINE.runKernel(StringToHashBucketFast, inputs, attrs);
  }
  var stringToHashBucketFast = /* @__PURE__ */ op({ stringToHashBucketFast_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/ops.js
  var spectral2 = {
    fft,
    ifft,
    rfft,
    irfft
  };
  var signal = {
    hammingWindow,
    hannWindow,
    frame,
    stft
  };
  var image = {
    flipLeftRight,
    grayscaleToRGB,
    resizeNearestNeighbor,
    resizeBilinear,
    rotateWithOffset,
    cropAndResize,
    nonMaxSuppression,
    nonMaxSuppressionAsync,
    nonMaxSuppressionWithScore,
    nonMaxSuppressionWithScoreAsync,
    nonMaxSuppressionPadded,
    nonMaxSuppressionPaddedAsync,
    threshold,
    transform
  };
  var linalg = {
    bandPart,
    gramSchmidt,
    qr: qr2
  };
  var losses = {
    absoluteDifference,
    computeWeightedLoss: computeWeightedLoss2,
    cosineDistance,
    hingeLoss,
    huberLoss,
    logLoss,
    meanSquaredError: meanSquaredError2,
    sigmoidCrossEntropy,
    softmaxCrossEntropy
  };
  var sparse = {
    sparseFillEmptyRows,
    sparseReshape,
    sparseSegmentMean,
    sparseSegmentSum
  };
  var string = {
    stringNGrams,
    stringSplit,
    stringToHashBucketFast
  };

  // node_modules/@tensorflow/tfjs-core/dist/serialization.js
  var Serializable = class {
    /**
     * Return the class name for this class to use in serialization contexts.
     *
     * Generally speaking this will be the same thing that constructor.name
     * would have returned.  However, the class name needs to be robust
     * against minification for serialization/deserialization to work properly.
     *
     * There's also places such as initializers.VarianceScaling, where
     * implementation details between different languages led to different
     * class hierarchies and a non-leaf node is used for serialization purposes.
     */
    getClassName() {
      return this.constructor.className;
    }
    /**
     * Creates an instance of T from a ConfigDict.
     *
     * This works for most descendants of serializable.  A few need to
     * provide special handling.
     * @param cls A Constructor for the class to instantiate.
     * @param config The Configuration for the object.
     */
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config);
    }
  };
  var SerializationMap = class {
    constructor() {
      this.classNameMap = {};
    }
    /**
     * Returns the singleton instance of the map.
     */
    static getMap() {
      if (SerializationMap.instance == null) {
        SerializationMap.instance = new SerializationMap();
      }
      return SerializationMap.instance;
    }
    /**
     * Registers the class as serializable.
     */
    static register(cls) {
      SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];
    }
  };
  function registerClass(cls) {
    assert2(cls.className != null, () => `Class being registered does not have the static className property defined.`);
    assert2(typeof cls.className === "string", () => `className is required to be a string, but got type ` + typeof cls.className);
    assert2(cls.className.length > 0, () => `Class being registered has an empty-string as its className, which is disallowed.`);
    SerializationMap.register(cls);
  }

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/optimizer.js
  var Optimizer = class extends Serializable {
    /**
     * Executes `f()` and minimizes the scalar output of `f()` by computing
     * gradients of y with respect to the list of trainable variables provided by
     * `varList`. If no list is provided, it defaults to all trainable variables.
     *
     * @param f The function to execute and whose output to minimize.
     * @param returnCost Whether to return the scalar cost value produced by
     * executing `f()`.
     * @param varList An optional list of variables to update. If specified, only
     * the trainable variables in varList will be updated by minimize. Defaults to
     * all trainable variables.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers'}
     */
    minimize(f2, returnCost = false, varList) {
      const { value, grads } = this.computeGradients(f2, varList);
      if (varList != null) {
        const gradArray = varList.map((v2) => ({ name: v2.name, tensor: grads[v2.name] }));
        this.applyGradients(gradArray);
      } else {
        this.applyGradients(grads);
      }
      dispose(grads);
      if (returnCost) {
        return value;
      } else {
        value.dispose();
        return null;
      }
    }
    /**
     * The number of iterations that this optimizer instance has been invoked for.
     */
    get iterations() {
      if (this.iterations_ == null) {
        this.iterations_ = 0;
      }
      return this.iterations_;
    }
    incrementIterations() {
      this.iterations_ = this.iterations + 1;
    }
    /**
     * Executes f() and computes the gradient of the scalar output of f() with
     * respect to the list of trainable variables provided by `varList`. If no
     * list is provided, it defaults to all trainable variables.
     *
     * @param f The function to execute and whose output to use for computing
     * gradients with respect to variables.
     * @param varList An optional list of variables to compute gradients with
     * respect to. If specified, only the trainable variables in varList will have
     * gradients computed with respect to. Defaults to all trainable variables.
     *
     * @doc {heading: 'Training', subheading: 'Optimizers'}
     */
    computeGradients(f2, varList) {
      return variableGrads(f2, varList);
    }
    /**
     * Dispose the variables (if any) owned by this optimizer instance.
     */
    dispose() {
      if (this.iterations_ != null) {
        dispose(this.iterations_);
      }
    }
    async saveIterations() {
      if (this.iterations_ == null) {
        this.iterations_ = 0;
      }
      return {
        name: "iter",
        // TODO(cais): Use 'int64' type when available.
        tensor: scalar(this.iterations_, "int32")
      };
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for this optimizer yet.");
    }
    async setWeights(weightValues) {
      throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
    }
    /**
     * Extract the first element of the weight values and set it
     * as the iterations counter variable of this instance of optimizer.
     *
     * @param weightValues
     * @returns Weight values with the first element consumed and excluded.
     */
    async extractIterations(weightValues) {
      this.iterations_ = (await weightValues[0].tensor.data())[0];
      return weightValues.slice(1);
    }
  };
  Object.defineProperty(Optimizer, Symbol.hasInstance, {
    value: (instance) => {
      return instance.minimize != null && instance.computeGradients != null && instance.applyGradients != null;
    }
  });

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/adadelta_optimizer.js
  var AdadeltaOptimizer = class extends Optimizer {
    constructor(learningRate, rho, epsilon2 = null) {
      super();
      this.learningRate = learningRate;
      this.rho = rho;
      this.epsilon = epsilon2;
      this.accumulatedGrads = [];
      this.accumulatedUpdates = [];
      if (epsilon2 == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    /** @nocollapse */
    static get className() {
      return "Adadelta";
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i2) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedGrads[i2] == null) {
          this.accumulatedGrads[i2] = {
            originalName: `${name}/accum_grad`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedUpdates[i2] == null) {
          this.accumulatedUpdates[i2] = {
            originalName: `${name}/accum_var`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const accumulatedGrad = this.accumulatedGrads[i2].variable;
        const accumulatedUpdate = this.accumulatedUpdates[i2].variable;
        tidy(() => {
          const newAccumulatedGrad = add2(mul(accumulatedGrad, this.rho), mul(square2(gradient), 1 - this.rho));
          const updates = mul(div(sqrt(add2(accumulatedUpdate, this.epsilon)), sqrt(add2(accumulatedGrad, this.epsilon))), gradient);
          const newAccumulatedUpdate = add2(mul(accumulatedUpdate, this.rho), mul(square2(updates), 1 - this.rho));
          accumulatedGrad.assign(newAccumulatedGrad);
          accumulatedUpdate.assign(newAccumulatedUpdate);
          const newValue = add2(mul(updates, -this.learningRate), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedUpdates != null) {
        dispose(this.accumulatedGrads.map((v2) => v2.variable));
        dispose(this.accumulatedUpdates.map((v2) => v2.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedGrads, ...this.accumulatedUpdates];
      return [await this.saveIterations()].concat(variables.map((v2) => ({ name: v2.originalName, tensor: v2.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const variableCount = weightValues.length / 2;
      const trainable = false;
      this.accumulatedGrads = weightValues.slice(0, variableCount).map((v2) => ({
        originalName: v2.name,
        variable: v2.tensor.variable(trainable)
      }));
      this.accumulatedUpdates = weightValues.slice(variableCount, variableCount * 2).map((v2) => ({
        originalName: v2.name,
        variable: v2.tensor.variable(trainable)
      }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "rho": this.rho,
        "epsilon": this.epsilon
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["rho"], config["epsilon"]);
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/adagrad_optimizer.js
  var AdagradOptimizer = class extends Optimizer {
    constructor(learningRate, initialAccumulatorValue = 0.1) {
      super();
      this.learningRate = learningRate;
      this.initialAccumulatorValue = initialAccumulatorValue;
      this.accumulatedGrads = [];
    }
    /** @nocollapse */
    static get className() {
      return "Adagrad";
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i2) => {
        const value = ENGINE.registeredVariables[name];
        if (this.accumulatedGrads[i2] == null) {
          const trainable = false;
          this.accumulatedGrads[i2] = {
            originalName: `${name}/accumulator`,
            variable: tidy(() => fill(value.shape, this.initialAccumulatorValue).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const accumulatedGrad = this.accumulatedGrads[i2].variable;
        tidy(() => {
          const newAccumulatedGrad = add2(accumulatedGrad, square2(gradient));
          accumulatedGrad.assign(newAccumulatedGrad);
          const newValue = add2(mul(div(gradient, sqrt(add2(newAccumulatedGrad, ENGINE.backend.epsilon()))), -this.learningRate), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedGrads != null) {
        dispose(this.accumulatedGrads.map((v2) => v2.variable));
      }
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulatedGrads.map((v2) => ({ name: v2.originalName, tensor: v2.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const trainable = false;
      this.accumulatedGrads = weightValues.map((v2) => ({ originalName: v2.name, variable: v2.tensor.variable(trainable) }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "initialAccumulatorValue": this.initialAccumulatorValue
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["initialAccumulatorValue"]);
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/adam_optimizer.js
  var AdamOptimizer = class extends Optimizer {
    constructor(learningRate, beta1, beta2, epsilon2 = null) {
      super();
      this.learningRate = learningRate;
      this.beta1 = beta1;
      this.beta2 = beta2;
      this.epsilon = epsilon2;
      this.accumulatedFirstMoment = [];
      this.accumulatedSecondMoment = [];
      tidy(() => {
        this.accBeta1 = scalar(beta1).variable();
        this.accBeta2 = scalar(beta2).variable();
      });
      if (epsilon2 == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    /** @nocollapse */
    static get className() {
      return "Adam";
    }
    applyGradients(variableGradients) {
      const varNames = Array.isArray(variableGradients) ? variableGradients.map((v2) => v2.name) : Object.keys(variableGradients);
      tidy(() => {
        const oneMinusAccBeta1 = sub(1, this.accBeta1);
        const oneMinusAccBeta2 = sub(1, this.accBeta2);
        varNames.forEach((name, i2) => {
          const value = ENGINE.registeredVariables[name];
          const trainable = false;
          if (this.accumulatedFirstMoment[i2] == null) {
            this.accumulatedFirstMoment[i2] = {
              originalName: `${name}/m`,
              variable: tidy(() => zerosLike(value).variable(trainable))
            };
          }
          if (this.accumulatedSecondMoment[i2] == null) {
            this.accumulatedSecondMoment[i2] = {
              originalName: `${name}/v`,
              variable: tidy(() => zerosLike(value).variable(trainable))
            };
          }
          const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          const firstMoment = this.accumulatedFirstMoment[i2].variable;
          const secondMoment = this.accumulatedSecondMoment[i2].variable;
          const newFirstMoment = add2(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));
          const newSecondMoment = add2(mul(secondMoment, this.beta2), mul(square2(gradient), 1 - this.beta2));
          const biasCorrectedFirstMoment = div(newFirstMoment, oneMinusAccBeta1);
          const biasCorrectedSecondMoment = div(newSecondMoment, oneMinusAccBeta2);
          firstMoment.assign(newFirstMoment);
          secondMoment.assign(newSecondMoment);
          const newValue = add2(mul(div(biasCorrectedFirstMoment, add2(sqrt(biasCorrectedSecondMoment), this.epsilon)), -this.learningRate), value);
          value.assign(newValue);
        });
        this.accBeta1.assign(mul(this.accBeta1, this.beta1));
        this.accBeta2.assign(mul(this.accBeta2, this.beta2));
      });
      this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose();
      this.accBeta2.dispose();
      if (this.accumulatedFirstMoment != null) {
        dispose(this.accumulatedFirstMoment.map((v2) => v2.variable));
      }
      if (this.accumulatedSecondMoment != null) {
        dispose(this.accumulatedSecondMoment.map((v2) => v2.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
      return [await this.saveIterations()].concat(variables.map((v2) => ({ name: v2.originalName, tensor: v2.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      tidy(() => {
        this.accBeta1.assign(pow(this.beta1, this.iterations_ + 1));
        this.accBeta2.assign(pow(this.beta2, this.iterations_ + 1));
      });
      const variableCount = weightValues.length / 2;
      const trainable = false;
      this.accumulatedFirstMoment = weightValues.slice(0, variableCount).map((v2) => ({
        originalName: v2.name,
        variable: v2.tensor.variable(trainable)
      }));
      this.accumulatedSecondMoment = weightValues.slice(variableCount, variableCount * 2).map((v2) => ({
        originalName: v2.name,
        variable: v2.tensor.variable(trainable)
      }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "beta1": this.beta1,
        "beta2": this.beta2,
        "epsilon": this.epsilon
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["beta1"], config["beta2"], config["epsilon"]);
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/adamax_optimizer.js
  var AdamaxOptimizer = class extends Optimizer {
    constructor(learningRate, beta1, beta2, epsilon2 = null, decay = 0) {
      super();
      this.learningRate = learningRate;
      this.beta1 = beta1;
      this.beta2 = beta2;
      this.epsilon = epsilon2;
      this.decay = decay;
      this.accumulatedFirstMoment = [];
      this.accumulatedWeightedInfNorm = [];
      tidy(() => {
        this.iteration = scalar(0).variable();
        this.accBeta1 = scalar(beta1).variable();
      });
      if (epsilon2 == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    /** @nocollapse */
    static get className() {
      return "Adamax";
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      tidy(() => {
        const oneMinusAccBeta1 = sub(1, this.accBeta1);
        const lr2 = div(-this.learningRate, add2(mul(this.iteration, this.decay), 1));
        variableNames.forEach((name, i2) => {
          const value = ENGINE.registeredVariables[name];
          const trainable = false;
          if (this.accumulatedFirstMoment[i2] == null) {
            this.accumulatedFirstMoment[i2] = {
              originalName: `${name}/m`,
              variable: zerosLike(value).variable(trainable)
            };
          }
          if (this.accumulatedWeightedInfNorm[i2] == null) {
            this.accumulatedWeightedInfNorm[i2] = {
              originalName: `${name}/v`,
              variable: zerosLike(value).variable(trainable)
            };
          }
          const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          const firstMoment = this.accumulatedFirstMoment[i2].variable;
          const weightedInfNorm = this.accumulatedWeightedInfNorm[i2].variable;
          const newFirstMoment = add2(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));
          const ut0 = mul(weightedInfNorm, this.beta2);
          const ut1 = abs(gradient);
          const newWeightedInfNorm = maximum(ut0, ut1);
          firstMoment.assign(newFirstMoment);
          weightedInfNorm.assign(newWeightedInfNorm);
          const newValue = add2(mul(div(lr2, oneMinusAccBeta1), div(newFirstMoment, add2(newWeightedInfNorm, this.epsilon))), value);
          value.assign(newValue);
        });
        this.iteration.assign(add2(this.iteration, 1));
        this.accBeta1.assign(mul(this.accBeta1, this.beta1));
      });
      this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose();
      this.iteration.dispose();
      if (this.accumulatedFirstMoment != null) {
        dispose(this.accumulatedFirstMoment.map((v2) => v2.variable));
      }
      if (this.accumulatedWeightedInfNorm != null) {
        dispose(this.accumulatedWeightedInfNorm.map((v2) => v2.variable));
      }
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for Adamax yet.");
    }
    async setWeights(weightValues) {
      throw new Error("setWeights() is not implemented for Adamax yet.");
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "beta1": this.beta1,
        "beta2": this.beta2,
        "epsilon": this.epsilon,
        "decay": this.decay
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["beta1"], config["beta2"], config["epsilon"], config["decay"]);
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/sgd_optimizer.js
  var SGDOptimizer = class extends Optimizer {
    constructor(learningRate) {
      super();
      this.learningRate = learningRate;
      this.setLearningRate(learningRate);
    }
    /** @nocollapse */
    static get className() {
      return "SGD";
    }
    applyGradients(variableGradients) {
      const varNames = Array.isArray(variableGradients) ? variableGradients.map((v2) => v2.name) : Object.keys(variableGradients);
      varNames.forEach((name, i2) => {
        const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const value = ENGINE.registeredVariables[name];
        tidy(() => {
          const newValue = add2(mul(this.c, gradient), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    /**
     * Sets the learning rate of the optimizer.
     */
    setLearningRate(learningRate) {
      this.learningRate = learningRate;
      if (this.c != null) {
        this.c.dispose();
      }
      this.c = keep(scalar(-learningRate));
    }
    dispose() {
      this.c.dispose();
    }
    async getWeights() {
      return [await this.saveIterations()];
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      if (weightValues.length !== 0) {
        throw new Error("SGD optimizer does not have settable weights.");
      }
    }
    getConfig() {
      return { "learningRate": this.learningRate };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"]);
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/momentum_optimizer.js
  var MomentumOptimizer = class extends SGDOptimizer {
    constructor(learningRate, momentum, useNesterov = false) {
      super(learningRate);
      this.learningRate = learningRate;
      this.momentum = momentum;
      this.useNesterov = useNesterov;
      this.accumulations = [];
      this.m = scalar(this.momentum);
    }
    /** @nocollapse */
    // Name matters for Python compatibility.
    static get className() {
      return "Momentum";
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i2) => {
        const value = ENGINE.registeredVariables[name];
        if (this.accumulations[i2] == null) {
          const trainable = false;
          this.accumulations[i2] = {
            originalName: `${name}/momentum`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const accumulation = this.accumulations[i2].variable;
        const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        tidy(() => {
          let newValue;
          const newAccumulation = add2(mul(this.m, accumulation), gradient);
          if (this.useNesterov) {
            newValue = add2(mul(this.c, add2(gradient, mul(newAccumulation, this.m))), value);
          } else {
            newValue = add2(mul(this.c, newAccumulation), value);
          }
          accumulation.assign(newAccumulation);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      this.m.dispose();
      if (this.accumulations != null) {
        dispose(this.accumulations.map((v2) => v2.variable));
      }
    }
    /**
     * Sets the momentum of the optimizer.
     *
     * @param momentum
     */
    setMomentum(momentum) {
      this.momentum = momentum;
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulations.map((v2) => ({ name: v2.originalName, tensor: v2.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const trainable = false;
      this.accumulations = weightValues.map((v2) => ({ originalName: v2.name, variable: v2.tensor.variable(trainable) }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "momentum": this.momentum,
        "useNesterov": this.useNesterov
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["momentum"], config["useNesterov"]);
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/rmsprop_optimizer.js
  var RMSPropOptimizer = class extends Optimizer {
    constructor(learningRate, decay = 0.9, momentum = 0, epsilon2 = null, centered = false) {
      super();
      this.learningRate = learningRate;
      this.decay = decay;
      this.momentum = momentum;
      this.epsilon = epsilon2;
      this.accumulatedMeanSquares = [];
      this.accumulatedMoments = [];
      this.accumulatedMeanGrads = [];
      this.centered = centered;
      if (epsilon2 == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
      if (learningRate == null) {
        throw new Error(`learningRate for RMSPropOptimizer must be defined.`);
      }
    }
    /** @nocollapse */
    static get className() {
      return "RMSProp";
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i2) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedMeanSquares[i2] == null) {
          this.accumulatedMeanSquares[i2] = {
            originalName: `${name}/rms`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedMoments[i2] == null) {
          this.accumulatedMoments[i2] = {
            originalName: `${name}/momentum`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedMeanGrads[i2] == null && this.centered) {
          this.accumulatedMeanGrads[i2] = {
            originalName: `${name}/mg`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i2].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const accumulatedMeanSquare = this.accumulatedMeanSquares[i2].variable;
        const accumulatedMoments = this.accumulatedMoments[i2].variable;
        tidy(() => {
          const newAccumulatedMeanSquare = add2(mul(accumulatedMeanSquare, this.decay), mul(square2(gradient), 1 - this.decay));
          if (this.centered) {
            const accumulatedMeanGrad = this.accumulatedMeanGrads[i2].variable;
            const newAccumulatedMeanGrad = add2(mul(accumulatedMeanGrad, this.decay), mul(gradient, 1 - this.decay));
            const gradContribution = div(mul(gradient, this.learningRate), sqrt(sub(newAccumulatedMeanSquare, add2(square2(newAccumulatedMeanGrad), this.epsilon))));
            const newAccumulatedMoments = add2(mul(accumulatedMoments, this.momentum), gradContribution);
            accumulatedMeanSquare.assign(newAccumulatedMeanSquare);
            accumulatedMeanGrad.assign(newAccumulatedMeanGrad);
            accumulatedMoments.assign(newAccumulatedMoments);
            const newValue = sub(value, newAccumulatedMoments);
            value.assign(newValue);
          } else {
            const newAccumulatedMeanSquare2 = add2(mul(accumulatedMeanSquare, this.decay), mul(square2(gradient), 1 - this.decay));
            const newAccumulatedMoments = add2(mul(accumulatedMoments, this.momentum), div(mul(gradient, this.learningRate), sqrt(add2(newAccumulatedMeanSquare2, this.epsilon))));
            accumulatedMeanSquare.assign(newAccumulatedMeanSquare2);
            accumulatedMoments.assign(newAccumulatedMoments);
            const newValue = sub(value, newAccumulatedMoments);
            value.assign(newValue);
          }
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedMeanSquares != null) {
        dispose(this.accumulatedMeanSquares.map((v2) => v2.variable));
      }
      if (this.accumulatedMeanGrads != null && this.centered) {
        dispose(this.accumulatedMeanGrads.map((v2) => v2.variable));
      }
      if (this.accumulatedMoments != null) {
        dispose(this.accumulatedMoments.map((v2) => v2.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
      if (this.centered) {
        variables.push(...this.accumulatedMeanGrads);
      }
      return [await this.saveIterations()].concat(variables.map((v2) => ({ name: v2.originalName, tensor: v2.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const variableCount = this.centered ? weightValues.length / 3 : weightValues.length / 2;
      const trainable = false;
      this.accumulatedMeanSquares = weightValues.slice(0, variableCount).map((v2) => ({
        originalName: v2.name,
        variable: v2.tensor.variable(trainable)
      }));
      this.accumulatedMoments = weightValues.slice(variableCount, variableCount * 2).map((v2) => ({
        originalName: v2.name,
        variable: v2.tensor.variable(trainable)
      }));
      if (this.centered) {
        this.accumulatedMeanGrads = weightValues.slice(variableCount * 2, variableCount * 3).map((v2) => ({
          originalName: v2.name,
          variable: v2.tensor.variable(trainable)
        }));
      }
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "decay": this.decay,
        "momentum": this.momentum,
        "epsilon": this.epsilon,
        "centered": this.centered
      };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["decay"], config["momentum"], config["epsilon"], config["centered"]);
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/register_optimizers.js
  var OPTIMIZERS = [
    AdadeltaOptimizer,
    AdagradOptimizer,
    AdamOptimizer,
    AdamaxOptimizer,
    MomentumOptimizer,
    RMSPropOptimizer,
    SGDOptimizer
  ];
  function registerOptimizers() {
    for (const optimizer of OPTIMIZERS) {
      registerClass(optimizer);
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/io.js
  var io_exports = {};
  __export(io_exports, {
    browserFiles: () => browserFiles,
    browserHTTPRequest: () => browserHTTPRequest,
    concatenateArrayBuffers: () => concatenateArrayBuffers,
    copyModel: () => copyModel,
    decodeWeights: () => decodeWeights,
    encodeWeights: () => encodeWeights,
    fromMemory: () => fromMemory,
    fromMemorySync: () => fromMemorySync,
    getLoadHandlers: () => getLoadHandlers,
    getModelArtifactsForJSON: () => getModelArtifactsForJSON,
    getModelArtifactsForJSONSync: () => getModelArtifactsForJSONSync,
    getModelArtifactsInfoForJSON: () => getModelArtifactsInfoForJSON,
    getSaveHandlers: () => getSaveHandlers,
    getWeightSpecs: () => getWeightSpecs,
    http: () => http,
    isHTTPScheme: () => isHTTPScheme,
    listModels: () => listModels,
    loadWeights: () => loadWeights,
    moveModel: () => moveModel,
    registerLoadRouter: () => registerLoadRouter,
    registerSaveRouter: () => registerSaveRouter,
    removeModel: () => removeModel,
    weightsLoaderFactory: () => weightsLoaderFactory,
    withSaveHandler: () => withSaveHandler,
    withSaveHandlerSync: () => withSaveHandlerSync
  });

  // node_modules/@tensorflow/tfjs-core/dist/io/browser_files.js
  var DEFAULT_FILE_NAME_PREFIX = "model";
  var DEFAULT_JSON_EXTENSION_NAME = ".json";
  var DEFAULT_WEIGHT_DATA_EXTENSION_NAME = ".weights.bin";
  function defer(f2) {
    return new Promise((resolve) => setTimeout(resolve)).then(f2);
  }
  var BrowserDownloads = class {
    constructor(fileNamePrefix) {
      if (!env().getBool("IS_BROWSER")) {
        throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
      }
      if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
        fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
      }
      if (fileNamePrefix == null || fileNamePrefix.length === 0) {
        fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
      }
      this.modelJsonFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
      this.weightDataFileName = fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
    }
    async save(modelArtifacts) {
      if (typeof document === "undefined") {
        throw new Error("Browser downloads are not supported in this environment since `document` is not present");
      }
      const weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], { type: "application/octet-stream" }));
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
      } else {
        const weightsManifest = [{
          paths: ["./" + this.weightDataFileName],
          weights: modelArtifacts.weightSpecs
        }];
        const modelJSON = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
        const modelJsonURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelJSON)], { type: "application/json" }));
        const jsonAnchor = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
        jsonAnchor.download = this.modelJsonFileName;
        jsonAnchor.href = modelJsonURL;
        await defer(() => jsonAnchor.dispatchEvent(new MouseEvent("click")));
        if (modelArtifacts.weightData != null) {
          const weightDataAnchor = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
          weightDataAnchor.download = this.weightDataFileName;
          weightDataAnchor.href = weightsURL;
          await defer(() => weightDataAnchor.dispatchEvent(new MouseEvent("click")));
        }
        return { modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts) };
      }
    }
  };
  BrowserDownloads.URL_SCHEME = "downloads://";
  var BrowserFiles = class {
    constructor(files) {
      if (files == null || files.length < 1) {
        throw new Error(`When calling browserFiles, at least 1 file is required, but received ${files}`);
      }
      this.jsonFile = files[0];
      this.weightsFiles = files.slice(1);
    }
    async load() {
      return new Promise((resolve, reject) => {
        const jsonReader = new FileReader();
        jsonReader.onload = (event) => {
          const modelJSON = JSON.parse(event.target.result);
          const modelTopology = modelJSON.modelTopology;
          if (modelTopology == null) {
            reject(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
            return;
          }
          const weightsManifest = modelJSON.weightsManifest;
          if (weightsManifest == null) {
            reject(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
            return;
          }
          if (this.weightsFiles.length === 0) {
            resolve({ modelTopology });
            return;
          }
          const modelArtifactsPromise = getModelArtifactsForJSON(modelJSON, (weightsManifest2) => this.loadWeights(weightsManifest2));
          resolve(modelArtifactsPromise);
        };
        jsonReader.onerror = (error) => reject(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`);
        jsonReader.readAsText(this.jsonFile);
      });
    }
    loadWeights(weightsManifest) {
      const weightSpecs = [];
      const paths = [];
      for (const entry of weightsManifest) {
        weightSpecs.push(...entry.weights);
        paths.push(...entry.paths);
      }
      const pathToFile = this.checkManifestAndWeightFiles(weightsManifest);
      const promises = paths.map((path) => this.loadWeightsFile(path, pathToFile[path]));
      return Promise.all(promises).then((buffers) => [weightSpecs, concatenateArrayBuffers(buffers)]);
    }
    loadWeightsFile(path, file) {
      return new Promise((resolve, reject) => {
        const weightFileReader = new FileReader();
        weightFileReader.onload = (event) => {
          const weightData = event.target.result;
          resolve(weightData);
        };
        weightFileReader.onerror = (error) => reject(`Failed to weights data from file of path '${path}'.`);
        weightFileReader.readAsArrayBuffer(file);
      });
    }
    /**
     * Check the compatibility between weights manifest and weight files.
     */
    checkManifestAndWeightFiles(manifest) {
      const basenames = [];
      const fileNames = this.weightsFiles.map((file) => basename(file.name));
      const pathToFile = {};
      for (const group of manifest) {
        group.paths.forEach((path) => {
          const pathBasename = basename(path);
          if (basenames.indexOf(pathBasename) !== -1) {
            throw new Error(`Duplicate file basename found in weights manifest: '${pathBasename}'`);
          }
          basenames.push(pathBasename);
          if (fileNames.indexOf(pathBasename) === -1) {
            throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);
          } else {
            pathToFile[path] = this.weightsFiles[fileNames.indexOf(pathBasename)];
          }
        });
      }
      if (basenames.length !== this.weightsFiles.length) {
        throw new Error(`Mismatch in the number of files in weights manifest (${basenames.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
      }
      return pathToFile;
    }
  };
  var browserDownloadsRouter = (url) => {
    if (!env().getBool("IS_BROWSER")) {
      return null;
    } else {
      if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {
        return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
      } else {
        return null;
      }
    }
  };
  IORouterRegistry.registerSaveRouter(browserDownloadsRouter);
  function browserDownloads(fileNamePrefix = "model") {
    return new BrowserDownloads(fileNamePrefix);
  }
  function browserFiles(files) {
    return new BrowserFiles(files);
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/progress.js
  function monitorPromisesProgress(promises, onProgress, startFraction, endFraction) {
    checkPromises(promises);
    startFraction = startFraction == null ? 0 : startFraction;
    endFraction = endFraction == null ? 1 : endFraction;
    checkFraction(startFraction, endFraction);
    let resolvedPromise = 0;
    const registerMonitor = (promise) => {
      promise.then((value) => {
        const fraction = startFraction + ++resolvedPromise / promises.length * (endFraction - startFraction);
        onProgress(fraction);
        return value;
      });
      return promise;
    };
    function checkPromises(promises2) {
      assert2(promises2 != null && Array.isArray(promises2) && promises2.length > 0, () => "promises must be a none empty array");
    }
    function checkFraction(startFraction2, endFraction2) {
      assert2(startFraction2 >= 0 && startFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${startFraction2}`);
      assert2(endFraction2 >= 0 && endFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${endFraction2}`);
      assert2(endFraction2 >= startFraction2, () => `startFraction must be no more than endFraction, but got startFraction ${startFraction2} and endFraction ${endFraction2}`);
    }
    return Promise.all(promises.map(registerMonitor));
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/weights_loader.js
  async function loadWeightsAsArrayBuffer(fetchURLs, loadOptions) {
    if (loadOptions == null) {
      loadOptions = {};
    }
    const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch : loadOptions.fetchFunc;
    const requests = fetchURLs.map((fetchURL) => fetchFunc(fetchURL, loadOptions.requestInit, { isBinary: true }));
    const fetchStartFraction = 0;
    const fetchEndFraction = 0.5;
    const responses = loadOptions.onProgress == null ? await Promise.all(requests) : await monitorPromisesProgress(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction);
    const bufferPromises = responses.map((response) => response.arrayBuffer());
    const bufferStartFraction = 0.5;
    const bufferEndFraction = 1;
    const buffers = loadOptions.onProgress == null ? await Promise.all(bufferPromises) : await monitorPromisesProgress(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction);
    return buffers;
  }
  async function loadWeights(manifest, filePathPrefix = "", weightNames, requestInit) {
    const fetchWeights = (fetchUrls) => loadWeightsAsArrayBuffer(fetchUrls, { requestInit });
    const loadWeights2 = weightsLoaderFactory(fetchWeights);
    return loadWeights2(manifest, filePathPrefix, weightNames);
  }
  function weightsLoaderFactory(fetchWeightsFunction) {
    return async (manifest, filePathPrefix = "", weightNames) => {
      const groupIndicesToFetchMap = manifest.map(() => false);
      const groupWeightsToFetch = {};
      const weightsFound = weightNames != null ? weightNames.map(() => false) : [];
      const allManifestWeightNames = [];
      manifest.forEach((manifestGroupConfig, groupIndex) => {
        let groupOffset = 0;
        manifestGroupConfig.weights.forEach((weightsEntry) => {
          const rawDtype = "quantization" in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;
          const weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] * sizeFromShape(weightsEntry.shape);
          const enqueueWeightsForFetchingFn = () => {
            groupIndicesToFetchMap[groupIndex] = true;
            if (groupWeightsToFetch[groupIndex] == null) {
              groupWeightsToFetch[groupIndex] = [];
            }
            groupWeightsToFetch[groupIndex].push({
              manifestEntry: weightsEntry,
              groupOffset,
              sizeBytes: weightsBytes
            });
          };
          if (weightNames != null) {
            weightNames.forEach((weightName, weightIndex) => {
              if (weightName === weightsEntry.name) {
                enqueueWeightsForFetchingFn();
                weightsFound[weightIndex] = true;
              }
            });
          } else {
            enqueueWeightsForFetchingFn();
          }
          allManifestWeightNames.push(weightsEntry.name);
          groupOffset += weightsBytes;
        });
      });
      if (!weightsFound.every((found) => found)) {
        const weightsNotFound = weightNames.filter((_3, i2) => !weightsFound[i2]);
        throw new Error(`Could not find weights in manifest with names: ${weightsNotFound.join(", ")}. 
Manifest JSON has weights with names: ${allManifestWeightNames.join(", ")}.`);
      }
      const groupIndicesToFetch = groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i2) => {
        if (shouldFetch) {
          accumulator.push(i2);
        }
        return accumulator;
      }, []);
      const fetchUrls = [];
      groupIndicesToFetch.forEach((i2) => {
        manifest[i2].paths.forEach((filepath) => {
          const fetchUrl = filePathPrefix + (!filePathPrefix.endsWith("/") ? "/" : "") + filepath;
          fetchUrls.push(fetchUrl);
        });
      });
      const buffers = await fetchWeightsFunction(fetchUrls);
      const weightsTensorMap = {};
      let bufferIndexOffset = 0;
      groupIndicesToFetch.forEach((i2) => {
        const numBuffers = manifest[i2].paths.length;
        let groupBytes = 0;
        for (let i3 = 0; i3 < numBuffers; i3++) {
          groupBytes += buffers[bufferIndexOffset + i3].byteLength;
        }
        const groupBuffer = new ArrayBuffer(groupBytes);
        const groupByteBuffer = new Uint8Array(groupBuffer);
        let groupBufferOffset = 0;
        for (let i3 = 0; i3 < numBuffers; i3++) {
          const buffer2 = new Uint8Array(buffers[bufferIndexOffset + i3]);
          groupByteBuffer.set(buffer2, groupBufferOffset);
          groupBufferOffset += buffer2.byteLength;
        }
        const weightsEntries = groupWeightsToFetch[i2];
        weightsEntries.forEach((weightsEntry) => {
          const byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
          const nameToTensorMap = decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);
          for (const name in nameToTensorMap) {
            weightsTensorMap[name] = nameToTensorMap[name];
          }
        });
        bufferIndexOffset += numBuffers;
      });
      return weightsTensorMap;
    };
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/http.js
  var OCTET_STREAM_MIME_TYPE = "application/octet-stream";
  var JSON_TYPE = "application/json";
  var HTTPRequest = class {
    constructor(path, loadOptions) {
      this.DEFAULT_METHOD = "POST";
      if (loadOptions == null) {
        loadOptions = {};
      }
      this.weightPathPrefix = loadOptions.weightPathPrefix;
      this.onProgress = loadOptions.onProgress;
      this.weightUrlConverter = loadOptions.weightUrlConverter;
      if (loadOptions.fetchFunc != null) {
        assert2(typeof loadOptions.fetchFunc === "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)");
        this.fetch = loadOptions.fetchFunc;
      } else {
        this.fetch = env().platform.fetch;
      }
      assert2(path != null && path.length > 0, () => "URL path for http must not be null, undefined or empty.");
      if (Array.isArray(path)) {
        assert2(path.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${path.length}).`);
      }
      this.path = path;
      if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) {
        throw new Error("requestInit is expected to have no pre-existing body, but has one.");
      }
      this.requestInit = loadOptions.requestInit || {};
    }
    async save(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
      }
      const init = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
      init.body = new FormData();
      const weightsManifest = [{
        paths: ["./model.weights.bin"],
        weights: modelArtifacts.weightSpecs
      }];
      const modelTopologyAndWeightManifest = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
      init.body.append("model.json", new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: JSON_TYPE }), "model.json");
      if (modelArtifacts.weightData != null) {
        init.body.append("model.weights.bin", new Blob([modelArtifacts.weightData], { type: OCTET_STREAM_MIME_TYPE }), "model.weights.bin");
      }
      const response = await this.fetch(this.path, init);
      if (response.ok) {
        return {
          modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts),
          responses: [response]
        };
      } else {
        throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${response.status}.`);
      }
    }
    /**
     * Load model artifacts via HTTP request(s).
     *
     * See the documentation to `tf.io.http` for details on the saved
     * artifacts.
     *
     * @returns The loaded model artifacts (if loading succeeds).
     */
    async load() {
      const modelConfigRequest = await this.fetch(this.path, this.requestInit);
      if (!modelConfigRequest.ok) {
        throw new Error(`Request to ${this.path} failed with status code ${modelConfigRequest.status}. Please verify this URL points to the model JSON of the model to load.`);
      }
      let modelJSON;
      try {
        modelJSON = await modelConfigRequest.json();
      } catch (e2) {
        let message = `Failed to parse model JSON of response from ${this.path}.`;
        if (this.path.endsWith(".pb")) {
          message += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.";
        } else {
          message += " Please make sure the server is serving valid JSON for this request.";
        }
        throw new Error(message);
      }
      const modelTopology = modelJSON.modelTopology;
      const weightsManifest = modelJSON.weightsManifest;
      if (modelTopology == null && weightsManifest == null) {
        throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
      }
      return getModelArtifactsForJSON(modelJSON, (weightsManifest2) => this.loadWeights(weightsManifest2));
    }
    async loadWeights(weightsManifest) {
      const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
      const [prefix, suffix] = parseUrl(weightPath);
      const pathPrefix = this.weightPathPrefix || prefix;
      const weightSpecs = getWeightSpecs(weightsManifest);
      const fetchURLs = [];
      const urlPromises = [];
      for (const weightsGroup of weightsManifest) {
        for (const path of weightsGroup.paths) {
          if (this.weightUrlConverter != null) {
            urlPromises.push(this.weightUrlConverter(path));
          } else {
            fetchURLs.push(pathPrefix + path + suffix);
          }
        }
      }
      if (this.weightUrlConverter) {
        fetchURLs.push(...await Promise.all(urlPromises));
      }
      const buffers = await loadWeightsAsArrayBuffer(fetchURLs, {
        requestInit: this.requestInit,
        fetchFunc: this.fetch,
        onProgress: this.onProgress
      });
      return [weightSpecs, concatenateArrayBuffers(buffers)];
    }
  };
  HTTPRequest.URL_SCHEME_REGEX = /^https?:\/\//;
  function parseUrl(url) {
    const lastSlash = url.lastIndexOf("/");
    const lastSearchParam = url.lastIndexOf("?");
    const prefix = url.substring(0, lastSlash);
    const suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : "";
    return [prefix + "/", suffix];
  }
  function isHTTPScheme(url) {
    return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;
  }
  var httpRouter = (url, loadOptions) => {
    if (typeof fetch === "undefined" && (loadOptions == null || loadOptions.fetchFunc == null)) {
      return null;
    } else {
      let isHTTP = true;
      if (Array.isArray(url)) {
        isHTTP = url.every((urlItem) => isHTTPScheme(urlItem));
      } else {
        isHTTP = isHTTPScheme(url);
      }
      if (isHTTP) {
        return http(url, loadOptions);
      }
    }
    return null;
  };
  IORouterRegistry.registerSaveRouter(httpRouter);
  IORouterRegistry.registerLoadRouter(httpRouter);
  function http(path, loadOptions) {
    return new HTTPRequest(path, loadOptions);
  }
  function browserHTTPRequest(path, loadOptions) {
    return http(path, loadOptions);
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/passthrough.js
  var PassthroughLoader = class {
    constructor(modelArtifacts) {
      this.modelArtifacts = modelArtifacts;
    }
    load() {
      return this.modelArtifacts;
    }
  };
  var PassthroughSaver = class {
    constructor(saveHandler) {
      this.saveHandler = saveHandler;
    }
    save(modelArtifacts) {
      return this.saveHandler(modelArtifacts);
    }
  };
  var PassthroughAsync = class {
    constructor(handler) {
      if (handler.load) {
        this.load = () => Promise.resolve(handler.load());
      }
      if (handler.save) {
        this.save = (modelArtifacts) => Promise.resolve(handler.save(modelArtifacts));
      }
    }
  };
  function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {
    const args = arguments;
    return new PassthroughAsync(fromMemorySync(...args));
  }
  function fromMemorySync(modelArtifacts, weightSpecs, weightData, trainingConfig) {
    if (arguments.length === 1) {
      const isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;
      if (isModelArtifacts) {
        return new PassthroughLoader(modelArtifacts);
      } else {
        console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
        return new PassthroughLoader({ modelTopology: modelArtifacts });
      }
    } else {
      console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
      return new PassthroughLoader({
        modelTopology: modelArtifacts,
        weightSpecs,
        weightData,
        trainingConfig
      });
    }
  }
  function withSaveHandler(saveHandler) {
    return new PassthroughSaver(saveHandler);
  }
  function withSaveHandlerSync(saveHandler) {
    return new PassthroughSaver(saveHandler);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/browser.js
  var browser_exports = {};
  __export(browser_exports, {
    fromPixels: () => fromPixels,
    fromPixelsAsync: () => fromPixelsAsync,
    toPixels: () => toPixels
  });
  var fromPixels2DContext;
  function fromPixels_(pixels, numChannels = 3) {
    if (numChannels > 4) {
      throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
    }
    if (pixels == null) {
      throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    }
    let isPixelData2 = false;
    let isImageData = false;
    let isVideo = false;
    let isImage = false;
    let isCanvasLike = false;
    let isImageBitmap = false;
    if (pixels.data instanceof Uint8Array) {
      isPixelData2 = true;
    } else if (typeof ImageData !== "undefined" && pixels instanceof ImageData) {
      isImageData = true;
    } else if (typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement) {
      isVideo = true;
    } else if (typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement) {
      isImage = true;
    } else if (pixels.getContext != null) {
      isCanvasLike = true;
    } else if (typeof ImageBitmap !== "undefined" && pixels instanceof ImageBitmap) {
      isImageBitmap = true;
    } else {
      throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${pixels.constructor.name}`);
    }
    const kernel = getKernel(FromPixels, ENGINE.backendName);
    if (kernel != null) {
      const inputs = { pixels };
      const attrs = { numChannels };
      return ENGINE.runKernel(FromPixels, inputs, attrs);
    }
    const [width, height] = isVideo ? [
      pixels.videoWidth,
      pixels.videoHeight
    ] : [pixels.width, pixels.height];
    let vals;
    if (isCanvasLike) {
      vals = // tslint:disable-next-line:no-any
      pixels.getContext("2d").getImageData(0, 0, width, height).data;
    } else if (isImageData || isPixelData2) {
      vals = pixels.data;
    } else if (isImage || isVideo || isImageBitmap) {
      if (fromPixels2DContext == null) {
        if (typeof document === "undefined") {
          if (typeof OffscreenCanvas !== "undefined" && typeof OffscreenCanvasRenderingContext2D !== "undefined") {
            fromPixels2DContext = new OffscreenCanvas(1, 1).getContext("2d");
          } else {
            throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
          }
        } else {
          fromPixels2DContext = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
        }
      }
      fromPixels2DContext.canvas.width = width;
      fromPixels2DContext.canvas.height = height;
      fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
      vals = fromPixels2DContext.getImageData(0, 0, width, height).data;
    }
    let values;
    if (numChannels === 4) {
      values = new Int32Array(vals);
    } else {
      const numPixels = width * height;
      values = new Int32Array(numPixels * numChannels);
      for (let i2 = 0; i2 < numPixels; i2++) {
        for (let channel = 0; channel < numChannels; ++channel) {
          values[i2 * numChannels + channel] = vals[i2 * 4 + channel];
        }
      }
    }
    const outShape = [height, width, numChannels];
    return tensor3d(values, outShape, "int32");
  }
  function isPixelData(pixels) {
    return pixels != null && pixels.data instanceof Uint8Array;
  }
  function isImageBitmapFullySupported() {
    return typeof window !== "undefined" && typeof ImageBitmap !== "undefined" && window.hasOwnProperty("createImageBitmap");
  }
  function isNonEmptyPixels(pixels) {
    return pixels != null && pixels.width !== 0 && pixels.height !== 0;
  }
  function canWrapPixelsToImageBitmap(pixels) {
    return isImageBitmapFullySupported() && !(pixels instanceof ImageBitmap) && isNonEmptyPixels(pixels) && !isPixelData(pixels);
  }
  async function fromPixelsAsync(pixels, numChannels = 3) {
    let inputs = null;
    if (env().getBool("WRAP_TO_IMAGEBITMAP") && canWrapPixelsToImageBitmap(pixels)) {
      let imageBitmap;
      try {
        imageBitmap = await createImageBitmap(pixels, { premultiplyAlpha: "none" });
      } catch (e2) {
        imageBitmap = null;
      }
      if (imageBitmap != null && imageBitmap.width === pixels.width && imageBitmap.height === pixels.height) {
        inputs = imageBitmap;
      } else {
        inputs = pixels;
      }
    } else {
      inputs = pixels;
    }
    return fromPixels_(inputs, numChannels);
  }
  async function toPixels(img, canvas) {
    let $img = convertToTensor(img, "img", "toPixels");
    if (!(img instanceof Tensor)) {
      const originalImgTensor = $img;
      $img = cast(originalImgTensor, "int32");
      originalImgTensor.dispose();
    }
    if ($img.rank !== 2 && $img.rank !== 3) {
      throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${$img.rank}.`);
    }
    const [height, width] = $img.shape.slice(0, 2);
    const depth = $img.rank === 2 ? 1 : $img.shape[2];
    if (depth > 4 || depth === 2) {
      throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${depth}`);
    }
    if ($img.dtype !== "float32" && $img.dtype !== "int32") {
      throw new Error(`Unsupported type for toPixels: ${$img.dtype}. Please use float32 or int32 tensors.`);
    }
    const data = await $img.data();
    const multiplier = $img.dtype === "float32" ? 255 : 1;
    const bytes = new Uint8ClampedArray(width * height * 4);
    for (let i2 = 0; i2 < height * width; ++i2) {
      const rgba = [0, 0, 0, 255];
      for (let d2 = 0; d2 < depth; d2++) {
        const value = data[i2 * depth + d2];
        if ($img.dtype === "float32") {
          if (value < 0 || value > 1) {
            throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${value}.`);
          }
        } else if ($img.dtype === "int32") {
          if (value < 0 || value > 255) {
            throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${value}.`);
          }
        }
        if (depth === 1) {
          rgba[0] = value * multiplier;
          rgba[1] = value * multiplier;
          rgba[2] = value * multiplier;
        } else {
          rgba[d2] = value * multiplier;
        }
      }
      const j3 = i2 * 4;
      bytes[j3 + 0] = Math.round(rgba[0]);
      bytes[j3 + 1] = Math.round(rgba[1]);
      bytes[j3 + 2] = Math.round(rgba[2]);
      bytes[j3 + 3] = Math.round(rgba[3]);
    }
    if (canvas != null) {
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      const imageData = new ImageData(bytes, width, height);
      ctx.putImageData(imageData, 0, 0);
    }
    if ($img !== img) {
      $img.dispose();
    }
    return bytes;
  }
  var fromPixels = /* @__PURE__ */ op({ fromPixels_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/gather_nd_util.js
  function prepareAndValidate(tensor2, indices) {
    const tensorRank = tensor2.shape.length;
    const indicesRank = indices.shape.length;
    if (tensorRank < 1) {
      throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${tensorRank}.`);
    }
    if (indicesRank < 1) {
      throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${indicesRank}.`);
    }
    if (indices.dtype !== "int32") {
      throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${indices.dtype}.`);
    }
    if (indices.shape[indicesRank - 1] > tensorRank) {
      throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);
    }
    if (sizeFromShape(tensor2.shape) === 0) {
      throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${tensor2.shape}.`);
    }
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    let nResult = 1;
    for (let i2 = 0; i2 < indicesShape.length - 1; ++i2) {
      nResult *= indicesShape[i2];
    }
    const inputShape = tensor2.shape;
    const resultShape = indicesShape.slice();
    resultShape.pop();
    let sliceSize = 1;
    for (let i2 = sliceRank; i2 < tensorRank; ++i2) {
      sliceSize *= inputShape[i2];
      resultShape.push(inputShape[i2]);
    }
    const strides = [
      ...computeStrides(tensor2.shape).map((stride) => stride / sliceSize),
      1
    ].slice(0, sliceRank);
    return [resultShape, nResult, sliceSize, strides];
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice_util.js
  var slice_util_exports = {};
  __export(slice_util_exports, {
    assertParamsValid: () => assertParamsValid,
    computeFlatOffset: () => computeFlatOffset,
    computeOutShape: () => computeOutShape,
    getNormalizedAxes: () => getNormalizedAxes,
    isSliceContinous: () => isSliceContinous,
    maskToAxes: () => maskToAxes,
    parseSliceParams: () => parseSliceParams,
    sliceInfo: () => sliceInfo,
    startForAxis: () => startForAxis,
    startIndicesWithElidedDims: () => startIndicesWithElidedDims,
    stopForAxis: () => stopForAxis,
    stopIndicesWithElidedDims: () => stopIndicesWithElidedDims,
    stridesForAxis: () => stridesForAxis,
    stridesWithElidedDims: () => stridesWithElidedDims
  });
  var NEW_AXIS = -2;
  var SHRINK_AXIS = -1;
  function assertParamsValid(input2, begin, size) {
    const inputRank = input2.shape.length;
    assert2(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must match the rank of the array (${inputRank}).`);
    assert2(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must match the rank of the array (${inputRank}).`);
    for (let i2 = 0; i2 < inputRank; ++i2) {
      assert2(begin[i2] + size[i2] <= input2.shape[i2], () => `Error in slice${inputRank}D: begin[${i2}] + size[${i2}] (${begin[i2] + size[i2]}) would overflow input.shape[${i2}] (${input2.shape[i2]})`);
    }
  }
  function maskToAxes(mask) {
    const axes = [];
    let axis = 0;
    while (mask > 0) {
      if (mask & 1) {
        axes.push(axis);
      }
      mask /= 2;
      axis++;
    }
    return axes;
  }
  function computeOutShape(begin, end, strides) {
    const size = [];
    for (let axis = 0; axis < begin.length; axis++) {
      size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
    }
    return size;
  }
  function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
    const newStrides = [...strides];
    for (let i2 = newStrides.length; i2 < inputShape.length; i2++) {
      newStrides.push(1);
    }
    for (let i2 = 0; i2 < numElidedAxes; i2++) {
      if (i2 === 0) {
        newStrides[ellipsisInsertionIndex] = 1;
      } else {
        newStrides.splice(
          ellipsisInsertionIndex,
          0,
          1
          /* element to add */
        );
        newStrides.pop();
      }
    }
    return newStrides;
  }
  function unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
    if (normalizedAxis <= ellipsisInsertionIndex) {
      return normalizedAxis;
    }
    return normalizedAxis - (numElidedAxes - 1);
  }
  function getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {
    const elidedAxes = [];
    for (let i2 = 0; i2 < numElidedAxes; i2++) {
      elidedAxes.push(ellipsisInsertionIndex + i2);
    }
    return elidedAxes;
  }
  function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
    const inputRank = inputShape.length;
    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
    if (ellipsisAxes.length && numInterpolatedAxes > 0) {
      const fullIndex = ellipsisAxes[0];
      const numElidedAxes = numInterpolatedAxes + 1;
      normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);
      normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);
      normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);
    } else {
      for (let axis = 0; axis < inputRank; axis++) {
        normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);
        normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);
        normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);
      }
    }
    return {
      begin: normalizedBegin,
      end: normalizedEnd,
      strides: normalizedStrides
    };
  }
  function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
    const newIndices = [...inputShape];
    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
    for (let axis = 0; axis < newIndices.length; axis++) {
      if (elidedAxes.indexOf(axis) > -1) {
        newIndices[axis] = 0;
      } else {
        const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
        let originalValue = originalBegin[originalAxis];
        if (beginMask & 1 << originalAxis) {
          originalValue = 0;
        }
        newIndices[axis] = originalValue;
      }
    }
    return newIndices;
  }
  function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
    const newIndices = [...inputShape];
    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
    for (let axis = 0; axis < newIndices.length; axis++) {
      if (elidedAxes.indexOf(axis) > -1) {
        newIndices[axis] = Number.MAX_SAFE_INTEGER;
      } else {
        const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
        let originalValue = originalEnd[originalAxis];
        if (endMask & 1 << originalAxis) {
          originalValue = Number.MAX_SAFE_INTEGER;
        }
        newIndices[axis] = originalValue;
      }
    }
    for (let i2 = 0; i2 < newIndices.length; i2++) {
      const axisSize = inputShape[i2];
      if (newIndices[i2] < 0) {
        newIndices[i2] += axisSize;
      }
      newIndices[i2] = clamp(0, newIndices[i2], inputShape[i2]);
    }
    return newIndices;
  }
  function stridesForAxis(strides, axis, ellipsisMask) {
    let stride = strides[axis];
    if (ellipsisMask & 1 << axis || stride == null) {
      stride = 1;
    }
    return stride;
  }
  function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
    let start = startIndices[axis];
    const stride = strides[axis] || 1;
    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
      if (stride > 0) {
        start = Number.MIN_SAFE_INTEGER;
      } else {
        start = Number.MAX_SAFE_INTEGER;
      }
    }
    const axisSize = inputShape[axis];
    if (start < 0) {
      start += axisSize;
    }
    start = clamp(0, start, axisSize - 1);
    return start;
  }
  function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
    let stop = stopIndices[axis];
    const stride = strides[axis] || 1;
    if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {
      if (stride > 0) {
        stop = Number.MAX_SAFE_INTEGER;
      } else {
        stop = Number.MIN_SAFE_INTEGER;
      }
    }
    const axisSize = inputShape[axis];
    if (stop < 0) {
      stop += axisSize;
    }
    if (stride > 0) {
      stop = clamp(0, stop, axisSize);
    } else {
      stop = clamp(-1, stop, axisSize - 1);
    }
    return stop;
  }
  function isSliceContinous(shape, begin, size) {
    let firstNonOneAxis = size.length;
    for (let i2 = 0; i2 < size.length; i2++) {
      if (size[i2] > 1) {
        firstNonOneAxis = i2;
        break;
      }
    }
    for (let i2 = firstNonOneAxis + 1; i2 < size.length; i2++) {
      if (begin[i2] > 0 || size[i2] !== shape[i2]) {
        return false;
      }
    }
    return true;
  }
  function computeFlatOffset(begin, strides) {
    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
    for (let i2 = 0; i2 < begin.length - 1; i2++) {
      flatOffset += begin[i2] * strides[i2];
    }
    return flatOffset;
  }
  function parseSliceParams(x2, begin, size) {
    let begin_;
    const xRank = x2.shape.length;
    if (typeof begin === "number") {
      begin_ = [begin, ...new Array(xRank - 1).fill(0)];
    } else if (begin.length < xRank) {
      begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
    } else {
      begin_ = begin.slice();
    }
    begin_.forEach((d2) => {
      assert2(d2 !== -1, () => "slice() does not support negative begin indexing.");
    });
    let size_;
    if (size == null) {
      size_ = new Array(xRank).fill(-1);
    } else if (typeof size === "number") {
      size_ = [size, ...new Array(xRank - 1).fill(-1)];
    } else if (size.length < xRank) {
      size_ = size.concat(new Array(xRank - size.length).fill(-1));
    } else {
      size_ = size;
    }
    size_ = size_.map((d2, i2) => {
      if (d2 >= 0) {
        return d2;
      } else {
        assert2(d2 === -1, () => `Negative size values should be exactly -1 but got ${d2} for the slice() size at index ${i2}.`);
        return x2.shape[i2] - begin_[i2];
      }
    });
    return [begin_, size_];
  }
  function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
    let stridesNonNull;
    if (strides == null) {
      stridesNonNull = new Array(begin.length);
      stridesNonNull.fill(1);
    } else {
      stridesNonNull = strides;
    }
    if (ellipsisMask != null && (ellipsisMask & ellipsisMask - 1) !== 0) {
      throw new Error("Multiple ellipses in slice is not allowed.");
    }
    let ellipsisSeen = false;
    const sparseSpec = {
      dims: stridesNonNull.length,
      numAddAxisAfterEllipsis: 0,
      begin: begin.slice(),
      end: end.slice(),
      strides: stridesNonNull.slice(),
      beginMask,
      endMask,
      ellipsisMask,
      newAxisMask,
      shrinkAxisMask
    };
    for (let i2 = 0; i2 < sparseSpec.dims; i2++) {
      if (ellipsisSeen && (1 << i2 & newAxisMask) !== 0) {
        sparseSpec.numAddAxisAfterEllipsis++;
      }
      if (1 << i2 & ellipsisMask) {
        ellipsisSeen = true;
      }
    }
    if (!ellipsisSeen) {
      sparseSpec.ellipsisMask |= 1 << sparseSpec.dims;
      sparseSpec.dims++;
    }
    const denseSpec = {
      dims: xShape.length,
      beginMask: 0,
      endMask: 0,
      beginValid: false,
      endValid: false
    };
    buildDenseSpec(sparseSpec, denseSpec);
    let isIdentity = true;
    let sliceDim0 = true;
    let isSimpleSlice = true;
    const processingShape = [];
    const finalShape = [];
    for (let i2 = 0; i2 < xShape.length; ++i2) {
      if (denseSpec.strides[i2] === 0) {
        throw Error(`strides[${i2}] must be non-zero`);
      }
      const shrinkI = !!(denseSpec.shrinkAxisMask & 1 << i2);
      const dimI = xShape[i2];
      if (dimI === -1) {
        processingShape.push(shrinkI ? 1 : -1);
        continue;
      }
      const masks = [denseSpec.beginMask & 1 << i2, denseSpec.endMask & 1 << i2];
      const validRange = [
        denseSpec.strides[i2] > 0 ? 0 : -1,
        denseSpec.strides[i2] > 0 ? dimI : dimI - 1
      ];
      if (shrinkI && denseSpec.strides[i2] <= 0) {
        throw Error("only stride 1 allowed on non-range indexing.");
      }
      isSimpleSlice = isSimpleSlice && denseSpec.strides[i2] === 1;
      const beginAndEndMasked = !!(denseSpec.beginMask & 1 << i2 && denseSpec.endMask & 1 << i2);
      if (denseSpec.beginValid && denseSpec.endValid) {
        if (shrinkI) {
          const xFwd = denseSpec.begin[i2] < 0 ? dimI + denseSpec.begin[i2] : denseSpec.begin[i2];
          denseSpec.begin[i2] = xFwd;
          denseSpec.end[i2] = denseSpec.begin[i2] + 1;
          if (xFwd < 0 || xFwd >= dimI) {
            throw Error(`slice index ${denseSpec.begin[i2]} of dimension ${i2} out of bounds.`);
          }
        } else {
          denseSpec.begin[i2] = canonical(denseSpec.begin[i2], 0, denseSpec.strides[i2], dimI, masks, validRange);
          denseSpec.end[i2] = canonical(denseSpec.end[i2], 1, denseSpec.strides[i2], dimI, masks, validRange);
        }
        const takeAllInDimension = denseSpec.strides[i2] === 1 && denseSpec.begin[i2] === 0 && denseSpec.end[i2] === dimI;
        isIdentity = isIdentity && takeAllInDimension;
        sliceDim0 = sliceDim0 && (i2 === 0 && denseSpec.strides[i2] === 1 || takeAllInDimension);
      } else {
        isIdentity = isIdentity && (denseSpec.strides[i2] === 1 && beginAndEndMasked);
        sliceDim0 = sliceDim0 && (i2 === 0 && denseSpec.strides[i2] === 1 || beginAndEndMasked);
      }
      let intervalLength;
      let knownInterval = false;
      if (denseSpec.beginValid && denseSpec.endValid) {
        intervalLength = denseSpec.end[i2] - denseSpec.begin[i2];
        knownInterval = true;
      } else if (shrinkI) {
        intervalLength = 1;
        knownInterval = true;
      } else if (beginAndEndMasked) {
        if (dimI >= 0) {
          if (denseSpec.strides[i2] < 0) {
            intervalLength = -dimI;
          } else {
            intervalLength = dimI;
          }
          knownInterval = true;
        }
      }
      if (knownInterval) {
        let sizeI;
        if (intervalLength === 0 || intervalLength < 0 !== denseSpec.strides[i2] < 0) {
          sizeI = 0;
        } else {
          sizeI = Math.trunc(intervalLength / denseSpec.strides[i2]) + (intervalLength % denseSpec.strides[i2] !== 0 ? 1 : 0);
        }
        processingShape.push(sizeI);
      } else {
        processingShape.push(-1);
      }
    }
    for (let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {
      const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];
      if (gatherIndex >= 0) {
        finalShape.push(processingShape[gatherIndex]);
      } else if (gatherIndex === NEW_AXIS) {
        finalShape.push(1);
      }
    }
    const finalShapeSparse = finalShape.filter((dim, i2) => denseSpec.finalShapeGatherIndices[i2] !== NEW_AXIS);
    return {
      finalShapeSparse,
      finalShape,
      isIdentity,
      sliceDim0,
      isSimpleSlice,
      begin: denseSpec.begin,
      end: denseSpec.end,
      strides: denseSpec.strides
    };
  }
  function buildDenseSpec(sparse2, dense2) {
    dense2.beginMask = 0;
    dense2.endMask = 0;
    dense2.shrinkAxisMask = 0;
    let fullIndex = 0;
    dense2.beginValid = sparse2.begin != null;
    dense2.endValid = sparse2.end != null;
    dense2.begin = new Array(dense2.dims);
    dense2.end = new Array(dense2.dims);
    dense2.strides = new Array(dense2.dims);
    dense2.finalShapeGatherIndices = [];
    dense2.finalShapeGatherIndicesSparse = [];
    dense2.inputShapeGatherIndicesSparse = new Array(dense2.dims);
    for (let i2 = 0; i2 < sparse2.dims; i2++) {
      if (1 << i2 & sparse2.ellipsisMask) {
        const nextIndex = Math.min(dense2.dims - (sparse2.dims - i2) + 1 + sparse2.numAddAxisAfterEllipsis, dense2.dims);
        for (; fullIndex < nextIndex; fullIndex++) {
          dense2.begin[fullIndex] = 0;
          dense2.end[fullIndex] = 0;
          dense2.strides[fullIndex] = 1;
          dense2.beginMask |= 1 << fullIndex;
          dense2.endMask |= 1 << fullIndex;
          dense2.finalShapeGatherIndices.push(fullIndex);
          dense2.finalShapeGatherIndicesSparse.push(-1);
          dense2.inputShapeGatherIndicesSparse[fullIndex] = i2;
        }
      } else if (1 << i2 & sparse2.newAxisMask) {
        dense2.finalShapeGatherIndices.push(NEW_AXIS);
        dense2.finalShapeGatherIndicesSparse.push(-1);
      } else {
        if (fullIndex === dense2.begin.length) {
          throw Error(`Index out of range using input dim ${fullIndex}; input has only ${dense2.dims} dims, ${dense2.begin.length}.`);
        }
        if (sparse2.begin != null) {
          dense2.begin[fullIndex] = sparse2.begin[i2];
        }
        if (sparse2.end != null) {
          dense2.end[fullIndex] = sparse2.end[i2];
        }
        dense2.strides[fullIndex] = sparse2.strides[i2];
        if (sparse2.beginMask & 1 << i2) {
          dense2.beginMask |= 1 << fullIndex;
        }
        if (sparse2.endMask & 1 << i2) {
          dense2.endMask |= 1 << fullIndex;
        }
        if (sparse2.shrinkAxisMask & 1 << i2) {
          dense2.finalShapeGatherIndices.push(SHRINK_AXIS);
          dense2.finalShapeGatherIndicesSparse.push(-1);
          dense2.shrinkAxisMask |= 1 << fullIndex;
        } else {
          dense2.finalShapeGatherIndices.push(fullIndex);
          dense2.finalShapeGatherIndicesSparse.push(i2);
        }
        dense2.inputShapeGatherIndicesSparse[fullIndex] = i2;
        fullIndex++;
      }
    }
  }
  function canonical(x2, c2, strideI, dimI, masks, validRange) {
    if (masks[c2]) {
      return strideI > 0 ? validRange[c2] : validRange[c2 + 1 & 1];
    } else {
      const xFwd = x2 < 0 ? dimI + x2 : x2;
      return xFwd < validRange[0] ? validRange[0] : xFwd > validRange[1] ? validRange[1] : xFwd;
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/browser_util.js
  var delayCallback = (() => {
    if (typeof requestAnimationFrame !== "undefined") {
      return requestAnimationFrame;
    } else if (typeof setImmediate !== "undefined") {
      return setImmediate;
    }
    return (f2) => f2();
  })();
  function nextFrame() {
    return new Promise((resolve) => delayCallback(() => resolve()));
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/backend_util.js
  var backend_util_exports = {};
  __export(backend_util_exports, {
    ERF_A1: () => ERF_A1,
    ERF_A2: () => ERF_A2,
    ERF_A3: () => ERF_A3,
    ERF_A4: () => ERF_A4,
    ERF_A5: () => ERF_A5,
    ERF_P: () => ERF_P,
    PARALLELIZE_THRESHOLD: () => PARALLELIZE_THRESHOLD,
    RowPartitionType: () => RowPartitionType,
    SELU_SCALE: () => SELU_SCALE,
    SELU_SCALEALPHA: () => SELU_SCALEALPHA,
    applyActivation: () => applyActivation,
    assertAndGetBroadcastShape: () => assertAndGetBroadcastShape,
    assertAxesAreInnerMostDims: () => assertAxesAreInnerMostDims,
    assertParamsConsistent: () => assertParamsConsistent,
    assignToTypedArray: () => assignToTypedArray,
    axesAreInnerMostDims: () => axesAreInnerMostDims,
    calculateShapes: () => calculateShapes,
    checkEinsumDimSizes: () => checkEinsumDimSizes,
    checkPadOnDimRoundingMode: () => checkPadOnDimRoundingMode,
    combineLocations: () => combineLocations,
    combineRaggedTensorToTensorShapes: () => combineRaggedTensorToTensorShapes,
    complexWithEvenIndex: () => complexWithEvenIndex,
    complexWithOddIndex: () => complexWithOddIndex,
    computeConv2DInfo: () => computeConv2DInfo,
    computeConv3DInfo: () => computeConv3DInfo,
    computeDefaultPad: () => computeDefaultPad,
    computeDilation2DInfo: () => computeDilation2DInfo,
    computeOptimalWindowSize: () => computeOptimalWindowSize,
    computeOutAndReduceShapes: () => computeOutAndReduceShapes,
    computeOutShape: () => computeOutShape2,
    computePool2DInfo: () => computePool2DInfo,
    computePool3DInfo: () => computePool3DInfo,
    convertConv2DDataFormat: () => convertConv2DDataFormat,
    decodeEinsumEquation: () => decodeEinsumEquation,
    eitherStridesOrDilationsAreOne: () => eitherStridesOrDilationsAreOne,
    expandShapeToKeepDim: () => expandShapeToKeepDim,
    exponent: () => exponent,
    exponents: () => exponents,
    fromStringArrayToUint8: () => fromStringArrayToUint8,
    fromUint8ToStringArray: () => fromUint8ToStringArray,
    getAxesPermutation: () => getAxesPermutation,
    getBroadcastDims: () => getBroadcastDims,
    getComplexWithIndex: () => getComplexWithIndex,
    getEinsumComputePath: () => getEinsumComputePath,
    getEinsumPermutation: () => getEinsumPermutation,
    getFusedBiasGradient: () => getFusedBiasGradient,
    getFusedDyActivation: () => getFusedDyActivation,
    getImageCenter: () => getImageCenter,
    getInnerMostAxes: () => getInnerMostAxes,
    getPermuted: () => getPermuted,
    getRaggedRank: () => getRaggedRank,
    getReductionAxes: () => getReductionAxes,
    getReshaped: () => getReshaped,
    getReshapedPermuted: () => getReshapedPermuted,
    getRowPartitionTypesHelper: () => getRowPartitionTypesHelper,
    getSliceBeginCoords: () => getSliceBeginCoords,
    getSliceSize: () => getSliceSize,
    getSparseFillEmptyRowsIndicesDenseShapeMismatch: () => getSparseFillEmptyRowsIndicesDenseShapeMismatch,
    getSparseFillEmptyRowsNegativeIndexErrorMessage: () => getSparseFillEmptyRowsNegativeIndexErrorMessage,
    getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: () => getSparseFillEmptyRowsOutOfRangeIndexErrorMessage,
    getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: () => getSparseReshapeEmptyTensorZeroOutputDimErrorMessage,
    getSparseReshapeInputOutputMismatchErrorMessage: () => getSparseReshapeInputOutputMismatchErrorMessage,
    getSparseReshapeInputOutputMultipleErrorMessage: () => getSparseReshapeInputOutputMultipleErrorMessage,
    getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: () => getSparseReshapeMultipleNegativeOneOutputDimErrorMessage,
    getSparseReshapeNegativeOutputDimErrorMessage: () => getSparseReshapeNegativeOutputDimErrorMessage,
    getSparseSegmentReductionIndicesOutOfRangeErrorMessage: () => getSparseSegmentReductionIndicesOutOfRangeErrorMessage,
    getSparseSegmentReductionNegativeSegmentIdsErrorMessage: () => getSparseSegmentReductionNegativeSegmentIdsErrorMessage,
    getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: () => getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage,
    getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: () => getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage,
    getUndoAxesPermutation: () => getUndoAxesPermutation,
    isIdentityPermutation: () => isIdentityPermutation,
    log: () => log,
    mergeRealAndImagArrays: () => mergeRealAndImagArrays,
    prepareAndValidate: () => prepareAndValidate,
    prepareSplitSize: () => prepareSplitSize,
    segment_util: () => segment_util_exports,
    shouldFuse: () => shouldFuse,
    slice_util: () => slice_util_exports,
    splitRealAndImagArrays: () => splitRealAndImagArrays,
    stridesOrDilationsArePositive: () => stridesOrDilationsArePositive,
    tupleValuesAreOne: () => tupleValuesAreOne,
    upcastType: () => upcastType,
    validateDefaultValueShape: () => validateDefaultValueShape,
    validateInput: () => validateInput,
    validateUpdateShape: () => validateUpdateShape,
    warn: () => warn
  });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat_util.js
  function assertParamsConsistent(shapes, axis) {
    const rank = shapes[0].length;
    shapes.forEach((shape, i2) => {
      assert2(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i2}] must be the same as the rank of the rest (${rank})`);
    });
    assert2(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);
    const firstShape = shapes[0];
    shapes.forEach((shape, i2) => {
      for (let r2 = 0; r2 < rank; r2++) {
        assert2(r2 === axis || shape[r2] === firstShape[r2], () => `Error in concat${rank}D: Shape of tensors[${i2}] (${shape}) does not match the shape of the rest (${firstShape}) along the non-concatenated axis ${i2}.`);
      }
    });
  }
  function computeOutShape2(shapes, axis) {
    const outputShape = shapes[0].slice();
    for (let i2 = 1; i2 < shapes.length; i2++) {
      outputShape[axis] += shapes[i2][axis];
    }
    return outputShape;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/ragged_to_dense_util.js
  var RowPartitionType;
  (function(RowPartitionType3) {
    RowPartitionType3[RowPartitionType3["FIRST_DIM_SIZE"] = 0] = "FIRST_DIM_SIZE";
    RowPartitionType3[RowPartitionType3["VALUE_ROWIDS"] = 1] = "VALUE_ROWIDS";
    RowPartitionType3[RowPartitionType3["ROW_LENGTHS"] = 2] = "ROW_LENGTHS";
    RowPartitionType3[RowPartitionType3["ROW_SPLITS"] = 3] = "ROW_SPLITS";
    RowPartitionType3[RowPartitionType3["ROW_LIMITS"] = 4] = "ROW_LIMITS";
    RowPartitionType3[RowPartitionType3["ROW_STARTS"] = 5] = "ROW_STARTS";
  })(RowPartitionType || (RowPartitionType = {}));
  function combineRaggedTensorToTensorShapes(raggedRank, shape, valueShape) {
    let outputShape = new Array();
    if (valueShape == null && shape == null) {
      return outputShape;
    }
    if (shape == null) {
      while (outputShape.length < raggedRank + valueShape.length) {
        outputShape.push(-1);
      }
    } else {
      outputShape = shape.slice();
    }
    if (valueShape == null) {
      return outputShape;
    }
    if (raggedRank + valueShape.length !== outputShape.length) {
      throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.rank = ${raggedRank + valueShape.length}, but shape.rank = ${outputShape.length}`);
    }
    for (let i2 = 1; i2 < valueShape.length; ++i2) {
      const valueDim = valueShape[i2];
      const outputShapeDimIndex = outputShape[outputShape.length - valueShape.length + i2];
      const outputShapeDim = outputShape[outputShapeDimIndex];
      if (valueDim >= 0) {
        if (outputShapeDim >= 0) {
          if (outputShapeDim !== valueDim) {
            throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.shape[${i2 + raggedRank}] = ${valueDim} but shape[${i2 + raggedRank}] = ${outputShapeDim}`);
          }
        } else {
          outputShape[outputShapeDimIndex] = valueDim;
        }
      }
    }
    return outputShape;
  }
  function getRowPartitionTypesHelper(rowPartitionTypeStrings) {
    const stringToType = {
      "FIRST_DIM_SIZE": RowPartitionType.FIRST_DIM_SIZE,
      "VALUE_ROWIDS": RowPartitionType.VALUE_ROWIDS,
      "ROW_LENGTHS": RowPartitionType.ROW_LENGTHS,
      "ROW_SPLITS": RowPartitionType.ROW_SPLITS,
      "ROW_LIMITS": RowPartitionType.ROW_LIMITS,
      "ROW_STARTS": RowPartitionType.ROW_STARTS
    };
    const result = [];
    for (const typeStr of rowPartitionTypeStrings) {
      if (typeStr in stringToType) {
        result.push(stringToType[typeStr]);
      } else {
        break;
      }
    }
    return result;
  }
  function getRaggedRank(rowPartitionTypes) {
    if (rowPartitionTypes.length === 0) {
      return 0;
    }
    if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {
      return rowPartitionTypes.length - 1;
    }
    return rowPartitionTypes.length;
  }
  function validateDefaultValueShape(defaultValueShape, valueShape) {
    if (defaultValueShape == null || valueShape == null) {
      return;
    }
    const defaultNDims = defaultValueShape.length;
    const valuesNDims = valueShape.length;
    if (defaultNDims >= valuesNDims) {
      throw new Error(`defaultValue.shape=${defaultValueShape} and ragged tensor flatValues.shape=${valueShape}, are incompatible: defaultValue.rank = ${defaultNDims} must be less than ragged tensor input flatValues.rank = ${valuesNDims})`);
    }
    for (let i2 = 0; i2 < Math.min(defaultNDims, valuesNDims - 1); ++i2) {
      const defaultDim = defaultValueShape[i2];
      const valueDim = valueShape[i2 + 1];
      if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 && defaultDim !== valueDim) {
        throw new Error(`defaultValue.shape=${defaultValueShape}, and ragged tensor input flatValues.shape=${valueShape} are incompatible: defaultValue.shape[${i2 - defaultValueShape.length}] = ${defaultDim} but ragged tensor input.flatValues.shape[${i2 - defaultValueShape.length}] = ${valueDim}`);
      }
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/reduce_util.js
  var PARALLELIZE_THRESHOLD = 30;
  function computeOptimalWindowSize(inSize) {
    if (inSize <= PARALLELIZE_THRESHOLD) {
      return inSize;
    }
    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/rotate_util.js
  function getImageCenter(center, imageHeight, imageWidth) {
    const centerX = imageWidth * (typeof center === "number" ? center : center[0]);
    const centerY = imageHeight * (typeof center === "number" ? center : center[1]);
    return [centerX, centerY];
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/array_ops_util.js
  function getReshaped(inputShape, blockShape, prod3, batchToSpace = true) {
    let reshaped = [];
    if (batchToSpace) {
      reshaped = reshaped.concat(blockShape.slice(0));
      reshaped.push(inputShape[0] / prod3);
      reshaped = reshaped.concat(inputShape.slice(1));
    } else {
      reshaped = reshaped.concat(inputShape[0]);
      const spatialLength = blockShape.length;
      for (let i2 = 0; i2 < spatialLength; ++i2) {
        reshaped = reshaped.concat([inputShape[i2 + 1] / blockShape[i2], blockShape[i2]]);
      }
      reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
    }
    return reshaped;
  }
  function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {
    const permuted = [];
    if (batchToSpace) {
      permuted.push(blockShapeRank);
      for (let i2 = blockShapeRank + 1; i2 < reshapedRank; ++i2) {
        if (i2 <= 2 * blockShapeRank) {
          permuted.push(i2);
          permuted.push(i2 - (blockShapeRank + 1));
        } else {
          permuted.push(i2);
        }
      }
    } else {
      const permutedBeforeBatch = [];
      const permutedAfterBatch = [];
      for (let i2 = 1; i2 < reshapedRank; ++i2) {
        if (i2 >= blockShapeRank * 2 + 1 || i2 % 2 === 1) {
          permutedAfterBatch.push(i2);
        } else {
          permutedBeforeBatch.push(i2);
        }
      }
      permuted.push(...permutedBeforeBatch);
      permuted.push(0);
      permuted.push(...permutedAfterBatch);
    }
    return permuted;
  }
  function getReshapedPermuted(inputShape, blockShape, prod3, batchToSpace = true) {
    const reshapedPermuted = [];
    if (batchToSpace) {
      reshapedPermuted.push(inputShape[0] / prod3);
    } else {
      reshapedPermuted.push(inputShape[0] * prod3);
    }
    for (let i2 = 1; i2 < inputShape.length; ++i2) {
      if (i2 <= blockShape.length) {
        if (batchToSpace) {
          reshapedPermuted.push(blockShape[i2 - 1] * inputShape[i2]);
        } else {
          reshapedPermuted.push(inputShape[i2] / blockShape[i2 - 1]);
        }
      } else {
        reshapedPermuted.push(inputShape[i2]);
      }
    }
    return reshapedPermuted;
  }
  function getSliceBeginCoords(crops, blockShape) {
    const sliceBeginCoords = [0];
    for (let i2 = 0; i2 < blockShape; ++i2) {
      sliceBeginCoords.push(crops[i2][0]);
    }
    return sliceBeginCoords;
  }
  function getSliceSize(uncroppedShape, crops, blockShape) {
    const sliceSize = uncroppedShape.slice(0, 1);
    for (let i2 = 0; i2 < blockShape; ++i2) {
      sliceSize.push(uncroppedShape[i2 + 1] - crops[i2][0] - crops[i2][1]);
    }
    return sliceSize;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/selu_util.js
  var SELU_SCALEALPHA = 1.7580993408473768;
  var SELU_SCALE = 1.0507009873554805;

  // node_modules/@tensorflow/tfjs-core/dist/ops/erf_util.js
  var ERF_P = 0.3275911;
  var ERF_A1 = 0.254829592;
  var ERF_A2 = -0.284496736;
  var ERF_A3 = 1.421413741;
  var ERF_A4 = -1.453152027;
  var ERF_A5 = 1.061405429;

  // node_modules/@tensorflow/tfjs-core/dist/backends/complex_util.js
  function mergeRealAndImagArrays(real4, imag3) {
    if (real4.length !== imag3.length) {
      throw new Error(`Cannot merge real and imag arrays of different lengths. real:${real4.length}, imag: ${imag3.length}.`);
    }
    const result = new Float32Array(real4.length * 2);
    for (let i2 = 0; i2 < result.length; i2 += 2) {
      result[i2] = real4[i2 / 2];
      result[i2 + 1] = imag3[i2 / 2];
    }
    return result;
  }
  function splitRealAndImagArrays(complex4) {
    const real4 = new Float32Array(complex4.length / 2);
    const imag3 = new Float32Array(complex4.length / 2);
    for (let i2 = 0; i2 < complex4.length; i2 += 2) {
      real4[i2 / 2] = complex4[i2];
      imag3[i2 / 2] = complex4[i2 + 1];
    }
    return { real: real4, imag: imag3 };
  }
  function complexWithEvenIndex(complex4) {
    const len = Math.ceil(complex4.length / 4);
    const real4 = new Float32Array(len);
    const imag3 = new Float32Array(len);
    for (let i2 = 0; i2 < complex4.length; i2 += 4) {
      real4[Math.floor(i2 / 4)] = complex4[i2];
      imag3[Math.floor(i2 / 4)] = complex4[i2 + 1];
    }
    return { real: real4, imag: imag3 };
  }
  function complexWithOddIndex(complex4) {
    const len = Math.floor(complex4.length / 4);
    const real4 = new Float32Array(len);
    const imag3 = new Float32Array(len);
    for (let i2 = 2; i2 < complex4.length; i2 += 4) {
      real4[Math.floor(i2 / 4)] = complex4[i2];
      imag3[Math.floor(i2 / 4)] = complex4[i2 + 1];
    }
    return { real: real4, imag: imag3 };
  }
  function getComplexWithIndex(complex4, index) {
    const real4 = complex4[index * 2];
    const imag3 = complex4[index * 2 + 1];
    return { real: real4, imag: imag3 };
  }
  function assignToTypedArray(data, real4, imag3, index) {
    data[index * 2] = real4;
    data[index * 2 + 1] = imag3;
  }
  function exponents(n2, inverse) {
    const real4 = new Float32Array(n2 / 2);
    const imag3 = new Float32Array(n2 / 2);
    for (let i2 = 0; i2 < Math.ceil(n2 / 2); i2++) {
      const x2 = (inverse ? 2 : -2) * Math.PI * (i2 / n2);
      real4[i2] = Math.cos(x2);
      imag3[i2] = Math.sin(x2);
    }
    return { real: real4, imag: imag3 };
  }
  function exponent(k4, n2, inverse) {
    const x2 = (inverse ? 2 : -2) * Math.PI * (k4 / n2);
    const real4 = Math.cos(x2);
    const imag3 = Math.sin(x2);
    return { real: real4, imag: imag3 };
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/einsum_util.js
  var ARROW = "->";
  var ARROW_REGEX = /->/g;
  var COMMA = ",";
  var ELLIPSIS = "...";
  function decodeEinsumEquation(equation, numTensors) {
    equation = equation.replace(/\s/g, "");
    const numArrows = (equation.length - equation.replace(ARROW_REGEX, "").length) / ARROW.length;
    if (numArrows < 1) {
      throw new Error("Equations without an arrow are not supported.");
    } else if (numArrows > 1) {
      throw new Error(`Equation must contain exactly one arrow ("${ARROW}").`);
    }
    const [inputString, outputString] = equation.split(ARROW);
    assert2(inputString.indexOf(ELLIPSIS) === -1, () => `The ellipsis notation ("${ELLIPSIS}") is not supported yet.`);
    const inputTerms = inputString.split(COMMA);
    const numInputs = inputTerms.length;
    if (numTensors !== numInputs) {
      throw new Error(`Expected ${numInputs} input tensors, received ${numTensors}`);
    }
    if (numInputs > 2) {
      throw new Error("Support for more than 2 input tensors is not implemented yet.");
    }
    const allDims = [];
    for (let i2 = 0; i2 < outputString.length; ++i2) {
      const dimName = outputString[i2];
      if (!inputTerms.some((inputTerm) => inputTerm.indexOf(dimName) !== -1)) {
        throw new Error(`Output subscripts contain the label ${dimName} not present in the input subscripts.`);
      }
      if (allDims.indexOf(dimName) === -1) {
        allDims.push(dimName);
      }
    }
    for (let i2 = 0; i2 < inputString.length; ++i2) {
      const dimName = inputString[i2];
      if (allDims.indexOf(dimName) === -1 && dimName !== COMMA) {
        allDims.push(dimName);
      }
    }
    const idDims = new Array(inputTerms.length);
    for (let i2 = 0; i2 < numInputs; ++i2) {
      if (new Set(inputTerms[i2].split("")).size !== inputTerms[i2].length) {
        throw new Error(`Found duplicate axes in input component ${inputTerms[i2]}. Support for duplicate axes in input is not implemented yet.`);
      }
      idDims[i2] = [];
      for (let j3 = 0; j3 < inputTerms[i2].length; ++j3) {
        idDims[i2].push(allDims.indexOf(inputTerms[i2][j3]));
      }
    }
    const numDims = allDims.length;
    const numOutDims = outputString.length;
    const summedDims = [];
    for (let i2 = numOutDims; i2 < numDims; ++i2) {
      summedDims.push(i2);
    }
    return { allDims, summedDims, idDims };
  }
  function getEinsumPermutation(nDims, idDims) {
    let permutationIndices = new Array(nDims);
    permutationIndices.fill(-1);
    for (let i2 = 0; i2 < idDims.length; ++i2) {
      permutationIndices[idDims[i2]] = i2;
    }
    const expandDims3 = [];
    for (let i2 = 0; i2 < nDims; ++i2) {
      if (permutationIndices[i2] === -1) {
        expandDims3.push(i2);
      }
    }
    permutationIndices = permutationIndices.filter((d2) => d2 !== -1);
    return { permutationIndices, expandDims: expandDims3 };
  }
  function checkEinsumDimSizes(nDims, idDims, tensors) {
    const dimSizes = new Array(nDims);
    for (let i2 = 0; i2 < tensors.length; ++i2) {
      const shape = tensors[i2].shape;
      for (let j3 = 0; j3 < idDims[i2].length; ++j3) {
        if (dimSizes[idDims[i2][j3]] === void 0) {
          dimSizes[idDims[i2][j3]] = shape[j3];
        } else {
          assert2(dimSizes[idDims[i2][j3]] === shape[j3], () => `Expected dimension ${dimSizes[idDims[i2][j3]]} at axis ${j3} of input shaped ${JSON.stringify(shape)}, but got dimension ${shape[j3]}`);
        }
      }
    }
  }
  function getEinsumComputePath(summedDims, idDims) {
    const path = summedDims;
    const steps = [];
    let nSteps = 0;
    if (summedDims.length === 0) {
      path.push(-1);
    }
    nSteps = summedDims.length + 1;
    for (let i2 = 0; i2 < nSteps; ++i2) {
      steps.push([]);
    }
    const computedTermIndices = [];
    for (let i2 = 0; i2 < path.length; ++i2) {
      const summedDim = path[i2];
      const termIndices = findTermsWithDim(idDims, summedDim);
      for (const termIndex of termIndices) {
        if (computedTermIndices.indexOf(termIndex) === -1) {
          steps[i2].push(termIndex);
          computedTermIndices.push(termIndex);
        }
      }
    }
    return { path, steps };
  }
  function isIdentityPermutation(perm) {
    return perm.every((dim, index) => dim === index);
  }
  function findTermsWithDim(idDims, dim) {
    const termIndices = [];
    for (let i2 = 0; i2 < idDims.length; ++i2) {
      if (idDims[i2].length === 0 || idDims[i2].indexOf(dim) !== -1 || dim === -1) {
        termIndices.push(i2);
      }
    }
    return termIndices;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/split_util.js
  function prepareSplitSize(x2, numOrSizeSplits, axis = 0) {
    let splitSizes = [];
    if (typeof numOrSizeSplits === "number") {
      assert2(x2.shape[axis] % numOrSizeSplits === 0, () => "Number of splits must evenly divide the axis.");
      splitSizes = new Array(numOrSizeSplits).fill(x2.shape[axis] / numOrSizeSplits);
    } else {
      const numOfNegs = numOrSizeSplits.reduce((count2, value) => {
        if (value === -1) {
          count2 += 1;
        }
        return count2;
      }, 0);
      assert2(numOfNegs <= 1, () => "There should be only one negative value in split array.");
      const negIndex = numOrSizeSplits.indexOf(-1);
      if (negIndex !== -1) {
        const total = numOrSizeSplits.reduce((a2, b2) => b2 > 0 ? a2 + b2 : a2);
        numOrSizeSplits[negIndex] = x2.shape[axis] - total;
      }
      assert2(x2.shape[axis] === numOrSizeSplits.reduce((a2, b2) => a2 + b2), () => "The sum of sizes must match the size of the axis dimension.");
      splitSizes = numOrSizeSplits;
    }
    return splitSizes;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_fill_empty_rows_util.js
  function getSparseFillEmptyRowsIndicesDenseShapeMismatch(indicesLength) {
    return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${indicesLength}`;
  }
  function getSparseFillEmptyRowsNegativeIndexErrorMessage(index, value) {
    return `indices(${index}, 0) is invalid: ${value} < 0`;
  }
  function getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(index, value, limit) {
    return `indices(${index}, 0) is invalid: ${value} >= ${limit}`;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape_util.js
  function getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(dim1, dim2) {
    return `only one output dimension may be -1, not both ${dim1} and ${dim2}`;
  }
  function getSparseReshapeNegativeOutputDimErrorMessage(dim, value) {
    return `size ${dim} must be non-negative, not ${value}`;
  }
  function getSparseReshapeEmptyTensorZeroOutputDimErrorMessage() {
    return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
  }
  function getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape) {
    const inputSize = sizeFromShape(inputShape);
    const outputSize = sizeFromShape(outputShape);
    return `Input to reshape is a SparseTensor with ${inputSize}
  dense values, but the requested shape requires a multiple of ${outputSize}. inputShape=${inputShape} outputShape= ${outputShape}`;
  }
  function getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape) {
    const inputSize = sizeFromShape(inputShape);
    const outputSize = sizeFromShape(outputShape);
    return `Input to reshape is a tensor with ${inputSize} dense values, but the requested shape has ${outputSize}. inputShape=${inputShape} outputShape=${outputShape}`;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_reduction_util.js
  function getSparseSegmentReductionNegativeSegmentIdsErrorMessage() {
    return `segment ids must be >= 0`;
  }
  function getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage() {
    return `segment ids are not increasing`;
  }
  function getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(segmentId, outputRows) {
    return `Segment id ${segmentId} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`;
  }
  function getSparseSegmentReductionIndicesOutOfRangeErrorMessage(index, indexValue, inputRows) {
    return `Bad: indices[${index}] == ${indexValue} out of range [0, ${inputRows})`;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/segment_util.js
  var segment_util_exports = {};
  __export(segment_util_exports, {
    collectGatherOpShapeInfo: () => collectGatherOpShapeInfo,
    computeOutShape: () => computeOutShape3,
    segOpComputeOptimalWindowSize: () => segOpComputeOptimalWindowSize
  });
  function segOpComputeOptimalWindowSize(inSize, numSegments) {
    let done = false;
    let res;
    if (inSize <= PARALLELIZE_THRESHOLD) {
      res = inSize;
      done = true;
    } else {
      res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
    }
    while (!done) {
      if (res > numSegments || res === inSize) {
        done = true;
      } else {
        res = nearestDivisor(inSize, res + 1);
      }
    }
    return res;
  }
  function computeOutShape3(aShape, axis, numSegments) {
    const outShape = [];
    const rank = aShape.length;
    for (let dim = 0; dim < rank; dim++) {
      if (dim !== axis) {
        outShape.push(aShape[dim]);
      } else {
        outShape.push(numSegments);
      }
    }
    return outShape;
  }
  function collectGatherOpShapeInfo(x2, indices, axis, batchDims) {
    const indicesRank = indices.shape.length;
    const xRank = x2.shape.length;
    if (batchDims !== 0) {
      if (batchDims < -indicesRank || batchDims > indicesRank) {
        throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);
      }
    }
    if (batchDims < 0) {
      batchDims += indicesRank;
    }
    if (batchDims > xRank) {
      throw new Error(`batchDims (${batchDims}) must be less than rank(x) (
    ${xRank}).`);
    }
    if (axis < batchDims) {
      throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);
    }
    for (let i2 = 0; i2 < batchDims; ++i2) {
      if (x2.shape[i2] !== indices.shape[i2]) {
        throw new Error(`x.shape[${i2}]: ${x2.shape[i2]} should be equal to indices.shape[${i2}]: ${indices.shape[i2]}.`);
      }
    }
    const dimSize = x2.shape[axis];
    const outputShape = [];
    let batchSize = 1;
    let outerSize = 1;
    let sliceSize = 1;
    for (let i2 = 0; i2 < batchDims; ++i2) {
      outputShape.push(x2.shape[i2]);
      batchSize *= x2.shape[i2];
    }
    for (let i2 = batchDims; i2 < axis; i2++) {
      outputShape.push(x2.shape[i2]);
      outerSize *= x2.shape[i2];
    }
    for (let i2 = batchDims; i2 < indicesRank; i2++) {
      outputShape.push(indices.shape[i2]);
    }
    for (let i2 = axis + 1; i2 < xRank; i2++) {
      outputShape.push(x2.shape[i2]);
      sliceSize *= x2.shape[i2];
    }
    return { batchSize, sliceSize, outerSize, dimSize, outputShape };
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/backend_util.js
  function fromUint8ToStringArray(vals) {
    try {
      return vals.map((val) => decodeString(val));
    } catch (err) {
      throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);
    }
  }
  function fromStringArrayToUint8(strings) {
    return strings.map((s2) => encodeString(s2));
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/kernel_impls.js
  var kernel_impls_exports = {};
  __export(kernel_impls_exports, {
    nonMaxSuppressionV3Impl: () => nonMaxSuppressionV3Impl,
    nonMaxSuppressionV4Impl: () => nonMaxSuppressionV4Impl,
    nonMaxSuppressionV5Impl: () => nonMaxSuppressionV5Impl,
    whereImpl: () => whereImpl
  });

  // node_modules/@tensorflow/tfjs-core/dist/index.js
  registerOptimizers();

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js
  var contexts = {};
  var WEBGL_ATTRIBUTES = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: true
  };
  function setWebGLContext(webGLVersion, gl2) {
    contexts[webGLVersion] = gl2;
  }
  function getWebGLContext(webGLVersion, customCanvas) {
    if (!(webGLVersion in contexts) || customCanvas != null) {
      const newCtx = getWebGLRenderingContext(webGLVersion, customCanvas);
      if (newCtx !== null) {
        contexts[webGLVersion] = newCtx;
      } else {
        console.log("Could not get context for WebGL version", webGLVersion);
        return null;
      }
    }
    const gl2 = contexts[webGLVersion];
    if (gl2 == null || gl2.isContextLost()) {
      delete contexts[webGLVersion];
      return getWebGLContext(webGLVersion);
    }
    gl2.disable(gl2.DEPTH_TEST);
    gl2.disable(gl2.STENCIL_TEST);
    gl2.disable(gl2.BLEND);
    gl2.disable(gl2.DITHER);
    gl2.disable(gl2.POLYGON_OFFSET_FILL);
    gl2.disable(gl2.SAMPLE_COVERAGE);
    gl2.enable(gl2.SCISSOR_TEST);
    gl2.enable(gl2.CULL_FACE);
    gl2.cullFace(gl2.BACK);
    return contexts[webGLVersion];
  }
  function createCanvas(webGLVersion) {
    if (typeof OffscreenCanvas !== "undefined" && webGLVersion === 2) {
      return new OffscreenCanvas(300, 150);
    } else if (typeof document !== "undefined") {
      return document.createElement("canvas");
    } else {
      throw new Error("Cannot create a canvas in this context");
    }
  }
  function getWebGLRenderingContext(webGLVersion, customCanvas) {
    if (webGLVersion !== 1 && webGLVersion !== 2) {
      throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    }
    const canvas = customCanvas == null ? createCanvas(webGLVersion) : customCanvas;
    canvas.addEventListener("webglcontextlost", (ev) => {
      ev.preventDefault();
      delete contexts[webGLVersion];
    }, false);
    if (env().getBool("SOFTWARE_WEBGL_ENABLED")) {
      WEBGL_ATTRIBUTES.failIfMajorPerformanceCaveat = false;
    }
    if (webGLVersion === 1) {
      return canvas.getContext("webgl", WEBGL_ATTRIBUTES) || canvas.getContext("experimental-webgl", WEBGL_ATTRIBUTES);
    }
    return canvas.getContext("webgl2", WEBGL_ATTRIBUTES);
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js
  var PackingScheme;
  (function(PackingScheme2) {
    PackingScheme2[PackingScheme2["DENSE"] = 0] = "DENSE";
    PackingScheme2[PackingScheme2["SHARED_BATCH"] = 1] = "SHARED_BATCH";
  })(PackingScheme || (PackingScheme = {}));
  var TextureUsage;
  (function(TextureUsage2) {
    TextureUsage2[TextureUsage2["RENDER"] = 0] = "RENDER";
    TextureUsage2[TextureUsage2["UPLOAD"] = 1] = "UPLOAD";
    TextureUsage2[TextureUsage2["PIXELS"] = 2] = "PIXELS";
    TextureUsage2[TextureUsage2["DOWNLOAD"] = 3] = "DOWNLOAD";
  })(TextureUsage || (TextureUsage = {}));
  var PhysicalTextureType;
  (function(PhysicalTextureType2) {
    PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16";
    PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
  })(PhysicalTextureType || (PhysicalTextureType = {}));
  function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
  }
  function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
  }
  function getDenseTexShape(shape) {
    const size = util_exports.sizeFromShape(shape);
    const texelsNeeded = Math.ceil(size / 4);
    return util_exports.sizeToSquarishShape(texelsNeeded);
  }
  function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [
      Math.max(1, Math.ceil(columns / 2)),
      Math.max(1, Math.ceil(rows / 2))
    ];
  }
  function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    const [w2, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return w2 * h * 4;
  }
  function getTextureConfig(gl2, textureHalfFloatExtension) {
    const glany = gl2;
    let internalFormatFloat;
    let internalFormatHalfFloat;
    let internalFormatPackedHalfFloat;
    let internalFormatPackedFloat;
    let textureFormatFloat;
    let downloadTextureFormat;
    let downloadUnpackNumChannels;
    let defaultNumChannels;
    let textureTypeHalfFloat;
    let textureTypeFloat;
    if (env().getNumber("WEBGL_VERSION") === 2) {
      internalFormatFloat = glany.R32F;
      internalFormatHalfFloat = glany.R16F;
      internalFormatPackedHalfFloat = glany.RGBA16F;
      internalFormatPackedFloat = glany.RGBA32F;
      textureFormatFloat = glany.RED;
      downloadUnpackNumChannels = 4;
      defaultNumChannels = 1;
      textureTypeHalfFloat = glany.HALF_FLOAT;
      textureTypeFloat = glany.FLOAT;
      downloadTextureFormat = glany.RGBA8;
    } else {
      internalFormatFloat = gl2.RGBA;
      internalFormatHalfFloat = gl2.RGBA;
      internalFormatPackedHalfFloat = gl2.RGBA;
      internalFormatPackedFloat = glany.RGBA;
      textureFormatFloat = gl2.RGBA;
      downloadUnpackNumChannels = 4;
      defaultNumChannels = 4;
      textureTypeHalfFloat = textureHalfFloatExtension != null ? textureHalfFloatExtension.HALF_FLOAT_OES : null;
      textureTypeFloat = gl2.FLOAT;
      downloadTextureFormat = gl2.RGBA;
    }
    return {
      internalFormatFloat,
      internalFormatHalfFloat,
      internalFormatPackedHalfFloat,
      internalFormatPackedFloat,
      textureFormatFloat,
      downloadTextureFormat,
      downloadUnpackNumChannels,
      defaultNumChannels,
      textureTypeHalfFloat,
      textureTypeFloat
    };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js
  function callAndCheck(gl2, func) {
    const returnValue = func();
    if (env().getBool("DEBUG")) {
      checkWebGLError(gl2);
    }
    return returnValue;
  }
  function checkWebGLError(gl2) {
    const error = gl2.getError();
    if (error !== gl2.NO_ERROR) {
      throw new Error("WebGL Error: " + getWebGLErrorMessage(gl2, error));
    }
  }
  var MIN_FLOAT16 = 596e-10;
  var MAX_FLOAT16 = 65504;
  function canBeRepresented(num) {
    if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {
      return true;
    }
    return false;
  }
  function getWebGLErrorMessage(gl2, status) {
    switch (status) {
      case gl2.NO_ERROR:
        return "NO_ERROR";
      case gl2.INVALID_ENUM:
        return "INVALID_ENUM";
      case gl2.INVALID_VALUE:
        return "INVALID_VALUE";
      case gl2.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case gl2.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case gl2.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      case gl2.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      default:
        return `Unknown error code ${status}`;
    }
  }
  function getExtensionOrThrow(gl2, extensionName) {
    return throwIfNull(gl2, () => gl2.getExtension(extensionName), 'Extension "' + extensionName + '" not supported on this browser.');
  }
  function createVertexShader(gl2, vertexShaderSource) {
    const vertexShader = throwIfNull(gl2, () => gl2.createShader(gl2.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
    callAndCheck(gl2, () => gl2.shaderSource(vertexShader, vertexShaderSource));
    callAndCheck(gl2, () => gl2.compileShader(vertexShader));
    if (gl2.getShaderParameter(vertexShader, gl2.COMPILE_STATUS) === false) {
      console.log(gl2.getShaderInfoLog(vertexShader));
      throw new Error("Failed to compile vertex shader.");
    }
    return vertexShader;
  }
  function createFragmentShader(gl2, fragmentShaderSource) {
    const fragmentShader = throwIfNull(gl2, () => gl2.createShader(gl2.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
    callAndCheck(gl2, () => gl2.shaderSource(fragmentShader, fragmentShaderSource));
    callAndCheck(gl2, () => gl2.compileShader(fragmentShader));
    if (env().get("ENGINE_COMPILE_ONLY")) {
      return fragmentShader;
    }
    if (gl2.getShaderParameter(fragmentShader, gl2.COMPILE_STATUS) === false) {
      logShaderSourceAndInfoLog(fragmentShaderSource, gl2.getShaderInfoLog(fragmentShader));
      throw new Error("Failed to compile fragment shader.");
    }
    return fragmentShader;
  }
  var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
  function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
      console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);
      console.log(shaderSource);
      return;
    }
    const lineNumber = +lineNumberRegexResult[1];
    const shaderLines = shaderSource.split("\n");
    const pad2 = shaderLines.length.toString().length + 2;
    const linesWithLineNumbers = shaderLines.map((line, lineNumber2) => util_exports.rightPad((lineNumber2 + 1).toString(), pad2) + line);
    let maxLineLength = 0;
    for (let i2 = 0; i2 < linesWithLineNumbers.length; i2++) {
      maxLineLength = Math.max(linesWithLineNumbers[i2].length, maxLineLength);
    }
    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    const afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join("\n"));
    console.log(shaderInfoLog.split("\n")[0]);
    console.log(`%c ${util_exports.rightPad(errorLine[0], maxLineLength)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717");
    console.log(afterErrorLines.join("\n"));
  }
  function createProgram(gl2) {
    return throwIfNull(gl2, () => gl2.createProgram(), "Unable to create WebGLProgram.");
  }
  function linkProgram(gl2, program) {
    callAndCheck(gl2, () => gl2.linkProgram(program));
    if (env().get("ENGINE_COMPILE_ONLY")) {
      return;
    }
    if (gl2.getProgramParameter(program, gl2.LINK_STATUS) === false) {
      console.log(gl2.getProgramInfoLog(program));
      throw new Error("Failed to link vertex and fragment shaders.");
    }
  }
  function validateProgram(gl2, program) {
    callAndCheck(gl2, () => gl2.validateProgram(program));
    if (gl2.getProgramParameter(program, gl2.VALIDATE_STATUS) === false) {
      console.log(gl2.getProgramInfoLog(program));
      throw new Error("Shader program validation failed.");
    }
  }
  function createStaticVertexBuffer(gl2, data) {
    const buffer2 = throwIfNull(gl2, () => gl2.createBuffer(), "Unable to create WebGLBuffer");
    callAndCheck(gl2, () => gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer2));
    callAndCheck(gl2, () => gl2.bufferData(gl2.ARRAY_BUFFER, data, gl2.STATIC_DRAW));
    return buffer2;
  }
  function createStaticIndexBuffer(gl2, data) {
    const buffer2 = throwIfNull(gl2, () => gl2.createBuffer(), "Unable to create WebGLBuffer");
    callAndCheck(gl2, () => gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, buffer2));
    callAndCheck(gl2, () => gl2.bufferData(gl2.ELEMENT_ARRAY_BUFFER, data, gl2.STATIC_DRAW));
    return buffer2;
  }
  function createTexture(gl2) {
    return throwIfNull(gl2, () => gl2.createTexture(), "Unable to create WebGLTexture.");
  }
  function validateTextureSize(width, height) {
    const maxTextureSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (width <= 0 || height <= 0) {
      const requested = `[${width}x${height}]`;
      throw new Error("Requested texture size " + requested + " is invalid.");
    }
    if (width > maxTextureSize || height > maxTextureSize) {
      const requested = `[${width}x${height}]`;
      const max3 = `[${maxTextureSize}x${maxTextureSize}]`;
      throw new Error("Requested texture size " + requested + " greater than WebGL maximum on this browser / GPU " + max3 + ".");
    }
  }
  function createFramebuffer(gl2) {
    return throwIfNull(gl2, () => gl2.createFramebuffer(), "Unable to create WebGLFramebuffer.");
  }
  function bindVertexBufferToProgramAttribute(gl2, program, attribute, buffer2, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    const loc = gl2.getAttribLocation(program, attribute);
    if (loc === -1) {
      return false;
    }
    callAndCheck(gl2, () => gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer2));
    callAndCheck(gl2, () => gl2.vertexAttribPointer(loc, arrayEntriesPerItem, gl2.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));
    callAndCheck(gl2, () => gl2.enableVertexAttribArray(loc));
    return true;
  }
  function bindTextureUnit(gl2, texture, textureUnit) {
    validateTextureUnit(gl2, textureUnit);
    callAndCheck(gl2, () => gl2.activeTexture(gl2.TEXTURE0 + textureUnit));
    callAndCheck(gl2, () => gl2.bindTexture(gl2.TEXTURE_2D, texture));
  }
  function getProgramUniformLocationOrThrow(gl2, program, uniformName) {
    return throwIfNull(gl2, () => gl2.getUniformLocation(program, uniformName), 'uniform "' + uniformName + '" not present in program.');
  }
  function getProgramUniformLocation(gl2, program, uniformName) {
    return gl2.getUniformLocation(program, uniformName);
  }
  function bindTextureToProgramUniformSampler(gl2, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl2, () => bindTextureUnit(gl2, texture, textureUnit));
    callAndCheck(gl2, () => gl2.uniform1i(uniformSamplerLocation, textureUnit));
  }
  function bindColorTextureToFramebuffer(gl2, texture, framebuffer) {
    callAndCheck(gl2, () => gl2.bindFramebuffer(gl2.FRAMEBUFFER, framebuffer));
    callAndCheck(gl2, () => gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, texture, 0));
  }
  function unbindColorTextureFromFramebuffer(gl2, framebuffer) {
    callAndCheck(gl2, () => gl2.bindFramebuffer(gl2.FRAMEBUFFER, framebuffer));
    callAndCheck(gl2, () => gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, null, 0));
  }
  function validateFramebuffer(gl2) {
    const status = gl2.checkFramebufferStatus(gl2.FRAMEBUFFER);
    if (status !== gl2.FRAMEBUFFER_COMPLETE) {
      throw new Error("Error binding framebuffer: " + getFramebufferErrorMessage(gl2, status));
    }
  }
  function getFramebufferErrorMessage(gl2, status) {
    switch (status) {
      case gl2.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case gl2.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case gl2.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case gl2.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
      default:
        return `unknown error ${status}`;
    }
  }
  function throwIfNull(gl2, returnTOrNull, failureMessage) {
    const tOrNull = callAndCheck(gl2, () => returnTOrNull());
    if (tOrNull == null) {
      throw new Error(failureMessage);
    }
    return tOrNull;
  }
  function validateTextureUnit(gl2, textureUnit) {
    const maxTextureUnit = gl2.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    const glTextureUnit = textureUnit + gl2.TEXTURE0;
    if (glTextureUnit < gl2.TEXTURE0 || glTextureUnit > maxTextureUnit) {
      const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;
      throw new Error(`textureUnit must be in ${textureUnitRange}.`);
    }
  }
  function getBatchDim(shape, dimsToSkip = 2) {
    return util_exports.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));
  }
  function getRowsCols(shape) {
    if (shape.length === 0) {
      throw Error("Cannot get rows and columns of an empty shape array.");
    }
    return [
      shape.length > 1 ? shape[shape.length - 2] : 1,
      shape[shape.length - 1]
    ];
  }
  function getShapeAs3D(shape) {
    let shapeAs3D = [1, 1, 1];
    const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;
    if (!isScalar) {
      shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];
    }
    return shapeAs3D;
  }
  function getTextureShapeFromLogicalShape(logShape, isPacked = false) {
    let maxTexSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    let maxSizeForNarrowTex = env().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
    if (maxSizeForNarrowTex === Infinity && env().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")) {
      maxSizeForNarrowTex = maxTexSize / 2;
    }
    if (isPacked) {
      maxTexSize = maxTexSize * 2;
      maxSizeForNarrowTex = maxSizeForNarrowTex * 2;
      logShape = logShape.map((d2, i2) => i2 >= logShape.length - 2 ? util_exports.nearestLargerEven(logShape[i2]) : logShape[i2]);
      if (logShape.length === 1) {
        logShape = [2, logShape[0]];
      }
    }
    if (logShape.length !== 2) {
      const squeezeResult = util_exports.squeezeShape(logShape);
      logShape = squeezeResult.newShape;
    }
    let size = util_exports.sizeFromShape(logShape);
    let textureShape = null;
    if (logShape.length <= 1 && size <= maxTexSize) {
      textureShape = [1, size];
    } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {
      textureShape = logShape;
    } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {
      textureShape = [logShape[0] * logShape[1], logShape[2]];
    } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {
      textureShape = [logShape[0], logShape[1] * logShape[2]];
    } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {
      textureShape = [logShape[0] * logShape[1] * logShape[2], logShape[3]];
    } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
      textureShape = [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    const isLongNarrowTex = textureShape != null && Math.max(...textureShape) > maxSizeForNarrowTex && Math.min(...textureShape) <= (isPacked ? 2 : 1) && Math.min(...textureShape) > 0;
    if (textureShape == null || isLongNarrowTex) {
      if (isPacked) {
        const batchDim = getBatchDim(logShape);
        let rows = 2, cols = 2;
        if (logShape.length) {
          [rows, cols] = getRowsCols(logShape);
        }
        size = batchDim * (rows / 2) * (cols / 2);
        textureShape = util_exports.sizeToSquarishShape(size).map((d2) => d2 * 2);
      } else {
        textureShape = util_exports.sizeToSquarishShape(size);
      }
    }
    return textureShape;
  }
  function isEven(n2) {
    return n2 % 2 === 0;
  }
  function isReshapeFree(shape1, shape2) {
    shape1 = shape1.slice(-2);
    shape2 = shape2.slice(-2);
    if (util_exports.arraysEqual(shape1, shape2)) {
      return true;
    }
    if (!shape1.length || !shape2.length) {
      return true;
    }
    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {
      return true;
    }
    if (shape1.length !== shape2.length) {
      const shape1Cols = shape1.slice(-1)[0];
      const shape2Cols = shape2.slice(-1)[0];
      if (shape1Cols === shape2Cols) {
        return true;
      }
      if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {
        return true;
      }
    }
    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);
  }
  var MAX_TEXTURE_SIZE;
  var MAX_TEXTURES_IN_SHADER;
  function getWebGLMaxTextureSize(webGLVersion) {
    if (MAX_TEXTURE_SIZE == null) {
      const gl2 = getWebGLContext(webGLVersion);
      MAX_TEXTURE_SIZE = gl2.getParameter(gl2.MAX_TEXTURE_SIZE);
    }
    return MAX_TEXTURE_SIZE;
  }
  function getMaxTexturesInShader(webGLVersion) {
    if (MAX_TEXTURES_IN_SHADER == null) {
      const gl2 = getWebGLContext(webGLVersion);
      MAX_TEXTURES_IN_SHADER = gl2.getParameter(gl2.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, MAX_TEXTURES_IN_SHADER);
  }
  function getWebGLDisjointQueryTimerVersion(webGLVersion) {
    if (webGLVersion === 0) {
      return 0;
    }
    let queryTimerVersion;
    const gl2 = getWebGLContext(webGLVersion);
    if (hasExtension(gl2, "EXT_disjoint_timer_query_webgl2") && webGLVersion === 2) {
      queryTimerVersion = 2;
    } else if (hasExtension(gl2, "EXT_disjoint_timer_query")) {
      queryTimerVersion = 1;
    } else {
      queryTimerVersion = 0;
    }
    return queryTimerVersion;
  }
  function hasExtension(gl2, extensionName) {
    const ext = gl2.getExtension(extensionName);
    return ext != null;
  }
  function isWebGLVersionEnabled(webGLVersion) {
    try {
      const gl2 = getWebGLContext(webGLVersion);
      if (gl2 != null) {
        return true;
      }
    } catch (e2) {
      console.log("Error when getting WebGL context: ", e2);
      return false;
    }
    return false;
  }
  function isCapableOfRenderingToFloatTexture(webGLVersion) {
    if (webGLVersion === 0) {
      return false;
    }
    const gl2 = getWebGLContext(webGLVersion);
    if (webGLVersion === 1) {
      if (!hasExtension(gl2, "OES_texture_float")) {
        return false;
      }
    } else {
      if (!hasExtension(gl2, "EXT_color_buffer_float")) {
        return false;
      }
    }
    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl2);
    return isFrameBufferComplete;
  }
  function isDownloadFloatTextureEnabled(webGLVersion) {
    if (webGLVersion === 0) {
      return false;
    }
    const gl2 = getWebGLContext(webGLVersion);
    if (webGLVersion === 1) {
      if (!hasExtension(gl2, "OES_texture_float")) {
        return false;
      }
      if (!hasExtension(gl2, "WEBGL_color_buffer_float")) {
        return false;
      }
    } else {
      if (hasExtension(gl2, "EXT_color_buffer_float")) {
        return createFloatTextureAndBindToFramebuffer(gl2);
      }
      const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
      if (hasExtension(gl2, COLOR_BUFFER_HALF_FLOAT)) {
        const textureHalfFloatExtension = gl2.getExtension(COLOR_BUFFER_HALF_FLOAT);
        return createHalfFloatTextureAndBindToFramebuffer(gl2, textureHalfFloatExtension);
      }
      return false;
    }
    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl2);
    return isFrameBufferComplete;
  }
  function createFloatTextureAndBindToFramebuffer(gl2) {
    const texConfig = getTextureConfig(gl2);
    const texture = gl2.createTexture();
    gl2.bindTexture(gl2.TEXTURE_2D, texture);
    const width = 1;
    const height = 1;
    gl2.texImage2D(gl2.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);
    const frameBuffer = gl2.createFramebuffer();
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, frameBuffer);
    gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, texture, 0);
    const isFrameBufferComplete = gl2.checkFramebufferStatus(gl2.FRAMEBUFFER) === gl2.FRAMEBUFFER_COMPLETE;
    gl2.bindTexture(gl2.TEXTURE_2D, null);
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
    gl2.deleteTexture(texture);
    gl2.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
  }
  function createHalfFloatTextureAndBindToFramebuffer(gl2, textureHalfFloatExtension) {
    const texConfig = getTextureConfig(gl2, textureHalfFloatExtension);
    const texture = gl2.createTexture();
    gl2.bindTexture(gl2.TEXTURE_2D, texture);
    const width = 1;
    const height = 1;
    gl2.texImage2D(gl2.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);
    const frameBuffer = gl2.createFramebuffer();
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, frameBuffer);
    gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, texture, 0);
    const isFrameBufferComplete = gl2.checkFramebufferStatus(gl2.FRAMEBUFFER) === gl2.FRAMEBUFFER_COMPLETE;
    gl2.bindTexture(gl2.TEXTURE_2D, null);
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
    gl2.deleteTexture(texture);
    gl2.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
  }
  function isWebGLFenceEnabled(webGLVersion) {
    if (webGLVersion !== 2) {
      return false;
    }
    const gl2 = getWebGLContext(webGLVersion);
    const isEnabled = gl2.fenceSync != null;
    return isEnabled;
  }
  function assertNotComplex(tensor2, opName) {
    if (!Array.isArray(tensor2)) {
      tensor2 = [tensor2];
    }
    tensor2.forEach((t3) => {
      if (t3 != null) {
        util_exports.assert(t3.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the WebGL backend.`);
      }
    });
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/flags_webgl.js
  var ENV3 = env();
  ENV3.registerFlag("HAS_WEBGL", () => ENV3.getNumber("WEBGL_VERSION") > 0);
  ENV3.registerFlag("WEBGL_VERSION", () => {
    if (isWebGLVersionEnabled(2)) {
      return 2;
    } else if (isWebGLVersionEnabled(1)) {
      return 1;
    }
    return 0;
  });
  ENV3.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
  ENV3.registerFlag("WEBGL_BUFFER_SUPPORTED", () => ENV3.get("WEBGL_VERSION") === 2);
  ENV3.registerFlag("WEBGL_CPU_FORWARD", () => true);
  ENV3.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
  ENV3.registerFlag("WEBGL_PACK", () => ENV3.getBool("HAS_WEBGL"));
  ENV3.registerFlag("WEBGL_PACK_NORMALIZATION", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_CLIP", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_REDUCE", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_LAZILY_UNPACK", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_CONV_IM2COL", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => getWebGLMaxTextureSize(ENV3.getNumber("WEBGL_VERSION")));
  ENV3.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => getMaxTexturesInShader(ENV3.getNumber("WEBGL_VERSION")));
  ENV3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
    const webGLVersion = ENV3.getNumber("WEBGL_VERSION");
    if (webGLVersion === 0) {
      return 0;
    }
    return getWebGLDisjointQueryTimerVersion(webGLVersion);
  });
  ENV3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => ENV3.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !device_util_exports.isMobile());
  ENV3.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => isCapableOfRenderingToFloatTexture(ENV3.getNumber("WEBGL_VERSION")));
  ENV3.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => {
    return ENV3.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : ENV3.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
  });
  ENV3.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => isDownloadFloatTextureEnabled(ENV3.getNumber("WEBGL_VERSION")));
  ENV3.registerFlag("WEBGL_FENCE_API_ENABLED", () => isWebGLFenceEnabled(ENV3.getNumber("WEBGL_VERSION")));
  ENV3.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => {
    const useUniforms = ENV3.getBool("WEBGL_RENDER_FLOAT32_ENABLED");
    return useUniforms ? 4 : 0;
  });
  ENV3.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => {
    return -1;
  }, (threshold2) => {
    if (threshold2 < 0 && threshold2 !== -1) {
      throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${threshold2}.`);
    }
  });
  ENV3.registerFlag("WEBGL_FLUSH_THRESHOLD", () => {
    return device_util_exports.isMobile() ? 1 : -1;
  }, (threshold2) => {
    if (threshold2 < 0 && threshold2 !== -1) {
      throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${threshold2}.`);
    }
  });
  ENV3.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
  ENV3.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
  ENV3.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
  ENV3.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
  ENV3.registerFlag("WEBGL_EXP_CONV", () => false);
  ENV3.registerFlag("SOFTWARE_WEBGL_ENABLED", () => ENV3.getBool("IS_TEST"));
  ENV3.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => Infinity);
  ENV3.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => false);
  ENV3.registerFlag("WEBGL2_ISNAN_CUSTOM", () => false);
  ENV3.registerFlag("ENGINE_COMPILE_ONLY", () => false);

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js
  function getGlslDifferences() {
    let version5;
    let attribute;
    let varyingVs;
    let varyingFs;
    let texture2D;
    let output;
    let defineOutput;
    let defineSpecialNaN;
    let defineSpecialInf;
    let defineRound;
    if (env().getNumber("WEBGL_VERSION") === 2) {
      version5 = "#version 300 es";
      attribute = "in";
      varyingVs = "out";
      varyingFs = "in";
      texture2D = "texture";
      output = "outputColor";
      defineOutput = "out vec4 outputColor;";
      defineSpecialNaN = env().getBool("WEBGL2_ISNAN_CUSTOM") ? `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    ` : "";
      defineSpecialInf = ``;
      defineRound = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
    } else {
      version5 = "";
      attribute = "attribute";
      varyingVs = "varying";
      varyingFs = "varying";
      texture2D = "texture2D";
      output = "gl_FragColor";
      defineOutput = "";
      defineSpecialNaN = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `;
      defineSpecialInf = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `;
      defineRound = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
    }
    return {
      version: version5,
      attribute,
      varyingVs,
      varyingFs,
      texture2D,
      output,
      defineOutput,
      defineSpecialNaN,
      defineSpecialInf,
      defineRound
    };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js
  function getLogicalCoordinatesFromFlatIndex(coords2, shape, index = "index") {
    const strides = util_exports.computeStrides(shape);
    return strides.map((stride, i2) => {
      const line1 = `int ${coords2[i2]} = ${index} / ${stride}`;
      const line2 = i2 === strides.length - 1 ? `int ${coords2[i2 + 1]} = ${index} - ${coords2[i2]} * ${stride}` : `index -= ${coords2[i2]} * ${stride}`;
      return `${line1}; ${line2};`;
    }).join("");
  }
  function getOutputLogicalCoordinatesFromFlatIndexByUniform(coords2, shape, index = "index") {
    const strides = util_exports.computeStrides(shape);
    return strides.map((_3, i2) => {
      const line1 = `int ${coords2[i2]} = ${index} / outShapeStrides[${i2}]`;
      const line2 = i2 === strides.length - 1 ? `int ${coords2[i2 + 1]} = ${index} - ${coords2[i2]} * outShapeStrides[${i2}]` : `index -= ${coords2[i2]} * outShapeStrides[${i2}]`;
      return `${line1}; ${line2};`;
    }).join("");
  }
  function symbolicallyComputeStrides(indicesArr, variableName) {
    const numCoords = indicesArr.length;
    const shape = indicesArr.map((d2) => `${variableName}[${d2}]`);
    const strides = new Array(numCoords - 1);
    strides[numCoords - 2] = shape[numCoords - 1];
    for (let i2 = numCoords - 3; i2 >= 0; --i2) {
      strides[i2] = `(${strides[i2 + 1]} * ${shape[i2 + 1]})`;
    }
    return strides;
  }
  function getLogicalCoordinatesFromFlatIndexByUniform(coords2, variableName, index = "index") {
    const indicesArray = coords2.map((_3, i2) => i2);
    const strides = symbolicallyComputeStrides(indicesArray, variableName);
    return strides.map((_3, i2) => {
      const line1 = `int ${coords2[i2]} = ${index} / ${strides[i2]}`;
      const line2 = i2 === strides.length - 1 ? `int ${coords2[i2 + 1]} = ${index} - ${coords2[i2]} * ${strides[i2]}` : `index -= ${coords2[i2]} * ${strides[i2]}`;
      return `${line1}; ${line2};`;
    }).join("");
  }
  function getFlatIndexFrom3D(shape) {
    const strides = util_exports.computeStrides(shape).map((d2) => d2.toString());
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;
  }
`;
  }
  function getFlatIndexFrom3DOutput() {
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
  }
  var ENCODE_FLOAT_SNIPPET = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js
  var { getBroadcastDims: getBroadcastDims2 } = backend_util_exports;
  function makeShader(inputsInfo, outputShape, program) {
    const prefixSnippets = [];
    inputsInfo.forEach((x2) => {
      const size = util_exports.sizeFromShape(x2.shapeInfo.logicalShape);
      if (x2.shapeInfo.isUniform) {
        prefixSnippets.push(`uniform float ${x2.name}${size > 1 ? `[${size}]` : ""};`);
      } else {
        prefixSnippets.push(`uniform sampler2D ${x2.name};`);
        prefixSnippets.push(`uniform int offset${x2.name};`);
      }
      if (program.enableShapeUniforms) {
        const { uniformShape } = getUniformInfoFromShape(program.packedInputs, x2.shapeInfo.logicalShape, x2.shapeInfo.texShape);
        switch (uniformShape.length) {
          case 1:
            prefixSnippets.push(`uniform int ${x2.name}Shape;`);
            break;
          case 2:
            prefixSnippets.push(`uniform ivec2 ${x2.name}Shape;`);
            break;
          case 3:
            prefixSnippets.push(`uniform ivec3 ${x2.name}Shape;`);
            break;
          case 4:
            prefixSnippets.push(`uniform ivec4 ${x2.name}Shape;`);
            break;
          default:
            break;
        }
        prefixSnippets.push(`uniform ivec2 ${x2.name}TexShape;`);
      }
    });
    if (program.enableShapeUniforms) {
      switch (outputShape.logicalShape.length) {
        case 1:
          prefixSnippets.push(`uniform int outShape;`);
          break;
        case 2:
          prefixSnippets.push(`uniform ivec2 outShape;`);
          prefixSnippets.push(`uniform int outShapeStrides;`);
          break;
        case 3:
          prefixSnippets.push(`uniform ivec3 outShape;`);
          prefixSnippets.push(`uniform ivec2 outShapeStrides;`);
          break;
        case 4:
          prefixSnippets.push(`uniform ivec4 outShape;`);
          prefixSnippets.push(`uniform ivec3 outShapeStrides;`);
          break;
        default:
          break;
      }
      prefixSnippets.push(`uniform ivec2 outTexShape;`);
    }
    if (program.customUniforms) {
      program.customUniforms.forEach((d2) => {
        prefixSnippets.push(`uniform ${d2.type} ${d2.name}${d2.arrayIndex ? `[${d2.arrayIndex}]` : ""};`);
      });
    }
    const inputPrefixSnippet = prefixSnippets.join("\n");
    const inputSamplingSnippet = inputsInfo.map((x2) => getInputSamplingSnippet(x2, outputShape, program.packedInputs, program.enableShapeUniforms)).join("\n");
    const outTexShape = outputShape.texShape;
    const glsl = getGlslDifferences();
    const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);
    let outputSamplingSnippet;
    let floatTextureSetOutputSnippet;
    let shaderPrefix = getShaderPrefix(glsl);
    if (outputShape.isPacked) {
      outputSamplingSnippet = getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
      floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);
    } else {
      outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
      floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);
    }
    if (program.packedInputs) {
      shaderPrefix += SHADER_PACKED_PREFIX;
    }
    const source = [
      shaderPrefix,
      floatTextureSampleSnippet,
      floatTextureSetOutputSnippet,
      inputPrefixSnippet,
      outputSamplingSnippet,
      inputSamplingSnippet,
      program.userCode
    ].join("\n");
    return source;
  }
  function getSamplerFromInInfo(inInfo, enableShapeUniforms = false) {
    const shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
      case 0:
        return getSamplerScalar(inInfo, enableShapeUniforms);
      case 1:
        return getSampler1D(inInfo, enableShapeUniforms);
      case 2:
        return getSampler2D(inInfo, enableShapeUniforms);
      case 3:
        return getSampler3D(inInfo, enableShapeUniforms);
      case 4:
        return getSampler4D(inInfo, enableShapeUniforms);
      case 5:
        return getSampler5D(inInfo);
      case 6:
        return getSampler6D(inInfo);
      default:
        throw new Error(`${shape.length}-D input sampling is not yet supported`);
    }
  }
  function getPackedSamplerFromInInfo(inInfo, enableShapeUniforms) {
    const shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
      case 0:
        return getPackedSamplerScalar(inInfo);
      case 1:
        return getPackedSampler1D(inInfo, enableShapeUniforms);
      case 2:
        return getPackedSampler2D(inInfo, enableShapeUniforms);
      case 3:
        return getPackedSampler3D(inInfo, enableShapeUniforms);
      default:
        return getPackedSamplerND(inInfo, enableShapeUniforms);
    }
  }
  function getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false, enableShapeUniforms) {
    let res = "";
    if (usesPackedTextures) {
      res += getPackedSamplerFromInInfo(inInfo, enableShapeUniforms);
    } else {
      res += getSamplerFromInInfo(inInfo, enableShapeUniforms);
    }
    const inShape = inInfo.shapeInfo.logicalShape;
    const outShape = outShapeInfo.logicalShape;
    if (inShape.length <= outShape.length) {
      if (usesPackedTextures) {
        res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);
      } else {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo);
      }
    }
    return res;
  }
  function getPackedOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
    switch (outShape.length) {
      case 0:
        return getOutputScalarCoords();
      case 1:
        return getOutputPacked1DCoords(outShape, outTexShape, enableShapeUniforms);
      case 2:
        return getOutputPacked2DCoords(outShape, outTexShape, enableShapeUniforms);
      case 3:
        return getOutputPacked3DCoords(outShape, outTexShape, enableShapeUniforms);
      default:
        return getOutputPackedNDCoords(outShape, outTexShape, enableShapeUniforms);
    }
  }
  function getOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
    switch (outShape.length) {
      case 0:
        return getOutputScalarCoords();
      case 1:
        return getOutput1DCoords(outShape, outTexShape, enableShapeUniforms);
      case 2:
        return getOutput2DCoords(outShape, outTexShape, enableShapeUniforms);
      case 3:
        return getOutput3DCoords(outShape, outTexShape, enableShapeUniforms);
      case 4:
        return getOutput4DCoords(outShape, outTexShape, enableShapeUniforms);
      case 5:
        return getOutput5DCoords(outShape, outTexShape);
      case 6:
        return getOutput6DCoords(outShape, outTexShape);
      default:
        throw new Error(`${outShape.length}-D output sampling is not yet supported`);
    }
  }
  function getFloatTextureSampleSnippet(glsl) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${glsl.texture2D}(textureSampler, uv).r;
    }
  `;
  }
  function getFloatTextureSetRSnippet(glsl) {
    return `
    void setOutput(float val) {
      ${glsl.output} = vec4(val, 0, 0, 0);
    }
  `;
  }
  function getFloatTextureSetRGBASnippet(glsl) {
    return `
    void setOutput(vec4 val) {
      ${glsl.output} = val;
    }
  `;
  }
  function getShaderPrefix(glsl) {
    const SHADER_PREFIX = `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFs} vec2 resultUV;
    ${glsl.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${glsl.defineSpecialNaN}
    ${glsl.defineSpecialInf}
    ${glsl.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${SAMPLE_1D_SNIPPET}
    ${SAMPLE_2D_SNIPPET}
    ${SAMPLE_3D_SNIPPET}
  `;
    return SHADER_PREFIX;
  }
  var SAMPLE_1D_SNIPPET = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var SAMPLE_2D_SNIPPET = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var SAMPLE_3D_SNIPPET = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var SHADER_PACKED_PREFIX = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
  function getOutputScalarCoords() {
    return `
    int getOutputCoords() {
      return 0;
    }
  `;
  }
  function getOutputPacked1DCoords(shape, texShape, enableShapeUniforms) {
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (packedTexShape[0] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);
      }
    `;
    }
    if (packedTexShape[1] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `;
    }
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);
    }
  `;
  }
  function getOutput1DCoords(shape, texShape, enableShapeUniforms) {
    if (texShape[0] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return int(resultUV.x * ${texShape[1]}.0);
      }
    `;
    }
    if (texShape[1] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return int(resultUV.y * ${texShape[0]}.0);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `;
    }
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      return resTexRC.x * ${texShape[1]} + resTexRC.y;
    }
  `;
  }
  function getOutputPacked3DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texelsInLogicalRow = Math.ceil(shape[2] / 2);
    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec3(b, r, c);
    }
  `;
  }
  function getOutput3DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      const coordsFromIndexSnippet2 = getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], shape);
      return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${coordsFromIndexSnippet2}
    return ivec3(r, c, d);
  }
`;
    }
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
  }
  function getOutputPackedNDCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
    let texelsInBatchN = texelsInBatch;
    let batches = ``;
    let coords2 = "b, r, c";
    for (let b2 = 2; b2 < shape.length - 1; b2++) {
      texelsInBatchN *= shape[shape.length - b2 - 1];
      batches = `
      int b${b2} = index / ${texelsInBatchN};
      index -= b${b2} * ${texelsInBatchN};
    ` + batches;
      coords2 = `b${b2}, ` + coords2;
    }
    return `
    ivec${shape.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      ${batches}

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec${shape.length}(${coords2});
    }
  `;
  }
  function getOutput4DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      const coordsFromIndexSnippet2 = getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d", "d2"], shape);
      return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${coordsFromIndexSnippet2}
      return ivec4(r, c, d, d2);
    }
  `;
    }
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2"], shape);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec4(r, c, d, d2);
    }
  `;
  }
  function getOutput5DCoords(shape, texShape) {
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3"], shape);
    return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},
                             ${texShape[1]}));

      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
  }
  function getOutput6DCoords(shape, texShape) {
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3", "d4"], shape);
    return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
  }
  function getOutputPacked2DCoords(shape, texShape, enableShapeUniforms) {
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (util_exports.arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      }
    `;
    }
    const texelsInLogicalRow = Math.ceil(shape[1] / 2);
    if (enableShapeUniforms) {
      return `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `;
    }
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec2(r, c);
    }
  `;
  }
  function getOutput2DCoords(shape, texShape, enableShapeUniforms) {
    if (util_exports.arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));
      }
    `;
    }
    if (shape[1] === 1) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
    }
    if (shape[0] === 1) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `;
    }
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      int r = index / ${shape[1]};
      int c = index - r * ${shape[1]};
      return ivec2(r, c);
    }
  `;
  }
  function getFlatOffsetUniformName(texName) {
    return `offset${texName}`;
  }
  function getPackedSamplerScalar(inputInfo) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const glsl = getGlslDifferences();
    return `
    vec4 ${funcName}() {
      return ${glsl.texture2D}(${texName}, halfCR);
    }
  `;
  }
  function getSamplerScalar(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) {
      return `float ${funcName}() {return ${texName};}`;
    }
    const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;
    if (texNumR === 1 && texNumC === 1) {
      return `
      float ${funcName}() {
        return sampleTexture(${texName}, halfCR);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) {
      return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;
    return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getPackedSampler1D(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const glsl = getGlslDifferences();
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    return `
    vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
        ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler1D(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int index) {
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texShape = inputInfo.shapeInfo.texShape;
    const tNumR = texShape[0];
    const tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
      return `
      float ${funcName}(int index) {
        return sampleTexture(${texName}, halfCR);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (tNumC === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (tNumR === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getPackedSampler2D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const glsl = getGlslDifferences();
    if (texShape != null && util_exports.arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
      }
      return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const valuesPerRow = Math.ceil(shape[1] / 2);
    return `
    vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler2D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    if (texShape != null && util_exports.arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      const texNumR2 = texShape[0];
      const texNumC2 = texShape[1];
      return `
    float ${funcName}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC2}.0, ${texNumR2}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const { newShape, keptDims } = util_exports.squeezeShape(shape);
    const squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
      const params = ["row", "col"];
      return `
      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const offset = getFlatOffsetUniformName(texName);
    if (texNumC === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    if (texNumR === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${texName}Shape[1] + col + ${offset};
        vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
  float ${funcName}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${shape[1]} + col + ${offset};
    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
    return sampleTexture(${texName}, uv);
  }
`;
  }
  function getPackedSampler3D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (shape[0] === 1) {
      const squeezedShape = shape.slice(1);
      const keptDims = [1, 2];
      const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
      const params = ["b", "row", "col"];
      return `
        ${getPackedSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        vec4 ${funcName}(int b, int row, int col) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
    }
    const glsl = getGlslDifferences();
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const texNumR = packedTexShape[0];
    const texNumC = packedTexShape[1];
    const valuesPerRow = Math.ceil(shape[2] / 2);
    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
    return `
    vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler3D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride0 = shape[1] * shape[2];
    const stride1 = shape[2];
    const { newShape, keptDims } = util_exports.squeezeShape(shape);
    const squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
      const params = ["row", "col", "depth"];
      return `
        ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        float ${funcName}(int row, int col, int depth) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${stride0}, ${stride1}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    if (texNumC === stride0 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth) {
        int stride1 = ${texName}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
        float ${funcName}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
    }
    if (texNumC === stride1 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${texName}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) {
      return `
    float ${funcName}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${texName}Shape[1] * ${texName}Shape[2];
      int stride1 = ${texName}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${offset};
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
      return sampleTexture(${texName}, uv);
    }
    `;
    }
    return `
      float ${funcName}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
  `;
  }
  function getPackedSamplerND(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const glsl = getGlslDifferences();
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${texName}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${texName}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const shape = inputInfo.shapeInfo.logicalShape;
    const rank = shape.length;
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texNumR = packedTexShape[0];
    const texNumC = packedTexShape[1];
    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);
    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
    let params = `int b, int row, int col`;
    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
    for (let b2 = 2; b2 < rank - 1; b2++) {
      params = `int b${b2}, ` + params;
      texelsInBatch *= shape[rank - b2 - 1];
      index = `b${b2} * ${texelsInBatch} + ` + index;
    }
    return `
    vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler4D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride2 = shape[3];
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    const { newShape, keptDims } = util_exports.squeezeShape(shape);
    if (newShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, newShape);
      const params = ["row", "col", "depth", "depth2"];
      return `
      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col, int depth, int depth2) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const stride2Str = `int stride2 = ${texName}Shape[3];`;
    const stride1Str = `int stride1 = ${texName}Shape[2] * stride2;`;
    const stride0Str = `int stride0 = ${texName}Shape[1] * stride1;`;
    if (texNumC === stride0 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        ${stride2Str}
        ${stride1Str}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${stride1}, ${stride2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride2 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${texName}Shape[1] * ${texName}Shape[2], ${texName}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) {
      return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${stride2Str}
      ${stride1Str}
      ${stride0Str}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} +
          depth * ${stride2} + depth2;
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getSampler5D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride3 = shape[4];
    const stride2 = shape[3] * stride3;
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    const { newShape, keptDims } = util_exports.squeezeShape(shape);
    if (newShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, newShape);
      const params = ["row", "col", "depth", "depth2", "depth3"];
      return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          depth3;
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${stride1}, ${stride2}, ${stride3}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride3 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3]},
               ${shape[2] * shape[3]}, ${shape[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getSampler6D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const { newShape, keptDims } = util_exports.squeezeShape(shape);
    if (newShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, newShape);
      const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
      return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    const stride4 = shape[5];
    const stride3 = shape[4] * stride4;
    const stride2 = shape[3] * stride3;
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          dot(
            vec2(depth3, depth4),
            vec2(${stride4}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride4 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},
               ${shape[2] * shape[3] * shape[4]},
               ${shape[3] * shape[4]},
               ${shape[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getUniformSampler(inputInfo) {
    const texName = inputInfo.name;
    const inSize = util_exports.sizeFromShape(inputInfo.shapeInfo.logicalShape);
    if (inSize < 2) {
      return `return ${texName};`;
    }
    return `
    for (int i = 0; i < ${inSize}; i++) {
      if (i == index) {
        return ${texName}[i];
      }
    }
  `;
  }
  function getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = "get" + texFuncSnippet + "AtOutCoords";
    const inRank = inputInfo.shapeInfo.logicalShape.length;
    const outRank = outShapeInfo.logicalShape.length;
    const broadcastDims = getBroadcastDims2(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    const type = getCoordsDataType(outRank);
    const rankDiff = outRank - inRank;
    let coordsSnippet;
    const fields = ["x", "y", "z", "w", "u", "v"];
    if (inRank === 0) {
      coordsSnippet = "";
    } else if (outRank < 2 && broadcastDims.length >= 1) {
      coordsSnippet = "coords = 0;";
    } else {
      coordsSnippet = broadcastDims.map((d2) => `coords.${fields[d2 + rankDiff]} = 0;`).join("\n");
    }
    let unpackedCoordsSnippet = "";
    if (outRank < 2 && inRank > 0) {
      unpackedCoordsSnippet = "coords";
    } else {
      unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s2, i2) => `coords.${fields[i2 + rankDiff]}`).join(", ");
    }
    let output = `return outputValue;`;
    const inSize = util_exports.sizeFromShape(inputInfo.shapeInfo.logicalShape);
    const isInputScalar = inSize === 1;
    const outSize = util_exports.sizeFromShape(outShapeInfo.logicalShape);
    const isOutputScalar = outSize === 1;
    if (inRank === 1 && !isInputScalar && !isOutputScalar) {
      output = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
    } else if (isInputScalar && !isOutputScalar) {
      if (outRank === 1) {
        output = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `;
      } else {
        output = `
        return vec4(outputValue.x);
      `;
      }
    } else if (broadcastDims.length) {
      const rows = inRank - 2;
      const cols = inRank - 1;
      if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
        output = `return vec4(outputValue.x);`;
      } else if (broadcastDims.indexOf(rows) > -1) {
        output = `return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);`;
      } else if (broadcastDims.indexOf(cols) > -1) {
        output = `return vec4(outputValue.xx, outputValue.zz);`;
      }
    }
    return `
    vec4 ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});
      ${output}
    }
  `;
  }
  function getSamplerAtOutputCoords(inputInfo, outShapeInfo) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = "get" + texFuncSnippet + "AtOutCoords";
    const outTexShape = outShapeInfo.texShape;
    const inTexShape = inputInfo.shapeInfo.texShape;
    const inRank = inputInfo.shapeInfo.logicalShape.length;
    const outRank = outShapeInfo.logicalShape.length;
    if (!inputInfo.shapeInfo.isUniform && inRank === outRank && inputInfo.shapeInfo.flatOffset == null && util_exports.arraysEqual(inTexShape, outTexShape)) {
      return `
      float ${funcName}() {
        return sampleTexture(${texName}, resultUV);
      }
    `;
    }
    const type = getCoordsDataType(outRank);
    const broadcastDims = getBroadcastDims2(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    const rankDiff = outRank - inRank;
    let coordsSnippet;
    const fields = ["x", "y", "z", "w", "u", "v"];
    if (inRank === 0) {
      coordsSnippet = "";
    } else if (outRank < 2 && broadcastDims.length >= 1) {
      coordsSnippet = "coords = 0;";
    } else {
      coordsSnippet = broadcastDims.map((d2) => `coords.${fields[d2 + rankDiff]} = 0;`).join("\n");
    }
    let unpackedCoordsSnippet = "";
    if (outRank < 2 && inRank > 0) {
      unpackedCoordsSnippet = "coords";
    } else {
      unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s2, i2) => `coords.${fields[i2 + rankDiff]}`).join(", ");
    }
    return `
    float ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      return get${texFuncSnippet}(${unpackedCoordsSnippet});
    }
  `;
  }
  function getCoordsDataType(rank) {
    if (rank <= 1) {
      return "int";
    } else if (rank === 2) {
      return "ivec2";
    } else if (rank === 3) {
      return "ivec3";
    } else if (rank === 4) {
      return "ivec4";
    } else if (rank === 5) {
      return "ivec5";
    } else if (rank === 6) {
      return "ivec6";
    } else {
      throw Error(`GPU for rank ${rank} is not yet supported`);
    }
  }
  function getUniformInfoFromShape(isPacked, shape, texShape) {
    const { newShape, keptDims } = util_exports.squeezeShape(shape);
    const rank = shape.length;
    const useSqueezePackedShape = isPacked && rank === 3 && shape[0] === 1;
    const squeezeShape2 = useSqueezePackedShape ? shape.slice(1) : newShape;
    const useSqueezeShape = !isPacked && rank > 1 && !util_exports.arraysEqual(shape, texShape) && newShape.length < rank || useSqueezePackedShape;
    const uniformShape = useSqueezeShape ? squeezeShape2 : shape;
    return { useSqueezeShape, uniformShape, keptDims };
  }
  function squeezeInputInfo(inInfo, squeezedShape) {
    const newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
  }
  function getSqueezedParams(params, keptDims) {
    return keptDims.map((d2) => params[d2]).join(", ");
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js
  function compileProgram(gpgpu, program, inputs, output) {
    const inputInfos = inputs.map((input2, i2) => {
      const shapeInfo = {
        logicalShape: input2.shape,
        texShape: input2.isUniform ? null : input2.texData.texShape,
        isUniform: input2.isUniform,
        isPacked: input2.isUniform ? false : input2.texData.isPacked,
        flatOffset: null
      };
      if (input2.texData != null && input2.texData.slice != null && input2.texData.slice.flatOffset > 0) {
        shapeInfo.flatOffset = input2.texData.slice.flatOffset;
      }
      return { name: program.variableNames[i2], shapeInfo };
    });
    const inShapeInfos = inputInfos.map((x2) => x2.shapeInfo);
    const outShapeInfo = {
      logicalShape: output.shape,
      texShape: output.texData.texShape,
      isUniform: false,
      isPacked: output.texData.isPacked,
      flatOffset: null
    };
    const source = makeShader(inputInfos, outShapeInfo, program);
    const fragmentShader = createFragmentShader(gpgpu.gl, source);
    const webGLProgram = gpgpu.createProgram(fragmentShader);
    if (!env().get("ENGINE_COMPILE_ONLY")) {
      return Object.assign({
        program,
        fragmentShader,
        source,
        webGLProgram,
        inShapeInfos,
        outShapeInfo
      }, getUniformLocations(gpgpu, program, webGLProgram));
    } else {
      return {
        program,
        fragmentShader,
        source,
        webGLProgram,
        inShapeInfos,
        outShapeInfo,
        uniformLocations: null,
        customUniformLocations: null,
        infLoc: null,
        nanLoc: null,
        inShapesLocations: null,
        inTexShapesLocations: null,
        outShapeLocation: null,
        outShapeStridesLocation: null,
        outTexShapeLocation: null
      };
    }
  }
  function getUniformLocations(gpgpu, program, webGLProgram) {
    const uniformLocations = {};
    const inShapesLocations = {};
    const inTexShapesLocations = {};
    const customUniformLocations = [];
    let outShapeLocation;
    let outTexShapeLocation;
    let outShapeStridesLocation;
    let infLoc = null;
    let nanLoc = null;
    nanLoc = gpgpu.getUniformLocation(webGLProgram, "NAN", false);
    if (env().getNumber("WEBGL_VERSION") === 1) {
      infLoc = gpgpu.getUniformLocation(webGLProgram, "INFINITY", false);
    }
    const shouldThrow = false;
    for (let i2 = 0; i2 < program.variableNames.length; i2++) {
      const varName = program.variableNames[i2];
      uniformLocations[varName] = gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);
      uniformLocations[`offset${varName}`] = gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);
      if (program.enableShapeUniforms) {
        inShapesLocations[`${varName}Shape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}Shape`, shouldThrow);
        inTexShapesLocations[`${varName}TexShape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}TexShape`, shouldThrow);
      }
    }
    if (program.enableShapeUniforms) {
      outShapeLocation = gpgpu.getUniformLocation(webGLProgram, "outShape", shouldThrow);
      outShapeStridesLocation = gpgpu.getUniformLocation(webGLProgram, "outShapeStrides", shouldThrow);
      outTexShapeLocation = gpgpu.getUniformLocation(webGLProgram, "outTexShape", shouldThrow);
    }
    if (program.customUniforms) {
      program.customUniforms.forEach((d2, i2) => {
        customUniformLocations[i2] = gpgpu.getUniformLocation(webGLProgram, d2.name, shouldThrow);
      });
    }
    return {
      uniformLocations,
      customUniformLocations,
      infLoc,
      nanLoc,
      inShapesLocations,
      inTexShapesLocations,
      outShapeLocation,
      outShapeStridesLocation,
      outTexShapeLocation
    };
  }
  function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
      throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but was executed with ${inputs.length} inputs`);
    }
    shapeInfos.forEach((s2, i2) => {
      const shapeA = s2.logicalShape;
      const input2 = inputs[i2];
      const shapeB = input2.shape;
      if (!util_exports.arraysEqual(shapeA, shapeB)) {
        throw Error(`Binary was compiled with different shapes than the current args. Shapes ${shapeA} and ${shapeB} must match`);
      }
      if (s2.isUniform && input2.isUniform) {
        return;
      }
      const texShapeA = s2.texShape;
      const texShapeB = input2.isUniform ? null : input2.texData.texShape;
      if (!util_exports.arraysEqual(texShapeA, texShapeB)) {
        throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${texShapeA} and ${texShapeB} must match`);
      }
    });
  }
  function runProgram(gpgpu, binary, inputs, output, customUniformValues) {
    if (!binary.program.enableShapeUniforms) {
      validateBinaryAndProgram(binary.inShapeInfos, inputs);
      validateBinaryAndProgram([binary.outShapeInfo], [output]);
    }
    const outTex = output.texData.texture;
    const outTexShape = output.texData.texShape;
    if (output.texData.isPacked) {
      gpgpu.setOutputPackedMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);
    } else {
      gpgpu.setOutputMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);
    }
    gpgpu.setProgram(binary.webGLProgram);
    if (env().getNumber("WEBGL_VERSION") === 1) {
      if (binary.infLoc !== null) {
        gpgpu.gl.uniform1f(binary.infLoc, Infinity);
      }
    }
    if (binary.nanLoc !== null) {
      gpgpu.gl.uniform1f(binary.nanLoc, NaN);
    }
    inputs.forEach((input2, i2) => {
      const varName = binary.program.variableNames[i2];
      const varLoc = binary.uniformLocations[varName];
      const varOffsetLoc = binary.uniformLocations[`offset${varName}`];
      const varShapeLoc = binary.inShapesLocations[`${varName}Shape`];
      const varTexShapeLoc = binary.inTexShapesLocations[`${varName}TexShape`];
      if (varShapeLoc) {
        const { uniformShape } = getUniformInfoFromShape(binary.program.packedInputs, input2.shape, input2.texData.texShape);
        switch (uniformShape.length) {
          case 1:
            gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          case 2:
            gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          case 3:
            gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          case 4:
            gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          default:
            break;
        }
      }
      if (varTexShapeLoc) {
        gpgpu.gl.uniform2i(varTexShapeLoc, input2.texData.texShape[0], input2.texData.texShape[1]);
      }
      if (varLoc == null) {
        return;
      }
      if (input2.isUniform) {
        if (util_exports.sizeFromShape(input2.shape) < 2) {
          gpgpu.gl.uniform1f(varLoc, input2.uniformValues[0]);
        } else {
          let vals = input2.uniformValues;
          if (!(vals instanceof Float32Array)) {
            vals = new Float32Array(vals);
          }
          gpgpu.gl.uniform1fv(varLoc, vals);
        }
        return;
      }
      if (input2.texData.slice != null && varOffsetLoc != null) {
        gpgpu.gl.uniform1i(varOffsetLoc, input2.texData.slice.flatOffset);
      }
      gpgpu.setInputMatrixTexture(input2.texData.texture.texture, varLoc, i2);
    });
    const outShapeLoc = binary.outShapeLocation;
    if (outShapeLoc) {
      switch (output.shape.length) {
        case 1:
          gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));
          break;
        case 2:
          gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));
          break;
        case 3:
          gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));
          break;
        case 4:
          gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));
          break;
        default:
          break;
      }
    }
    if (binary.outShapeStridesLocation) {
      const strides = util_exports.computeStrides(output.shape);
      switch (output.shape.length) {
        case 2:
          gpgpu.gl.uniform1iv(binary.outShapeStridesLocation, new Int32Array(strides));
          break;
        case 3:
          gpgpu.gl.uniform2iv(binary.outShapeStridesLocation, new Int32Array(strides));
          break;
        case 4:
          gpgpu.gl.uniform3iv(binary.outShapeStridesLocation, new Int32Array(strides));
          break;
        default:
          break;
      }
    }
    if (binary.outTexShapeLocation) {
      gpgpu.gl.uniform2i(binary.outTexShapeLocation, output.texData.texShape[0], output.texData.texShape[1]);
    }
    if (binary.program.customUniforms && customUniformValues) {
      binary.program.customUniforms.forEach((d2, i2) => {
        const customLoc = binary.customUniformLocations[i2];
        const customValue = customUniformValues[i2];
        if (d2.type === "float") {
          gpgpu.gl.uniform1fv(customLoc, customValue);
        } else if (d2.type === "vec2") {
          gpgpu.gl.uniform2fv(customLoc, customValue);
        } else if (d2.type === "vec3") {
          gpgpu.gl.uniform3fv(customLoc, customValue);
        } else if (d2.type === "vec4") {
          gpgpu.gl.uniform4fv(customLoc, customValue);
        } else if (d2.type === "int") {
          gpgpu.gl.uniform1iv(customLoc, customValue);
        } else if (d2.type === "ivec2") {
          gpgpu.gl.uniform2iv(customLoc, customValue);
        } else if (d2.type === "ivec3") {
          gpgpu.gl.uniform3iv(customLoc, customValue);
        } else if (d2.type === "ivec4") {
          gpgpu.gl.uniform4iv(customLoc, customValue);
        } else {
          throw Error(`uniform type ${d2.type} is not supported yet.`);
        }
      });
    }
    gpgpu.executeProgram();
  }
  function makeShaderKey(program, inputs, output) {
    let keyInputs = "";
    inputs.concat(output).forEach((x2) => {
      const hasOffset = x2.texData != null && x2.texData.slice != null && x2.texData.slice.flatOffset > 0;
      if (program.enableShapeUniforms && !x2.isUniform) {
        const xTexShape = x2.texData.texShape;
        const { useSqueezeShape, uniformShape, keptDims } = getUniformInfoFromShape(program.packedInputs, x2.shape, xTexShape);
        let rank1 = "", rank2 = "", rank34 = "";
        if (uniformShape.length === 1 && program.packedInputs) {
          const packedTexShape = [Math.ceil(xTexShape[0] / 2), Math.ceil(xTexShape[1] / 2)];
          rank1 = `${packedTexShape[0] > 1}_${packedTexShape[1] > 1}`;
        } else if (uniformShape.length === 2 && !program.packedInputs) {
          rank2 = `${uniformShape[0] > 1}_${uniformShape[1] > 1}`;
        } else if (uniformShape.length > 2 && !program.packedInputs) {
          const strides = util_exports.computeStrides(uniformShape);
          rank34 = `${strides[0] === xTexShape[1]}_${strides[strides.length - 1] === xTexShape[1]}`;
        }
        const xRank = x2.shape.length;
        const isLogicalShapTexShapeEqual = uniformShape.length === 2 && util_exports.arraysEqual(x2.shape, xTexShape);
        const isScalar = util_exports.sizeFromShape(x2.shape) === 1;
        const broadcastDims = backend_util_exports.getBroadcastDims(x2.shape, output.shape);
        const isInOutTexShapeEqual = !program.packedInputs && xRank === output.shape.length && util_exports.arraysEqual(xTexShape, output.texData.texShape);
        const isTexShapeGreaterThanOne = program.packedInputs || uniformShape.length > 2 ? "" : `${xTexShape[0] > 1}_${xTexShape[1] > 1}`;
        keyInputs += `${xRank}_${isInOutTexShapeEqual}_${useSqueezeShape ? keptDims : ""}_${uniformShape.length}_${isScalar}_${broadcastDims}_${isLogicalShapTexShapeEqual}_${rank1}_${rank2}_${rank34}_${isTexShapeGreaterThanOne}_${hasOffset}`;
      } else {
        const texShape = x2.isUniform ? "uniform" : x2.texData.texShape;
        keyInputs += `${x2.shape}_${texShape}_${hasOffset}`;
      }
    });
    const keyUserCode = program.userCode;
    let key = program.constructor.name;
    key += "_" + keyInputs + "_" + keyUserCode + `${env().getNumber("WEBGL_VERSION")}`;
    return key;
  }
  function useShapeUniforms(rank) {
    return env().getBool("WEBGL_USE_SHAPES_UNIFORMS") && rank <= 4;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_gpu.js
  var DecodeMatrixProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      this.outPackingScheme = PackingScheme.DENSE;
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], outputShape) : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${glsl.output} = result;
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js
  var DecodeMatrixPackedProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outPackingScheme = PackingScheme.DENSE;
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], outputShape) : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${glsl.output} = result;
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_gpu.js
  var EncodeFloatProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.outTexUsage = TextureUsage.DOWNLOAD;
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        float x = getAAtOutCoords();
        ${glsl.output} = encode_float(x);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_packed_gpu.js
  var EncodeFloatPackedProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = false;
      this.outTexUsage = TextureUsage.DOWNLOAD;
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${glsl.output} = encode_float(x);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js
  var CHANNEL_CHAR_TO_INDEX_MAP = {
    "R": 0,
    "G": 1,
    "B": 2,
    "A": 3
  };
  var EncodeMatrixProgram = class {
    constructor(outputShape, inputIsUnsignedByte = false, usedChannels = "RGBA") {
      this.variableNames = ["A"];
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      let output = `result`;
      if (inputIsUnsignedByte) {
        output = `floor(result * 255. + 0.5)`;
      }
      let mainLoop = "";
      for (let usedChannelIndex = 0; usedChannelIndex < usedChannels.length; usedChannelIndex++) {
        const curChannel = usedChannels[usedChannelIndex];
        mainLoop += `
          if(offset == ${usedChannelIndex}) {
            result = values[${CHANNEL_CHAR_TO_INDEX_MAP[curChannel]}];
          }`;
      }
      this.userCode = `
      ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${usedChannels.length});

        flatIndex = idiv(flatIndex, ${usedChannels.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${glsl.texture2D}(A, uv);
          ${mainLoop}
        }
        ${glsl.output} = vec4(${output}, 0., 0., 0.);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js
  var EncodeMatrixPackedProgram = class {
    constructor(outputShape, inputIsUnsignedByte = false) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      let mainLoop = "";
      let output = "result";
      if (inputIsUnsignedByte) {
        output = "floor(result * 255. + 0.5)";
      }
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          const channel = row * 2 + col;
          mainLoop += `
          localCoords = coords;
          if(localCoords[2] + ${col} < ${this.enableShapeUniforms ? "outShape[2]" : `${outputShape[2]}`}) {
          localCoords[2] += ${col};
          if (localCoords[1] + ${row} < ${this.enableShapeUniforms ? "outShape[1]" : `${outputShape[1]}`}) {
            localCoords[1] += ${row};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${glsl.texture2D}(A, uv);

            if (offset == 0) {
              result[${channel}] = values[0];
            } else if (offset == 1) {
              result[${channel}] = values[1];
            } else if (offset == 2) {
              result[${channel}] = values[2];
            } else {
              result[${channel}] = values[3];
            }
          }
        }
        `;
        }
      }
      this.userCode = `
        ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${mainLoop}

          ${glsl.output} = ${output};
        }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js
  function createVertexShader2(gl2) {
    const glsl = getGlslDifferences();
    const vertexShaderSource = `${glsl.version}
    precision highp float;
    ${glsl.attribute} vec3 clipSpacePos;
    ${glsl.attribute} vec2 uv;
    ${glsl.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
    return createVertexShader(gl2, vertexShaderSource);
  }
  function createVertexBuffer(gl2) {
    const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return createStaticVertexBuffer(gl2, vertexArray);
  }
  function createIndexBuffer(gl2) {
    const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return createStaticIndexBuffer(gl2, triangleVertexIndices);
  }
  function createAndConfigureTexture(gl2, width, height, internalFormat, textureFormat, textureType) {
    validateTextureSize(width, height);
    const texture = createTexture(gl2);
    const tex2d = gl2.TEXTURE_2D;
    callAndCheck(gl2, () => gl2.bindTexture(tex2d, texture));
    callAndCheck(gl2, () => gl2.texParameteri(tex2d, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE));
    callAndCheck(gl2, () => gl2.texParameteri(tex2d, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE));
    callAndCheck(gl2, () => gl2.texParameteri(tex2d, gl2.TEXTURE_MIN_FILTER, gl2.NEAREST));
    callAndCheck(gl2, () => gl2.texParameteri(tex2d, gl2.TEXTURE_MAG_FILTER, gl2.NEAREST));
    if (env().getNumber("WEBGL_VERSION") === 1) {
      callAndCheck(gl2, () => gl2.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));
    } else {
      callAndCheck(gl2, () => gl2.texStorage2D(tex2d, 1, internalFormat, width, height));
    }
    callAndCheck(gl2, () => gl2.bindTexture(gl2.TEXTURE_2D, null));
    return { texture, texShape: [height, width] };
  }
  function getInternalFormatForFloat32MatrixTexture(textureConfig) {
    return textureConfig.internalFormatFloat;
  }
  function createFloat32MatrixTexture(gl2, rows, columns, textureConfig) {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl2, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl2.FLOAT);
  }
  function getInternalFormatForFloat16MatrixTexture(textureConfig) {
    return textureConfig.internalFormatHalfFloat;
  }
  function createFloat16MatrixTexture(gl2, rows, columns, textureConfig) {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl2, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);
  }
  function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {
    return textureConfig.downloadTextureFormat;
  }
  function createUnsignedBytesMatrixTexture(gl2, rows, columns, textureConfig) {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl2, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl2.RGBA, gl2.UNSIGNED_BYTE);
  }
  function getInternalFormatForPackedMatrixTexture(textureConfig) {
    return textureConfig.internalFormatPackedFloat;
  }
  function createPackedMatrixTexture(gl2, rows, columns, textureConfig) {
    const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl2, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl2.RGBA, gl2.FLOAT);
  }
  function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {
    return textureConfig.internalFormatPackedHalfFloat;
  }
  function createFloat16PackedMatrixTexture(gl2, rows, columns, textureConfig) {
    const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl2, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl2.RGBA, textureConfig.textureTypeHalfFloat);
  }
  function bindVertexProgramAttributeStreams(gl2, program, vertexBuffer) {
    const posOffset = 0;
    const uvOffset = 3 * 4;
    const stride = 3 * 4 + 2 * 4;
    callAndCheck(gl2, () => gl2.bindBuffer(gl2.ARRAY_BUFFER, vertexBuffer));
    const success = bindVertexBufferToProgramAttribute(gl2, program, "clipSpacePos", vertexBuffer, 3, stride, posOffset);
    return success && bindVertexBufferToProgramAttribute(gl2, program, "uv", vertexBuffer, 2, stride, uvOffset);
  }
  function uploadDenseMatrixToTexture(gl2, texture, width, height, data, textureConfig) {
    callAndCheck(gl2, () => gl2.bindTexture(gl2.TEXTURE_2D, texture));
    let dataForUpload, texelDataType, internalFormat;
    if (data instanceof Uint8Array) {
      dataForUpload = new Uint8Array(width * height * 4);
      texelDataType = gl2.UNSIGNED_BYTE;
      internalFormat = gl2.RGBA;
    } else {
      dataForUpload = new Float32Array(width * height * 4);
      texelDataType = gl2.FLOAT;
      internalFormat = textureConfig.internalFormatPackedFloat;
    }
    dataForUpload.set(data);
    if (env().getNumber("WEBGL_VERSION") === 2) {
      callAndCheck(gl2, () => gl2.texSubImage2D(gl2.TEXTURE_2D, 0, 0, 0, width, height, gl2.RGBA, texelDataType, dataForUpload));
    } else {
      callAndCheck(gl2, () => gl2.texImage2D(gl2.TEXTURE_2D, 0, internalFormat, width, height, 0, gl2.RGBA, texelDataType, dataForUpload));
    }
    callAndCheck(gl2, () => gl2.bindTexture(gl2.TEXTURE_2D, null));
  }
  function uploadPixelDataToTexture(gl2, texture, pixels) {
    callAndCheck(gl2, () => gl2.bindTexture(gl2.TEXTURE_2D, texture));
    if (pixels.data instanceof Uint8Array) {
      if (env().getNumber("WEBGL_VERSION") === 2) {
        callAndCheck(gl2, () => gl2.texSubImage2D(gl2.TEXTURE_2D, 0, 0, 0, pixels.width, pixels.height, gl2.RGBA, gl2.UNSIGNED_BYTE, pixels.data));
      } else {
        callAndCheck(gl2, () => gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, pixels.width, pixels.height, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, pixels.data));
      }
    } else {
      if (env().getNumber("WEBGL_VERSION") === 2) {
        callAndCheck(gl2, () => gl2.texSubImage2D(gl2.TEXTURE_2D, 0, 0, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, pixels));
      } else {
        callAndCheck(gl2, () => gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, pixels));
      }
    }
    callAndCheck(gl2, () => gl2.bindTexture(gl2.TEXTURE_2D, null));
  }
  function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {
    const buffer2 = gl2.createBuffer();
    callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer2));
    const bytesPerFloat = 4;
    const valuesPerTexel = 4;
    const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;
    callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));
    callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));
    callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));
    return buffer2;
  }
  function downloadFloat32MatrixFromBuffer(gl2, buffer2, size) {
    const gl22 = gl2;
    const downloadTarget = new Float32Array(size);
    gl22.bindBuffer(gl22.PIXEL_PACK_BUFFER, buffer2);
    gl22.getBufferSubData(gl22.PIXEL_PACK_BUFFER, 0, downloadTarget);
    gl22.bindBuffer(gl22.PIXEL_PACK_BUFFER, null);
    return downloadTarget;
  }
  function downloadByteEncodedFloatMatrixFromOutputTexture(gl2, rows, columns, textureConfig) {
    const [w2, h] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    const numChannels = 4;
    const downloadTarget = new Uint8Array(getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));
    callAndCheck(gl2, () => gl2.readPixels(0, 0, w2, h, textureConfig.downloadTextureFormat, gl2.UNSIGNED_BYTE, downloadTarget));
    return new Float32Array(downloadTarget.buffer);
  }
  function downloadPackedMatrixFromBuffer(gl2, buffer2, batch, rows, cols, physicalRows, physicalCols, textureConfig) {
    const gl22 = gl2;
    const downloadTarget = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));
    gl22.bindBuffer(gl22.PIXEL_PACK_BUFFER, buffer2);
    gl22.getBufferSubData(gl22.PIXEL_PACK_BUFFER, 0, downloadTarget);
    gl22.bindBuffer(gl22.PIXEL_PACK_BUFFER, null);
    return downloadTarget;
  }
  function downloadMatrixFromPackedOutputTexture(gl2, physicalRows, physicalCols) {
    const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);
    callAndCheck(gl2, () => gl2.readPixels(0, 0, physicalCols, physicalRows, gl2.RGBA, gl2.FLOAT, packedRGBA));
    return packedRGBA;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js
  var GPGPUContext = class {
    constructor(gl2) {
      this.outputTexture = null;
      this.program = null;
      this.disposed = false;
      this.itemsToPoll = [];
      const glVersion = env().getNumber("WEBGL_VERSION");
      if (gl2 != null) {
        this.gl = gl2;
        setWebGLContext(glVersion, gl2);
      } else {
        this.gl = getWebGLContext(glVersion);
      }
      gl2 = this.gl;
      if (env().getNumber("WEBGL_VERSION") === 2) {
        const gl22 = gl2;
        this.createVertexArray = () => {
          return callAndCheck(gl22, () => gl22.createVertexArray());
        };
        this.bindVertexArray = (vao) => {
          return callAndCheck(gl22, () => gl22.bindVertexArray(vao));
        };
        this.deleteVertexArray = (vao) => {
          return callAndCheck(gl22, () => gl22.deleteVertexArray(vao));
        };
        this.getVertexArray = () => {
          return callAndCheck(gl22, () => gl22.getParameter(gl22.VERTEX_ARRAY_BINDING));
        };
      } else if (gl2 != null) {
        const ext = gl2.getExtension("OES_vertex_array_object");
        if (ext == null) {
          throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
        }
        this.createVertexArray = () => {
          return callAndCheck(gl2, () => ext.createVertexArrayOES());
        };
        this.bindVertexArray = (vao) => {
          return callAndCheck(gl2, () => ext.bindVertexArrayOES(vao));
        };
        this.deleteVertexArray = (vao) => {
          return callAndCheck(gl2, () => ext.deleteVertexArrayOES(vao));
        };
        this.getVertexArray = () => {
          return callAndCheck(gl2, () => gl2.getParameter(ext.VERTEX_ARRAY_BINDING_OES));
        };
      }
      let COLOR_BUFFER_FLOAT = "WEBGL_color_buffer_float";
      const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
      this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile");
      if (env().getNumber("WEBGL_VERSION") === 1) {
        const TEXTURE_FLOAT = "OES_texture_float";
        const TEXTURE_HALF_FLOAT = "OES_texture_half_float";
        this.textureFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_FLOAT);
        if (hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {
          this.textureHalfFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);
        } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
          throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        }
        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
        if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
          this.colorBufferHalfFloatExtension = getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);
        } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
          throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        }
      } else {
        COLOR_BUFFER_FLOAT = "EXT_color_buffer_float";
        if (hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {
          this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
        } else if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
          this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
        } else {
          throw new Error("GL context does not support color renderable floats");
        }
      }
      this.vertexBuffer = createVertexBuffer(this.gl);
      this.indexBuffer = createIndexBuffer(this.gl);
      this.framebuffer = createFramebuffer(this.gl);
      this.textureConfig = getTextureConfig(this.gl, this.textureHalfFloatExtension);
    }
    get debug() {
      return env().getBool("DEBUG");
    }
    dispose() {
      if (this.disposed) {
        return;
      }
      if (this.program != null) {
        console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.");
      }
      if (this.outputTexture != null) {
        console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      }
      const gl2 = this.gl;
      callAndCheck(gl2, () => gl2.finish());
      callAndCheck(gl2, () => gl2.bindFramebuffer(gl2.FRAMEBUFFER, null));
      callAndCheck(gl2, () => gl2.deleteFramebuffer(this.framebuffer));
      callAndCheck(gl2, () => gl2.bindBuffer(gl2.ARRAY_BUFFER, null));
      callAndCheck(gl2, () => gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, null));
      callAndCheck(gl2, () => gl2.deleteBuffer(this.indexBuffer));
      this.disposed = true;
    }
    createFloat32MatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createFloat16MatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createUnsignedBytesMatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    uploadPixelDataToTexture(texture, pixels) {
      this.throwIfDisposed();
      uploadPixelDataToTexture(this.gl, texture, pixels);
    }
    uploadDenseMatrixToTexture(texture, width, height, data) {
      this.throwIfDisposed();
      uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);
    }
    createFloat16PackedMatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createPackedMatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    deleteMatrixTexture(texture) {
      this.throwIfDisposed();
      if (this.outputTexture === texture) {
        unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        this.outputTexture = null;
      }
      callAndCheck(this.gl, () => this.gl.deleteTexture(texture));
    }
    downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {
      return this.downloadMatrixDriver(texture, () => downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));
    }
    downloadPackedMatrixFromBuffer(buffer2, batch, rows, columns, physicalRows, physicalCols) {
      return downloadPackedMatrixFromBuffer(this.gl, buffer2, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);
    }
    downloadFloat32MatrixFromBuffer(buffer2, size) {
      return downloadFloat32MatrixFromBuffer(this.gl, buffer2, size);
    }
    createBufferFromTexture(texture, rows, columns) {
      this.bindTextureToFrameBuffer(texture);
      const result = createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);
      this.unbindTextureToFrameBuffer();
      return result;
    }
    createAndWaitForFence() {
      const fenceContext = this.createFence(this.gl);
      return this.pollFence(fenceContext);
    }
    createFence(gl2) {
      let query;
      let isFencePassed;
      if (env().getBool("WEBGL_FENCE_API_ENABLED")) {
        const gl22 = gl2;
        const sync = gl22.fenceSync(gl22.SYNC_GPU_COMMANDS_COMPLETE, 0);
        gl2.flush();
        isFencePassed = () => {
          const status = gl22.clientWaitSync(sync, 0, 0);
          return status === gl22.ALREADY_SIGNALED || status === gl22.CONDITION_SATISFIED;
        };
        query = sync;
      } else if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
        query = this.beginQuery();
        this.endQuery();
        isFencePassed = () => this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
      } else {
        isFencePassed = () => true;
      }
      return { query, isFencePassed };
    }
    downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {
      return this.downloadMatrixDriver(texture, () => downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));
    }
    createProgram(fragmentShader) {
      this.throwIfDisposed();
      const gl2 = this.gl;
      if (this.vertexShader == null) {
        this.vertexShader = createVertexShader2(gl2);
      }
      const program = createProgram(gl2);
      callAndCheck(gl2, () => gl2.attachShader(program, this.vertexShader));
      callAndCheck(gl2, () => gl2.attachShader(program, fragmentShader));
      linkProgram(gl2, program);
      let program2;
      {
        program2 = Object.assign(program, {
          vao: this.createVertexArray()
        });
        this.bindVertexArray(program2.vao);
        callAndCheck(gl2, () => gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, this.indexBuffer));
        console.assert(bindVertexProgramAttributeStreams(gl2, program2, this.vertexBuffer), "gpgpu_util.bindVertexProgramAttributeStreams not fully successful.");
        if (this.debug) {
          validateProgram(gl2, program2);
        }
      }
      this.setProgram(program2);
      return program2;
    }
    deleteProgram(program) {
      this.throwIfDisposed();
      if (program === this.program) {
        this.program = null;
      }
      if (program != null) {
        callAndCheck(this.gl, () => this.gl.deleteProgram(program));
        this.deleteVertexArray(program.vao);
      }
    }
    setProgram(program) {
      this.throwIfDisposed();
      this.program = program;
      if (this.program != null) {
        this.bindVertexArray(this.program.vao);
        if (this.debug) {
          validateProgram(this.gl, this.program);
        }
      }
      callAndCheck(this.gl, () => this.gl.useProgram(program));
    }
    getUniformLocation(program, uniformName, shouldThrow = true) {
      this.throwIfDisposed();
      if (shouldThrow) {
        return getProgramUniformLocationOrThrow(this.gl, program, uniformName);
      } else {
        return getProgramUniformLocation(this.gl, program, uniformName);
      }
    }
    getAttributeLocation(program, attribute) {
      this.throwIfDisposed();
      return callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));
    }
    getUniformLocationNoThrow(program, uniformName) {
      this.throwIfDisposed();
      return this.gl.getUniformLocation(program, uniformName);
    }
    setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {
      this.throwIfDisposed();
      this.throwIfNoProgram();
      bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);
    }
    setOutputMatrixTexture(outputMatrixTexture, rows, columns) {
      this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    }
    setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {
      this.throwIfDisposed();
      const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
      this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    }
    setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
      this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    }
    setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
      throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }
    debugValidate() {
      if (this.program != null) {
        validateProgram(this.gl, this.program);
      }
      validateFramebuffer(this.gl);
    }
    executeProgram() {
      this.throwIfDisposed();
      this.throwIfNoProgram();
      const gl2 = this.gl;
      if (this.debug) {
        const boundVao = this.getVertexArray();
        console.assert(boundVao === this.program.vao, "VAO changed between setProgram and executeProgram!");
        this.debugValidate();
      }
      callAndCheck(gl2, () => gl2.drawElements(gl2.TRIANGLES, 6, gl2.UNSIGNED_SHORT, 0));
    }
    blockUntilAllProgramsCompleted() {
      this.throwIfDisposed();
      callAndCheck(this.gl, () => this.gl.finish());
    }
    getQueryTimerExtension() {
      if (this.disjointQueryTimerExtension == null) {
        this.disjointQueryTimerExtension = getExtensionOrThrow(this.gl, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
      }
      return this.disjointQueryTimerExtension;
    }
    getQueryTimerExtensionWebGL2() {
      return this.getQueryTimerExtension();
    }
    getQueryTimerExtensionWebGL1() {
      return this.getQueryTimerExtension();
    }
    beginQuery() {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        const gl2 = this.gl;
        const ext2 = this.getQueryTimerExtensionWebGL2();
        const query2 = gl2.createQuery();
        gl2.beginQuery(ext2.TIME_ELAPSED_EXT, query2);
        return query2;
      }
      const ext = this.getQueryTimerExtensionWebGL1();
      const query = ext.createQueryEXT();
      ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
      return query;
    }
    endQuery() {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        const gl2 = this.gl;
        const ext2 = this.getQueryTimerExtensionWebGL2();
        gl2.endQuery(ext2.TIME_ELAPSED_EXT);
        return;
      }
      const ext = this.getQueryTimerExtensionWebGL1();
      ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
    }
    async waitForQueryAndGetTime(query) {
      await util_exports.repeatedTry(() => this.disposed || // while testing contexts are created / disposed
      // in rapid succession, so without this check we
      // may poll for the query timer indefinitely
      this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
      return this.getQueryTime(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }
    getQueryTime(query, queryTimerVersion) {
      if (queryTimerVersion === 0) {
        return null;
      }
      if (queryTimerVersion === 2) {
        const gl2 = this.gl;
        const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
        return timeElapsedNanos / 1e6;
      } else {
        const ext = this.getQueryTimerExtensionWebGL1();
        const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
        return timeElapsedNanos / 1e6;
      }
    }
    isQueryAvailable(query, queryTimerVersion) {
      if (queryTimerVersion === 0) {
        return true;
      }
      if (queryTimerVersion === 2) {
        const gl2 = this.gl;
        const ext = this.getQueryTimerExtensionWebGL2();
        const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
        if (this.disjoint == null) {
          this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
        }
        return available && !this.disjoint;
      } else {
        const ext = this.getQueryTimerExtensionWebGL1();
        const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
        if (this.disjoint == null) {
          this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
        }
        return available && !this.disjoint;
      }
    }
    pollFence(fenceContext) {
      return new Promise((resolve) => {
        this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());
      });
    }
    pollItems() {
      const index = linearSearchLastTrue(this.itemsToPoll.map((x2) => x2.isDoneFn));
      for (let i2 = 0; i2 <= index; ++i2) {
        const { resolveFn } = this.itemsToPoll[i2];
        resolveFn();
      }
      this.itemsToPoll = this.itemsToPoll.slice(index + 1);
    }
    addItemToPoll(isDoneFn, resolveFn) {
      this.itemsToPoll.push({ isDoneFn, resolveFn });
      if (this.itemsToPoll.length > 1) {
        return;
      }
      let scheduleFn = void 0;
      if ("setTimeoutCustom" in env().platform) {
        scheduleFn = env().platform.setTimeoutCustom.bind(env().platform);
      }
      util_exports.repeatedTry(() => {
        this.pollItems();
        return this.itemsToPoll.length === 0;
      }, () => 0, null, scheduleFn);
    }
    bindTextureToFrameBuffer(texture) {
      this.throwIfDisposed();
      bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
      if (this.debug) {
        validateFramebuffer(this.gl);
      }
    }
    unbindTextureToFrameBuffer() {
      if (this.outputTexture != null) {
        bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
        if (this.debug) {
          validateFramebuffer(this.gl);
        }
      } else {
        unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
      }
    }
    downloadMatrixDriver(texture, downloadAndDecode) {
      this.bindTextureToFrameBuffer(texture);
      const result = downloadAndDecode();
      this.unbindTextureToFrameBuffer();
      return result;
    }
    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {
      this.throwIfDisposed();
      const gl2 = this.gl;
      bindColorTextureToFramebuffer(gl2, outputMatrixTextureMaybePacked, this.framebuffer);
      if (this.debug) {
        validateFramebuffer(gl2);
      }
      this.outputTexture = outputMatrixTextureMaybePacked;
      callAndCheck(gl2, () => gl2.viewport(0, 0, width, height));
      callAndCheck(gl2, () => gl2.scissor(0, 0, width, height));
    }
    setOutputMatrixWriteRegionDriver(x2, y2, width, height) {
      this.throwIfDisposed();
      callAndCheck(this.gl, () => this.gl.scissor(x2, y2, width, height));
    }
    throwIfDisposed() {
      if (this.disposed) {
        throw new Error("Attempted to use disposed GPGPUContext.");
      }
    }
    throwIfNoProgram() {
      if (this.program == null) {
        throw new Error("No GPU program is currently set.");
      }
    }
  };
  function linearSearchLastTrue(arr) {
    let i2 = 0;
    for (; i2 < arr.length; ++i2) {
      const isDone = arr[i2]();
      if (!isDone) {
        break;
      }
    }
    return i2 - 1;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/shared.js
  var shared_exports = {};
  __export(shared_exports, {
    addImpl: () => addImpl,
    bincountImpl: () => bincountImpl,
    bincountReduceImpl: () => bincountReduceImpl,
    castImpl: () => castImpl,
    ceilImpl: () => ceilImpl,
    concatImpl: () => concatImpl,
    equalImpl: () => equalImpl,
    expImpl: () => expImpl,
    expm1Impl: () => expm1Impl,
    floorImpl: () => floorImpl,
    gatherNdImpl: () => gatherNdImpl,
    gatherV2Impl: () => gatherV2Impl,
    greaterEqualImpl: () => greaterEqualImpl,
    greaterImpl: () => greaterImpl,
    lessEqualImpl: () => lessEqualImpl,
    lessImpl: () => lessImpl,
    linSpaceImpl: () => linSpaceImpl,
    logImpl: () => logImpl,
    maxImpl: () => maxImpl,
    maximumImpl: () => maximumImpl,
    minimumImpl: () => minimumImpl,
    multiplyImpl: () => multiplyImpl,
    negImpl: () => negImpl,
    notEqualImpl: () => notEqualImpl,
    prodImpl: () => prodImpl,
    raggedGatherImpl: () => raggedGatherImpl,
    raggedRangeImpl: () => raggedRangeImpl,
    raggedTensorToTensorImpl: () => raggedTensorToTensorImpl,
    rangeImpl: () => rangeImpl,
    rsqrtImpl: () => rsqrtImpl,
    scatterImpl: () => scatterImpl,
    sigmoidImpl: () => sigmoidImpl,
    simpleAbsImpl: () => simpleAbsImpl,
    sliceImpl: () => sliceImpl,
    sparseFillEmptyRowsImpl: () => sparseFillEmptyRowsImpl,
    sparseReshapeImpl: () => sparseReshapeImpl,
    sparseSegmentReductionImpl: () => sparseSegmentReductionImpl,
    sqrtImpl: () => sqrtImpl,
    squaredDifferenceImpl: () => squaredDifferenceImpl,
    stridedSliceImpl: () => stridedSliceImpl,
    stringNGramsImpl: () => stringNGramsImpl,
    stringSplitImpl: () => stringSplitImpl,
    stringToHashBucketFastImpl: () => stringToHashBucketFastImpl,
    subImpl: () => subImpl,
    tileImpl: () => tileImpl,
    topKImpl: () => topKImpl,
    transposeImpl: () => transposeImpl,
    uniqueImpl: () => uniqueImpl
  });

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js
  function assertNotComplex2(tensor2, opName) {
    if (!Array.isArray(tensor2)) {
      tensor2 = [tensor2];
    }
    tensor2.forEach((t3) => {
      if (t3 != null) {
        util_exports.assert(t3.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the CPU backend.`);
      }
    });
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js
  function simpleAbsImpl(vals) {
    const resultValues = new Float32Array(vals.length);
    for (let i2 = 0; i2 < vals.length; ++i2) {
      resultValues[i2] = Math.abs(vals[i2]);
    }
    return resultValues;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js
  function createSimpleBinaryKernelImpl(op2) {
    return (aShape, bShape, aVals, bVals, dtype) => {
      const newShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
      const resultRank = newShape.length;
      const resultStrides = util_exports.computeStrides(newShape);
      const resultSize = util_exports.sizeFromShape(newShape);
      const result = util_exports.getTypedArrayFromDType(dtype, resultSize);
      const aRank = aShape.length;
      const bRank = bShape.length;
      const aStrides = util_exports.computeStrides(aShape);
      const bStrides = util_exports.computeStrides(bShape);
      const aBroadcastDims = backend_util_exports.getBroadcastDims(aShape, newShape);
      const bBroadcastDims = backend_util_exports.getBroadcastDims(bShape, newShape);
      if (aBroadcastDims.length + bBroadcastDims.length === 0) {
        for (let i2 = 0; i2 < result.length; ++i2) {
          result[i2] = op2(aVals[i2 % aVals.length], bVals[i2 % bVals.length]);
        }
      } else {
        for (let i2 = 0; i2 < result.length; ++i2) {
          const loc = util_exports.indexToLoc(i2, resultRank, resultStrides);
          const aLoc = loc.slice(-aRank);
          aBroadcastDims.forEach((d2) => aLoc[d2] = 0);
          const aIndex = util_exports.locToIndex(aLoc, aRank, aStrides);
          const bLoc = loc.slice(-bRank);
          bBroadcastDims.forEach((d2) => bLoc[d2] = 0);
          const bIndex = util_exports.locToIndex(bLoc, bRank, bStrides);
          result[i2] = op2(aVals[aIndex], bVals[bIndex]);
        }
      }
      return [result, newShape];
    };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js
  function complex2(args) {
    const { inputs, backend } = args;
    const { real: real4, imag: imag3 } = inputs;
    const realVals = backend.data.get(real4.dataId).values;
    const imagVals = backend.data.get(imag3.dataId).values;
    const complexInfo = backend.makeTensorInfo(real4.shape, "complex64");
    const complex4 = backend.data.get(complexInfo.dataId);
    complex4.complexTensorInfos = {
      real: backend.makeTensorInfo(real4.shape, "float32", realVals),
      imag: backend.makeTensorInfo(imag3.shape, "float32", imagVals)
    };
    return complexInfo;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/zeros_impl.js
  function zeros2(backend, shape, dtype = "float32") {
    if (dtype === "complex64") {
      const real4 = zeros2(backend, shape, "float32");
      const imag3 = zeros2(backend, shape, "float32");
      return complex2({ inputs: { real: real4, imag: imag3 }, backend });
    }
    const values = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(shape), dtype);
    return backend.makeTensorInfo(shape, dtype, values);
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Identity.js
  function identity2(args) {
    const { inputs, backend } = args;
    const { x: x2 } = inputs;
    backend.incRef(x2.dataId);
    return { dataId: x2.dataId, shape: x2.shape, dtype: x2.dtype };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Real.js
  function real2(args) {
    const { inputs, backend } = args;
    const { input: input2 } = inputs;
    const real4 = backend.data.get(input2.dataId).complexTensorInfos.real;
    const realVal = backend.data.get(real4.dataId).values;
    return backend.makeTensorInfo(real4.shape, real4.dtype, realVal);
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cast.js
  function castImpl(values, shape, inputType, dtype) {
    if (dtype === "int32") {
      const resultValues = Int32Array.from(values);
      return [shape, "int32", resultValues];
    }
    if (dtype === "bool") {
      const zero = util_exports.toTypedArray([0], inputType);
      const [resultData, resultShape] = createSimpleBinaryKernelImpl((a2, b2) => a2 !== b2 ? 1 : 0)(shape, [], values, zero, "bool");
      return [resultShape, "bool", resultData];
    }
    throw new Error(`Error in Cast: failed to cast ${inputType} to ${dtype}`);
  }
  function cast2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { dtype } = attrs;
    if (dtype === "complex64") {
      if (x2.dtype === "complex64") {
        return identity2({ inputs: { x: x2 }, backend });
      }
      const zerosTensorInfo = zeros2(backend, x2.shape, x2.dtype);
      const floatX = cast2({ inputs: { x: x2 }, backend, attrs: { dtype: "float32" } });
      const result = complex2({ inputs: { real: floatX, imag: zerosTensorInfo }, backend });
      backend.disposeIntermediateTensorInfo(zerosTensorInfo);
      backend.disposeIntermediateTensorInfo(floatX);
      return result;
    }
    if (x2.dtype === "complex64") {
      const realPart = real2({ inputs: { input: x2 }, backend });
      const result = cast2({ inputs: { x: realPart }, backend, attrs: { dtype } });
      backend.disposeIntermediateTensorInfo(realPart);
      return result;
    }
    if (!util_exports.hasEncodingLoss(x2.dtype, dtype)) {
      const result = identity2({ inputs: { x: x2 }, backend });
      return { dataId: result.dataId, shape: result.shape, dtype };
    }
    const values = backend.data.get(x2.dataId).values;
    const [resultShape, resultType, resultData] = castImpl(values, x2.shape, x2.dtype, dtype);
    return backend.makeTensorInfo(resultShape, resultType, resultData);
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js
  function binaryKernelFunc(name, simpleImpl, complexImpl, dtype) {
    if (complexImpl == null) {
      return ({ inputs, backend }) => {
        const { a: a2, b: b2 } = inputs;
        const cpuBackend = backend;
        assertNotComplex2([a2, b2], name);
        const aVals = cpuBackend.data.get(a2.dataId).values;
        const bVals = cpuBackend.data.get(b2.dataId).values;
        const decodedAVals = a2.dtype === "string" ? (
          // tslint:disable-next-line: no-any
          backend_util_exports.fromUint8ToStringArray(aVals)
        ) : aVals;
        const decodedBVals = a2.dtype === "string" ? (
          // tslint:disable-next-line: no-any
          backend_util_exports.fromUint8ToStringArray(bVals)
        ) : bVals;
        const $dtype = dtype || a2.dtype;
        const [resultData, resultShape] = simpleImpl(a2.shape, b2.shape, decodedAVals, decodedBVals, $dtype);
        return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
      };
    }
    return ({ inputs, backend }) => {
      const { a: a2, b: b2 } = inputs;
      const cpuBackend = backend;
      if (a2.dtype === "complex64" || b2.dtype === "complex64") {
        const $aComplex = cast2({ inputs: { x: a2 }, backend: cpuBackend, attrs: { dtype: "complex64" } });
        const $aComplexVals = cpuBackend.data.get($aComplex.dataId);
        const aReal = $aComplexVals.complexTensorInfos.real;
        const aImag = $aComplexVals.complexTensorInfos.imag;
        const aRealVals = cpuBackend.data.get(aReal.dataId).values;
        const aImagVals = cpuBackend.data.get(aImag.dataId).values;
        const $bComplex = cast2({ inputs: { x: b2 }, backend: cpuBackend, attrs: { dtype: "complex64" } });
        const $bComplexVals = cpuBackend.data.get($bComplex.dataId);
        const bReal = $bComplexVals.complexTensorInfos.real;
        const bImag = $bComplexVals.complexTensorInfos.imag;
        const bRealVals = cpuBackend.data.get(bReal.dataId).values;
        const bImagVals = cpuBackend.data.get(bImag.dataId).values;
        const [resultRealData, resultImagData, resultShape] = complexImpl(a2.shape, b2.shape, aRealVals, aImagVals, bRealVals, bImagVals);
        const resultReal = cpuBackend.makeTensorInfo(resultShape, "float32", resultRealData);
        const resultImag = cpuBackend.makeTensorInfo(resultShape, "float32", resultImagData);
        const result = complex2({ inputs: { real: resultReal, imag: resultImag }, backend: cpuBackend });
        cpuBackend.disposeIntermediateTensorInfo($aComplex);
        cpuBackend.disposeIntermediateTensorInfo($bComplex);
        cpuBackend.disposeIntermediateTensorInfo(resultReal);
        cpuBackend.disposeIntermediateTensorInfo(resultImag);
        return result;
      } else {
        const aVals = cpuBackend.data.get(a2.dataId).values;
        const bVals = cpuBackend.data.get(b2.dataId).values;
        const $dtype = dtype || a2.dtype;
        const [resultData, resultShape] = simpleImpl(a2.shape, b2.shape, aVals, bVals, $dtype);
        return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
      }
    };
  }
  function createComplexBinaryKernelImpl(op2) {
    return (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals) => {
      const resultShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
      const resultSize = util_exports.sizeFromShape(resultShape);
      const resultRank = resultShape.length;
      const resultStrides = util_exports.computeStrides(resultShape);
      const resultRealVals = util_exports.getTypedArrayFromDType("float32", resultSize);
      const resultImagVals = util_exports.getTypedArrayFromDType("float32", resultSize);
      const aBroadcastDims = backend_util_exports.getBroadcastDims(aShape, resultShape);
      const bBroadcastDims = backend_util_exports.getBroadcastDims(bShape, resultShape);
      const aVals = backend_util_exports.mergeRealAndImagArrays(aRealVals, aImagVals);
      const bVals = backend_util_exports.mergeRealAndImagArrays(bRealVals, bImagVals);
      const aRank = aShape.length;
      const aStrides = util_exports.computeStrides(aShape);
      const bRank = bShape.length;
      const bStrides = util_exports.computeStrides(bShape);
      if (aBroadcastDims.length + bBroadcastDims.length === 0) {
        for (let i2 = 0; i2 < resultRealVals.length; i2++) {
          const aIdx = i2 % aVals.length;
          const bIdx = i2 % bVals.length;
          const result = op2(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);
          resultRealVals[i2] = result.real;
          resultImagVals[i2] = result.imag;
        }
      } else {
        for (let i2 = 0; i2 < resultRealVals.length; i2++) {
          const loc = util_exports.indexToLoc(i2, resultRank, resultStrides);
          const aLoc = loc.slice(-aRank);
          aBroadcastDims.forEach((d2) => aLoc[d2] = 0);
          const aIndex = util_exports.locToIndex(aLoc, aRank, aStrides);
          const bLoc = loc.slice(-bRank);
          bBroadcastDims.forEach((d2) => bLoc[d2] = 0);
          const bIndex = util_exports.locToIndex(bLoc, bRank, bStrides);
          const opResult = op2(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);
          resultRealVals[i2] = opResult.real;
          resultImagVals[i2] = opResult.imag;
        }
      }
      return [resultRealVals, resultImagVals, resultShape];
    };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js
  var addImpl = createSimpleBinaryKernelImpl((a2, b2) => a2 + b2);
  var addComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
    return { real: aReal + bReal, imag: aImag + bImag };
  });
  var add3 = binaryKernelFunc(Add2, addImpl, addComplexImpl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount_impl.js
  function bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size) {
    const weightsSize = util_exports.sizeFromShape(weightsShape);
    const outVals = util_exports.makeZerosTypedArray(size, weightsDtype);
    for (let i2 = 0; i2 < xVals.length; i2++) {
      const value = xVals[i2];
      if (value < 0) {
        throw new Error("Input x must be non-negative!");
      }
      if (value >= size) {
        continue;
      }
      if (weightsSize > 0) {
        outVals[value] += weightsVals[i2];
      } else {
        outVals[value] += 1;
      }
    }
    return outVals;
  }
  function bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput = false) {
    const numRows = xBuf.shape[0];
    const numCols = xBuf.shape[1];
    const outBuf = buffer([numRows, size], weightsBuf.dtype);
    for (let i2 = 0; i2 < numRows; i2++) {
      for (let j3 = 0; j3 < numCols; j3++) {
        const value = xBuf.get(i2, j3);
        if (value < 0) {
          throw new Error("Input x must be non-negative!");
        }
        if (value >= size) {
          continue;
        }
        if (binaryOutput) {
          outBuf.set(1, i2, value);
        } else {
          if (weightsBuf.size > 0) {
            outBuf.set(outBuf.get(i2, value) + weightsBuf.get(i2, j3), i2, value);
          } else {
            outBuf.set(outBuf.get(i2, value) + 1, i2, value);
          }
        }
      }
    }
    return outBuf;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js
  function createSimpleUnaryImpl(op2) {
    return (values, dtype, attrs) => {
      const newValues = util_exports.getTypedArrayFromDType(dtype, values.length);
      for (let i2 = 0; i2 < values.length; ++i2) {
        newValues[i2] = op2(values[i2], attrs);
      }
      return newValues;
    };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js
  function unaryKernelFunc(name, op2, dtype) {
    return ({ inputs, attrs, backend }) => {
      const { x: x2 } = inputs;
      assertNotComplex2(x2, name);
      if (x2.dtype === "string" || dtype === "string") {
        throw new Error("unaryKernelFunc does not support string input/output");
      }
      const cpuBackend = backend;
      const values = cpuBackend.data.get(x2.dataId).values;
      const xSize = util_exports.sizeFromShape(x2.shape);
      const $dtype = dtype || x2.dtype;
      const newValues = util_exports.getArrayFromDType($dtype, xSize);
      for (let i2 = 0; i2 < xSize; ++i2) {
        newValues[i2] = op2(values[i2], attrs);
      }
      return cpuBackend.makeTensorInfo(x2.shape, $dtype, newValues);
    };
  }
  function unaryKernelFuncFromImpl(name, unaryImpl, dtype) {
    return ({ inputs, attrs, backend }) => {
      const { x: x2 } = inputs;
      assertNotComplex2(x2, name);
      if (x2.dtype === "string" || dtype === "string") {
        throw new Error("unaryKernelFunc does not support string input/output");
      }
      const cpuBackend = backend;
      const values = cpuBackend.data.get(x2.dataId).values;
      const $dtype = dtype || x2.dtype;
      const newValues = unaryImpl(values, $dtype, attrs);
      return cpuBackend.makeTensorInfo(x2.shape, $dtype, newValues);
    };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js
  var ceilImpl = createSimpleUnaryImpl((xi2) => Math.ceil(xi2));
  var ceil2 = unaryKernelFuncFromImpl(Ceil, ceilImpl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js
  function concatImpl(inputs, outShape, dtype, simplyConcat) {
    const outVals = util_exports.getArrayFromDType(dtype, util_exports.sizeFromShape(outShape));
    if (simplyConcat && dtype !== "string") {
      let offset = 0;
      inputs.forEach((input2) => {
        const size = util_exports.sizeFromShape(input2.shape);
        outVals.set(input2.vals, offset);
        offset += size;
      });
    } else {
      let colOffset = 0;
      inputs.forEach((input2) => {
        const decodedData = dtype === "string" ? backend_util_exports.fromUint8ToStringArray(input2.vals) : input2.vals;
        let tIdx = 0;
        for (let row = 0; row < input2.shape[0]; ++row) {
          const resIdx = row * outShape[1] + colOffset;
          for (let col = 0; col < input2.shape[1]; ++col) {
            outVals[resIdx + col] = decodedData[tIdx++];
          }
        }
        colOffset += input2.shape[1];
      });
    }
    return outVals;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Equal.js
  var equalImpl = createSimpleBinaryKernelImpl((a2, b2) => a2 === b2 ? 1 : 0);
  var equal2 = binaryKernelFunc(Equal, equalImpl, null, "bool");

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js
  var expImpl = createSimpleUnaryImpl((xi2) => Math.exp(xi2));
  var exp2 = unaryKernelFuncFromImpl(Exp, expImpl, "float32");

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js
  var expm1Impl = createSimpleUnaryImpl((xi2) => Math.expm1(xi2));
  var expm12 = unaryKernelFuncFromImpl(Expm1, expm1Impl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js
  var floorImpl = createSimpleUnaryImpl((xi2) => Math.floor(xi2));
  var floor2 = unaryKernelFuncFromImpl(Floor, floorImpl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherNd_Impl.js
  function gatherNdImpl(indicesData, paramsBuf, dtype, numSlices, sliceRank, sliceSize, strides, paramsShape, paramsSize) {
    const outBuf = buffer([numSlices, sliceSize], dtype);
    for (let i2 = 0; i2 < numSlices; i2++) {
      const index = [];
      let flattenIndex = 0;
      for (let j3 = 0; j3 < sliceRank; j3++) {
        const dim = indicesData[i2 * sliceRank + j3];
        flattenIndex += dim * strides[j3];
        index.push(dim);
      }
      if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {
        throw new Error(`Invalid indices: ${index} does not index into ${paramsShape}`);
      }
      for (let k4 = 0; k4 < sliceSize; k4++) {
        outBuf.values[i2 * sliceSize + k4] = paramsBuf.get(...paramsBuf.indexToLoc(flattenIndex * sliceSize + k4));
      }
    }
    return outBuf;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js
  function gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {
    const outBuf = buffer(flattenOutputShape, xBuf.dtype);
    for (let i2 = 0; i2 < outBuf.size; ++i2) {
      const newLoc = outBuf.indexToLoc(i2);
      const originalLoc = newLoc.slice();
      const batchIdx = originalLoc[0];
      const indicesIdx = originalLoc[2];
      const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);
      originalLoc[2] = indicesBuf.values[indicesIndex];
      const originalIndex = xBuf.locToIndex(originalLoc);
      if (0 <= originalIndex && originalIndex < xBuf.values.length) {
        outBuf.values[i2] = xBuf.values[originalIndex];
      }
    }
    return outBuf;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Greater.js
  var greaterImpl = createSimpleBinaryKernelImpl((a2, b2) => a2 > b2 ? 1 : 0);
  var greater2 = binaryKernelFunc(Greater, greaterImpl, null, "bool");

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GreaterEqual.js
  var greaterEqualImpl = createSimpleBinaryKernelImpl((a2, b2) => a2 >= b2 ? 1 : 0);
  var greaterEqual2 = binaryKernelFunc(GreaterEqual, greaterEqualImpl, null, "bool");

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Less.js
  var lessImpl = createSimpleBinaryKernelImpl((a2, b2) => a2 < b2 ? 1 : 0);
  var less3 = binaryKernelFunc(Less, lessImpl, null, "bool");

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LessEqual.js
  var lessEqualImpl = createSimpleBinaryKernelImpl((a2, b2) => a2 <= b2 ? 1 : 0);
  var lessEqual2 = binaryKernelFunc(LessEqual, lessEqualImpl, null, "bool");

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js
  function linSpaceImpl(start, stop, num) {
    const step3 = (stop - start) / (num - 1);
    const values = util_exports.makeZerosTypedArray(num, "float32");
    values[0] = start;
    for (let i2 = 1; i2 < values.length; i2++) {
      values[i2] = values[i2 - 1] + step3;
    }
    return values;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js
  var logImpl = createSimpleUnaryImpl((xi2) => Math.log(xi2));
  var log3 = unaryKernelFuncFromImpl(Log, logImpl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js
  function maxImpl(aVals, reduceSize, outShape, dtype) {
    const vals = util_exports.getTypedArrayFromDType(dtype, util_exports.sizeFromShape(outShape));
    for (let i2 = 0; i2 < vals.length; ++i2) {
      const offset = i2 * reduceSize;
      let max3 = aVals[offset];
      for (let j3 = 0; j3 < reduceSize; ++j3) {
        const value = aVals[offset + j3];
        if (Number.isNaN(value) || value > max3) {
          max3 = value;
        }
      }
      vals[i2] = max3;
    }
    return vals;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Maximum.js
  var maximumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.max(aValue, bValue));
  var maximum2 = binaryKernelFunc(Maximum2, maximumImpl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Minimum.js
  var minimumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.min(aValue, bValue));
  var minimum2 = binaryKernelFunc(Minimum2, minimumImpl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js
  var multiplyImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue * bValue);
  var multiplyComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
    return {
      real: aReal * bReal - aImag * bImag,
      imag: aReal * bImag + aImag * bReal
    };
  });
  var multiply = binaryKernelFunc(Multiply2, multiplyImpl, multiplyComplexImpl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Neg.js
  function negImpl(xVals, xShape, xDtype) {
    const minusOne = util_exports.createScalarValue(-1, xDtype);
    return multiplyImpl([], xShape, minusOne, xVals, xDtype);
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NotEqual.js
  var notEqualImpl = createSimpleBinaryKernelImpl((a2, b2) => a2 !== b2 ? 1 : 0);
  var notEqual2 = binaryKernelFunc(NotEqual, notEqualImpl, null, "bool");

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js
  function transposeImpl(xVals, xShape, dtype, perm, newShape) {
    const xRank = xShape.length;
    const xSize = util_exports.sizeFromShape(xShape);
    const xStrides = util_exports.computeStrides(xShape);
    const newStrides = util_exports.computeStrides(newShape);
    const result = util_exports.getTypedArrayFromDType(dtype, util_exports.sizeFromShape(newShape));
    for (let i2 = 0; i2 < xSize; ++i2) {
      const loc = util_exports.indexToLoc(i2, xRank, xStrides);
      const newLoc = new Array(loc.length);
      for (let i3 = 0; i3 < newLoc.length; i3++) {
        newLoc[i3] = loc[perm[i3]];
      }
      const newIndex = util_exports.locToIndex(newLoc, xRank, newStrides);
      result[newIndex] = xVals[i2];
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Prod.js
  function prodImpl(xShape, xDtype, xVals, reductionAxes) {
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(xShape, reductionAxes);
    const outDtype = upcastType(xDtype, "int32");
    const outVals = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(outShape), outDtype);
    const reduceSize = util_exports.sizeFromShape(reduceShape);
    for (let i2 = 0; i2 < outVals.length; ++i2) {
      const offset = i2 * reduceSize;
      let prod3 = 1;
      for (let j3 = 0; j3 < reduceSize; ++j3) {
        prod3 *= xVals[offset + j3];
      }
      outVals[i2] = prod3;
    }
    return { outVals, outShape, outDtype };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedGather_impl.js
  function validateIndices(indices, indicesShape, numParams) {
    indices.forEach((index, i2) => {
      if (index < 0 || index >= numParams) {
        const locString = util_exports.indexToLoc(i2, indicesShape.length, util_exports.computeStrides(indicesShape)).join(",");
        throw new Error(`indices[${locString}] = ${index} is not in [0, ${numParams})`);
      }
    });
  }
  function validateSplits(paramsNestedSplits, numParamsDenseValues) {
    for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {
      const splits = paramsNestedSplits[dim];
      const lastSplit = dim === paramsNestedSplits.length - 1 ? numParamsDenseValues : paramsNestedSplits[dim + 1].length;
      if (splits.length === 0) {
        throw new Error("Ragged splits may not be empty");
      }
      if (splits[0] < 0) {
        throw new Error("Ragged splits must be non-negative");
      }
      if (splits[splits.length - 1] > lastSplit) {
        throw new Error("Ragged splits must not point past values");
      }
      for (let i2 = 1; i2 < splits.length; ++i2) {
        if (splits[i2 - 1] > splits[i2]) {
          throw new Error("Ragged splits must be sorted in ascending order");
        }
      }
    }
  }
  function makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues) {
    const valueSlices = [];
    let numValues = 0;
    const numSplits = indicesShape.length - 1 + paramsNestedSplits.length;
    const outSplits = new Array(numSplits).fill(null).map(() => [0]);
    validateSplits(paramsNestedSplits, numParamsDenseValues);
    let nrows = 1;
    for (let dim = 0; dim < indicesShape.length - 1; ++dim) {
      nrows *= indicesShape[dim];
      const rowLength = indicesShape[dim + 1];
      for (let i2 = 1; i2 < nrows + 1; ++i2) {
        outSplits[dim].push(i2 * rowLength);
      }
    }
    for (let i2 = 0; i2 < indices.length; ++i2) {
      let start = indices[i2];
      let limit = indices[i2] + 1;
      for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {
        const splits = paramsNestedSplits[dim];
        const outDim = dim + indicesShape.length - 1;
        if (outDim >= 0) {
          const outSplitsOutDim = outSplits[outDim];
          const delta = outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];
          for (let j3 = start; j3 < limit; ++j3) {
            outSplits[outDim].push(splits[j3 + 1] + delta);
          }
        }
        start = splits[start];
        limit = splits[limit];
      }
      if (limit !== start) {
        valueSlices.push([start, limit]);
        numValues += limit - start;
      }
    }
    return { outSplits, valueSlices, numValues };
  }
  function getSplits(outSplits) {
    const splitsOut = [];
    for (let i2 = 0; i2 < outSplits.length; ++i2) {
      const numSplits = outSplits[i2].length;
      const splits = util_exports.getArrayFromDType("int32", numSplits);
      splitsOut.push(splits);
      outSplits[i2].forEach((value, j3) => splits[j3] = value);
    }
    return splitsOut;
  }
  function computeFlatOuterDims(orig, numOutDims) {
    const outDims = orig.slice(0, numOutDims);
    while (outDims.length < numOutDims) {
      outDims.push(1);
    }
    for (let inDim = numOutDims; inDim < orig.length; inDim++) {
      outDims[numOutDims - 1] *= orig[inDim];
    }
    return outDims;
  }
  function writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, values, valuesShape) {
    const denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];
    const valuesM = computeFlatOuterDims(valuesShape, 2)[1];
    let outPos = 0;
    for (const slice3 of valueSlices) {
      for (let i2 = slice3[0]; i2 < slice3[1]; ++i2) {
        for (let j3 = 0; j3 < valueSize; ++j3) {
          values[outPos * valuesM + j3] = paramsDenseValues[i2 * denseM + j3];
        }
        ++outPos;
      }
    }
  }
  function getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues) {
    const valuesShape = paramsDenseValuesShape.slice();
    valuesShape[0] = numValues;
    const valuesOut = util_exports.getArrayFromDType(paramsDenseValuesDType, util_exports.sizeFromShape(valuesShape));
    const numElements = paramsDenseValues.length;
    const valueSize = numElements === 0 ? 0 : numElements / paramsDenseValuesShape[0];
    writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, valuesOut, valuesShape);
    return [valuesOut, valuesShape];
  }
  function raggedGatherImpl(paramsNestedSplits, paramsNestedSplitsShapes, paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, indices, indicesShape, outputRaggedRank) {
    if (paramsNestedSplits.length === 0) {
      throw new Error("paramsNestedSplits must be non empty");
    }
    if (paramsNestedSplitsShapes[0].length === 0) {
      throw new Error("Split tensors must not be scalars");
    }
    const numParams = paramsNestedSplitsShapes[0][0] - 1;
    validateIndices(indices, indicesShape, numParams);
    if (paramsDenseValuesShape.length === 0) {
      throw new Error("params.rank must be nonzero");
    }
    const numParamsDenseValues = paramsDenseValuesShape[0];
    const { outSplits, valueSlices, numValues } = makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues);
    const outputNestedSplits = getSplits(outSplits);
    const outputDenseValues = getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues);
    return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedRange_impl.js
  var INT32_MAX2 = 2147483647;
  function raggedRangeImpl(starts, startsShape, startsDType, limits, limitsShape, deltas, deltasShape) {
    if (startsShape.length > 1) {
      throw new Error("starts must be a scalar or vector");
    }
    if (limitsShape.length > 1) {
      throw new Error("limits must be a scalar or vector");
    }
    if (deltasShape.length > 1) {
      throw new Error("deltas must be a scalar or vector");
    }
    const broadcastStarts = startsShape.length === 0;
    const broadcastLimits = limitsShape.length === 0;
    const broadcastDeltas = deltasShape.length === 0;
    const inSizes = [];
    if (!broadcastStarts) {
      inSizes.push(startsShape[0]);
    }
    if (!broadcastLimits) {
      inSizes.push(limitsShape[0]);
    }
    if (!broadcastDeltas) {
      inSizes.push(deltasShape[0]);
    }
    for (let i2 = 1; i2 < inSizes.length; ++i2) {
      if (inSizes[i2] !== inSizes[i2 - 1]) {
        throw new Error("starts, limits, and deltas must have the same shape");
      }
    }
    const nRows = inSizes.length === 0 ? 1 : inSizes[0];
    const rtNestedSplits = util_exports.getArrayFromDType("int32", nRows + 1);
    rtNestedSplits[0] = 0;
    for (let row = 0; row < nRows; ++row) {
      const start = broadcastStarts ? starts[0] : starts[row];
      const limit = broadcastLimits ? limits[0] : limits[row];
      const delta = broadcastDeltas ? deltas[0] : deltas[row];
      if (delta === 0) {
        throw new Error("Requires delta != 0");
      }
      let size;
      if (delta > 0 && limit < start || delta < 0 && limit > start) {
        size = 0;
      } else {
        size = Math.ceil(Math.abs((limit - start) / delta));
        if (size > INT32_MAX2) {
          throw new Error(`Requires ((limit - start) / delta) <= ${INT32_MAX2}`);
        }
      }
      rtNestedSplits[row + 1] = rtNestedSplits[row] + size;
    }
    const nVals = rtNestedSplits[nRows];
    const rtDenseValues = util_exports.getArrayFromDType(startsDType, nVals);
    let valueIndex = 0;
    for (let row = 0; row < nRows; ++row) {
      const rowSize = rtNestedSplits[row + 1] - rtNestedSplits[row];
      let value = broadcastStarts ? starts[0] : starts[row];
      const delta = broadcastDeltas ? deltas[0] : deltas[row];
      for (let i2 = 0; i2 < rowSize; ++i2) {
        rtDenseValues[valueIndex++] = value;
        value += delta;
      }
    }
    return [rtNestedSplits, rtDenseValues];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedTensorToTensor_impl.js
  var RowPartitionType2 = backend_util_exports.RowPartitionType;
  var RaggedTensorToTensorOp = class {
    constructor(shape, shapeShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypeStrings) {
      this.shape = shape;
      this.shapeShape = shapeShape;
      this.values = values;
      this.valuesShape = valuesShape;
      this.valuesDType = valuesDType;
      this.defaultValue = defaultValue;
      this.defaultValueShape = defaultValueShape;
      this.rowPartitionValues = rowPartitionValues;
      this.rowPartitionValuesShapes = rowPartitionValuesShapes;
      this.rowPartitionTypes = backend_util_exports.getRowPartitionTypesHelper(rowPartitionTypeStrings);
      this.raggedRank = backend_util_exports.getRaggedRank(this.rowPartitionTypes);
    }
    getRowPartitionTypeByDimension(dimension) {
      if (this.rowPartitionTypes[0] === RowPartitionType2.FIRST_DIM_SIZE) {
        return this.rowPartitionTypes[dimension + 1];
      } else {
        return this.rowPartitionTypes[dimension];
      }
    }
    // Returns the relationship between dimension and dimension + 1.
    getRowPartitionTensor(dimension) {
      if (this.rowPartitionTypes[0] === RowPartitionType2.FIRST_DIM_SIZE) {
        return this.rowPartitionValues[dimension + 1];
      } else {
        return this.rowPartitionValues[dimension];
      }
    }
    getMaxWidth(dimension) {
      const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);
      switch (this.getRowPartitionTypeByDimension(dimension - 1)) {
        case RowPartitionType2.VALUE_ROWIDS:
          return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);
        case RowPartitionType2.ROW_SPLITS:
          return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);
        default:
          throw new Error(`Cannot handle partition type ${RowPartitionType2[this.getRowPartitionTypeByDimension(dimension - 1)]}`);
      }
    }
    static getMaxWidthRowSplit(rowSplit) {
      const tensorLength = rowSplit.length;
      if (tensorLength === 0 || tensorLength === 1) {
        return 0;
      }
      let maxWidth = 0;
      for (let i2 = 0; i2 < tensorLength - 1; ++i2) {
        const currentWidth = rowSplit[i2 + 1] - rowSplit[i2];
        if (currentWidth > maxWidth) {
          maxWidth = currentWidth;
        }
      }
      return maxWidth;
    }
    static getMaxWidthValueRowID(valueRowIds) {
      const indexLength = valueRowIds.length;
      if (indexLength === 0) {
        return 0;
      }
      let firstEqualIndex = 0;
      let firstEqualIndexValue = valueRowIds[0];
      let maxWidth = 0;
      for (let i2 = 1; i2 < indexLength; ++i2) {
        const value = valueRowIds[i2];
        if (value !== firstEqualIndexValue) {
          firstEqualIndexValue = value;
          maxWidth = Math.max(i2 - firstEqualIndex, maxWidth);
          firstEqualIndex = i2;
        }
      }
      return Math.max(indexLength - firstEqualIndex, maxWidth);
    }
    tensorShapeFromTensor(t3, tShape, isPartial = true) {
      if (tShape.length === 0) {
        if (t3[0] === -1) {
          return [];
        }
        throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`);
      }
      return makeShape(t3, isPartial);
    }
    calculateOutputSize(firstDim) {
      const valueShape = this.valuesShape;
      const defaultValueShape = this.defaultValueShape;
      backend_util_exports.validateDefaultValueShape(defaultValueShape, valueShape);
      const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);
      const outputShape = backend_util_exports.combineRaggedTensorToTensorShapes(this.raggedRank, shape, valueShape);
      const result = outputShape;
      if (result[0] < 0) {
        result[0] = firstDim;
      }
      for (let i2 = 1; i2 <= this.raggedRank; ++i2) {
        if (result[i2] < 0) {
          result[i2] = this.getMaxWidth(i2);
        }
      }
      return result;
    }
    /**
     * The outputIndex represents the index in the output tensor
     * where the first element of a particular dimension would be written.
     * If it is -1, it indicates that the index is out of scope.
     * Example, given firstDimension = 10, firstDimensionOutput = 6,
     * and outputIndexMultiplier = 100:
     * result = [0 100 200 300 400 500 -1 -1 -1 -1]
     * If firstDimensionOutput = 11 instead, then:
     * result = [0 100 200 300 400 500 600 700 800 900]
     */
    calculateFirstParentOutputIndex(firstDimension, outputIndexMultiplier, firstDimensionOutput) {
      const minDimension = Math.min(firstDimension, firstDimensionOutput);
      const result = [];
      let currentOutputIndex = 0;
      for (let i2 = 0; i2 < minDimension; ++i2, currentOutputIndex += outputIndexMultiplier) {
        result.push(currentOutputIndex);
      }
      for (let i2 = minDimension; i2 < firstDimension; ++i2) {
        result.push(-1);
      }
      util_exports.assert(result.length === firstDimension, () => "Final length of result must be equal to firstDimension.");
      return result;
    }
    calculateOutputIndexRowSplit(rowSplit, parentOutputIndex, outputIndexMultiplier, outputSize) {
      const rowSplitSize = rowSplit.length;
      const result = [];
      for (let i2 = 0; i2 < rowSplitSize - 1; ++i2) {
        const rowLength = rowSplit[i2 + 1] - rowSplit[i2];
        let realLength = Math.min(outputSize, rowLength);
        let parentOutputIndexCurrent = parentOutputIndex[i2];
        if (parentOutputIndexCurrent === -1) {
          realLength = 0;
        }
        for (let j3 = 0; j3 < realLength; ++j3) {
          result.push(parentOutputIndexCurrent);
          parentOutputIndexCurrent += outputIndexMultiplier;
        }
        for (let j3 = 0; j3 < rowLength - realLength; ++j3) {
          result.push(-1);
        }
      }
      if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {
        throw new Error("Invalid row split size.");
      }
      return result;
    }
    // Calculate the output index of the first element of a list.
    // The parentOutputIndex is the same computation for the previous list.
    // -1 indicates an element or list that is out of range.
    // The outputIndexMultiplier is the number of output indices one moves
    // forward for each column.
    // E.g., given:
    // valueRowIds:[0 1 2 2 2 3 5 5 6]
    // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]
    // outputIndexMultiplier: 10
    // outputSize: 2
    // You get:
    // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]
    // result[0] = parentOutputIndex[valueRowIds[0]]
    // result[1] = parentOutputIndex[valueRowIds[1]]
    // result[2] = parentOutputIndex[valueRowIds[2]]
    // result[3] = parentOutputIndex[valueRowIds[2] + 10]
    // result[4] = -1 because it is the third element the size is 2.
    // result[5] = parentOutputIndex[valueRowIds[3]]
    // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1
    // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1
    // result[8] = parentOutputIndex[valueRowIds[7]]
    calculateOutputIndexValueRowID(valueRowIds, parentOutputIndex, outputIndexMultiplier, outputSize) {
      const indexSize = valueRowIds.length;
      const result = [];
      if (indexSize === 0) {
        return [];
      }
      let currentOutputColumn = 0;
      let currentValueRowId = valueRowIds[0];
      if (currentValueRowId >= parentOutputIndex.length) {
        throw new Error(`Got currentValueRowId=${currentValueRowId}, which is not less than ${parentOutputIndex.length}`);
      }
      let currentOutputIndex = parentOutputIndex[currentValueRowId];
      result.push(currentOutputIndex);
      for (let i2 = 1; i2 < indexSize; ++i2) {
        const nextValueRowId = valueRowIds[i2];
        if (nextValueRowId === currentValueRowId) {
          if (currentOutputIndex >= 0) {
            ++currentOutputColumn;
            if (currentOutputColumn < outputSize) {
              currentOutputIndex += outputIndexMultiplier;
            } else {
              currentOutputIndex = -1;
            }
          }
        } else {
          currentOutputColumn = 0;
          currentValueRowId = nextValueRowId;
          if (nextValueRowId >= parentOutputIndex.length) {
            throw new Error(`Got nextValueRowId=${nextValueRowId} which is not less than ${parentOutputIndex.length}`);
          }
          currentOutputIndex = parentOutputIndex[nextValueRowId];
        }
        result.push(currentOutputIndex);
      }
      if (result.length !== valueRowIds.length) {
        throw new Error("Invalid row ids.");
      }
      return result;
    }
    calculateOutputIndex(dimension, parentOutputIndex, outputIndexMultiplier, outputSize) {
      const rowPartitionTensor = this.getRowPartitionTensor(dimension);
      const partitionType = this.getRowPartitionTypeByDimension(dimension);
      switch (partitionType) {
        case RowPartitionType2.VALUE_ROWIDS:
          return this.calculateOutputIndexValueRowID(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);
        case RowPartitionType2.ROW_SPLITS:
          if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {
            throw new Error(`Row partition size is greater than output size: ${rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);
          }
          return this.calculateOutputIndexRowSplit(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);
        default:
          throw new Error(`Unsupported partition type: ${RowPartitionType2[partitionType]}`);
      }
    }
    getFirstDimensionSize() {
      const firstPartitionTensor = this.rowPartitionValues[0];
      if (this.rowPartitionTypes.length === 0) {
        throw new Error("No row_partition_types given.");
      }
      const firstPartitionType = this.rowPartitionTypes[0];
      switch (firstPartitionType) {
        case RowPartitionType2.FIRST_DIM_SIZE:
          return firstPartitionTensor[0];
        case RowPartitionType2.VALUE_ROWIDS:
          throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
        case RowPartitionType2.ROW_SPLITS:
          return this.rowPartitionValuesShapes[0][0] - 1;
        default:
          throw new Error(`Cannot handle type ${RowPartitionType2[firstPartitionType]}`);
      }
    }
    compute() {
      const firstPartitionTensor = this.rowPartitionValues[0];
      if (firstPartitionTensor.length <= 0) {
        throw new Error("Invalid first partition input. Tensor requires at least one element.");
      }
      const firstDimension = this.getFirstDimensionSize();
      const outputSize = this.calculateOutputSize(firstDimension);
      const multiplier = new Array(this.raggedRank + 1);
      multiplier[multiplier.length - 1] = 1;
      for (let i2 = multiplier.length - 2; i2 >= 0; --i2) {
        multiplier[i2] = multiplier[i2 + 1] * outputSize[i2 + 1];
      }
      const outputShape = makeShape(outputSize, false);
      const outputTensor = util_exports.getArrayFromDType(this.valuesDType, util_exports.sizeFromShape(outputShape));
      const fullSize = multiplier[0] * outputSize[0];
      if (fullSize > 0) {
        let outputIndex = this.calculateFirstParentOutputIndex(firstDimension, multiplier[0], outputSize[0]);
        for (let i2 = 1; i2 <= this.raggedRank; ++i2) {
          const newOutputIndex = this.calculateOutputIndex(i2 - 1, outputIndex, multiplier[i2], outputSize[i2]);
          outputIndex = newOutputIndex;
        }
        this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);
      }
      return [outputShape, outputTensor];
    }
    setOutput(raggedRank, outputIndex, outputTensor, outputShape) {
      if (outputTensor.length === 0) {
        return;
      }
      const valuesBase = this.values;
      const outputBase = outputTensor;
      let elementShape = outputShape.slice();
      elementShape = elementShape.slice(raggedRank + 1);
      const valueElementSize = util_exports.sizeFromShape(elementShape);
      const outputIndexSize = outputIndex.length;
      let defaultValue = this.defaultValue;
      if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {
        const srcShape = this.defaultValueShape;
        tidy(() => {
          const defaultValueTensor = reshape2(defaultValue, srcShape);
          const bCastDefault = broadcastTo(defaultValueTensor, elementShape);
          defaultValue = bCastDefault.dataSync();
        });
      }
      let srcStart = 0;
      let dstStart = 0;
      let dstEnd = 0;
      for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {
        let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;
        if (dstI === dstEnd) {
          ++dstEnd;
          continue;
        }
        if (dstStart < dstEnd) {
          const src = valuesBase.subarray(srcStart * valueElementSize);
          const dst = outputBase.subarray(dstStart * valueElementSize);
          const nVals = (dstEnd - dstStart) * valueElementSize;
          copyArray(dst, src, nVals);
        }
        if (srcI >= outputIndexSize) {
          const outputSize = outputTensor.length;
          dstI = Math.floor(outputSize / valueElementSize);
        }
        if (dstI > dstEnd) {
          if (this.defaultValue.length === 1) {
            outputBase.subarray(dstEnd * valueElementSize, dstI * valueElementSize).fill(this.defaultValue[0]);
            dstEnd = dstI;
          } else {
            while (dstI > dstEnd) {
              const dst = outputBase.slice(dstEnd * valueElementSize);
              copyArray(dst, defaultValue, valueElementSize);
              ++dstEnd;
            }
          }
        }
        if (dstI < 0) {
          srcStart = srcI + 1;
          dstStart = dstEnd;
        } else {
          srcStart = srcI;
          dstStart = dstEnd;
          dstEnd = dstStart + 1;
        }
      }
    }
  };
  function copyArray(dst, src, size) {
    for (let i2 = 0; i2 < size; i2++) {
      dst[i2] = src[i2];
    }
  }
  function makeShape(shape, isPartial) {
    const out = [];
    for (let dim of shape) {
      if (dim < 0) {
        if (!isPartial) {
          throw new Error(`Dimension ${dim} must be >= 0`);
        }
        if (dim < -1) {
          throw new Error(`Dimension ${dim} must be >= -1`);
        }
        dim = -1;
      }
      out.push(dim);
    }
    return out;
  }
  function raggedTensorToTensorImpl(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes) {
    return new RaggedTensorToTensorOp(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes).compute();
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js
  function rangeImpl(start, stop, step3, dtype) {
    const sameStartStop = start === stop;
    const increasingRangeNegativeStep = start < stop && step3 < 0;
    const decreasingRangePositiveStep = stop < start && step3 > 1;
    if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {
      return util_exports.makeZerosTypedArray(0, dtype);
    }
    const numElements = Math.abs(Math.ceil((stop - start) / step3));
    const values = util_exports.makeZerosTypedArray(numElements, dtype);
    if (stop < start && step3 === 1) {
      step3 = -1;
    }
    values[0] = start;
    for (let i2 = 1; i2 < values.length; i2++) {
      values[i2] = values[i2 - 1] + step3;
    }
    return values;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js
  var rsqrtImpl = createSimpleUnaryImpl((xi2) => 1 / Math.sqrt(xi2));
  var rsqrt2 = unaryKernelFuncFromImpl(Rsqrt, rsqrtImpl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Scatter_impl.js
  function scatterImpl(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {
    const flattenShape = [outputSize / sliceSize, sliceSize];
    const indicesData = indices.values;
    const updatesData = updates.values;
    if (outputSize === 0) {
      return buffer(shape, updates.dtype);
    }
    const outBuf = buffer(flattenShape, updates.dtype);
    if (typeof defaultValue === "string") {
      outBuf.values.fill(defaultValue);
    } else if (typeof defaultValue === "number") {
      outBuf.values.fill(defaultValue);
    } else if (typeof defaultValue === "boolean") {
      outBuf.values.fill(+defaultValue);
    }
    for (let i2 = 0; i2 < numUpdates; i2++) {
      const index = [];
      let flattenIndex = 0;
      for (let j3 = 0; j3 < sliceRank; j3++) {
        const dim = indicesData[i2 * sliceRank + j3];
        index.push(dim);
        flattenIndex += dim * strides[j3];
      }
      if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {
        throw new Error(`Invalid indices: ${index} does not index into ${shape}`);
      }
      for (let k4 = 0; k4 < sliceSize; k4++) {
        if (sumDupeIndices) {
          outBuf.values[flattenIndex * sliceSize + k4] += updatesData[i2 * sliceSize + k4];
        } else {
          outBuf.values[flattenIndex * sliceSize + k4] = updates.rank === 0 ? updatesData[0] : updatesData[i2 * sliceSize + k4];
        }
      }
    }
    return outBuf;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sigmoid.js
  var sigmoidImpl = createSimpleUnaryImpl((xi2) => 1 / (1 + Math.exp(-xi2)));
  var sigmoid2 = unaryKernelFunc(Sigmoid2, (xi2) => 1 / (1 + Math.exp(-xi2)));

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js
  function sliceImpl(vals, begin, size, shape, dtype) {
    const isContinous = slice_util_exports.isSliceContinous(shape, begin, size);
    const length = util_exports.sizeFromShape(size);
    const xStrides = util_exports.computeStrides(shape);
    if (isContinous) {
      const flatOffset = slice_util_exports.computeFlatOffset(begin, xStrides);
      if (dtype === "string") {
        return vals.slice(flatOffset, flatOffset + length);
      }
      return vals.subarray(flatOffset, flatOffset + length);
    }
    const decodedData = dtype === "string" ? backend_util_exports.fromUint8ToStringArray(vals) : vals;
    const inBuf = buffer(shape, dtype, decodedData);
    const outBuf = buffer(size, dtype);
    for (let i2 = 0; i2 < outBuf.size; ++i2) {
      const outLoc = outBuf.indexToLoc(i2);
      const inLoc = outLoc.map((idx, j3) => idx + begin[j3]);
      outBuf.set(inBuf.get(...inLoc), ...outLoc);
    }
    if (dtype === "string") {
      return backend_util_exports.fromStringArrayToUint8(outBuf.values);
    }
    return outBuf.values;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows_impl.js
  function sparseFillEmptyRowsImpl(indices, indicesShape, indicesDType, values, valuesDType, denseShape, defaultValue) {
    const indicesCount = indicesShape[0];
    const denseRows = denseShape[0];
    const emptyRowIndicator = new Array(denseRows);
    const reverseIndexMap = new Array(indicesCount);
    const rank = indicesShape[1];
    if (denseRows === 0) {
      if (indicesCount !== 0) {
        throw new Error(backend_util_exports.getSparseFillEmptyRowsIndicesDenseShapeMismatch(indicesCount));
      }
      const outputIndices = util_exports.getArrayFromDType(indicesDType, 0);
      const outputValues = util_exports.getArrayFromDType(valuesDType, 0);
      return [
        outputIndices,
        [0, rank],
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    }
    let rowsAreOrdered = true;
    let lastIndicesRow = 0;
    const csrOffset = new Array(denseRows).fill(0);
    for (let i2 = 0; i2 < indicesCount; ++i2) {
      const row = indices[i2 * rank];
      if (row < 0) {
        throw new Error(backend_util_exports.getSparseFillEmptyRowsNegativeIndexErrorMessage(i2, row));
      }
      if (row >= denseRows) {
        throw new Error(backend_util_exports.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(i2, row, denseRows));
      }
      ++csrOffset[row];
      rowsAreOrdered = rowsAreOrdered && row >= lastIndicesRow;
      lastIndicesRow = row;
    }
    let allRowsFull = true;
    for (let row = 0; row < denseRows; ++row) {
      const rowEmpty = csrOffset[row] === 0;
      emptyRowIndicator[row] = rowEmpty;
      allRowsFull = allRowsFull && !rowEmpty;
      csrOffset[row] = Math.max(csrOffset[row], 1);
      if (row > 0) {
        csrOffset[row] += csrOffset[row - 1];
      }
    }
    if (allRowsFull && rowsAreOrdered) {
      const outputIndices = indices;
      const outputValues = values;
      for (let i2 = 0; i2 < indicesCount; ++i2) {
        reverseIndexMap[i2] = i2;
      }
      return [
        outputIndices,
        [indicesCount, rank],
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    } else {
      const fullIndicesCount = csrOffset[denseRows - 1];
      const outputIndices = util_exports.getArrayFromDType(indicesDType, fullIndicesCount * rank);
      const outputValues = util_exports.getArrayFromDType(valuesDType, fullIndicesCount);
      const filledCount = new Array(denseRows).fill(0);
      for (let i2 = 0; i2 < indicesCount; ++i2) {
        const row = indices[i2 * rank];
        const offset = filledCount[row];
        const outputI = (row === 0 ? 0 : csrOffset[row - 1]) + offset;
        filledCount[row]++;
        for (let j3 = 0; j3 < rank; ++j3) {
          outputIndices[outputI * rank + j3] = indices[i2 * rank + j3];
        }
        outputValues[outputI] = values[i2];
        reverseIndexMap[i2] = outputI;
      }
      for (let row = 0; row < denseRows; ++row) {
        const rowCount = filledCount[row];
        if (rowCount === 0) {
          const startingIndex = row === 0 ? 0 : csrOffset[row - 1];
          outputIndices[startingIndex * rank + 0] = row;
          for (let col = 1; col < rank; ++col) {
            outputIndices[startingIndex * rank + col] = 0;
          }
          outputValues[startingIndex] = defaultValue;
        }
      }
      return [
        outputIndices,
        [fullIndicesCount, rank],
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    }
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseReshape_impl.js
  function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {
    const denseSize = util_exports.sizeFromShape(inputShape);
    const nnz = inputIndicesShape[0];
    const outputRank = targetShape.length;
    const outputShape = [];
    let product = 1;
    let unknownIndex = -1;
    for (let d2 = 0; d2 < outputRank; ++d2) {
      const size = targetShape[d2];
      if (size === -1) {
        if (unknownIndex !== -1) {
          throw new Error(backend_util_exports.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(unknownIndex, d2));
        }
        unknownIndex = d2;
        outputShape.push(1);
      } else {
        if (size < 0) {
          throw new Error(backend_util_exports.getSparseReshapeNegativeOutputDimErrorMessage(d2, size));
        }
        product *= size;
        outputShape.push(size);
      }
    }
    if (unknownIndex !== -1) {
      if (product <= 0) {
        throw new Error(backend_util_exports.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());
      }
      const missing = Math.trunc(denseSize / product);
      if (product * missing !== denseSize) {
        throw new Error(backend_util_exports.getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape));
      }
      outputShape[unknownIndex] = missing;
    }
    const outputSize = util_exports.sizeFromShape(outputShape);
    if (outputSize !== denseSize) {
      throw new Error(backend_util_exports.getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape));
    }
    const inputRank = inputShape.length;
    const inputStrides = [];
    if (inputRank > 0) {
      inputStrides[inputRank - 1] = 1;
      for (let d2 = inputRank - 2; d2 >= 0; --d2) {
        inputStrides[d2] = inputStrides[d2 + 1] * inputShape[d2 + 1];
      }
    }
    const outputStrides = [];
    if (outputRank > 0) {
      outputStrides[outputRank - 1] = 1;
      for (let d2 = outputRank - 2; d2 >= 0; --d2) {
        outputStrides[d2] = outputStrides[d2 + 1] * outputShape[d2 + 1];
      }
    }
    const newIndices = util_exports.getArrayFromDType(inputDType, nnz * outputRank);
    for (let i2 = 0; i2 < nnz; ++i2) {
      let id = 0;
      for (let j3 = 0; j3 < inputRank; ++j3) {
        id += inputIndices[i2 * inputRank + j3] * inputStrides[j3];
      }
      for (let j3 = 0; j3 < outputRank; ++j3) {
        newIndices[i2 * outputRank + j3] = Math.trunc(id / outputStrides[j3]);
        id %= outputStrides[j3];
      }
    }
    return [newIndices, [nnz, outputRank], outputShape];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentReduction_impl.js
  function sparseSegmentReductionImpl(input2, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {
    const numIndices = indices.length;
    const inputFlat = [inputShape[0], input2.length / inputShape[0]];
    const numCol = inputFlat[1];
    const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;
    const outputRows = lastSegmentIdPlusOne;
    if (outputRows < 0) {
      throw new Error(backend_util_exports.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    }
    const outputShape = inputShape.slice();
    outputShape[0] = outputRows;
    const outputLength = outputShape.reduce((product, value) => product * value, 1);
    const output = util_exports.getArrayFromDType(inputDType, outputLength);
    if (numIndices === 0) {
      if (outputRows > 0) {
        output.fill(defaultValue);
      }
      return [output, outputShape];
    }
    if (outputRows <= 0) {
      throw new Error(backend_util_exports.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    }
    let start = 0, end = 1;
    let uninitializedIndex = 0;
    let outIndex = segmentIds[start];
    while (true) {
      let nextIndex = 0;
      if (end < numIndices) {
        nextIndex = segmentIds[end];
        if (outIndex === nextIndex) {
          ++end;
          continue;
        }
        if (outIndex >= nextIndex) {
          throw new Error(backend_util_exports.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());
        }
      }
      if (outIndex < 0 || outIndex >= outputRows) {
        throw new Error(backend_util_exports.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(outIndex, outputRows));
      }
      if (outIndex > uninitializedIndex) {
        output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);
      }
      for (let i2 = start; i2 < end; ++i2) {
        const index = indices[i2];
        if (index < 0 || index >= inputFlat[0]) {
          throw new Error(backend_util_exports.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i2, indices[i2], inputFlat[0]));
        }
        for (let j3 = 0; j3 < numCol; j3++) {
          output[outIndex * numCol + j3] += input2[index * numCol + j3];
        }
      }
      if (isMean) {
        for (let j3 = 0; j3 < numCol; j3++) {
          output[outIndex * numCol + j3] /= end - start;
        }
      }
      start = end;
      ++end;
      uninitializedIndex = outIndex + 1;
      outIndex = nextIndex;
      if (end > numIndices) {
        break;
      }
    }
    if (uninitializedIndex < outputRows) {
      output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);
    }
    return [output, outputShape];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sqrt.js
  var sqrtImpl = createSimpleUnaryImpl((xi2) => Math.sqrt(xi2));
  var sqrt2 = unaryKernelFunc(Sqrt, (xi2) => Math.sqrt(xi2));

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SquaredDifference.js
  var squaredDifferenceImpl = createSimpleBinaryKernelImpl((a2, b2) => {
    const diff = a2 - b2;
    return diff * diff;
  });
  var squaredDifference2 = binaryKernelFunc(SquaredDifference, squaredDifferenceImpl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js
  function stridedSliceImpl(outShape, xBuf, strides, begin) {
    const outBuf = buffer(outShape, xBuf.dtype);
    for (let i2 = 0; i2 < outBuf.size; i2++) {
      const loc = outBuf.indexToLoc(i2);
      const newLoc = new Array(loc.length);
      for (let j3 = 0; j3 < newLoc.length; j3++) {
        newLoc[j3] = loc[j3] * strides[j3] + begin[j3];
      }
      outBuf.set(xBuf.get(...newLoc), ...loc);
    }
    return outBuf;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringNGrams_impl.js
  var StringNGramsOp = class {
    constructor(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
      this.separator = util_exports.encodeString(separator);
      this.nGramWidths = nGramWidths;
      this.leftPad = util_exports.encodeString(leftPad);
      this.rightPad = util_exports.encodeString(rightPad2);
      this.padWidth = padWidth;
      this.preserveShort = preserveShortSequences;
    }
    getPadWidth(nGramWidth) {
      return Math.min(this.padWidth < 0 ? nGramWidth - 1 : this.padWidth, nGramWidth - 1);
    }
    getNumNGrams(length, nGramWidth) {
      const padWidth = this.getPadWidth(nGramWidth);
      return Math.max(0, length + 2 * padWidth - nGramWidth + 1);
    }
    createNGrams(data, splitIndex, output, outputStartIndex, numNGrams, nGramWidth) {
      for (let nGramIndex = 0; nGramIndex < numNGrams; ++nGramIndex) {
        const padWidth = this.getPadWidth(nGramWidth);
        const leftPadding = Math.max(0, padWidth - nGramIndex);
        const rightPadding = Math.max(0, padWidth - (numNGrams - (nGramIndex + 1)));
        const numTokens = nGramWidth - (leftPadding + rightPadding);
        const dataStartIndex = splitIndex + (leftPadding > 0 ? 0 : nGramIndex - padWidth);
        let nGramSize = 0;
        nGramSize += leftPadding * this.leftPad.length;
        for (let n2 = 0; n2 < numTokens; ++n2) {
          nGramSize += data[dataStartIndex + n2].length;
        }
        nGramSize += rightPadding * this.rightPad.length;
        const numSeparators = leftPadding + rightPadding + numTokens - 1;
        nGramSize += numSeparators * this.separator.length;
        output[outputStartIndex + nGramIndex] = new Uint8Array(nGramSize);
        const nGram = output[outputStartIndex + nGramIndex];
        let nextNGramIndex = 0;
        const appendToNGram = (str) => str.forEach((value) => nGram[nextNGramIndex++] = value);
        for (let n2 = 0; n2 < leftPadding; ++n2) {
          appendToNGram(this.leftPad);
          appendToNGram(this.separator);
        }
        for (let n2 = 0; n2 < numTokens - 1; ++n2) {
          appendToNGram(data[dataStartIndex + n2]);
          appendToNGram(this.separator);
        }
        if (numTokens > 0) {
          appendToNGram(data[dataStartIndex + numTokens - 1]);
          for (let n2 = 0; n2 < rightPadding; ++n2) {
            appendToNGram(this.separator);
            appendToNGram(this.rightPad);
          }
        } else {
          for (let n2 = 0; n2 < rightPadding - 1; ++n2) {
            appendToNGram(this.rightPad);
            appendToNGram(this.separator);
          }
          appendToNGram(this.rightPad);
        }
      }
    }
    // Data and splits together form the definition of the ragged tensor,
    // where data is 1 dimensional and contains the values of the tensor
    // and splits denotes the indices at which each row starts.
    compute(data, splits) {
      const inputDataSize = data.length;
      const splitsSize = splits.length;
      if (splitsSize > 0) {
        let prevSplit = splits[0];
        if (prevSplit !== 0) {
          throw new Error(`First split value must be 0, got ${prevSplit}`);
        }
        for (let i2 = 1; i2 < splitsSize; ++i2) {
          let validSplits = splits[i2] >= prevSplit;
          validSplits = validSplits && splits[i2] <= inputDataSize;
          if (!validSplits) {
            throw new Error(`Invalid split value ${splits[i2]}, must be in [${prevSplit}, ${inputDataSize}]`);
          }
          prevSplit = splits[i2];
        }
        if (prevSplit !== inputDataSize) {
          throw new Error(`Last split value must be data size. Expected ${inputDataSize}, got ${prevSplit}`);
        }
      }
      const numBatchItems = splitsSize - 1;
      const nGramsSplits = util_exports.getArrayFromDType("int32", splitsSize);
      if (inputDataSize === 0 || splitsSize === 0) {
        const empty = new Array(inputDataSize);
        for (let i2 = 0; i2 <= numBatchItems; ++i2) {
          nGramsSplits[i2] = 0;
        }
        return [empty, nGramsSplits];
      }
      nGramsSplits[0] = 0;
      for (let i2 = 1; i2 <= numBatchItems; ++i2) {
        const length = splits[i2] - splits[i2 - 1];
        let numNGrams = 0;
        this.nGramWidths.forEach((nGramWidth) => {
          numNGrams += this.getNumNGrams(length, nGramWidth);
        });
        if (this.preserveShort && length > 0 && numNGrams === 0) {
          numNGrams = 1;
        }
        nGramsSplits[i2] = nGramsSplits[i2 - 1] + numNGrams;
      }
      const nGrams = new Array(nGramsSplits[numBatchItems]);
      for (let i2 = 0; i2 < numBatchItems; ++i2) {
        const splitIndex = splits[i2];
        let outputStartIdx = nGramsSplits[i2];
        this.nGramWidths.forEach((nGramWidth) => {
          const length = splits[i2 + 1] - splits[i2];
          const numNGrams = this.getNumNGrams(length, nGramWidth);
          this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
          outputStartIdx += numNGrams;
        });
        if (this.preserveShort && outputStartIdx === nGramsSplits[i2]) {
          const dataLength = splits[i2 + 1] - splits[i2];
          if (dataLength === 0) {
            continue;
          }
          const nGramWidth = dataLength + 2 * this.padWidth;
          const numNGrams = 1;
          this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
        }
      }
      return [nGrams, nGramsSplits];
    }
  };
  function stringNGramsImpl(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
    return new StringNGramsOp(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences).compute(data, dataSplits);
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringSplit_impl.js
  function split2(str, delimiters, skipEmpty, result) {
    if (!str.length) {
      return;
    }
    if (delimiters.length === 0) {
      for (let i2 = 0; i2 < str.length; ++i2) {
        result.push(str.subarray(i2, i2 + 1));
      }
      return;
    }
    if (delimiters.length === 1) {
      const delimiter = delimiters[0];
      let f2 = str.indexOf(delimiter);
      while (f2 !== -1) {
        const token = str.subarray(0, f2);
        if (!skipEmpty || token.length !== 0) {
          result.push(token);
        }
        str = str.subarray(f2 + 1);
        f2 = str.indexOf(delimiter);
      }
      if (!skipEmpty || str.length !== 0) {
        result.push(str);
      }
      return;
    }
    let tokenStart = 0;
    for (let i2 = 0; i2 < str.length + 1; i2++) {
      if (i2 === str.length || delimiters.indexOf(str[i2]) !== -1) {
        const token = str.subarray(tokenStart, i2);
        if (!skipEmpty || token.length !== 0) {
          result.push(token);
        }
        tokenStart = i2 + 1;
      }
    }
  }
  function stringSplitImpl(input2, delimiter, skipEmpty) {
    const batchSize = input2.length;
    const tokens = [];
    let outputSize = 0;
    let maxNumEntries = 0;
    const numIndices = new Array(batchSize);
    for (let i2 = 0; i2 < batchSize; ++i2) {
      const prevTokensLength = tokens.length;
      split2(input2[i2], delimiter, skipEmpty, tokens);
      const nEntries = tokens.length - prevTokensLength;
      numIndices[i2] = nEntries;
      outputSize += nEntries;
      maxNumEntries = Math.max(maxNumEntries, nEntries);
    }
    const indices = util_exports.getArrayFromDType("int32", outputSize * 2);
    const values = new Array(outputSize);
    const shape = [batchSize, maxNumEntries];
    let c2 = 0;
    for (let i2 = 0; i2 < batchSize; ++i2) {
      for (let j3 = 0; j3 < numIndices[i2]; ++j3) {
        indices[c2 * 2] = i2;
        indices[c2 * 2 + 1] = j3;
        values[c2] = tokens[c2];
        ++c2;
      }
    }
    return [indices, values, shape];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringToHashBucketFast_impl.js
  function stringToHashBucketFastImpl(input2, numBuckets) {
    const output = util_exports.getArrayFromDType("int32", input2.length);
    for (let i2 = 0; i2 < input2.length; ++i2) {
      output[i2] = util_exports.fingerPrint64(input2[i2]).modulo(numBuckets).getLowBitsUnsigned();
    }
    return output;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js
  var subImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue - bValue);
  var subComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
    return { real: aReal - bReal, imag: aImag - bImag };
  });
  var sub2 = binaryKernelFunc(Sub, subImpl, subComplexImpl);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tile_impl.js
  function tileImpl(xBuf, reps) {
    const newShape = new Array(xBuf.rank);
    for (let i2 = 0; i2 < newShape.length; i2++) {
      newShape[i2] = xBuf.shape[i2] * reps[i2];
    }
    const result = buffer(newShape, xBuf.dtype);
    for (let i2 = 0; i2 < result.values.length; ++i2) {
      const newLoc = result.indexToLoc(i2);
      const originalLoc = new Array(xBuf.rank);
      for (let j3 = 0; j3 < originalLoc.length; j3++) {
        originalLoc[j3] = newLoc[j3] % xBuf.shape[j3];
      }
      const originalIndex = xBuf.locToIndex(originalLoc);
      result.values[i2] = xBuf.values[originalIndex];
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TopK_impl.js
  var comparePair = (a2, b2) => {
    const valueDiff = b2.value - a2.value;
    return valueDiff === 0 ? a2.index - b2.index : valueDiff;
  };
  function select(array, k4, left = 0, right = array.length - 1) {
    while (right > left) {
      if (right - left > 600) {
        const n2 = right - left + 1;
        const i3 = k4 - left + 1;
        const z3 = Math.log(n2);
        const s2 = 0.5 * Math.exp(2 * z3 / 3);
        const sd = 0.5 * Math.sqrt(z3 * s2 * (n2 - s2) / n2) * Math.sign(i3 - n2 / 2);
        const newLeft = Math.max(left, Math.floor(k4 - i3 * s2 / n2 + sd));
        const newRight = Math.min(right, Math.floor(k4 + (n2 - i3) * s2 / n2 + sd));
        select(array, k4, newLeft, newRight);
      }
      const t3 = array[k4];
      let i2 = left;
      let j3 = right;
      util_exports.swap(array, left, k4);
      if (comparePair(array[right], t3) > 0) {
        util_exports.swap(array, left, right);
      }
      while (i2 < j3) {
        util_exports.swap(array, i2, j3);
        i2++;
        j3--;
        while (comparePair(array[i2], t3) < 0) {
          i2 = i2 + 1;
        }
        while (comparePair(array[j3], t3) > 0) {
          j3 = j3 - 1;
        }
      }
      if (comparePair(array[left], t3) === 0) {
        util_exports.swap(array, left, j3);
      } else {
        j3 = j3 + 1;
        util_exports.swap(array, j3, right);
      }
      if (j3 <= k4) {
        left = j3 + 1;
      }
      if (k4 <= j3) {
        right = j3 - 1;
      }
    }
  }
  function topKImpl(x2, xShape, xDtype, k4, sorted) {
    const lastDim = xShape[xShape.length - 1];
    const [batch, size] = [x2.length / lastDim, lastDim];
    const allTopKVals = util_exports.getTypedArrayFromDType(xDtype, batch * k4);
    const allTopKIndices = util_exports.getTypedArrayFromDType("int32", batch * k4);
    for (let b2 = 0; b2 < batch; b2++) {
      const offset = b2 * size;
      const vals = x2.subarray(offset, offset + size);
      let valAndInd = new Array(vals.length);
      vals.forEach((value, index) => valAndInd[index] = { value, index });
      if (k4 < valAndInd.length) {
        select(valAndInd, k4);
        valAndInd = valAndInd.slice(0, k4);
      }
      if (sorted) {
        valAndInd.sort(comparePair);
      }
      const outOffset = b2 * k4;
      const topKVals = allTopKVals.subarray(outOffset, outOffset + k4);
      const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k4);
      for (let i2 = 0; i2 < k4; i2++) {
        topKVals[i2] = valAndInd[i2].value;
        topKIndices[i2] = valAndInd[i2].index;
      }
    }
    const outputShape = xShape.slice();
    outputShape[outputShape.length - 1] = k4;
    return [
      buffer(outputShape, xDtype, allTopKVals),
      buffer(outputShape, "int32", allTopKIndices)
    ];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js
  function uniqueImpl(values, axis, shape, dtype) {
    const $axis = util_exports.parseAxisParam(axis, shape)[0];
    const newShape = [1, shape[0], 1];
    for (let i2 = 0; i2 < $axis; i2++) {
      newShape[0] *= shape[i2];
    }
    newShape[1] = shape[$axis];
    for (let i2 = $axis + 1; i2 < shape.length; i2++) {
      newShape[2] *= shape[i2];
    }
    const uniqueElements = {};
    const indices = new Int32Array(shape[$axis]);
    const inputBuffer = new TensorBuffer(newShape, dtype, values);
    const uniqueIndices = [];
    const is1DTensor = newShape[0] === 1 && newShape[2] === 1;
    for (let i2 = 0; i2 < shape[$axis]; i2++) {
      let element;
      if (is1DTensor) {
        element = values[i2].toString();
      } else {
        const axisValues = [];
        for (let m2 = 0; m2 < newShape[0]; m2++) {
          for (let n2 = 0; n2 < newShape[2]; n2++) {
            axisValues.push(inputBuffer.get(m2, i2, n2));
          }
        }
        element = axisValues.join(",");
      }
      if (uniqueElements[element] !== void 0) {
        indices[i2] = uniqueElements[element];
      } else {
        const uniqueIndex = Object.keys(uniqueElements).length;
        uniqueElements[element] = uniqueIndex;
        indices[i2] = uniqueIndex;
        uniqueIndices.push(i2);
      }
    }
    const outputTmpShape = newShape.slice();
    outputTmpShape[1] = Object.keys(uniqueElements).length;
    const outputBuffer = new TensorBuffer(outputTmpShape, dtype);
    uniqueIndices.forEach((uniqueElementIndex, i2) => {
      for (let m2 = 0; m2 < newShape[0]; m2++) {
        for (let n2 = 0; n2 < newShape[2]; n2++) {
          outputBuffer.set(inputBuffer.get(m2, uniqueElementIndex, n2), m2, i2, n2);
        }
      }
    });
    const outputShape = shape.slice();
    outputShape[$axis] = outputTmpShape[1];
    return {
      outputValues: outputBuffer.values,
      outputShape,
      indices
    };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js
  var { addImpl: addImplCPU, bincountImpl: bincountImplCPU, bincountReduceImpl: bincountReduceImplCPU, castImpl: castImplCPU, ceilImpl: ceilImplCPU, concatImpl: concatImplCPU, equalImpl: equalImplCPU, expImpl: expImplCPU, expm1Impl: expm1ImplCPU, floorImpl: floorImplCPU, gatherNdImpl: gatherNdImplCPU, gatherV2Impl: gatherV2ImplCPU, greaterImpl: greaterImplCPU, greaterEqualImpl: greaterEqualImplCPU, lessImpl: lessImplCPU, lessEqualImpl: lessEqualImplCPU, linSpaceImpl: linSpaceImplCPU, logImpl: logImplCPU, maxImpl: maxImplCPU, maximumImpl: maximumImplCPU, minimumImpl: minimumImplCPU, multiplyImpl: multiplyImplCPU, negImpl: negImplCPU, notEqualImpl: notEqualImplCPU, prodImpl: prodImplCPU, raggedGatherImpl: raggedGatherImplCPU, raggedRangeImpl: raggedRangeImplCPU, raggedTensorToTensorImpl: raggedTensorToTensorImplCPU, rangeImpl: rangeImplCPU, rsqrtImpl: rsqrtImplCPU, scatterImpl: scatterImplCPU, sigmoidImpl: sigmoidImplCPU, simpleAbsImpl: simpleAbsImplCPU, sliceImpl: sliceImplCPU, sparseFillEmptyRowsImpl: sparseFillEmptyRowsImplCPU, sparseReshapeImpl: sparseReshapeImplCPU, sparseSegmentReductionImpl: sparseSegmentReductionImplCPU, sqrtImpl: sqrtImplCPU, stridedSliceImpl: stridedSliceImplCPU, stringNGramsImpl: stringNGramsImplCPU, stringSplitImpl: stringSplitImplCPU, stringToHashBucketFastImpl: stringToHashBucketFastImplCPU, subImpl: subImplCPU, tileImpl: tileImplCPU, topKImpl: topKImplCPU, transposeImpl: transposeImplCPU, uniqueImpl: uniqueImplCPU } = shared_exports;

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js
  function getVecChannels(name, rank) {
    return ["x", "y", "z", "w", "u", "v"].slice(0, rank).map((d2) => `${name}.${d2}`);
  }
  function getChannels(name, rank) {
    if (rank === 1) {
      return [name];
    }
    return getVecChannels(name, rank);
  }
  function getSourceCoords(rank, dims) {
    if (rank === 1) {
      return "rc";
    }
    let coords2 = "";
    for (let i2 = 0; i2 < rank; i2++) {
      coords2 += dims[i2];
      if (i2 < rank - 1) {
        coords2 += ",";
      }
    }
    return coords2;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js
  var PackProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      if (this.rank === 0) {
        this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
      } else {
        const channels = getChannels("rc", this.rank);
        const dtype = getCoordsDataType(this.rank);
        const outOfBoundsCondition = this.getOutOfBoundsCondition(channels);
        const setup = this.getSetup(channels);
        const output = this.getOutput(channels);
        this.userCode = `
        void main() {
          ${dtype} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            setOutput(vec4(0));
          } else {
            ${setup}

            setOutput(vec4(${output}));
          }
        }
      `;
      }
    }
    getSourceCoordsArr(dims) {
      const coords2 = [];
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          let coord = `${row === 0 ? "r" : "rp1"}, ${col === 0 ? "c" : "cp1"}`;
          for (let d2 = 2; d2 < this.rank; d2++) {
            coord = `${dims[dims.length - 1 - d2]},` + coord;
          }
          coords2.push(coord);
        }
      }
      return coords2;
    }
    getOutOfBoundsCondition(dims) {
      if (this.rank === 1) {
        return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
      }
      let cond = "";
      for (let i2 = this.rank - 2; i2 < this.rank; i2++) {
        cond += `${dims[i2]} >= ${this.enableShapeUniforms ? `outShape[${i2}]` : this.outputShape[i2]}`;
        if (i2 < this.rank - 1) {
          cond += "||";
        }
      }
      return cond;
    }
    getSetup(dims) {
      if (this.rank === 1) {
        return "";
      }
      const innerDims = dims.slice(-2);
      const col = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1];
      const row = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
      return `
      int r = ${innerDims[0]};
      int c = ${innerDims[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${col};
      bool rEdge = rp1 >= ${row};
    `;
    }
    getOutput(dims) {
      const sourceCoords = this.getSourceCoordsArr(dims);
      if (this.rank === 1) {
        const outShape = this.enableShapeUniforms ? "outShape" : this.outputShape[0];
        return `getA(rc), (rc + 1 >= ${outShape} ? 0. : getA(rc + 1)), 0, 0`;
      }
      return `getA(${sourceCoords[0]}),
            cEdge ? 0. : getA(${sourceCoords[1]}),
            rEdge ? 0. : getA(${sourceCoords[2]}),
            rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js
  var ReshapePackedProgram = class {
    constructor(outputShape, inputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [{ name: "inputShape", type: "ivec3" }];
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      let mainLoop = ``;
      for (let i2 = 0; i2 < 4; i2++) {
        let thisRC = `thisRC = rc;`;
        if (i2 % 2 === 1) {
          thisRC += `thisRC.z += 1;`;
        }
        if (i2 > 1) {
          thisRC += `thisRC.y += 1;`;
        }
        mainLoop += `
        ${thisRC}
        ${i2 > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i2}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i2 > 0 ? "}" : ""}
      `;
      }
      this.userCode = `
      ${getReshapedInputCoords(inputShape, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : outputShape[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : outputShape[2]};

        ${mainLoop}

        setOutput(result);
      }
    `;
    }
  };
  function getReshapedInputCoords(shape, enableShapeUniforms) {
    const coordsFromIndexSnippet = enableShapeUniforms ? getLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], "inputShape") : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/texture_manager.js
  var TextureManager = class {
    constructor(gpgpu) {
      this.gpgpu = gpgpu;
      this.numUsedTextures = 0;
      this.numFreeTextures = 0;
      this._numBytesAllocated = 0;
      this._numBytesFree = 0;
      this.freeTextures = {};
      this.logEnabled = false;
      this.usedTextures = {};
    }
    acquireTexture(shapeRC, usage, isPacked) {
      const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);
      const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);
      if (!(shapeKey in this.freeTextures)) {
        this.freeTextures[shapeKey] = [];
      }
      if (!(shapeKey in this.usedTextures)) {
        this.usedTextures[shapeKey] = [];
      }
      const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
      if (this.freeTextures[shapeKey].length > 0) {
        this.numFreeTextures--;
        this.numUsedTextures++;
        this._numBytesFree -= texBytes;
        this.log();
        const newTexture2 = this.freeTextures[shapeKey].shift();
        this.usedTextures[shapeKey].push(newTexture2);
        return newTexture2;
      }
      let newTexture;
      if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {
        newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {
        newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {
        newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {
        newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {
        newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);
      }
      this.usedTextures[shapeKey].push(newTexture);
      this.numUsedTextures++;
      this._numBytesAllocated += texBytes;
      this.log();
      return newTexture;
    }
    releaseTexture(texture, shape, logicalTexType, isPacked) {
      if (this.freeTextures == null) {
        return;
      }
      const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);
      const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);
      if (!(shapeKey in this.freeTextures)) {
        this.freeTextures[shapeKey] = [];
      }
      const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
      const deleteTexThreshold = env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
      if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {
        this.gpgpu.deleteMatrixTexture(texture.texture);
        this._numBytesAllocated -= texBytes;
      } else {
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this._numBytesFree += texBytes;
      }
      this.numUsedTextures--;
      const texList = this.usedTextures[shapeKey];
      const texIndex = texList.indexOf(texture);
      if (texIndex < 0) {
        throw new Error("Cannot release a texture that was never provided by this texture manager");
      }
      texList.splice(texIndex, 1);
      this.log();
    }
    log() {
      if (!this.logEnabled) {
        return;
      }
      const total = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);
      const freeRatio = this._numBytesFree / this._numBytesAllocated;
      console.log(`Bytes allocated: ${this._numBytesAllocated}`);
      console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);
    }
    get numBytesAllocated() {
      return this._numBytesAllocated;
    }
    get numBytesFree() {
      return this._numBytesFree;
    }
    getNumUsedTextures() {
      return this.numUsedTextures;
    }
    getNumFreeTextures() {
      return this.numFreeTextures;
    }
    dispose() {
      if (this.freeTextures == null) {
        return;
      }
      for (const texShape in this.freeTextures) {
        this.freeTextures[texShape].forEach((tex) => {
          this.gpgpu.deleteMatrixTexture(tex.texture);
        });
      }
      for (const texShape in this.usedTextures) {
        this.usedTextures[texShape].forEach((tex) => {
          this.gpgpu.deleteMatrixTexture(tex.texture);
        });
      }
      this.freeTextures = null;
      this.usedTextures = null;
      this.numUsedTextures = 0;
      this.numFreeTextures = 0;
      this._numBytesAllocated = 0;
      this._numBytesFree = 0;
    }
  };
  function numBytesForInternalFormat(gl2, internalFormat) {
    const glany = gl2;
    if (internalFormat === glany.R32F) {
      return 4;
    } else if (internalFormat === glany.R16F) {
      return 2;
    } else if (internalFormat === glany.RGBA32F) {
      return 16;
    } else if (internalFormat === gl2.RGBA) {
      return 16;
    } else if (internalFormat === glany.RGBA16F) {
      return 8;
    } else if (internalFormat === glany.RGBA8) {
      return 4;
    }
    throw new Error(`Unknown internal format ${internalFormat}`);
  }
  function computeBytes(shape, physicalTexType, gl2, textureConfig, isPacked) {
    const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);
    let numElements;
    if (isPacked) {
      const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
      numElements = packedWidth * packedHeight;
    } else {
      const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
      numElements = width * height;
    }
    const bytesPerElement2 = numBytesForInternalFormat(gl2, internalFormat);
    return numElements * bytesPerElement2;
  }
  function internalFormatForPhysicalTexType(physicalTexType, textureConfig) {
    switch (physicalTexType) {
      case PhysicalTextureType.PACKED_2X2_FLOAT32:
        return getInternalFormatForPackedMatrixTexture(textureConfig);
      case PhysicalTextureType.PACKED_2X2_FLOAT16:
        return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);
      case PhysicalTextureType.UNPACKED_FLOAT32:
        return getInternalFormatForFloat32MatrixTexture(textureConfig);
      case PhysicalTextureType.UNPACKED_FLOAT16:
        return getInternalFormatForFloat16MatrixTexture(textureConfig);
      case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:
        return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);
      default:
        throw new Error(`Unknown physical texture type ${physicalTexType}`);
    }
  }
  function getPhysicalTextureForRendering(isPacked) {
    if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")) {
      if (isPacked) {
        return PhysicalTextureType.PACKED_2X2_FLOAT32;
      }
      return PhysicalTextureType.UNPACKED_FLOAT32;
    }
    if (isPacked) {
      return PhysicalTextureType.PACKED_2X2_FLOAT16;
    }
    return PhysicalTextureType.UNPACKED_FLOAT16;
  }
  function getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {
    if (logicalTexType === TextureUsage.UPLOAD) {
      return PhysicalTextureType.PACKED_2X2_FLOAT32;
    } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {
      return getPhysicalTextureForRendering(isPacked);
    } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {
      return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;
    }
    throw new Error(`Unknown logical texture type ${logicalTexType}`);
  }
  function getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {
    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js
  var UnaryOpProgram = class {
    constructor(aShape, opSnippet) {
      this.variableNames = ["A"];
      this.outputShape = aShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      float unaryOperation(float x) {
        ${opSnippet}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  };
  var CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;
  var LINEAR = `return x;`;
  var ABS = `return abs(x);`;
  var ELU2 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
  var RELU = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : x;
`;
  var RELU6 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  var CLONE = "return x;";
  var SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js
  var LINEAR2 = `return x;`;
  var ELU3 = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
  var RELU2 = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var RELU62 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var SIGMOID2 = `return 1.0 / (1.0 + exp(-1.0 * x));`;
  var UnaryOpPackedProgram = class {
    constructor(aShape, opSnippet) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = aShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${opSnippet}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/unpack_gpu.js
  var UnpackProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = false;
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const rank = outputShape.length;
      const channels = getChannels("rc", rank);
      const dtype = getCoordsDataType(rank);
      const sourceCoords = getSourceCoords(rank, channels);
      const innerDims = channels.slice(-2);
      const coords2 = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
      this.userCode = `
      void main() {
        ${dtype} rc = getOutputCoords();
        vec4 packedInput = getA(${sourceCoords});

        setOutput(getChannel(packedInput, ${coords2}));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js
  var whereImpl2 = kernel_impls_exports.whereImpl;
  var EPSILON_FLOAT322 = 1e-7;
  var EPSILON_FLOAT162 = 1e-4;
  var binaryCaches = {};
  function getBinaryCache(webGLVersion) {
    if (webGLVersion in binaryCaches) {
      return binaryCaches[webGLVersion];
    }
    binaryCaches[webGLVersion] = {};
    return binaryCaches[webGLVersion];
  }
  var CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
  var BEFORE_PAGING_CONSTANT = 600;
  function numMBBeforeWarning() {
    if (env().global.screen == null) {
      return 1024;
    }
    return env().global.screen.height * env().global.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT / 1024 / 1024;
  }
  var MathBackendWebGL = class extends KernelBackend {
    constructor(gpuResource) {
      super();
      this.pendingRead = /* @__PURE__ */ new WeakMap();
      this.pendingDisposal = /* @__PURE__ */ new WeakSet();
      this.dataRefCount = /* @__PURE__ */ new WeakMap();
      this.numBytesInGPU = 0;
      this.uploadWaitMs = 0;
      this.downloadWaitMs = 0;
      this.lastGlFlushTime = 0;
      this.warnedAboutMemory = false;
      this.pendingDeletes = 0;
      this.disposed = false;
      if (!env().getBool("HAS_WEBGL")) {
        throw new Error("WebGL is not supported on this device");
      }
      let newGPGPU;
      if (gpuResource != null) {
        if (gpuResource instanceof GPGPUContext) {
          newGPGPU = gpuResource;
        } else {
          const gl2 = getWebGLContext(env().getNumber("WEBGL_VERSION"), gpuResource);
          newGPGPU = new GPGPUContext(gl2);
        }
        this.binaryCache = {};
        this.gpgpuCreatedLocally = false;
      } else {
        const gl2 = getWebGLContext(env().getNumber("WEBGL_VERSION"));
        newGPGPU = new GPGPUContext(gl2);
        this.binaryCache = getBinaryCache(env().getNumber("WEBGL_VERSION"));
        this.gpgpuCreatedLocally = true;
      }
      this.gpgpu = newGPGPU;
      this.canvas = this.gpgpu.gl.canvas;
      this.textureManager = new TextureManager(this.gpgpu);
      this.numMBBeforeWarning = numMBBeforeWarning();
      this.texData = new DataStorage(this, engine());
    }
    nextDataId() {
      return MathBackendWebGL.nextDataId++;
    }
    numDataIds() {
      return this.texData.numDataIds() - this.pendingDeletes;
    }
    // Writes a new entry to the data store with a WebGL texture, and registers it
    // to the texture manager.
    writeTexture(texture, shape, dtype, texHeight, texWidth, channels) {
      const input2 = this.makeTensorInfo(shape, dtype);
      const inData = this.texData.get(input2.dataId);
      inData.isPacked = false;
      inData.texture = { texture, texShape: [texHeight, texWidth] };
      inData.texShape = [texHeight, texWidth];
      const shapeAs3D = getShapeAs3D(shape);
      const program = new EncodeMatrixProgram(shapeAs3D, false, channels);
      const output = this.runWebGLProgram(program, [input2], dtype, [[texHeight, texWidth]]);
      output.shape = shape;
      inData.texture = null;
      this.disposeIntermediateTensorInfo(input2);
      return output.dataId;
    }
    write(values, shape, dtype) {
      if (env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || env().getBool("DEBUG")) {
        this.checkNumericalProblems(values);
      }
      if (dtype === "complex64" && values != null) {
        throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
      }
      const dataId = { id: this.nextDataId() };
      this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1 });
      return dataId;
    }
    /** Return refCount of a `TensorData`. */
    refCount(dataId) {
      if (this.texData.has(dataId)) {
        const tensorData = this.texData.get(dataId);
        return tensorData.refCount;
      }
      return 0;
    }
    /** Increase refCount of a `TextureData`. */
    incRef(dataId) {
      const texData = this.texData.get(dataId);
      texData.refCount++;
    }
    /** Decrease refCount of a `TextureData`. */
    decRef(dataId) {
      if (this.texData.has(dataId)) {
        const texData = this.texData.get(dataId);
        texData.refCount--;
      }
    }
    move(dataId, values, shape, dtype, refCount) {
      if (env().getBool("DEBUG")) {
        this.checkNumericalProblems(values);
      }
      if (dtype === "complex64") {
        throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
      }
      this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount });
    }
    disposeIntermediateTensorInfo(tensorInfo) {
      this.disposeData(tensorInfo.dataId);
    }
    readSync(dataId) {
      const texData = this.texData.get(dataId);
      const { values, dtype, complexTensorInfos, slice: slice3, shape, isPacked } = texData;
      if (slice3 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const data = this.readSync(res.dataId);
        this.disposeIntermediateTensorInfo(res);
        return data;
      }
      if (values != null) {
        return this.convertAndCacheOnCPU(dataId);
      }
      if (dtype === "string") {
        return values;
      }
      const shouldTimeProgram = this.activeTimers != null;
      let start;
      if (shouldTimeProgram) {
        start = util_exports.now();
      }
      let result;
      if (dtype === "complex64") {
        const realValues = this.readSync(complexTensorInfos.real.dataId);
        const imagValues = this.readSync(complexTensorInfos.imag.dataId);
        result = backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
      } else {
        result = this.getValuesFromTexture(dataId);
      }
      if (shouldTimeProgram) {
        this.downloadWaitMs += util_exports.now() - start;
      }
      return this.convertAndCacheOnCPU(dataId, result);
    }
    async read(dataId) {
      if (this.pendingRead.has(dataId)) {
        const subscribers2 = this.pendingRead.get(dataId);
        return new Promise((resolve) => subscribers2.push(resolve));
      }
      const texData = this.texData.get(dataId);
      const { values, shape, slice: slice3, dtype, complexTensorInfos, isPacked } = texData;
      if (slice3 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const data = this.read(res.dataId);
        this.disposeIntermediateTensorInfo(res);
        return data;
      }
      if (values != null) {
        return this.convertAndCacheOnCPU(dataId);
      }
      if (env().getBool("DEBUG")) {
        if (!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && env().getNumber("WEBGL_VERSION") === 2) {
          throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.`);
        }
      }
      let buffer2 = null;
      let tmpDownloadTarget;
      if (dtype !== "complex64" && env().get("WEBGL_BUFFER_SUPPORTED")) {
        tmpDownloadTarget = this.decode(dataId);
        const tmpData = this.texData.get(tmpDownloadTarget.dataId);
        buffer2 = this.gpgpu.createBufferFromTexture(tmpData.texture.texture, ...getDenseTexShape(shape));
      }
      this.pendingRead.set(dataId, []);
      if (dtype !== "complex64") {
        await this.gpgpu.createAndWaitForFence();
      }
      let vals;
      if (dtype === "complex64") {
        const ps2 = await Promise.all([
          this.read(complexTensorInfos.real.dataId),
          this.read(complexTensorInfos.imag.dataId)
        ]);
        const realValues = ps2[0];
        const imagValues = ps2[1];
        vals = backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
      } else if (buffer2 == null) {
        vals = this.getValuesFromTexture(dataId);
      } else {
        const size = util_exports.sizeFromShape(shape);
        vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer2, size);
      }
      if (tmpDownloadTarget != null) {
        this.disposeIntermediateTensorInfo(tmpDownloadTarget);
      }
      if (buffer2 != null) {
        const gl2 = this.gpgpu.gl;
        callAndCheck(gl2, () => gl2.deleteBuffer(buffer2));
      }
      const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);
      const subscribers = this.pendingRead.get(dataId);
      this.pendingRead.delete(dataId);
      subscribers.forEach((resolve) => resolve(dTypeVals));
      if (this.pendingDisposal.has(dataId)) {
        this.pendingDisposal.delete(dataId);
        if (this.disposeData(dataId)) {
          engine().removeDataId(dataId, this);
        }
        this.pendingDeletes--;
      }
      return dTypeVals;
    }
    /**
     * Read tensor to a new texture that is densely packed for ease of use.
     * @param dataId The source tensor.
     * @param options
     *     customTexShape: Optional. If set, will use the user defined texture
     *     shape to create the texture.
     */
    readToGPU(dataId, options = {}) {
      const texData = this.texData.get(dataId);
      const { values, shape, slice: slice3, dtype, isPacked, texture } = texData;
      if (dtype === "complex64") {
        throw new Error("Does not support reading texture for complex64 dtype.");
      }
      if (slice3 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const gpuResouorce = this.readToGPU(res, options);
        this.disposeIntermediateTensorInfo(res);
        return gpuResouorce;
      }
      if (texture == null) {
        if (values != null) {
          throw new Error("Data is not on GPU but on CPU.");
        } else {
          throw new Error("There is no data on GPU or CPU.");
        }
      }
      const tmpTarget = this.decode(dataId, options.customTexShape);
      const tensorRef = engine().makeTensorFromTensorInfo(tmpTarget);
      const tmpData = this.texData.get(tmpTarget.dataId);
      return Object.assign({ tensorRef }, tmpData.texture);
    }
    bufferSync(t3) {
      const data = this.readSync(t3.dataId);
      if (t3.dtype === "string") {
        try {
          const strings = data.map((d2) => util_exports.decodeString(d2));
          return buffer(t3.shape, t3.dtype, strings);
        } catch (_a2) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
      }
      return buffer(t3.shape, t3.dtype, data);
    }
    checkNumericalProblems(values) {
      if (values == null) {
        return;
      }
      for (let i2 = 0; i2 < values.length; i2++) {
        const num = values[i2];
        if (!canBeRepresented(num)) {
          if (env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) {
            throw Error(`The value ${num} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
          }
          throw Error(`The value ${num} cannot be represented on this device.`);
        }
      }
    }
    getValuesFromTexture(dataId) {
      const { shape, dtype, isPacked } = this.texData.get(dataId);
      const size = util_exports.sizeFromShape(shape);
      if (env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
        const tmpTarget = this.decode(dataId);
        const tmpData2 = this.texData.get(tmpTarget.dataId);
        const vals2 = this.gpgpu.downloadMatrixFromPackedTexture(tmpData2.texture.texture, ...getDenseTexShape(shape)).subarray(0, size);
        this.disposeIntermediateTensorInfo(tmpTarget);
        return vals2;
      }
      const shouldUsePackedProgram = env().getBool("WEBGL_PACK") && isPacked === true;
      const outputShape = shouldUsePackedProgram ? getShapeAs3D(shape) : shape;
      const program = shouldUsePackedProgram ? new EncodeFloatPackedProgram(outputShape) : new EncodeFloatProgram(outputShape);
      const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], "float32");
      const tmpData = this.texData.get(output.dataId);
      const vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size);
      this.disposeIntermediateTensorInfo(output);
      return vals;
    }
    timerAvailable() {
      return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
    }
    time(f2) {
      const oldActiveTimers = this.activeTimers;
      const newActiveTimers = [];
      let outerMostTime = false;
      if (this.programTimersStack == null) {
        this.programTimersStack = newActiveTimers;
        outerMostTime = true;
      } else {
        this.activeTimers.push(newActiveTimers);
      }
      this.activeTimers = newActiveTimers;
      f2();
      const flattenedActiveTimerQueries = util_exports.flatten(this.activeTimers.map((d2) => d2.query)).filter((d2) => d2 != null);
      const flattenedActiveTimerNames = util_exports.flatten(this.activeTimers.map((d2) => d2.name)).filter((d2) => d2 != null);
      this.activeTimers = oldActiveTimers;
      if (outerMostTime) {
        this.programTimersStack = null;
      }
      const res = {
        uploadWaitMs: this.uploadWaitMs,
        downloadWaitMs: this.downloadWaitMs,
        kernelMs: null,
        wallMs: null
        // will be filled by the engine
      };
      return (async () => {
        if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          const kernelMs = await Promise.all(flattenedActiveTimerQueries);
          res["kernelMs"] = util_exports.sum(kernelMs);
          res["getExtraProfileInfo"] = () => kernelMs.map((d2, i2) => ({ name: flattenedActiveTimerNames[i2], ms: d2 })).map((d2) => `${d2.name}: ${d2.ms}`).join(", ");
        } else {
          res["kernelMs"] = {
            error: "WebGL query timers are not supported in this environment."
          };
        }
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        return res;
      })();
    }
    memory() {
      return {
        unreliable: false,
        numBytesInGPU: this.numBytesInGPU,
        numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
        numBytesInGPUFree: this.textureManager.numBytesFree
      };
    }
    startTimer() {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        return this.gpgpu.beginQuery();
      }
      return { startMs: util_exports.now(), endMs: null };
    }
    endTimer(query) {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        this.gpgpu.endQuery();
        return query;
      }
      query.endMs = util_exports.now();
      return query;
    }
    async getQueryTime(query) {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        return this.gpgpu.waitForQueryAndGetTime(query);
      }
      const timerQuery = query;
      return timerQuery.endMs - timerQuery.startMs;
    }
    /**
     * Decrease the RefCount on the dataId and dispose the memory if the dataId
     * has 0 refCount. If there are pending read on the data, the disposal would
     * added to the pending delete queue. Return true if the dataId is removed
     * from backend or the backend does not contain the dataId, false if the
     * dataId is not removed. Memory may or may not be released even when dataId
     * is removed, which also depends on dataRefCount, see `releaseGPU`.
     * @param dataId
     * @oaram force Optional, remove the data regardless of refCount
     */
    disposeData(dataId, force = false) {
      if (this.pendingDisposal.has(dataId)) {
        return false;
      }
      if (!this.texData.has(dataId)) {
        return true;
      }
      if (force) {
        this.texData.get(dataId).refCount = 0;
      } else {
        this.texData.get(dataId).refCount--;
      }
      if (!force && this.texData.get(dataId).refCount > 0) {
        return false;
      }
      if (this.pendingRead.has(dataId)) {
        this.pendingDisposal.add(dataId);
        this.pendingDeletes++;
        return false;
      }
      this.releaseGPUData(dataId);
      const { complexTensorInfos } = this.texData.get(dataId);
      if (complexTensorInfos != null) {
        this.disposeData(complexTensorInfos.real.dataId, force);
        this.disposeData(complexTensorInfos.imag.dataId, force);
      }
      this.texData.delete(dataId);
      return true;
    }
    releaseGPUData(dataId) {
      const { texture, dtype, texShape, usage, isPacked, slice: slice3 } = this.texData.get(dataId);
      const key = slice3 && slice3.origDataId || dataId;
      const refCount = this.dataRefCount.get(key);
      if (refCount > 1) {
        this.dataRefCount.set(key, refCount - 1);
      } else {
        this.dataRefCount.delete(key);
        if (texture != null) {
          this.numBytesInGPU -= this.computeBytes(texShape, dtype);
          this.textureManager.releaseTexture(texture, texShape, usage, isPacked);
        }
      }
      const texData = this.texData.get(dataId);
      texData.texture = null;
      texData.texShape = null;
      texData.isPacked = false;
      texData.slice = null;
    }
    getTexture(dataId) {
      this.uploadToGPU(dataId);
      return this.texData.get(dataId).texture.texture;
    }
    /**
     * Returns internal information for the specific data bucket. Used in unit
     * tests.
     */
    getDataInfo(dataId) {
      return this.texData.get(dataId);
    }
    /*
    Tests whether all the inputs to an op are small and on the CPU. This heuristic
    determines when it would be faster to execute a kernel on the CPU. WebGL
    kernels opt into running this check and forwarding when appropriate.
    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more
    sustainable strategy for optimizing backend execution of ops.
     */
    shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {
      return env().getBool("WEBGL_CPU_FORWARD") && inputs.every((input2) => this.texData.get(input2.dataId).texture == null && util_exports.sizeFromShape(input2.shape) < sizeThreshold);
    }
    getGPGPUContext() {
      return this.gpgpu;
    }
    where(condition) {
      backend_util_exports.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
      const condVals = condition.dataSync();
      return whereImpl2(condition.shape, condVals);
    }
    packedUnaryOp(x2, op2, dtype) {
      const program = new UnaryOpPackedProgram(x2.shape, op2);
      const outInfo = this.compileAndRun(program, [x2], dtype);
      return engine().makeTensorFromTensorInfo(outInfo);
    }
    // TODO(msoulanille) remove this once the backend has been modularized
    // a copy is needed here to break a circular dependency.
    // Also remove the op from unary_op.
    abs(x2) {
      if (this.shouldExecuteOnCPU([x2]) && x2.dtype !== "complex64") {
        const outValues = simpleAbsImplCPU(this.texData.get(x2.dataId).values);
        return this.makeOutput(x2.shape, x2.dtype, outValues);
      }
      if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
        return this.packedUnaryOp(x2, ABS, x2.dtype);
      }
      const program = new UnaryOpProgram(x2.shape, ABS);
      const outInfo = this.compileAndRun(program, [x2]);
      return engine().makeTensorFromTensorInfo(outInfo);
    }
    makeTensorInfo(shape, dtype, values) {
      let dataId;
      if (dtype === "string" && values != null && values.length > 0 && util_exports.isString(values[0])) {
        const encodedValues = values.map((d2) => util_exports.encodeString(d2));
        dataId = this.write(encodedValues, shape, dtype);
      } else {
        dataId = this.write(values, shape, dtype);
      }
      this.texData.get(dataId).usage = null;
      return { dataId, shape, dtype };
    }
    makeOutput(shape, dtype, values) {
      return engine().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);
    }
    unpackTensor(input2) {
      const program = new UnpackProgram(input2.shape);
      return this.runWebGLProgram(program, [input2], input2.dtype);
    }
    packTensor(input2) {
      const program = new PackProgram(input2.shape);
      const preventEagerUnpackingOutput = true;
      return this.runWebGLProgram(program, [input2], input2.dtype, null, preventEagerUnpackingOutput);
    }
    packedReshape(input2, afterShape) {
      const input3DShape = [
        getBatchDim(input2.shape),
        ...getRowsCols(input2.shape)
      ];
      const input3D = {
        dtype: input2.dtype,
        shape: input3DShape,
        dataId: input2.dataId
      };
      const afterShapeAs3D = [
        getBatchDim(afterShape),
        ...getRowsCols(afterShape)
      ];
      const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
      const preventEagerUnpackingOfOutput = true;
      const customValues = [input3DShape];
      const output = this.runWebGLProgram(program, [input3D], input2.dtype, customValues, preventEagerUnpackingOfOutput);
      return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
    }
    decode(dataId, customTexShape) {
      const texData = this.texData.get(dataId);
      const { isPacked, shape, dtype } = texData;
      if (customTexShape != null) {
        const size = util_exports.sizeFromShape(shape);
        const texSize = customTexShape[0] * customTexShape[1] * 4;
        util_exports.assert(size <= texSize, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
      }
      const shapeAs3D = getShapeAs3D(shape);
      let program;
      if (isPacked) {
        program = new DecodeMatrixPackedProgram(shapeAs3D);
      } else {
        program = new DecodeMatrixProgram(shapeAs3D);
      }
      const preventEagerUnpackingOfOutput = true;
      const customValues = [customTexShape != null ? customTexShape : getDenseTexShape(shapeAs3D)];
      const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, customValues, preventEagerUnpackingOfOutput, customTexShape);
      return { dtype, shape, dataId: out.dataId };
    }
    runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false, customTexShape) {
      const output = this.makeTensorInfo(program.outputShape, outputDtype);
      const outData = this.texData.get(output.dataId);
      if (program.packedOutput) {
        outData.isPacked = true;
      }
      if (program.outPackingScheme === PackingScheme.DENSE) {
        const texelShape = customTexShape != null ? customTexShape : getDenseTexShape(program.outputShape);
        outData.texShape = texelShape.map((d2) => d2 * 2);
      }
      if (program.outTexUsage != null) {
        outData.usage = program.outTexUsage;
      }
      if (util_exports.sizeFromShape(output.shape) === 0) {
        outData.values = util_exports.getTypedArrayFromDType(output.dtype, 0);
        return output;
      }
      const dataToDispose = [];
      const inputsData = inputs.map((input2) => {
        if (input2.dtype === "complex64") {
          throw new Error(`GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.`);
        }
        let texData = this.texData.get(input2.dataId);
        if (texData.texture == null) {
          if (!program.packedInputs && util_exports.sizeFromShape(input2.shape) <= env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) {
            return {
              shape: input2.shape,
              texData: null,
              isUniform: true,
              uniformValues: texData.values
            };
          }
          if (program.packedInputs) {
            texData.isPacked = true;
            texData.shape = input2.shape;
          }
        }
        this.uploadToGPU(input2.dataId);
        if (!!texData.isPacked !== !!program.packedInputs) {
          input2 = texData.isPacked ? this.unpackTensor(input2) : this.packTensor(input2);
          dataToDispose.push(input2);
          texData = this.texData.get(input2.dataId);
        } else if (texData.isPacked && !isReshapeFree(texData.shape, input2.shape)) {
          const savedInput = input2;
          const targetShape = input2.shape;
          input2.shape = texData.shape;
          input2 = this.packedReshape(input2, targetShape);
          dataToDispose.push(input2);
          texData = this.texData.get(input2.dataId);
          savedInput.shape = targetShape;
        }
        return { shape: input2.shape, texData, isUniform: false };
      });
      this.uploadToGPU(output.dataId);
      const outputData = { shape: output.shape, texData: outData, isUniform: false };
      const key = makeShaderKey(program, inputsData, outputData);
      const binary = this.getAndSaveBinary(key, () => {
        return compileProgram(this.gpgpu, program, inputsData, outputData);
      });
      const shouldTimeProgram = this.activeTimers != null;
      let query;
      if (shouldTimeProgram) {
        query = this.startTimer();
      }
      if (!env().get("ENGINE_COMPILE_ONLY")) {
        runProgram(this.gpgpu, binary, inputsData, outputData, customUniformValues);
      }
      dataToDispose.forEach((info) => this.disposeIntermediateTensorInfo(info));
      if (shouldTimeProgram) {
        query = this.endTimer(query);
        this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });
      }
      const glFlushThreshold = env().get("WEBGL_FLUSH_THRESHOLD");
      if (glFlushThreshold > 0) {
        const time = util_exports.now();
        if (time - this.lastGlFlushTime > glFlushThreshold) {
          this.gpgpu.gl.flush();
          this.lastGlFlushTime = time;
        }
      }
      if (!env().getBool("WEBGL_LAZILY_UNPACK") && outData.isPacked && preventEagerUnpackingOfOutput === false) {
        const unpacked = this.unpackTensor(output);
        this.disposeIntermediateTensorInfo(output);
        return unpacked;
      }
      return output;
    }
    compileAndRun(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false) {
      outputDtype = outputDtype || inputs[0].dtype;
      const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput);
      return outInfo;
    }
    getAndSaveBinary(key, getBinary) {
      if (!(key in this.binaryCache)) {
        this.binaryCache[key] = getBinary();
      }
      return this.binaryCache[key];
    }
    getTextureManager() {
      return this.textureManager;
    }
    dispose() {
      if (this.disposed) {
        return;
      }
      if (!env().getBool("IS_TEST")) {
        const allKeys = Object.keys(this.binaryCache);
        allKeys.forEach((key) => {
          this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
          delete this.binaryCache[key];
        });
      }
      this.textureManager.dispose();
      if (this.canvas != null && (typeof HTMLCanvasElement !== "undefined" && this.canvas instanceof HTMLCanvasElement)) {
        this.canvas.remove();
      } else {
        this.canvas = null;
      }
      if (this.gpgpuCreatedLocally) {
        this.gpgpu.program = null;
        this.gpgpu.dispose();
      }
      this.disposed = true;
    }
    floatPrecision() {
      if (this.floatPrecisionValue == null) {
        this.floatPrecisionValue = tidy(() => {
          if (!env().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
            const debugFlag = env().getBool("DEBUG");
            env().set("DEBUG", false);
            const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];
            env().set("DEBUG", debugFlag);
            if (underflowCheckValue > 0) {
              return 32;
            }
          }
          return 16;
        });
      }
      return this.floatPrecisionValue;
    }
    /** Returns the smallest representable number.  */
    epsilon() {
      return this.floatPrecision() === 32 ? EPSILON_FLOAT322 : EPSILON_FLOAT162;
    }
    uploadToGPU(dataId) {
      const texData = this.texData.get(dataId);
      const { shape, dtype, values, texture, usage, isPacked } = texData;
      if (texture != null) {
        return;
      }
      const shouldTimeProgram = this.activeTimers != null;
      let start;
      if (shouldTimeProgram) {
        start = util_exports.now();
      }
      let texShape = texData.texShape;
      if (texShape == null) {
        texShape = getTextureShapeFromLogicalShape(shape, isPacked);
        texData.texShape = texShape;
      }
      if (values != null) {
        const shapeAs3D = getShapeAs3D(shape);
        let program;
        let width = texShape[1], height = texShape[0];
        const isByteArray = values instanceof Uint8Array || values instanceof Uint8ClampedArray;
        if (isPacked || !isByteArray) {
          [width, height] = getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);
        }
        if (isPacked) {
          program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);
        } else {
          program = new EncodeMatrixProgram(shapeAs3D, isByteArray);
        }
        const tempDenseInputTexShape = isByteArray ? [height, width] : texShape;
        const tempDenseInputHandle = this.makeTensorInfo(tempDenseInputTexShape, dtype);
        const tempDenseInputTexData = this.texData.get(tempDenseInputHandle.dataId);
        if (isByteArray) {
          tempDenseInputTexData.usage = TextureUsage.PIXELS;
        } else {
          tempDenseInputTexData.usage = TextureUsage.UPLOAD;
        }
        tempDenseInputTexData.texShape = tempDenseInputTexShape;
        this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);
        const customValues = [[height, width]];
        const preventEagerUnpacking = true;
        const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, customValues, preventEagerUnpacking);
        const outputTexData = this.texData.get(encodedOutputTarget.dataId);
        texData.texShape = outputTexData.texShape;
        texData.isPacked = outputTexData.isPacked;
        texData.usage = outputTexData.usage;
        if (!env().get("ENGINE_COMPILE_ONLY")) {
          texData.texture = outputTexData.texture;
          texData.values = null;
          this.texData.delete(encodedOutputTarget.dataId);
        } else {
          this.disposeData(encodedOutputTarget.dataId);
        }
        this.disposeIntermediateTensorInfo(tempDenseInputHandle);
        if (shouldTimeProgram) {
          this.uploadWaitMs += util_exports.now() - start;
        }
      } else {
        const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);
        texData.texture = newTexture;
      }
    }
    convertAndCacheOnCPU(dataId, float32Values) {
      const texData = this.texData.get(dataId);
      const { dtype } = texData;
      if (float32Values != null) {
        texData.values = float32ToTypedArray(float32Values, dtype);
      }
      return texData.values;
    }
    acquireTexture(texShape, texType, dtype, isPacked) {
      this.numBytesInGPU += this.computeBytes(texShape, dtype);
      if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
        const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
        this.warnedAboutMemory = true;
        console.warn(`High memory usage in GPU: ${mb} MB, most likely due to a memory leak`);
      }
      return this.textureManager.acquireTexture(texShape, texType, isPacked);
    }
    computeBytes(shape, dtype) {
      return shape[0] * shape[1] * util_exports.bytesPerElement(dtype);
    }
    checkCompileCompletion() {
      for (const [, binary] of Object.entries(this.binaryCache)) {
        this.checkCompletion_(binary);
      }
    }
    async checkCompileCompletionAsync() {
      const ps2 = [];
      if (this.gpgpu.parallelCompilationExtension) {
        for (const [, binary] of Object.entries(this.binaryCache)) {
          ps2.push(this.checkCompletionAsync_(binary));
        }
        return Promise.all(ps2);
      } else {
        for (const [, binary] of Object.entries(this.binaryCache)) {
          const p2 = new Promise((resolve) => {
            try {
              this.checkCompletion_(binary);
              resolve(true);
            } catch (error) {
              throw error;
            }
          });
          ps2.push(p2);
        }
        return Promise.all(ps2);
      }
    }
    async checkCompletionAsync_(binary) {
      if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {
        return this.checkCompletion_(binary);
      } else {
        await nextFrame();
        return this.checkCompletionAsync_(binary);
      }
    }
    checkCompletion_(binary) {
      if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {
        console.log(this.gpgpu.gl.getProgramInfoLog(binary.webGLProgram));
        if (this.gpgpu.gl.getShaderParameter(binary.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {
          logShaderSourceAndInfoLog(binary.source, this.gpgpu.gl.getShaderInfoLog(binary.fragmentShader));
          throw new Error("Failed to compile fragment shader.");
        }
        throw new Error("Failed to link vertex and fragment shaders.");
      }
      return true;
    }
    getUniformLocations() {
      for (const [, binary] of Object.entries(this.binaryCache)) {
        const { uniformLocations, customUniformLocations, infLoc, nanLoc, inShapesLocations, inTexShapesLocations, outShapeLocation, outShapeStridesLocation, outTexShapeLocation } = getUniformLocations(this.gpgpu, binary.program, binary.webGLProgram);
        binary.uniformLocations = uniformLocations;
        binary.customUniformLocations = customUniformLocations;
        binary.infLoc = infLoc;
        binary.nanLoc = nanLoc;
        binary.inShapesLocations = inShapesLocations;
        binary.inTexShapesLocations = inTexShapesLocations;
        binary.outShapeLocation = outShapeLocation;
        binary.outShapeStridesLocation = outShapeStridesLocation;
        binary.outTexShapeLocation = outTexShapeLocation;
      }
    }
    /**
     * Create a TF.js tensor out of an existing WebGL texture. A new texture will
     * be created.
     */
    createTensorFromGPUData(values, shape, dtype) {
      values.channels = values.channels || "RGBA";
      const { texture, height, width, channels } = values;
      const backend = engine().backend;
      if (!backend.gpgpu.gl.isTexture(texture)) {
        throw new Error(`The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.`);
      }
      const dataId = backend.writeTexture(texture, shape, dtype, height, width, channels);
      return engine().makeTensorFromDataId(dataId, shape, dtype, backend);
    }
  };
  MathBackendWebGL.nextDataId = 0;
  function float32ToTypedArray(a2, dtype) {
    if (dtype === "float32" || dtype === "complex64") {
      return a2;
    } else if (dtype === "int32" || dtype === "bool") {
      const result = dtype === "int32" ? new Int32Array(a2.length) : new Uint8Array(a2.length);
      for (let i2 = 0; i2 < result.length; ++i2) {
        result[i2] = Math.round(a2[i2]);
      }
      return result;
    } else {
      throw new Error(`Unknown dtype ${dtype}`);
    }
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/base.js
  if (device_util_exports.isBrowser()) {
    registerBackend(
      "webgl",
      () => new MathBackendWebGL(),
      2
      /* priority */
    );
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js
  var CHECK_NAN_SNIPPET2 = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
  var BinaryOpProgram = class {
    constructor(op2, aShape, bShape) {
      this.variableNames = ["A", "B"];
      this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      float binaryOperation(float a, float b) {
        ${op2}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js
  var CHECK_NAN_SNIPPET_PACKED = `
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;
  var BinaryOpPackedProgram = class {
    constructor(op2, aShape, bShape, checkOutOfBounds = false) {
      this.variableNames = ["A", "B"];
      this.supportsBroadcasting = true;
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
      const rank = this.outputShape.length;
      this.enableShapeUniforms = useShapeUniforms(rank);
      let checkOutOfBoundsString = "";
      if (checkOutOfBounds) {
        if (rank === 0 || util_exports.sizeFromShape(this.outputShape) === 1) {
          checkOutOfBoundsString = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
        } else {
          const dtype = getCoordsDataType(rank);
          checkOutOfBoundsString = `
          ${dtype} coords = getOutputCoords();
        `;
          if (rank === 1) {
            if (this.enableShapeUniforms) {
              checkOutOfBoundsString += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
            } else {
              checkOutOfBoundsString += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
            }
          } else {
            const channels = getChannels("coords", rank);
            if (this.enableShapeUniforms) {
              checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= outShape[${rank} - 2];
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= outShape[${rank} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
            } else {
              checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
            }
          }
        }
      }
      this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${op2}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${checkOutOfBoundsString}

        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js
  function identity3(args) {
    const { inputs, backend } = args;
    const { x: x2 } = inputs;
    backend.incRef(x2.dataId);
    return { dataId: x2.dataId, shape: x2.shape, dtype: x2.dtype };
  }
  var identityConfig = {
    kernelName: Identity2,
    backendName: "webgl",
    kernelFunc: identity3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js
  function complex3(args) {
    const { inputs, backend } = args;
    const { real: real4, imag: imag3 } = inputs;
    const complexInfo = backend.makeTensorInfo(real4.shape, "complex64");
    const complex4 = backend.texData.get(complexInfo.dataId);
    const realTensorInfo = identity3({ inputs: { x: real4 }, backend });
    const imagTensorInfo = identity3({ inputs: { x: imag3 }, backend });
    complex4.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };
    return complexInfo;
  }
  var complexConfig = {
    kernelName: Complex,
    backendName: "webgl",
    kernelFunc: complex3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LeakyRelu.js
  var LEAKYRELU = `return (a < 0.) ? b * a : a;`;
  var LEAKYRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function leakyRelu2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { alpha } = attrs;
    const $alpha = backend.makeTensorInfo([], "float32", util_exports.createScalarValue(alpha, "float32"));
    const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(LEAKYRELU_PACKED, x2.shape, $alpha.shape) : new BinaryOpProgram(LEAKYRELU, x2.shape, $alpha.shape);
    const result = backend.runWebGLProgram(program, [x2, $alpha], "float32");
    backend.disposeIntermediateTensorInfo($alpha);
    return result;
  }
  var leakyReluConfig = {
    kernelName: LeakyRelu,
    backendName: "webgl",
    kernelFunc: leakyRelu2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prelu.js
  var PRELU = `return (a < 0.) ? b * a : a;`;
  var PRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function prelu2(args) {
    const { inputs, backend } = args;
    const { x: x2, alpha } = inputs;
    const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(PRELU_PACKED, x2.shape, alpha.shape) : new BinaryOpProgram(PRELU, x2.shape, alpha.shape);
    return backend.runWebGLProgram(program, [x2, alpha], "float32");
  }
  var preluConfig = {
    kernelName: Prelu,
    backendName: "webgl",
    kernelFunc: prelu2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js
  var CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;
  function unaryKernelFunc2({ opSnippet, packedOpSnippet, cpuKernelImpl, dtype }) {
    return ({ inputs, backend }) => {
      const { x: x2 } = inputs;
      const webglBackend = backend;
      const $dtype = dtype || x2.dtype;
      if (webglBackend.shouldExecuteOnCPU([x2]) && cpuKernelImpl != null) {
        const xData = webglBackend.texData.get(x2.dataId);
        const outValues = cpuKernelImpl(xData.values, $dtype);
        return webglBackend.makeTensorInfo(x2.shape, $dtype, outValues);
      }
      const shouldUsePackedProgram = env().getBool("WEBGL_PACK_UNARY_OPERATIONS") && packedOpSnippet != null;
      let program;
      if (shouldUsePackedProgram) {
        program = new UnaryOpPackedProgram(x2.shape, packedOpSnippet);
      } else {
        program = new UnaryOpProgram(x2.shape, opSnippet);
      }
      return webglBackend.runWebGLProgram(program, [x2], $dtype);
    };
  }
  function binaryKernelFunc2({ opSnippet, packedOpSnippet, checkOutOfBounds = false, supportsComplex = false, cpuKernelImpl, dtype }) {
    return ({ inputs, backend }) => {
      const { a: a2, b: b2 } = inputs;
      const webglBackend = backend;
      if (supportsComplex && a2.dtype === "complex64") {
        const aData = webglBackend.texData.get(a2.dataId);
        const bData = webglBackend.texData.get(b2.dataId);
        const [real4, imag3] = [
          [aData.complexTensorInfos.real, bData.complexTensorInfos.real],
          [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]
        ].map((complexParts) => {
          const [aPart, bPart] = complexParts;
          const aHandle = {
            dataId: aPart.dataId,
            dtype: aPart.dtype,
            shape: a2.shape
          };
          const bHandle = {
            dataId: bPart.dataId,
            dtype: bPart.dtype,
            shape: b2.shape
          };
          const program2 = new BinaryOpProgram(opSnippet, a2.shape, b2.shape);
          return webglBackend.runWebGLProgram(program2, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));
        });
        const complexOutput = complex3({ inputs: { real: real4, imag: imag3 }, backend: webglBackend });
        webglBackend.disposeIntermediateTensorInfo(real4);
        webglBackend.disposeIntermediateTensorInfo(imag3);
        return complexOutput;
      }
      const $dtype = dtype || upcastType(a2.dtype, b2.dtype);
      if ((a2.dtype === "string" || b2.dtype === "string" || webglBackend.shouldExecuteOnCPU([a2, b2])) && cpuKernelImpl != null) {
        const aVals = webglBackend.texData.get(a2.dataId).values;
        const bVals = webglBackend.texData.get(b2.dataId).values;
        const decodedAVals = a2.dtype === "string" ? (
          // tslint:disable-next-line: no-any
          backend_util_exports.fromUint8ToStringArray(aVals)
        ) : aVals;
        const decodedBVals = a2.dtype === "string" ? (
          // tslint:disable-next-line: no-any
          backend_util_exports.fromUint8ToStringArray(bVals)
        ) : bVals;
        const [outValues, outShape] = cpuKernelImpl(a2.shape, b2.shape, decodedAVals, decodedBVals, $dtype);
        const out = webglBackend.makeTensorInfo(outShape, $dtype);
        const outData = webglBackend.texData.get(out.dataId);
        outData.values = outValues;
        return out;
      }
      const shouldUsePackedProgram = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") && packedOpSnippet != null;
      let program;
      if (shouldUsePackedProgram) {
        program = new BinaryOpPackedProgram(packedOpSnippet, a2.shape, b2.shape, checkOutOfBounds);
      } else {
        program = new BinaryOpProgram(opSnippet, a2.shape, b2.shape);
      }
      return webglBackend.runWebGLProgram(program, [a2, b2], $dtype);
    };
  }
  function mapActivationToShaderProgram(activation2, packed = false) {
    if (activation2 === "linear") {
      if (packed) {
        return LINEAR2;
      }
      return LINEAR;
    } else if (activation2 === "relu") {
      if (packed) {
        return RELU2;
      }
      return RELU;
    } else if (activation2 === "elu") {
      if (packed) {
        return ELU3;
      }
      return ELU2;
    } else if (activation2 === "relu6") {
      if (packed) {
        return RELU62;
      }
      return RELU6;
    } else if (activation2 === "prelu") {
      if (packed) {
        return PRELU_PACKED;
      }
      return PRELU;
    } else if (activation2 === "leakyrelu") {
      if (packed) {
        return LEAKYRELU_PACKED;
      }
      return LEAKYRELU;
    } else if (activation2 === "sigmoid") {
      if (packed) {
        return SIGMOID2;
      }
      return SIGMOID;
    }
    throw new Error(`Activation ${activation2} has not been implemented for the WebGL backend.`);
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js
  var MatMulPackedProgram = class {
    constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyreluActivation = false) {
      this.variableNames = ["matrixA", "matrixB"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const sharedDim = transposeA ? aShape[1] : aShape[2];
      const sharedDimensionPacked = Math.ceil(sharedDim / 2);
      const aSample = transposeA ? "i * 2, rc.y" : "rc.y, i * 2";
      const bSample = transposeB ? "rc.z, i * 2" : "i * 2, rc.z";
      const aSwizzle = transposeA ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"];
      const bSwizzle = transposeB ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation2) {
        if (hasPreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
        } else if (hasLeakyreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
        } else {
          activationSnippet = `vec4 activation(vec4 x) {
          ${activation2}
        }`;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyreluActivation) {
        this.variableNames.push("leakyreluAlpha");
      }
      let batchASnippet = "rc.x";
      let batchBSnippet = "rc.x";
      if (aShape[0] < bShape[0]) {
        batchASnippet = `imod(rc.x, ${aShape[0]})`;
      } else if (bShape[0] < aShape[0]) {
        batchBSnippet = `imod(rc.x, ${bShape[0]})`;
      }
      this.userCode = `
      ${activationSnippet}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${sharedDimensionPacked}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${batchASnippet};
        int batchB = ${batchBSnippet};
        for (int i = 0; i < ${sharedDimensionPacked}; i++) {
          vec4 a = getMatrixA(batchA, ${aSample});
          vec4 b = getMatrixB(batchB, ${bSample});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${aSwizzle[0]} * ${bSwizzle[0]});
          result += (${aSwizzle[1]} * ${bSwizzle[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${addBiasSnippet}

        ${applyActivationSnippet}

        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_complex_gpu.js
  var COMPLEX_MULTIPLY = {
    REAL: "return areal * breal - aimag * bimag;",
    IMAG: "return areal * bimag + aimag * breal;"
  };
  var BinaryOpComplexProgram = class {
    constructor(op2, aShape, bShape) {
      this.variableNames = ["AReal", "AImag", "BReal", "BImag"];
      this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
      this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${op2}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply.js
  var MUL = "return a * b;";
  function multiply2(args) {
    const { inputs, backend } = args;
    const { a: a2, b: b2 } = inputs;
    const dtype = backend_util_exports.upcastType(a2.dtype, b2.dtype);
    if (a2.dtype === "complex64") {
      const aData = backend.texData.get(a2.dataId);
      const bData = backend.texData.get(b2.dataId);
      const realProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL, a2.shape, b2.shape);
      const imagProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG, a2.shape, b2.shape);
      const inputs2 = [
        {
          dataId: aData.complexTensorInfos.real.dataId,
          dtype: aData.complexTensorInfos.real.dtype,
          shape: a2.shape
        },
        {
          dataId: aData.complexTensorInfos.imag.dataId,
          dtype: aData.complexTensorInfos.imag.dtype,
          shape: a2.shape
        },
        {
          dataId: bData.complexTensorInfos.real.dataId,
          dtype: bData.complexTensorInfos.real.dtype,
          shape: b2.shape
        },
        {
          dataId: bData.complexTensorInfos.imag.dataId,
          dtype: bData.complexTensorInfos.imag.dtype,
          shape: b2.shape
        }
      ];
      const realPart = backend.runWebGLProgram(realProgram, inputs2, "float32");
      const imagPart = backend.runWebGLProgram(imagProgram, inputs2, "float32");
      const complexOutput = complex3({ inputs: { real: realPart, imag: imagPart }, backend });
      backend.disposeIntermediateTensorInfo(realPart);
      backend.disposeIntermediateTensorInfo(imagPart);
      return complexOutput;
    }
    if (backend.shouldExecuteOnCPU([a2, b2])) {
      const aData = backend.texData.get(a2.dataId);
      const bData = backend.texData.get(b2.dataId);
      const [outValues, outShape] = multiplyImplCPU(a2.shape, b2.shape, aData.values, bData.values, dtype);
      const out = backend.makeTensorInfo(outShape, dtype);
      const outData = backend.texData.get(out.dataId);
      outData.values = outValues;
      return out;
    }
    let program;
    if (env().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
      program = new BinaryOpPackedProgram(MUL, a2.shape, b2.shape);
    } else {
      program = new BinaryOpProgram(MUL, a2.shape, b2.shape);
    }
    return backend.runWebGLProgram(program, [a2, b2], dtype);
  }
  var multiplyConfig = {
    kernelName: Multiply2,
    backendName: "webgl",
    kernelFunc: multiply2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reshape.js
  function packedReshape(input2, afterShape, backend) {
    const input3DShape = [
      getBatchDim(input2.shape),
      ...getRowsCols(input2.shape)
    ];
    const input3D = {
      dtype: input2.dtype,
      shape: input3DShape,
      dataId: input2.dataId
    };
    const afterShapeAs3D = [
      getBatchDim(afterShape),
      ...getRowsCols(afterShape)
    ];
    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
    const preventEagerUnpackingOfOutput = true;
    const customValues = [input3DShape];
    const output = backend.runWebGLProgram(program, [input3D], input2.dtype, customValues, preventEagerUnpackingOfOutput);
    return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js
  function reshape3(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { shape } = attrs;
    const webglBackend = backend;
    const xSize = util_exports.sizeFromShape(x2.shape);
    const $shape = util_exports.inferFromImplicitShape(shape, xSize);
    const $xSize = util_exports.sizeFromShape($shape);
    util_exports.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old shape (${x2.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);
    const xTexData = webglBackend.texData.get(x2.dataId);
    if (xTexData.isPacked && !isReshapeFree(x2.shape, $shape) && !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {
      return packedReshape(x2, $shape, webglBackend);
    }
    webglBackend.incRef(x2.dataId);
    return { dataId: x2.dataId, shape: $shape, dtype: x2.dtype };
  }
  var reshapeConfig = {
    kernelName: Reshape2,
    backendName: "webgl",
    kernelFunc: reshape3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/mean_gpu.js
  var MeanProgram = class {
    constructor(reduceInfo, divisor) {
      this.variableNames = ["x"];
      const { windowSize, batchSize, inSize, outSize } = reduceInfo;
      this.outputShape = [batchSize, outSize];
      const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
      const windowSizeVec4Remainder = windowSize % 4;
      let updateSnippet = `sumValue += dot(values, ones);`;
      if (divisor != null) {
        const denominator = 1 / divisor;
        updateSnippet = `sumValue += dot(values * ${util_exports.isInt(denominator) ? denominator.toPrecision(2) : denominator}, ones);`;
      }
      let checkOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return 0.0;
        }
      `;
      }
      this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${updateSnippet}
        }
        setOutput(sumValue);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js
  var ReduceProgram = class {
    constructor(reduceInfo, reduceType) {
      this.variableNames = ["x"];
      const { windowSize, batchSize, inSize, outSize } = reduceInfo;
      this.outputShape = [batchSize, outSize];
      let initializationValue = "0.0";
      let compareOp = ``;
      if (reduceType === "prod") {
        initializationValue = "1.0";
      } else if (reduceType === "min") {
        initializationValue = "1.0 / 1e-20";
        compareOp = `min`;
      } else if (reduceType === "max") {
        initializationValue = "-1.0 / 1e-20";
        compareOp = `max`;
      }
      let returnValue = `${reduceType}(${reduceType}(${reduceType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (reduceType === "sum") {
        returnValue = `sumValue`;
      } else if (reduceType === "prod") {
        returnValue = `prodValue`;
      } else if (reduceType === "all") {
        returnValue = `allValue`;
      } else if (reduceType === "any") {
        returnValue = `anyValue`;
      }
      const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
      const windowSizeVec4Remainder = windowSize % 4;
      let updateSnippet = `
      if (${reduceType === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${reduceType === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
        if (${reduceType === "min"} || ${reduceType === "max"}) {
          minMaxValue = ${compareOp}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `;
      let vecType = `vec4`;
      if (reduceType === "all") {
        initializationValue = "1.0";
        updateSnippet = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `;
        vecType = `bvec4`;
      } else if (reduceType === "any") {
        initializationValue = "0.0";
        updateSnippet = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `;
        vecType = `bvec4`;
      }
      let checkOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
      }
      this.userCode = `
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        vec4 minMaxValue = vec4(${initializationValue});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js
  function getReductionStages(inShape) {
    const stages = [];
    while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {
      const outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];
      const windowSize = backend_util_exports.computeOptimalWindowSize(outSize);
      stages.push({
        inSize: outSize,
        windowSize,
        outSize: Math.ceil(outSize / windowSize)
      });
    }
    return stages;
  }
  function reduce(x2, dtype, reductionType, backend) {
    const reductionStages = getReductionStages(x2.shape);
    let result = x2;
    for (let i2 = 0; i2 < reductionStages.length; i2++) {
      const { inSize, windowSize, outSize } = reductionStages[i2];
      let program;
      let previousResult;
      if (reductionType === "mean") {
        program = i2 === 0 ? new MeanProgram({ windowSize, inSize, batchSize: x2.shape[0], outSize }, inSize) : new MeanProgram({ windowSize, inSize, batchSize: x2.shape[0], outSize });
      } else {
        program = new ReduceProgram({ windowSize, inSize, batchSize: x2.shape[0], outSize }, reductionType);
      }
      previousResult = result;
      result = backend.runWebGLProgram(program, [result], dtype);
      if (previousResult.dataId !== x2.dataId) {
        backend.disposeIntermediateTensorInfo(previousResult);
      }
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_gpu.js
  var TransposeProgram = class {
    constructor(aShape, newDim) {
      this.variableNames = ["A"];
      const outputShape = new Array(aShape.length);
      for (let i2 = 0; i2 < outputShape.length; i2++) {
        outputShape[i2] = aShape[newDim[i2]];
      }
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      const dtype = getCoordsDataType(this.rank);
      const switched = getSwitchedCoords(newDim);
      this.userCode = `
    void main() {
      ${dtype} resRC = getOutputCoords();
      setOutput(getA(${switched}));
    }
    `;
    }
  };
  function getSwitchedCoords(newDim) {
    const rank = newDim.length;
    if (rank > 6) {
      throw Error(`Transpose for rank ${rank} is not yet supported`);
    }
    const originalOrder = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"];
    const switchedCoords = new Array(rank);
    for (let i2 = 0; i2 < newDim.length; i2++) {
      switchedCoords[newDim[i2]] = originalOrder[i2];
    }
    return switchedCoords.join();
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_packed_gpu.js
  var TransposePackedProgram = class {
    constructor(aShape, newDim) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      const outputShape = new Array(aShape.length);
      for (let i2 = 0; i2 < outputShape.length; i2++) {
        outputShape[i2] = aShape[newDim[i2]];
      }
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      if (this.rank > 6) {
        throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
      }
      const dtype = getCoordsDataType(this.rank);
      const outputOrder = getVecChannels("rc", this.rank);
      const switchedOrder = new Array(this.rank);
      for (let i2 = 0; i2 < newDim.length; i2++) {
        switchedOrder[newDim[i2]] = outputOrder[i2];
      }
      const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;
      const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;
      const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;
      this.userCode = `
    void main() {
      ${dtype} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${getc};
      if(${nextColumn}) {
        result[1] = ${getc};
      }
      --${outputOrder[this.rank - 1]};
      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {
        result[2] = ${getc};
        if(${nextColumn}) {
          result[3] = ${getc};
        }
      }
      setOutput(result);
    }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js
  function transposeImpl2(x2, perm, backend) {
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new TransposePackedProgram(x2.shape, perm) : new TransposeProgram(x2.shape, perm);
    return backend.runWebGLProgram(program, [x2], x2.dtype);
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum_impl.js
  function sumImpl(x2, axis, keepDims, backend) {
    const reductionIndices = axis;
    const xRank = x2.shape.length;
    const origAxes = util_exports.parseAxisParam(reductionIndices, x2.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    const sumInputIsTransposed = permutedAxes != null;
    let sumInput = x2;
    if (sumInputIsTransposed) {
      sumInput = transposeImpl2(x2, permutedAxes, backend);
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    }
    backend_util_exports.assertAxesAreInnerMostDims("sum", axes, xRank);
    const [sumOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(sumInput.shape, axes);
    let outShape = sumOutShape;
    if (keepDims) {
      outShape = backend_util_exports.expandShapeToKeepDim(sumOutShape, origAxes);
    }
    const inSize = util_exports.sizeFromShape(reduceShape);
    const xSize = util_exports.sizeFromShape(x2.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = reshape3({ inputs: { x: sumInput }, attrs: { shape: [batchSize, inSize] }, backend });
    const outType = sumOutType(x2.dtype);
    const reduced = reduce(reshapedInput, outType, "sum", backend);
    const out = reshape3({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });
    backend.disposeIntermediateTensorInfo(reshapedInput);
    backend.disposeIntermediateTensorInfo(reduced);
    if (sumInputIsTransposed) {
      backend.disposeIntermediateTensorInfo(sumInput);
    }
    return out;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js
  function sum3(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { axis, keepDims } = attrs;
    return sumImpl(x2, axis, keepDims, backend);
  }
  var sumConfig = {
    kernelName: Sum,
    backendName: "webgl",
    kernelFunc: sum3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js
  function transpose2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { perm } = attrs;
    const webglBackend = backend;
    const xRank = x2.shape.length;
    const newShape = new Array(xRank);
    for (let i2 = 0; i2 < newShape.length; i2++) {
      newShape[i2] = x2.shape[perm[i2]];
    }
    let out;
    if (webglBackend.shouldExecuteOnCPU([x2])) {
      const xTexData = webglBackend.texData.get(x2.dataId);
      const values = xTexData.values;
      const outValues = transposeImplCPU(values, x2.shape, x2.dtype, perm, newShape);
      out = webglBackend.makeTensorInfo(newShape, x2.dtype);
      const outData = webglBackend.texData.get(out.dataId);
      outData.values = outValues;
    } else {
      out = transposeImpl2(x2, perm, webglBackend);
    }
    return out;
  }
  var transposeConfig = {
    kernelName: Transpose,
    backendName: "webgl",
    kernelFunc: transpose2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js
  var MATMUL_SHARED_DIM_THRESHOLD = 1e3;
  function batchMatMulImpl({ a: a2, b: b2, transposeA, transposeB, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
    const aRank = a2.shape.length;
    const bRank = b2.shape.length;
    const innerShapeA = transposeA ? a2.shape[aRank - 2] : a2.shape[aRank - 1];
    const innerShapeB = transposeB ? b2.shape[bRank - 1] : b2.shape[bRank - 2];
    const outerShapeA = transposeA ? a2.shape[aRank - 1] : a2.shape[aRank - 2];
    const outerShapeB = transposeB ? b2.shape[bRank - 2] : b2.shape[bRank - 1];
    const outerDimsA = a2.shape.slice(0, -2);
    const outerDimsB = b2.shape.slice(0, -2);
    const batchDimA = util_exports.sizeFromShape(outerDimsA);
    const batchDimB = util_exports.sizeFromShape(outerDimsB);
    const outShapeOuterDims = broadcast_util_exports.assertAndGetBroadcastShape(a2.shape.slice(0, -2), b2.shape.slice(0, -2));
    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
    util_exports.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a2.shape} and ${b2.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
    const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
    const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
    const a3d = reshape3({ inputs: { x: a2 }, backend, attrs: { shape: a3dShape } });
    const b3d = reshape3({ inputs: { x: b2 }, backend, attrs: { shape: b3dShape } });
    const intermediates = [a3d, b3d];
    const batchDim = Math.max(batchDimA, batchDimB);
    const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation2 === "leakyrelu";
    const fusedActivation = activation2 != null ? mapActivationToShaderProgram(activation2, true) : null;
    const containsFusedOps = hasBias || hasPreluActivationWeights || hasLeakyreluAlpha || fusedActivation != null;
    let out;
    if ((outerShapeA === 1 || outerShapeB === 1) && sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {
      let aVec = a3d;
      let bVec = b3d;
      if (transposeA) {
        aVec = transpose2({ inputs: { x: a3d }, backend, attrs: { perm: [0, 2, 1] } });
        intermediates.push(aVec);
      }
      if (transposeB) {
        bVec = transpose2({ inputs: { x: b3d }, backend, attrs: { perm: [0, 2, 1] } });
        intermediates.push(bVec);
      }
      const shouldReshapeA = outerShapeB !== 1;
      const shouldReshapeB = outerShapeB === 1;
      let aVec3d = aVec;
      if (shouldReshapeA) {
        aVec3d = reshape3({
          inputs: { x: aVec },
          backend,
          attrs: { shape: [batchDim, sharedDim, 1] }
        });
        intermediates.push(aVec3d);
      }
      const axis = outerShapeB === 1 ? 2 : 1;
      let bVec3d = bVec;
      if (shouldReshapeB) {
        bVec3d = reshape3({
          inputs: { x: bVec },
          backend,
          attrs: { shape: [batchDim, 1, sharedDim] }
        });
        intermediates.push(bVec3d);
      }
      const product = multiply2({ inputs: { a: aVec3d, b: bVec3d }, backend });
      out = sum3({ inputs: { x: product }, backend, attrs: { axis, keepDims: true } });
      intermediates.push(product);
    } else {
      const dtype = upcastType(a2.dtype, b2.dtype);
      const program = new MatMulPackedProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      const inputs = [a3d, b3d];
      if (bias != null) {
        inputs.push(bias);
      }
      if (hasPreluActivationWeights) {
        inputs.push(preluActivationWeights);
      }
      if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
        inputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
      }
      out = backend.runWebGLProgram(program, inputs, dtype);
    }
    const outReshaped = reshape3({ inputs: { x: out }, backend, attrs: { shape: outShape } });
    intermediates.push(out);
    for (const i2 of intermediates) {
      backend.disposeIntermediateTensorInfo(i2);
    }
    return outReshaped;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/_FusedMatMul.js
  function _fusedMatMul(args) {
    const { inputs, backend, attrs } = args;
    const { a: a2, b: b2, bias, preluActivationWeights } = inputs;
    const { transposeA, transposeB, activation: activation2, leakyreluAlpha } = attrs;
    return batchMatMulImpl({
      a: a2,
      b: b2,
      transposeA,
      transposeB,
      backend,
      bias,
      preluActivationWeights,
      leakyreluAlpha,
      activation: activation2
    });
  }
  var _fusedMatMulConfig = {
    kernelName: _FusedMatMul,
    backendName: "webgl",
    kernelFunc: _fusedMatMul
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Abs.js
  var ABS2 = `return abs(x);`;
  function abs2(args) {
    const { inputs, backend } = args;
    const { x: x2 } = inputs;
    if (backend.shouldExecuteOnCPU([x2]) && x2.dtype !== "complex64") {
      const xData = backend.texData.get(x2.dataId);
      const outValues = simpleAbsImplCPU(xData.values);
      return backend.makeTensorInfo(x2.shape, x2.dtype, outValues);
    }
    let program;
    if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
      program = new UnaryOpPackedProgram(x2.shape, ABS2);
    } else {
      program = new UnaryOpProgram(x2.shape, ABS2);
    }
    return backend.runWebGLProgram(program, [x2], x2.dtype);
  }
  var absConfig = {
    kernelName: Abs,
    backendName: "webgl",
    kernelFunc: abs2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acos.js
  var ACOS = CHECK_NAN_SNIPPET + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
  var acos2 = unaryKernelFunc2({ opSnippet: ACOS });
  var acosConfig = {
    kernelName: Acos,
    backendName: "webgl",
    kernelFunc: acos2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acosh.js
  var ACOSH = CHECK_NAN_SNIPPET + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`;
  var acosh2 = unaryKernelFunc2({ opSnippet: ACOSH });
  var acoshConfig = {
    kernelName: Acosh,
    backendName: "webgl",
    kernelFunc: acosh2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Add.js
  var ADD = "return a + b;";
  var addKernelFunc = binaryKernelFunc2({
    opSnippet: ADD,
    packedOpSnippet: ADD,
    supportsComplex: true,
    cpuKernelImpl: addImplCPU
  });
  var addConfig = {
    kernelName: Add2,
    backendName: "webgl",
    kernelFunc: addKernelFunc
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_gpu.js
  var AddNProgram = class {
    constructor(outputShape, shapes) {
      this.outputShape = [];
      this.outputShape = outputShape;
      this.variableNames = shapes.map((_3, i2) => `T${i2}`);
      const snippets = [];
      this.variableNames.forEach((variable2) => {
        snippets.push(`float v${variable2} = get${variable2}AtOutCoords();`);
      });
      const operation = this.variableNames.map((variable2) => {
        return `v${variable2}`;
      }).join(" + ");
      this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        float result = ${operation};
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_packed_gpu.js
  var AddNPackedProgram = class {
    constructor(outputShape, shapes) {
      this.outputShape = [];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = outputShape;
      this.variableNames = shapes.map((_3, i2) => `T${i2}`);
      const snippets = [];
      this.variableNames.forEach((variable2) => {
        snippets.push(`vec4 v${variable2} = get${variable2}AtOutCoords();`);
      });
      const operation = this.variableNames.map((variable2) => {
        return `v${variable2}`;
      }).join(" + ");
      this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        vec4 result = ${operation};
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AddN.js
  function addN2(args) {
    const { inputs, backend } = args;
    const tensors = inputs;
    if (tensors.length === 1) {
      return identity3({ inputs: { x: tensors[0] }, backend });
    }
    if (tensors.length > env().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      const midIndex = Math.floor(tensors.length / 2);
      const leftSide = addN2({ inputs: tensors.slice(0, midIndex), backend });
      const rightSide = addN2({ inputs: tensors.slice(midIndex), backend });
      return addN2({ inputs: [leftSide, rightSide], backend });
    }
    const dtype = tensors.map((t3) => t3.dtype).reduce((d1, d2) => upcastType(d1, d2));
    const shapes = tensors.map((t3) => t3.shape);
    const usePackedOp = env().getBool("WEBGL_PACK");
    const program = usePackedOp ? new AddNPackedProgram(tensors[0].shape, shapes) : new AddNProgram(tensors[0].shape, shapes);
    return backend.runWebGLProgram(program, tensors, dtype);
  }
  var addNConfig = {
    kernelName: AddN,
    backendName: "webgl",
    kernelFunc: addN2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/All.js
  function all2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x2.shape.length;
    const origAxes = util_exports.parseAxisParam(axis, x2.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    let permutedX = x2;
    if (permutedAxes != null) {
      permutedX = transpose2({ inputs: { x: x2 }, backend, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    }
    backend_util_exports.assertAxesAreInnerMostDims("all", axes, xRank);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = util_exports.sizeFromShape(reduceShape);
    const a2D = reshape3({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
    const reduced = reduce(a2D, a2D.dtype, "all", backend);
    let res;
    if (keepDims) {
      const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
      res = reshape3({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });
    } else {
      res = reshape3({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
    }
    backend.disposeIntermediateTensorInfo(a2D);
    backend.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
      backend.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
  }
  var allConfig = {
    kernelName: All,
    backendName: "webgl",
    kernelFunc: all2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Any.js
  function any2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x2.shape.length;
    const origAxes = util_exports.parseAxisParam(axis, x2.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    let permutedX = x2;
    if (permutedAxes != null) {
      permutedX = transpose2({ inputs: { x: x2 }, backend, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    }
    backend_util_exports.assertAxesAreInnerMostDims("any", axes, xRank);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = util_exports.sizeFromShape(reduceShape);
    const a2D = reshape3({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
    const reduced = reduce(a2D, a2D.dtype, "any", backend);
    let res;
    if (keepDims) {
      const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
      res = reshape3({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });
    } else {
      res = reshape3({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
    }
    backend.disposeIntermediateTensorInfo(a2D);
    backend.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
      backend.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
  }
  var anyConfig = {
    kernelName: Any,
    backendName: "webgl",
    kernelFunc: any2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_gpu.js
  var ArgMinMaxProgram = class {
    constructor(reduceInfo, op2, firstPass) {
      this.variableNames = ["A"];
      const { windowSize, batchSize, outSize } = reduceInfo;
      if (!firstPass) {
        this.variableNames.push("bestIndicesA");
      }
      this.outputShape = [batchSize, outSize];
      const compOp = op2 === "max" ? ">" : "<";
      const indexSnippet = firstPass ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${windowSize}; i++) {
          int inIdx = ${indexSnippet};
          float candidate = getA(batch, inIdx);
          if (candidate ${compOp} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js
  var ArgMinMaxPackedProgram = class {
    constructor(shape, windowSize, op2, firstPass) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      util_exports.assert(shape.length > 2, () => `Packed arg${op2.charAt(0).toUpperCase() + op2.slice(1)} supports only inputs with rank above 2.`);
      const inSize = shape[shape.length - 1];
      const outSize = Math.ceil(inSize / windowSize);
      this.outputShape = shape.slice(0, -1);
      if (outSize > 1) {
        this.outputShape.push(outSize);
      }
      if (!firstPass) {
        this.variableNames.push("bestIndicesA");
      }
      const outShape = this.outputShape;
      const rank = outShape.length;
      const dtype = getCoordsDataType(rank);
      const coords2 = getChannels("coords", rank);
      let sourceLocSetup;
      let sourceRank;
      if (outSize === 1) {
        sourceRank = rank + 1;
        const sourceLocDType = getCoordsDataType(sourceRank);
        sourceLocSetup = `
        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords2.join()}, 0);
        ++${coords2[rank - 1]};
        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords2.join()}, 0);
        ++${coords2[rank - 2]};
        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords2.join()}, 0);
        --${coords2[rank - 1]};
        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords2.join()}, 0);
        --${coords2[rank - 2]};`;
      } else {
        sourceRank = rank;
        sourceLocSetup = `
        ${dtype} sourceLocR = coords;
        ++${coords2[rank - 1]};
        ${dtype} sourceLocG = coords;
        ++${coords2[rank - 2]};
        ${dtype} sourceLocA = coords;
        --${coords2[rank - 1]};
        ${dtype} sourceLocB = coords;
        --${coords2[rank - 2]};`;
      }
      const channels = ["x", "y", "z", "w", "u", "v"].slice(0, sourceRank);
      const inChannel = "." + channels[sourceRank - 1];
      const intChannels = channels.map((x2) => "int " + x2);
      const srcRCoords = getChannels("sourceLocR", sourceRank - 1).concat("inIdx.r");
      const srcGCoords = getChannels("sourceLocG", sourceRank - 1).concat("inIdx.g");
      const srcBCoords = getChannels("sourceLocB", sourceRank - 1).concat("inIdx.b");
      const srcACoords = getChannels("sourceLocA", sourceRank - 1).concat("inIdx.a");
      const compOp = op2 === "max" ? "greaterThan" : "lessThan";
      const fetchCandidateIdx = firstPass ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),
                             getBestIndicesAChannel(${srcGCoords.join()}),
                             getBestIndicesAChannel(${srcBCoords.join()}),
                             getBestIndicesAChannel(${srcACoords.join()})));`;
      const fetchValue = `vec4(
            getAChannel(${srcRCoords.join()}),
            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,
            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;
      const getBestIndicesAChannelSnippet = firstPass ? "" : `
      float getBestIndicesAChannel(${intChannels.join()}) {
        return getChannel(getBestIndicesA(${channels.join()}),
                                          vec2(${channels.slice(-2).join()}));
      }`;
      this.userCode = `
      float getAChannel(${intChannels.join()}) {
        return getChannel(getA(${channels.join()}),
                               vec2(${channels.slice(-2).join()}));
      }
      ${getBestIndicesAChannelSnippet}
      void main() {
        ${dtype} coords = getOutputCoords();
        bool hasNextCol = ${coords2[rank - 1]} < ${outShape[rank - 1] - 1};
        bool hasNextRow = ${coords2[rank - 2]} < ${outShape[rank - 2] - 1};
        ${sourceLocSetup}
        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},
          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${fetchValue};

        for (int i = 0; i < ${windowSize}; i++) {
          inIdx = srcIdx;
          ${fetchCandidateIdx}
          vec4 candidate = ${fetchValue};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js
  function argReduce(backend, x2, reduceType, bestIndicesA = null) {
    let batchSize = x2.shape[0];
    let inSize = x2.shape[1];
    if (bestIndicesA != null) {
      batchSize = bestIndicesA.shape[0];
      inSize = bestIndicesA.shape[1];
    }
    const windowSize = backend_util_exports.computeOptimalWindowSize(inSize);
    const reduceInfo = { windowSize, inSize, batchSize, outSize: Math.ceil(inSize / windowSize) };
    const program = new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
    const inputs = [x2];
    if (bestIndicesA != null) {
      inputs.push(bestIndicesA);
    }
    const output = backend.runWebGLProgram(program, inputs, "int32");
    if (output.shape[1] === 1) {
      return output;
    }
    const result = argReduce(backend, x2, reduceType, output);
    backend.disposeIntermediateTensorInfo(output);
    return result;
  }
  function argReducePacked(backend, x2, reduceType, bestIndicesA = null) {
    const inShape = bestIndicesA != null ? bestIndicesA.shape : x2.shape;
    const inSize = inShape[inShape.length - 1];
    const windowSize = backend_util_exports.computeOptimalWindowSize(inSize);
    const program = new ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);
    const inputs = bestIndicesA == null ? [x2] : [x2, bestIndicesA];
    const output = backend.runWebGLProgram(program, inputs, "int32");
    if (output.shape.length === x2.shape.length) {
      const result = argReducePacked(backend, x2, reduceType, output);
      backend.disposeIntermediateTensorInfo(output);
      return result;
    }
    return output;
  }
  function argMinMaxReduce(backend, x2, axis, reduceType) {
    const axes = [axis];
    backend_util_exports.assertAxesAreInnerMostDims("arg" + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x2.shape.length);
    if (!env().getBool("WEBGL_PACK_REDUCE") || x2.shape.length <= 2) {
      const intermediateTensorInfos = [];
      const xtexData = backend.texData.get(x2.dataId);
      const xIsPacked = xtexData !== null && xtexData.isPacked;
      let xUnPacked = x2;
      if (xIsPacked) {
        xUnPacked = backend.unpackTensor(x2);
        intermediateTensorInfos.push(xUnPacked);
      }
      const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(xUnPacked.shape, axes);
      const inSize = util_exports.sizeFromShape(reduceShape);
      const a2D = reshape3({ inputs: { x: xUnPacked }, backend, attrs: { shape: [-1, inSize] } });
      intermediateTensorInfos.push(a2D);
      const reduced = argReduce(backend, a2D, reduceType);
      intermediateTensorInfos.push(reduced);
      const reshaped = reshape3({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
      intermediateTensorInfos.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
      return reshaped;
    }
    return argReducePacked(backend, x2, reduceType);
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMax.js
  function argMax2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { axis } = attrs;
    let axes = util_exports.parseAxisParam(axis, x2.shape);
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
    let $x = x2;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
      $x = transpose2({ inputs: { x: x2 }, backend, attrs: { perm: permutedAxes } });
      intermediateTensorInfos.push($x);
      axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
    }
    backend_util_exports.assertAxesAreInnerMostDims("argMax", [axes[0]], $x.shape.length);
    const out = argMinMaxReduce(backend, $x, axes[0], "max");
    intermediateTensorInfos.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return out;
  }
  var argMaxConfig = {
    kernelName: ArgMax,
    backendName: "webgl",
    kernelFunc: argMax2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMin.js
  function argMin2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { axis } = attrs;
    let axes = util_exports.parseAxisParam(axis, x2.shape);
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, x2.shape.length);
    let $x = x2;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
      $x = transpose2({ inputs: { x: x2 }, backend, attrs: { perm: permutedAxes } });
      intermediateTensorInfos.push($x);
      axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
    }
    backend_util_exports.assertAxesAreInnerMostDims("argMin", [axes[0]], $x.shape.length);
    const out = argMinMaxReduce(backend, $x, axes[0], "min");
    intermediateTensorInfos.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return out;
  }
  var argMinConfig = {
    kernelName: ArgMin,
    backendName: "webgl",
    kernelFunc: argMin2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asin.js
  var ASIN = CHECK_NAN_SNIPPET + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
  var asin2 = unaryKernelFunc2({ opSnippet: ASIN });
  var asinConfig = {
    kernelName: Asin,
    backendName: "webgl",
    kernelFunc: asin2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asinh.js
  var ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;
  var asinh2 = unaryKernelFunc2({ opSnippet: ASINH });
  var asinhConfig = {
    kernelName: Asinh,
    backendName: "webgl",
    kernelFunc: asinh2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan.js
  var ATAN = CHECK_NAN_SNIPPET + `
  return atan(x);
`;
  var atan3 = unaryKernelFunc2({ opSnippet: ATAN });
  var atanConfig = {
    kernelName: Atan,
    backendName: "webgl",
    kernelFunc: atan3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan2.js
  var ATAN2 = CHECK_NAN_SNIPPET2 + `
  return atan(a, b);
`;
  var ATAN2_PACKED = `
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  var atan22 = binaryKernelFunc2({ opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED });
  var atan2Config = {
    kernelName: Atan2,
    backendName: "webgl",
    kernelFunc: atan22
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atanh.js
  var ATANH = CHECK_NAN_SNIPPET + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
  var atanh2 = unaryKernelFunc2({ opSnippet: ATANH });
  var atanhConfig = {
    kernelName: Atanh,
    backendName: "webgl",
    kernelFunc: atanh2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js
  var Pool2DProgram = class {
    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
      this.variableNames = ["x"];
      if (poolType === "avg" && computePositions) {
        throw new Error("Cannot compute positions for average pool.");
      }
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      this.outputShape = convInfo.outShape;
      const isAvgPool = poolType === "avg";
      const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
      const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
      let initializationValue = "0.0";
      if (!isAvgPool) {
        initializationValue = "-1.0 / 1e-20";
      }
      if (computePositions) {
        const compareOp2 = ">=";
        this.userCode = `
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${compareOp2} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : `wR * ${effectiveFilterWidth} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      const compareOp = "max";
      let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (poolType === "avg") {
        returnValue = `avgValue / max(count, 1.0)`;
      }
      const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
      const filterWidthVec4Remainder = filterWidth % 4;
      const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
            int xC = xCCorner + wC * ${dilationWidth};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)
            );

            ${updateSnippet}
          }

          int xC = xCCorner + ${filterWidthNearestVec4};
          if (${filterWidthVec4Remainder === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              initializationValue
            );

            ${updateSnippet}
          }
        }
        setOutput(${returnValue});
      }
    `;
    }
  };
  var Pool3DProgram = class {
    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
      this.variableNames = ["x"];
      if (poolType === "avg" && computePositions) {
        throw new Error("Cannot compute positions for average pool.");
      }
      const filterWidth = convInfo.filterWidth;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterDepth = convInfo.effectiveFilterDepth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padFront = convInfo.padInfo.front;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      this.outputShape = convInfo.outShape;
      const isAvgPool = poolType === "avg";
      let initializationValue = "0.0";
      if (!isAvgPool) {
        initializationValue = "-1.0 / 1e-20";
      }
      if (computePositions) {
        const compareOp2 = ">=";
        this.userCode = `
        const ivec3 strides =
            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${convInfo.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${compareOp2} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${flattenPositions ? includeBatchInIndex ? `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                      wR * ${effectiveFilterWidth} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      const compareOp = "max";
      let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (poolType === "avg") {
        returnValue = `avgValue / max(count, 1.0)`;
      }
      const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
      const filterWidthVec4Remainder = filterWidth % 4;
      const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec3 strides =
        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
              int xC = xCCorner + wC * ${dilationWidth};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)
              );

              ${updateSnippet}
            }

            int xC = xCCorner + ${filterWidthNearestVec4};
            if (${filterWidthVec4Remainder === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                initializationValue
              );

              ${updateSnippet}
            }
          }
        }
        setOutput(${returnValue});
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool.js
  function avgPool2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    assertNotComplex(x2, "avgPool");
    const { filterSize, strides, pad: pad2, dimRoundingMode } = attrs;
    const dilations = 1;
    util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, dilations, pad2, dimRoundingMode);
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports.arraysEqual(convInfo.inShape, convInfo.outShape)) {
      return identity3({ inputs: { x: x2 }, backend });
    }
    const avgPoolProgram = new Pool2DProgram(convInfo, "avg", false);
    return backend.runWebGLProgram(avgPoolProgram, [x2], "float32");
  }
  var avgPoolConfig = {
    kernelName: AvgPool,
    backendName: "webgl",
    kernelFunc: avgPool2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3D.js
  function avgPool3D(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { filterSize, strides, pad: pad2, dimRoundingMode, dataFormat } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = backend_util_exports.computePool3DInfo(x2.shape, filterSize, strides, dilations, pad2, dimRoundingMode, dataFormat);
    const avgPoolProgram = new Pool3DProgram(convInfo, "avg", false);
    return backend.runWebGLProgram(avgPoolProgram, [x2], "float32");
  }
  var avgPool3DConfig = {
    kernelName: AvgPool3D,
    backendName: "webgl",
    kernelFunc: avgPool3D
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js
  var AvgPool2DBackpropProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy"];
      this.outputShape = convInfo.inShape;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const avgMultiplier = 1 / (filterHeight * filterWidth);
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth};
            wC+= ${dilationWidth}) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var AvgPool3DBackpropProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy"];
      this.outputShape = convInfo.inShape;
      const filterDepth = convInfo.filterDepth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterDepth = convInfo.effectiveFilterDepth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
      this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3DGrad.js
  function avgPool3DGrad(args) {
    const { inputs, backend, attrs } = args;
    const { dy, input: input2 } = inputs;
    const x2 = input2;
    const { filterSize, strides, pad: pad2, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = backend_util_exports.computePool3DInfo(x2.shape, filterSize, strides, dilations, pad2, dimRoundingMode);
    const avgPoolBackpropProgram = new AvgPool3DBackpropProgram(convInfo);
    return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x2.dtype);
  }
  var avgPool3DGradConfig = {
    kernelName: AvgPool3DGrad,
    backendName: "webgl",
    kernelFunc: avgPool3DGrad
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPoolGrad.js
  function avgPoolGrad(args) {
    const { inputs, backend, attrs } = args;
    const { dy, input: input2 } = inputs;
    const x2 = input2;
    assertNotComplex([dy, input2], "avgPoolGrad");
    const { filterSize, strides, pad: pad2 } = attrs;
    const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, 1, pad2);
    const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);
    return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x2.dtype);
  }
  var avgPoolGradConfig = {
    kernelName: AvgPoolGrad,
    backendName: "webgl",
    kernelFunc: avgPoolGrad
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul.js
  function batchMatMul(args) {
    const { inputs, backend, attrs } = args;
    const { a: a2, b: b2 } = inputs;
    const { transposeA, transposeB } = attrs;
    return batchMatMulImpl({ a: a2, b: b2, transposeA, transposeB, backend });
  }
  var batchMatMulConfig = {
    kernelName: BatchMatMul,
    backendName: "webgl",
    kernelFunc: batchMatMul
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_gpu.js
  var BatchNormProgram = class {
    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
      this.outputShape = [];
      this.variableNames = ["x", "mean", "variance"];
      backend_util_exports.assertAndGetBroadcastShape(xShape, meanShape);
      backend_util_exports.assertAndGetBroadcastShape(xShape, varianceShape);
      let offsetSnippet = "0.0";
      if (offsetShape != null) {
        backend_util_exports.assertAndGetBroadcastShape(xShape, offsetShape);
        this.variableNames.push("offset");
        offsetSnippet = "getOffsetAtOutCoords()";
      }
      let scaleSnippet = "1.0";
      if (scaleShape != null) {
        backend_util_exports.assertAndGetBroadcastShape(xShape, scaleShape);
        this.variableNames.push("scale");
        scaleSnippet = "getScaleAtOutCoords()";
      }
      this.outputShape = xShape;
      this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${offsetSnippet};
        float scale = ${scaleSnippet};
        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js
  var BatchNormPackedProgram = class {
    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
      this.packedInputs = true;
      this.packedOutput = true;
      this.variableNames = ["x", "mean", "variance"];
      backend_util_exports.assertAndGetBroadcastShape(xShape, meanShape);
      backend_util_exports.assertAndGetBroadcastShape(xShape, varianceShape);
      let offsetSnippet = "vec4(0.0)";
      if (offsetShape != null) {
        backend_util_exports.assertAndGetBroadcastShape(xShape, offsetShape);
        this.variableNames.push("offset");
        offsetSnippet = "getOffsetAtOutCoords()";
      }
      let scaleSnippet = "vec4(1.0)";
      if (scaleShape != null) {
        backend_util_exports.assertAndGetBroadcastShape(xShape, scaleShape);
        this.variableNames.push("scale");
        scaleSnippet = "getScaleAtOutCoords()";
      }
      this.outputShape = xShape;
      this.userCode = `
      void main() {
        vec4 offset = ${offsetSnippet};
        vec4 scale = ${scaleSnippet};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));

        setOutput((x - mean) * inv + offset);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchNorm.js
  var batchNorm2 = ({ inputs, backend, attrs }) => {
    const { x: x2, mean: mean2, variance, offset, scale } = inputs;
    util_exports.assert(mean2.shape.length === variance.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
    util_exports.assert(offset == null || mean2.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
    util_exports.assert(scale == null || mean2.shape.length === scale.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    let { varianceEpsilon } = attrs;
    if (varianceEpsilon == null) {
      varianceEpsilon = 1e-3;
    }
    const finalInputs = [x2, mean2, variance];
    let offsetShape = null;
    if (offset != null) {
      offsetShape = offset.shape;
      finalInputs.push(offset);
    }
    let scaleShape = null;
    if (scale != null) {
      scaleShape = scale.shape;
      finalInputs.push(scale);
    }
    const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new BatchNormPackedProgram(x2.shape, mean2.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon) : new BatchNormProgram(x2.shape, mean2.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
    const output = backend.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);
    return output;
  };
  var batchNormConfig = {
    kernelName: FusedBatchNorm,
    backendName: "webgl",
    kernelFunc: batchNorm2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js
  var SliceProgram = class {
    constructor(destSize) {
      this.variableNames = ["source"];
      this.outputShape = destSize;
      this.rank = destSize.length;
      const dtype = getCoordsDataType(this.rank);
      this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
      const sourceCoords = getCoords(this.rank);
      let body;
      const coordSum = destSize.map((_3, i2) => {
        return `sourceLoc.${coords[i2]} = start[${i2}] + coords.${coords[i2]};`;
      });
      body = `
        ${dtype} sourceLoc;
        ${dtype} coords = getOutputCoords();
        ${coordSum.join("\n")}
      `;
      this.userCode = `
      void main() {
        ${body}
        setOutput(getSource(${sourceCoords}));
      }
    `;
    }
  };
  var coords = ["x", "y", "z", "w", "u", "v"];
  function getCoords(rank) {
    if (rank === 1) {
      return "sourceLoc";
    } else if (rank <= 6) {
      return coords.slice(0, rank).map((x2) => "sourceLoc." + x2).join(",");
    } else {
      throw Error(`Slicing for rank ${rank} is not yet supported`);
    }
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_packed_gpu.js
  var SlicePackedProgram = class {
    constructor(destSize) {
      this.variableNames = ["source"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = destSize;
      this.rank = destSize.length;
      this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
      const dtype = getCoordsDataType(this.rank);
      const coords2 = getChannels("coords", this.rank);
      const sourceLoc = getChannels("sourceLoc", this.rank);
      const innerDims = this.rank === 1 ? "sourceLoc" : `vec2(${sourceLoc.slice(-2).join()})`;
      const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;
      const upperRow = `
      result.x = ${getChannel};
      if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
        ++${sourceLoc[this.rank - 1]};
        result.y = ${getChannel};
        --${sourceLoc[this.rank - 1]};
      }
    `;
      const lowerRow = this.rank === 1 ? "" : `
      --${coords2[this.rank - 1]};
      if (++${coords2[this.rank - 2]} < ${destSize[this.rank - 2]}) {
        ++${sourceLoc[this.rank - 2]};
        result.z = ${getChannel};
        if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
          ++${sourceLoc[this.rank - 1]};
          result.w = ${getChannel};
        }
      }
    `;
      const sourceLocSetup = this.rank <= 4 ? `sourceLoc = coords +
            ${dtype}(${destSize.map((_3, i2) => `start[${i2}]`).join()});` : destSize.map((_3, i2) => `${sourceLoc[i2]} = ${coords2[i2]} + start[${i2}];`).join("\n");
      this.userCode = `
      void main() {
        ${dtype} coords = getOutputCoords();
        ${dtype} sourceLoc;
        ${sourceLocSetup}
        vec4 result = vec4(0.);
        ${upperRow}
        ${lowerRow}
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js
  function shallowSlice(x2, begin, size, backend) {
    const xTexData = backend.texData.get(x2.dataId);
    const t3 = backend.makeTensorInfo(size, x2.dtype);
    const newTexData = backend.texData.get(t3.dataId);
    Object.assign(newTexData, xTexData);
    newTexData.refCount = 1;
    newTexData.shape = size;
    newTexData.dtype = x2.dtype;
    let flatOffset = slice_util_exports.computeFlatOffset(begin, util_exports.computeStrides(x2.shape));
    if (xTexData.slice) {
      flatOffset += xTexData.slice.flatOffset;
    }
    newTexData.slice = {
      flatOffset,
      // Point to the original dataId, which is used to do ref counting.
      origDataId: xTexData.slice && xTexData.slice.origDataId || x2.dataId
    };
    const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;
    backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);
    return t3;
  }
  function slice2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { begin, size } = attrs;
    const [$begin, $size] = slice_util_exports.parseSliceParams(x2, begin, size);
    slice_util_exports.assertParamsValid(x2, $begin, $size);
    if (util_exports.sizeFromShape($size) === 0) {
      return backend.makeTensorInfo($size, x2.dtype, []);
    }
    if (backend.shouldExecuteOnCPU([x2]) || x2.dtype === "string") {
      const xTexData = backend.texData.get(x2.dataId);
      const outValues = sliceImplCPU(xTexData.values, $begin, $size, x2.shape, x2.dtype);
      return backend.makeTensorInfo($size, x2.dtype, outValues);
    }
    const { isPacked } = backend.texData.get(x2.dataId);
    const isContinous = slice_util_exports.isSliceContinous(x2.shape, $begin, $size);
    if (isPacked || !isContinous) {
      const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new SlicePackedProgram($size) : new SliceProgram($size);
      const customValues = [$begin];
      return backend.runWebGLProgram(program, [x2], x2.dtype, customValues);
    }
    backend.uploadToGPU(x2.dataId);
    return shallowSlice(x2, $begin, $size, backend);
  }
  var sliceConfig = {
    kernelName: Slice,
    backendName: "webgl",
    kernelFunc: slice2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchToSpaceND.js
  var batchToSpaceND2 = (args) => {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { blockShape, crops } = attrs;
    util_exports.assert(x2.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
    const prod3 = blockShape.reduce((a2, b2) => a2 * b2);
    const reshaped = backend_util_exports.getReshaped(x2.shape, blockShape, prod3);
    const permuted = backend_util_exports.getPermuted(reshaped.length, blockShape.length);
    const reshapedPermuted = backend_util_exports.getReshapedPermuted(x2.shape, blockShape, prod3);
    const sliceBeginCoords = backend_util_exports.getSliceBeginCoords(crops, blockShape.length);
    const sliceSize = backend_util_exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
    const toDispose = [];
    const reshapedIntermediate = reshape3({ inputs: { x: x2 }, backend, attrs: { shape: reshaped } });
    const transposedIntermediate = transpose2({ inputs: { x: reshapedIntermediate }, backend, attrs: { perm: permuted } });
    const reshapedIntermediate2 = reshape3({
      inputs: { x: transposedIntermediate },
      backend,
      attrs: { shape: reshapedPermuted }
    });
    const sliced = slice2({
      inputs: { x: reshapedIntermediate2 },
      backend,
      attrs: { begin: sliceBeginCoords, size: sliceSize }
    });
    toDispose.push(reshapedIntermediate);
    toDispose.push(transposedIntermediate);
    toDispose.push(reshapedIntermediate2);
    toDispose.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return sliced;
  };
  var batchToSpaceNDConfig = {
    kernelName: BatchToSpaceND,
    backendName: "webgl",
    kernelFunc: batchToSpaceND2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Bincount.js
  function bincount2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, weights } = inputs;
    const { size } = attrs;
    const xVals = backend.readSync(x2.dataId);
    const weightsVals = backend.readSync(weights.dataId);
    const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);
    return backend.makeTensorInfo([size], weights.dtype, outVals);
  }
  var bincountConfig = {
    kernelName: Bincount,
    backendName: "webgl",
    kernelFunc: bincount2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BroadcastArgs.js
  function broadcastArgs2(args) {
    const { inputs, backend } = args;
    const { s0, s1 } = inputs;
    const s0Vals = backend.readSync(s0.dataId);
    const s1Vals = backend.readSync(s1.dataId);
    const broadcastShape = backend_util_exports.assertAndGetBroadcastShape(Array.from(s0Vals), Array.from(s1Vals));
    return backend.makeTensorInfo([broadcastShape.length], "int32", Int32Array.from(broadcastShape));
  }
  var broadcastArgsConfig = {
    kernelName: BroadcastArgs,
    backendName: "webgl",
    kernelFunc: broadcastArgs2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NotEqual.js
  var NOT_EQUAL = `return float(a != b);`;
  var notEqual3 = binaryKernelFunc2({ opSnippet: NOT_EQUAL, cpuKernelImpl: notEqualImplCPU, dtype: "bool" });
  var notEqualConfig = {
    kernelName: NotEqual,
    backendName: "webgl",
    kernelFunc: notEqual3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js
  function real3(args) {
    const { inputs, backend } = args;
    const { input: input2 } = inputs;
    const inputData = backend.texData.get(input2.dataId);
    return identity3({ inputs: { x: inputData.complexTensorInfos.real }, backend });
  }
  var realConfig = {
    kernelName: Real,
    backendName: "webgl",
    kernelFunc: real3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/int.js
  var TO_INT = `return float(int(x));`;
  function int(input2, backend) {
    const program = new UnaryOpProgram(input2.shape, TO_INT);
    const output = backend.runWebGLProgram(program, [input2], "int32");
    return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cast.js
  function cast3(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { dtype } = attrs;
    if (dtype === "complex64") {
      if (x2.dtype === "complex64") {
        return identity3({ inputs: { x: x2 }, backend });
      }
      const zerosTensor = zeros(x2.shape);
      const floatX = cast3({ inputs: { x: x2 }, backend, attrs: { dtype: "float32" } });
      const result = complex3({ inputs: { real: floatX, imag: zerosTensor }, backend });
      zerosTensor.dispose();
      backend.disposeIntermediateTensorInfo(floatX);
      return result;
    }
    if (x2.dtype === "complex64") {
      const realPart = real3({ inputs: { input: x2 }, backend });
      const result = cast3({ inputs: { x: realPart }, backend, attrs: { dtype } });
      backend.disposeIntermediateTensorInfo(realPart);
      return result;
    }
    if (!util_exports.hasEncodingLoss(x2.dtype, dtype)) {
      const result = identity3({ inputs: { x: x2 }, backend });
      return { dataId: result.dataId, shape: result.shape, dtype };
    }
    if (backend.shouldExecuteOnCPU([x2])) {
      const values = backend.texData.get(x2.dataId).values;
      const [resultShape, resultType, resultData] = castImplCPU(values, x2.shape, x2.dtype, dtype);
      return backend.makeTensorInfo(resultShape, resultType, resultData);
    }
    if (dtype === "int32") {
      return int(x2, backend);
    }
    if (dtype === "bool") {
      const zerosTensorInfo = backend.makeTensorInfo([], "bool", util_exports.getTypedArrayFromDType("bool", 1));
      const binaryInputs = { a: x2, b: zerosTensorInfo };
      const result = notEqual3({ inputs: binaryInputs, backend });
      backend.disposeIntermediateTensorInfo(zerosTensorInfo);
      return result;
    }
    throw new Error(`Error in Cast: failed to cast ${x2.dtype} to ${dtype}`);
  }
  var castConfig = {
    kernelName: Cast,
    backendName: "webgl",
    kernelFunc: cast3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Ceil.js
  var CEIL = `return ceil(x);`;
  var ceil3 = unaryKernelFunc2({ opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: ceilImplCPU });
  var ceilConfig = {
    kernelName: Ceil,
    backendName: "webgl",
    kernelFunc: ceil3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_gpu.js
  var ClipProgram = class {
    constructor(aShape) {
      this.variableNames = ["A"];
      this.customUniforms = [
        { name: "minVal", type: "float" },
        { name: "maxVal", type: "float" }
      ];
      this.outputShape = aShape;
      this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_packed_gpu.js
  var ClipPackedProgram = class {
    constructor(aShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "minVal", type: "float" },
        { name: "maxVal", type: "float" }
      ];
      this.outputShape = aShape;
      this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ClipByValue.js
  function clipByValue2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { clipValueMin, clipValueMax } = attrs;
    let program;
    if (env().getBool("WEBGL_PACK_CLIP")) {
      program = new ClipPackedProgram(x2.shape);
    } else {
      program = new ClipProgram(x2.shape);
    }
    const customValues = [[clipValueMin], [clipValueMax]];
    return backend.runWebGLProgram(program, [x2], x2.dtype, customValues);
  }
  var clipByValueConfig = {
    kernelName: ClipByValue,
    backendName: "webgl",
    kernelFunc: clipByValue2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/complex_abs_gpu.js
  var ComplexAbsProgram = class {
    constructor(shape) {
      this.variableNames = ["real", "imag"];
      this.outputShape = shape;
      this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ComplexAbs.js
  function makeComplexComponentTensorInfo(complexTensor, complexPart) {
    return {
      dataId: complexPart.dataId,
      dtype: complexPart.dtype,
      shape: complexTensor.shape
    };
  }
  function complexAbs(args) {
    const { inputs, backend } = args;
    const { x: x2 } = inputs;
    const xData = backend.texData.get(x2.dataId);
    const program = new ComplexAbsProgram(x2.shape);
    const programInputs = [
      makeComplexComponentTensorInfo(x2, xData.complexTensorInfos.real),
      makeComplexComponentTensorInfo(x2, xData.complexTensorInfos.imag)
    ];
    return backend.runWebGLProgram(program, programInputs, programInputs[0].dtype);
  }
  var complexAbsConfig = {
    kernelName: ComplexAbs,
    backendName: "webgl",
    kernelFunc: complexAbs
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js
  var ConcatProgram = class {
    // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().
    constructor(shapes) {
      this.outputShape = [];
      this.outputShape = backend_util_exports.computeOutShape(
        shapes,
        1
        /* axis */
      );
      this.variableNames = shapes.map((_3, i2) => `T${i2}`);
      const offsets = new Array(shapes.length - 1);
      offsets[0] = shapes[0][1];
      for (let i2 = 1; i2 < offsets.length; i2++) {
        offsets[i2] = offsets[i2 - 1] + shapes[i2][1];
      }
      const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];
      for (let i2 = 1; i2 < offsets.length; i2++) {
        const shift = offsets[i2 - 1];
        snippets.push(`else if (yC < ${offsets[i2]}) setOutput(getT${i2}(yR, yC-${shift}));`);
      }
      const lastIndex = offsets.length;
      const lastShift = offsets[offsets.length - 1];
      snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${snippets.join("\n        ")}
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js
  var ConcatPackedProgram = class {
    constructor(shapes, axis) {
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = [];
      this.outputShape = backend_util_exports.computeOutShape(shapes, axis);
      const shape = this.outputShape;
      const rank = shape.length;
      const dtype = getCoordsDataType(rank);
      const coords2 = getChannels("coords", rank);
      const channels = ["x", "y", "z", "w", "u", "v"].slice(0, rank);
      this.variableNames = shapes.map((_3, i2) => `T${i2}`);
      const offsets = new Array(shapes.length - 1);
      offsets[0] = shapes[0][axis];
      for (let i2 = 1; i2 < offsets.length; i2++) {
        offsets[i2] = offsets[i2 - 1] + shapes[i2][axis];
      }
      const channel = channels[axis];
      const lastChannels = channels.slice(-2);
      const allChannels = channels.join();
      let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getT0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
      for (let i2 = 1; i2 < offsets.length; i2++) {
        const shift2 = offsets[i2 - 1];
        getValueSnippet += `
        if (${channel} < ${offsets[i2]}  && ${channel} >= ${offsets[i2 - 1]}) {
          return getChannel(
            getT${i2}(${shiftedChannels(channels, channel, shift2)}),
            vec2(${shiftedChannels(lastChannels, channel, shift2)}));
        }`;
      }
      const lastIndex = offsets.length;
      const shift = offsets[offsets.length - 1];
      getValueSnippet += `
        return getChannel(
          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),
          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;
      this.userCode = `
      float getValue(${channels.map((x2) => "int " + x2)}) {
        ${getValueSnippet}
      }

      void main() {
        ${dtype} coords = getOutputCoords();
        vec4 result = vec4(getValue(${coords2}), 0., 0., 0.);

        ${coords2[rank - 1]} = ${coords2[rank - 1]} + 1;
        if (${coords2[rank - 1]} < ${shape[rank - 1]}) {
          result.g = getValue(${coords2});
        }

        ${coords2[rank - 2]} = ${coords2[rank - 2]} + 1;
        if (${coords2[rank - 2]} < ${shape[rank - 2]}) {
          result.a = getValue(${coords2});
        }

        ${coords2[rank - 1]} = ${coords2[rank - 1]} - 1;
        if (${coords2[rank - 2]} < ${shape[rank - 2]} &&
            ${coords2[rank - 1]} < ${shape[rank - 1]}) {
          result.b = getValue(${coords2});
        }
        setOutput(result);
      }
    `;
    }
  };
  function shiftedChannels(channels, channel, shift) {
    const channelIdx = channels.indexOf(channel);
    const res = channels.map((c2, idx) => {
      if (idx === channelIdx) {
        return `${c2} - ${shift}`;
      } else {
        return c2;
      }
    });
    return res.join();
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js
  function imag2(args) {
    const { inputs, backend } = args;
    const { input: input2 } = inputs;
    const inputData = backend.texData.get(input2.dataId);
    return identity3({ inputs: { x: inputData.complexTensorInfos.imag }, backend });
  }
  var imagConfig = {
    kernelName: Imag,
    backendName: "webgl",
    kernelFunc: imag2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat_impl.js
  function concatImpl2(inputs, axis, backend) {
    const dtype = inputs[0].dtype;
    if (dtype === "complex64") {
      const reals = inputs.map((t3) => real3({ inputs: { input: t3 }, backend }));
      const imags = inputs.map((t3) => imag2({ inputs: { input: t3 }, backend }));
      const realConcated = concatImpl2(reals, axis, backend);
      const imagConcated = concatImpl2(imags, axis, backend);
      const result2 = complex3({ inputs: { real: realConcated, imag: imagConcated }, backend });
      reals.forEach((r2) => backend.disposeIntermediateTensorInfo(r2));
      imags.forEach((i2) => backend.disposeIntermediateTensorInfo(i2));
      backend.disposeIntermediateTensorInfo(realConcated);
      backend.disposeIntermediateTensorInfo(imagConcated);
      return result2;
    }
    let runOnCpu = backend.shouldExecuteOnCPU(inputs);
    if (dtype === "string") {
      runOnCpu = true;
    }
    if (runOnCpu) {
      const tensors2D2 = inputs.map((t3) => {
        const innerSize = util_exports.sizeFromShape(t3.shape.slice(axis));
        const shape = [-1, innerSize];
        return reshape3({ inputs: { x: t3 }, backend, attrs: { shape } });
      });
      const inputsValShapes = tensors2D2.map((t3) => {
        return { vals: backend.readSync(t3.dataId), shape: t3.shape };
      });
      const outShape2 = backend_util_exports.computeOutShape(
        tensors2D2.map((t3) => t3.shape),
        1
        /* axis */
      );
      const simplyConcat = tensors2D2[0].shape[0] === 1;
      const outVals = concatImplCPU(inputsValShapes, outShape2, dtype, simplyConcat);
      const finalOutShape = backend_util_exports.computeOutShape(inputs.map((t3) => t3.shape), axis);
      const outInfo = backend.makeTensorInfo(finalOutShape, dtype, outVals);
      tensors2D2.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
      return outInfo;
    }
    const $inputs = inputs.filter((t3) => util_exports.sizeFromShape(t3.shape) > 0);
    const shouldPack = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && $inputs[0].shape.length > 1;
    if ($inputs.length === 1) {
      const program2 = shouldPack ? new UnaryOpProgram(inputs[0].shape, CLONE) : new UnaryOpPackedProgram(inputs[0].shape, CLONE);
      return backend.runWebGLProgram(program2, inputs, dtype);
    }
    const maxTexturesInShader = env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
    if ($inputs.length > maxTexturesInShader) {
      const reducedInputs = [];
      for (let i2 = 0; i2 < $inputs.length; i2 += maxTexturesInShader) {
        const subArray = $inputs.slice(i2, i2 + maxTexturesInShader);
        reducedInputs.push(concatImpl2(subArray, axis, backend));
      }
      const result2 = concatImpl2(reducedInputs, axis, backend);
      for (const i2 of reducedInputs) {
        backend.disposeIntermediateTensorInfo(i2);
      }
      return result2;
    }
    if (shouldPack) {
      const program2 = new ConcatPackedProgram($inputs.map((t3) => t3.shape), axis);
      return backend.runWebGLProgram(program2, $inputs, dtype);
    }
    const { tensors2D, outShape } = computeTensors2D($inputs, axis, backend);
    const program = new ConcatProgram(tensors2D.map((t3) => t3.shape));
    const result = backend.runWebGLProgram(program, tensors2D, dtype);
    tensors2D.forEach((r2) => backend.disposeIntermediateTensorInfo(r2));
    const reshapedResult = reshape3({ inputs: { x: result }, attrs: { shape: outShape }, backend });
    backend.disposeIntermediateTensorInfo(result);
    return reshapedResult;
  }
  function computeTensors2D(inputs, axis, backend) {
    const outShape = backend_util_exports.computeOutShape(inputs.map((t3) => t3.shape), axis);
    const tensors2D = inputs.map((x2) => reshape3({
      inputs: { x: x2 },
      attrs: { shape: [-1, util_exports.sizeFromShape(x2.shape.slice(axis))] },
      backend
    }));
    return { tensors2D, outShape };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat.js
  function concat2(args) {
    const { inputs, backend, attrs } = args;
    const { axis } = attrs;
    const $axis = util_exports.parseAxisParam(axis, inputs[0].shape)[0];
    const shapes = inputs.map((t3) => t3.shape);
    backend_util_exports.assertParamsConsistent(shapes, $axis);
    const outShape = backend_util_exports.computeOutShape(inputs.map((t3) => t3.shape), $axis);
    if (util_exports.sizeFromShape(outShape) === 0) {
      return backend.makeTensorInfo(outShape, inputs[0].dtype, []);
    }
    const $inputs = inputs.filter((t3) => util_exports.sizeFromShape(t3.shape) > 0);
    if ($inputs.length === 1) {
      return identity3({ inputs: { x: $inputs[0] }, backend });
    }
    return concatImpl2($inputs, $axis, backend);
  }
  var concatConfig = {
    kernelName: Concat,
    backendName: "webgl",
    kernelFunc: concat2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js
  var Conv2DProgram = class {
    constructor(convInfo, addBias = false, activation2 = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.outputShape = convInfo.outShape;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
      const inputDepthVec4Remainder = convInfo.inChannels % 4;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      const rowDim = isChannelsLast ? 1 : 2;
      const colDim = isChannelsLast ? 2 : 3;
      const channelDim = isChannelsLast ? 3 : 1;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation2) {
        if (hasPreluActivationWeights) {
          activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
        } else if (hasLeakyreluAlpha) {
          activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
        } else {
          activationSnippet = `
          float activation(float x) {
            ${activation2}
          }
        `;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivationWeights) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyreluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${channelDim}];

        ivec2 xRCCorner =
            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${convInfo.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${isChannelsLast}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${inputDepthVec4Remainder === 1}) {

              if (${isChannelsLast}) {
                dotProd +=
                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              } else {
                dotProd +=
                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              }

            } else if (${inputDepthVec4Remainder === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)
              );

              if (${isChannelsLast}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${inputDepthVec4Remainder === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)
              );

              if (${isChannelsLast}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
  };
  var Conv3DProgram = class {
    constructor(convInfo) {
      this.variableNames = ["x", "W"];
      this.outputShape = convInfo.outShape;
      const padFront = convInfo.padInfo.front;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const filterDepth = convInfo.filterDepth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
      const inputDepthVec4Remainder = convInfo.inChannels % 4;
      this.userCode = `
      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          int xF = xFCorner + wF * ${dilationDepth};

          if (xF < 0 || xF >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${inputDepthVec4Remainder === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);
              } else if (${inputDepthVec4Remainder === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${inputDepthVec4Remainder === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu.js
  var Conv2DPackedProgram = class {
    constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "pads", type: "ivec2" },
        { name: "strides", type: "ivec2" },
        { name: "dilations", type: "ivec2" },
        { name: "inDims", type: "ivec2" }
      ];
      this.outputShape = convInfo.outShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const padLeft = convInfo.padInfo.left;
      const strideWidth = convInfo.strideWidth;
      const dilationWidth = convInfo.dilationWidth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const texelsAcross = filterWidth;
      let mainLoop = `
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;
      for (let c2 = 0; c2 < filterWidth; c2++) {
        mainLoop += `
           vec4 xTexelC${c2 * 2};
           int xTexelC${c2 * 2}Ready;
           vec4 xTexelC${c2 * 2 + 1};
           int xTexelC${c2 * 2 + 1}Ready;
           vec4 xC${c2};`;
      }
      mainLoop += `
     for (int r = 0; r < ${filterHeight}; r++) {
      for (int d1 = 0; d1 < ${convInfo.inChannels}; d1 += 2) {
       `;
      for (let c2 = 0; c2 < filterWidth; c2++) {
        mainLoop += `
           xTexelC${c2 * 2} = vec4(0.0);
           xTexelC${c2 * 2}Ready = 0;
           xTexelC${c2 * 2 + 1} = vec4(0.0);
           xTexelC${c2 * 2 + 1}Ready = 0;
           xC${c2} = vec4(0.0);`;
      }
      mainLoop += `
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;
      for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {
        const colIndex = texelC * 2;
        mainLoop += `
           xC = xCCorner + ${colIndex * dilationWidth};
           `;
        if (strideWidth === 1) {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }
               `;
              if (dilationWidth === 1 && colIndex > 0) {
                mainLoop += `
                 xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);
                 `;
              } else {
                mainLoop += `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);
                   } else {
                     xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);
                   }
                   `;
              }
            } else {
              mainLoop += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }

                 xC${colIndex} = xTexelC${colIndex};
                 `;
            }
            if (colIndex + 1 < filterWidth) {
              const nextTexelOffset = padLeft % 2 === 0 ? util_exports.nearestLargerEven(dilationWidth) : dilationWidth;
              if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
                mainLoop += `
                   xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                     xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${colIndex + 1}.zw = vec2(0.0);
                     }
                     xTexelC${colIndex + 1}Ready = 1;
                   }
                   `;
                if (dilationWidth > 1) {
                  mainLoop += `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${colIndex + 1} = vec4(previous.zw, xTexelC${colIndex + 1}.xy);
                     } else {
                      xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${colIndex + 1}.xy);
                     }
                     `;
                } else {
                  mainLoop += `
                     xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);
                     `;
                }
              } else {
                if (nextTexelOffset === 1) {
                  mainLoop += `
                     xC${colIndex + 1} = xTexelC${colIndex};
                     `;
                } else {
                  mainLoop += `
                     xCOffset = xC + ${nextTexelOffset};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                       xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${colIndex + 1}.zw = vec2(0.0);
                       }
                       xTexelC${colIndex + 1}Ready = 1;
                     }

                     xC${colIndex + 1} = xTexelC${colIndex + 1};
                     `;
                }
              }
            }
          }
        } else {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                   xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${colIndex + 1}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex + 1}Ready = 1;
                 }

                 xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
               `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);
                 `;
              }
            } else {
              mainLoop += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                   xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${colIndex + 1}.zw = vec2(0.);
                   }
                   xTexelC${colIndex + 1}Ready = 1;
                 }

                 xC${colIndex} = vec4(
                   xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);
               `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                   xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
                 `;
              }
            }
          }
        }
        if (colIndex < filterWidth) {
          mainLoop += `
             wTexel = getW(r, ${colIndex}, d1, d2);
             dotProd += xC${colIndex}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${convInfo.inChannels}) {
               dotProd += xC${colIndex}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `;
          if (colIndex + 1 < filterWidth) {
            mainLoop += `
               wTexel = getW(r, ${colIndex + 1}, d1, d2);
               dotProd += xC${colIndex + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${convInfo.inChannels}) {
                 dotProd += xC${colIndex + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `;
          }
        }
      }
      mainLoop += `
     }
   `;
      mainLoop += `
     }
   `;
      mainLoop += `
     }
   `;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation2) {
        if (hasPreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${activation2}
         }`;
        } else if (hasLeakyReluAlpha) {
          activationSnippet = `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${activation2}
         }`;
        } else {
          activationSnippet = `vec4 activation(vec4 x) {
           ${activation2}
         }`;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyReluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
       ${activationSnippet}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${mainLoop}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${addBiasSnippet}
         ${applyActivationSnippet}
         setOutput(result);
       }
     `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/im2col_packed_gpu.js
  var Im2ColPackedProgram = class {
    constructor(outputShape, convInfo) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "inputShape", type: "ivec4" },
        { name: "pad", type: "ivec2" },
        { name: "stride", type: "ivec2" },
        { name: "dilation", type: "ivec2" },
        { name: "inChannels", type: "int" },
        { name: "itemsPerBlockRow", type: "int" },
        { name: "outWidth", type: "int" }
      ];
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const { dataFormat } = convInfo;
      const glsl = getGlslDifferences();
      const isChannelsLast = dataFormat === "channelsLast";
      const rowDim = isChannelsLast ? 1 : 2;
      const colDim = isChannelsLast ? 2 : 3;
      const boundsCheckingSnippet = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${outputShape[2]} && pos < ${outputShape[1]}) {`;
      let unrolled = ``;
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          unrolled += `
          blockIndex = rc.z + ${col};
          pos = rc.y + ${row};

          ${boundsCheckingSnippet}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${rowDim}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${colDim}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${isChannelsLast}) {
                  innerDims = vec2(d1, ch);
                  result[${row * 2 + col}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${row * 2 + col}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
        }
      }
      this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${unrolled}

        ${glsl.output} = result;
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js
  function getShapeForBatchMatMul(shape, isChannelsLast) {
    const length = shape.length;
    if (length >= 3) {
      return isChannelsLast ? [
        ...shape.slice(0, -3),
        shape[length - 3] * shape[length - 2],
        shape[length - 1]
        /* channel */
      ] : [
        ...shape.slice(0, -3),
        shape[length - 3],
        shape[length - 2] * shape[length - 1]
        /* height * width */
      ];
    } else if (!isChannelsLast && length === 1 && shape[0] > 1) {
      return [shape[0], 1];
    } else {
      return null;
    }
  }
  function conv2dByMatMul({ x: x2, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
    const xShape = x2.shape;
    const xTexData = backend.texData.get(x2.dataId);
    const sharedMatMulDim = convInfo.inChannels;
    const outerShapeX = xShape[0] * xShape[1] * xShape[2];
    const outerShapeFilter = convInfo.outChannels;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    const transposeA = false;
    const transposeB = false;
    let out;
    const intermediates = [];
    if (preluActivationWeights != null) {
      const targetShape = getShapeForBatchMatMul(preluActivationWeights.shape, isChannelsLast);
      if (targetShape != null) {
        preluActivationWeights = reshape3({
          inputs: { x: preluActivationWeights },
          backend,
          attrs: { shape: targetShape }
        });
        intermediates.push(preluActivationWeights);
      }
    }
    if (bias != null) {
      const targetShape = getShapeForBatchMatMul(bias.shape, isChannelsLast);
      if (targetShape != null) {
        bias = reshape3({ inputs: { x: bias }, backend, attrs: { shape: targetShape } });
        intermediates.push(bias);
      }
    }
    const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) && sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;
    const canOptimize = !batchMatMulWillBeUnpacked && xTexData.isPacked && isChannelsLast && xTexData.texture != null && xShape[2] % 2 !== 0 && util_exports.arraysEqual(xTexData.shape.slice(-3), xShape.slice(-3));
    if (canOptimize) {
      const targetShape = xShape[0] * xShape[1] * (xShape[2] + 1);
      const xReshaped = {
        dataId: x2.dataId,
        shape: [1, targetShape, convInfo.inChannels],
        dtype: x2.dtype
      };
      const originalXTexDataShape = xTexData.shape;
      xTexData.shape = xTexData.shape.slice();
      xTexData.shape[xTexData.shape.length - 2]++;
      util_exports.assert(isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);
      const filterReshaped = reshape3({
        inputs: { x: filter },
        backend,
        attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
      });
      intermediates.push(filterReshaped);
      const pointwiseConv = batchMatMulImpl({
        a: xReshaped,
        b: filterReshaped,
        backend,
        transposeA,
        transposeB,
        bias,
        activation: activation2,
        preluActivationWeights,
        leakyreluAlpha
      });
      const pointwiseConvTexData = backend.texData.get(pointwiseConv.dataId);
      util_exports.assert(pointwiseConvTexData.isPacked, () => "batchMatMul result is expected to be packed");
      xTexData.shape = originalXTexDataShape;
      pointwiseConvTexData.shape = convInfo.outShape;
      out = identity3({ inputs: { x: pointwiseConv }, backend });
      out.shape = convInfo.outShape;
      intermediates.push(pointwiseConv);
    } else {
      const numCols = convInfo.outHeight * convInfo.outWidth;
      const xReshaped = reshape3({
        inputs: { x: x2 },
        backend,
        attrs: {
          shape: isChannelsLast ? [convInfo.batchSize, numCols, convInfo.inChannels] : [convInfo.batchSize, convInfo.inChannels, numCols]
        }
      });
      const filterReshaped = reshape3({
        inputs: { x: filter },
        backend,
        attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
      });
      const result = batchMatMulImpl({
        a: isChannelsLast ? xReshaped : filterReshaped,
        b: isChannelsLast ? filterReshaped : xReshaped,
        transposeA: !isChannelsLast,
        transposeB,
        backend,
        bias,
        activation: activation2,
        preluActivationWeights,
        leakyreluAlpha
      });
      out = reshape3({ inputs: { x: result }, backend, attrs: { shape: convInfo.outShape } });
      intermediates.push(xReshaped);
      intermediates.push(filterReshaped);
      intermediates.push(result);
    }
    for (const i2 of intermediates) {
      backend.disposeIntermediateTensorInfo(i2);
    }
    return out;
  }
  function conv2dWithIm2Row({ x: x2, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
    const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;
    const isChannelsLast = dataFormat === "channelsLast";
    const sharedDim = filterWidth * filterHeight * inChannels;
    const numCols = outHeight * outWidth;
    const x2ColShape = [convInfo.batchSize, sharedDim, numCols];
    const transposeA = true;
    const transposeB = false;
    const intermediates = [];
    if (preluActivationWeights != null) {
      const targetShape = getShapeForBatchMatMul(preluActivationWeights.shape, isChannelsLast);
      if (targetShape != null) {
        preluActivationWeights = reshape3({
          inputs: { x: preluActivationWeights },
          backend,
          attrs: { shape: targetShape }
        });
        intermediates.push(preluActivationWeights);
      }
    }
    if (bias != null) {
      const targetShape = getShapeForBatchMatMul(bias.shape, isChannelsLast);
      if (targetShape != null) {
        bias = reshape3({ inputs: { x: bias }, backend, attrs: { shape: targetShape } });
        intermediates.push(bias);
      }
    }
    const w2Row = reshape3({
      inputs: { x: filter },
      backend,
      attrs: { shape: [1, sharedDim, util_exports.sizeFromShape(filter.shape) / sharedDim] }
    });
    intermediates.push(w2Row);
    const im2ColProgram = new Im2ColPackedProgram(x2ColShape, convInfo);
    const customValues = [
      x2.shape,
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inChannels],
      [convInfo.filterWidth * convInfo.inChannels],
      [convInfo.outWidth]
    ];
    const im2Col = backend.runWebGLProgram(im2ColProgram, [x2], "float32", customValues);
    const im2ColReshaped = reshape3({ inputs: { x: im2Col }, backend, attrs: { shape: x2ColShape } });
    intermediates.push(im2Col);
    intermediates.push(im2ColReshaped);
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation2 === "leakyrelu";
    const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, true) : null;
    const matmulProgram = new MatMulPackedProgram(isChannelsLast ? im2ColReshaped.shape : w2Row.shape, isChannelsLast ? w2Row.shape : im2ColReshaped.shape, isChannelsLast ? [convInfo.batchSize, numCols, convInfo.outChannels] : [convInfo.batchSize, convInfo.outChannels, numCols], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs = isChannelsLast ? [im2ColReshaped, w2Row] : [w2Row, im2ColReshaped];
    if (bias) {
      inputs.push(bias);
    }
    if (hasPreluActivationWeights) {
      inputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
      const $leakyreluAlpha = backend.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
      inputs.push($leakyreluAlpha);
      intermediates.push($leakyreluAlpha);
    }
    const product = backend.runWebGLProgram(matmulProgram, inputs, "float32");
    const out = reshape3({ inputs: { x: product }, backend, attrs: { shape: convInfo.outShape } });
    intermediates.push(product);
    for (const i2 of intermediates) {
      backend.disposeIntermediateTensorInfo(i2);
    }
    return out;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D.js
  function conv2d3(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, filter } = inputs;
    const { strides, pad: pad2, dataFormat, dilations, dimRoundingMode } = attrs;
    const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, dilations, pad2, dimRoundingMode, false, $dataFormat);
    let out;
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
      out = conv2dByMatMul({ x: x2, filter, convInfo, backend });
    } else if (convInfo.strideWidth <= 2 && $dataFormat === "channelsLast" && env().getBool("WEBGL_EXP_CONV")) {
      const program = new Conv2DPackedProgram(convInfo);
      const customValues = [
        [convInfo.padInfo.top, convInfo.padInfo.left],
        [convInfo.strideHeight, convInfo.strideWidth],
        [convInfo.dilationHeight, convInfo.dilationWidth],
        [convInfo.inHeight, convInfo.inWidth]
      ];
      out = backend.runWebGLProgram(program, [x2, filter], "float32", customValues);
    } else if (env().getBool("WEBGL_CONV_IM2COL")) {
      out = conv2dWithIm2Row({ x: x2, filter, convInfo, backend });
    } else {
      const program = new Conv2DProgram(convInfo);
      out = backend.runWebGLProgram(program, [x2, filter], "float32");
    }
    const outReshaped = reshape3({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });
    backend.disposeIntermediateTensorInfo(out);
    return outReshaped;
  }
  var conv2DConfig = {
    kernelName: Conv2D2,
    backendName: "webgl",
    kernelFunc: conv2d3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js
  var Conv2DDerFilterProgram = class {
    constructor(convInfo) {
      this.variableNames = ["x", "dy"];
      this.outputShape = convInfo.filterShape;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              if (${isChannelsLast}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Conv2DDerInputProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy", "W"];
      this.outputShape = convInfo.inShape;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      const padTop = filterHeight - 1 - convInfo.padInfo.top;
      const padLeft = filterWidth - 1 - convInfo.padInfo.left;
      const rowDim = isChannelsLast ? 1 : 2;
      const colDim = isChannelsLast ? 2 : 3;
      const channelDim = isChannelsLast ? 3 : 1;
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${channelDim}];

        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {

              if (${isChannelsLast}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Conv3DDerFilterProgram = class {
    constructor(convInfo) {
      this.variableNames = ["x", "dy"];
      this.outputShape = convInfo.filterShape;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padFront = convInfo.padInfo.front;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {
            int xF = wF + yF * ${strideDepth} - ${padFront};

            if (xF < 0 || xF >= ${convInfo.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Conv3DDerInputProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy", "W"];
      this.outputShape = convInfo.inShape;
      const filterDepth = convInfo.filterDepth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padFront = filterDepth - 1 - convInfo.padInfo.front;
      const padTop = filterHeight - 1 - convInfo.padInfo.top;
      const padLeft = filterWidth - 1 - convInfo.padInfo.left;
      this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;

          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${filterDepth} - 1 - wF;

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${filterHeight} - 1 - wR;

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${filterWidth} - 1 - wC;

              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropFilter.js
  function conv2DBackpropFilter2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, dy } = inputs;
    const { strides, pad: pad2, dataFormat, dimRoundingMode, filterShape } = attrs;
    const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filterShape, strides, 1, pad2, dimRoundingMode, false, $dataFormat);
    const program = new Conv2DDerFilterProgram(convInfo);
    return backend.runWebGLProgram(program, [x2, dy], "float32");
  }
  var conv2DBackpropFilterConfig = {
    kernelName: Conv2DBackpropFilter,
    backendName: "webgl",
    kernelFunc: conv2DBackpropFilter2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropInput.js
  function conv2DBackpropInput2(args) {
    const { inputs, backend, attrs } = args;
    const { dy, filter } = inputs;
    const { inputShape, strides, pad: pad2, dataFormat, dimRoundingMode } = attrs;
    const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter.shape, strides, 1, pad2, dimRoundingMode, false, $dataFormat);
    const program = new Conv2DDerInputProgram(convInfo);
    return backend.runWebGLProgram(program, [dy, filter], "float32");
  }
  var conv2DBackpropInputConfig = {
    kernelName: Conv2DBackpropInput,
    backendName: "webgl",
    kernelFunc: conv2DBackpropInput2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3D.js
  function conv3D(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, filter } = inputs;
    const { strides, pad: pad2, dilations } = attrs;
    const convInfo = backend_util_exports.computeConv3DInfo(x2.shape, filter.shape, strides, dilations, pad2);
    const program = new Conv3DProgram(convInfo);
    return backend.runWebGLProgram(program, [x2, filter], "float32");
  }
  var conv3DConfig = {
    kernelName: Conv3D2,
    backendName: "webgl",
    kernelFunc: conv3D
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropFilterV2.js
  function conv3DBackpropFilterV2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, dy } = inputs;
    const { strides, pad: pad2, filterShape } = attrs;
    const convInfo = backend_util_exports.computeConv3DInfo(x2.shape, filterShape, strides, 1, pad2);
    const program = new Conv3DDerFilterProgram(convInfo);
    return backend.runWebGLProgram(program, [x2, dy], "float32");
  }
  var conv3DBackpropFilterV2Config = {
    kernelName: Conv3DBackpropFilterV2,
    backendName: "webgl",
    kernelFunc: conv3DBackpropFilterV2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropInputV2.js
  function conv3DBackpropInput2(args) {
    const { inputs, backend, attrs } = args;
    const { dy, filter } = inputs;
    const { pad: pad2, strides, inputShape } = attrs;
    const convInfo = backend_util_exports.computeConv3DInfo(inputShape, filter.shape, strides, 1, pad2);
    const program = new Conv3DDerInputProgram(convInfo);
    return backend.runWebGLProgram(program, [dy, filter], "float32");
  }
  var conv3DBackpropInputConfig = {
    kernelName: Conv3DBackpropInputV2,
    backendName: "webgl",
    kernelFunc: conv3DBackpropInput2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cos.js
  var COS = CHECK_NAN_SNIPPET_UNARY + `
  return cos(x);
`;
  var cos2 = unaryKernelFunc2({ opSnippet: COS });
  var cosConfig = {
    kernelName: Cos,
    backendName: "webgl",
    kernelFunc: cos2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cosh.js
  var COSH = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`;
  var cosh2 = unaryKernelFunc2({ opSnippet: COSH });
  var coshConfig = {
    kernelName: Cosh,
    backendName: "webgl",
    kernelFunc: cosh2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js
  var CropAndResizeProgram = class {
    constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {
      this.variableNames = ["Image", "Boxes", "BoxInd"];
      this.outputShape = [];
      const [batch, imageHeight, imageWidth, depth] = imageShape;
      const [numBoxes] = boxShape;
      const [cropHeight, cropWidth] = cropSize;
      this.outputShape = [numBoxes, cropHeight, cropWidth, depth];
      const methodId = method === "bilinear" ? 1 : 0;
      const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];
      const [heightRatio, heightScale, inY] = cropHeight > 1 ? [
        `${(imageHeight - 1) / (cropHeight - 1)}`,
        "(y2-y1) * height_ratio",
        `y1*${inputHeightFloat} + float(y)*(height_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (y1+y2) * ${inputHeightFloat}`
      ];
      const [widthRatio, widthScale, inX] = cropWidth > 1 ? [
        `${(imageWidth - 1) / (cropWidth - 1)}`,
        "(x2-x1) * width_ratio",
        `x1*${inputWidthFloat} + float(x)*(width_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (x1+x2) * ${inputWidthFloat}`
      ];
      this.userCode = `
      const float height_ratio = float(${heightRatio});
      const float width_ratio = float(${widthRatio});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${batch}) {
          return;
        }

        float height_scale = ${heightScale};
        float width_scale = ${widthScale};

        float in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }
        float in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${methodId} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/CropAndResize.js
  var cropAndResize2 = (args) => {
    const { inputs, backend, attrs } = args;
    const { image: image2, boxes, boxInd } = inputs;
    const { cropSize, method, extrapolationValue } = attrs;
    const program = new CropAndResizeProgram(image2.shape, boxes.shape, cropSize, method, extrapolationValue);
    return backend.runWebGLProgram(program, [image2, boxes, boxInd], "float32");
  };
  var cropAndResizeConfig = {
    kernelName: CropAndResize,
    backendName: "webgl",
    kernelFunc: cropAndResize2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/cum_gpu.js
  var CumOpType;
  (function(CumOpType2) {
    CumOpType2["Prod"] = "*";
    CumOpType2["Sum"] = "+";
  })(CumOpType || (CumOpType = {}));
  var CumProgram = class {
    constructor(op2, outputShape, exclusive, reverse3) {
      this.op = op2;
      this.outputShape = outputShape;
      this.variableNames = ["x"];
      this.customUniforms = [{ name: "index", type: "float" }];
      const rank = this.outputShape.length;
      const initVal = this.op === CumOpType.Prod ? "1.0" : "0.0";
      const val = exclusive ? initVal : `getX(${getCoords2(rank, "coords", this.op)})`;
      const length = this.outputShape[this.outputShape.length - 1];
      let condition = "";
      let idxString = "";
      if (exclusive) {
        condition = reverse3 ? `end != ${length - 1}` : "end != 0";
        idxString = reverse3 ? "end + 1" : "end - 1";
      } else {
        condition = reverse3 ? `end + pow2 < ${length}` : "end >= pow2";
        idxString = reverse3 ? "end + pow2" : "end - pow2";
      }
      this.userCode = `
      void main() {
        ${getCoordsDataType(rank)} coords = getOutputCoords();
        int end = ${getFinalCoord(rank, "coords", this.op)};
        float val = ${val};
        int pow2 = int(pow(2.0, index));
        if (${condition}) {
          int idx = ${idxString};
          ${getFinalCoord(rank, "coords", this.op)} = idx;
          val ${this.op}= getX(${getCoords2(rank, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
    }
  };
  function getCoords2(rank, name, op2) {
    if (rank === 1) {
      return `${name}`;
    } else if (rank === 2) {
      return `${name}.x, ${name}.y`;
    } else if (rank === 3) {
      return `${name}.x, ${name}.y, ${name}.z`;
    } else if (rank === 4) {
      return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
    } else {
      throw new Error(`Cumulative ${op2} for rank ${rank} is not yet supported`);
    }
  }
  function getFinalCoord(rank, name, op2) {
    if (rank === 1) {
      return `${name}`;
    } else if (rank === 2) {
      return `${name}.y`;
    } else if (rank === 3) {
      return `${name}.z`;
    } else if (rank === 4) {
      return `${name}.w`;
    } else {
      throw new Error(`Cumulative ${op2} for rank ${rank} is not yet supported`);
    }
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cum_impl.js
  function cumImpl(op2, x2, backend, axis, exclusive, reverse3) {
    const xRank = x2.shape.length;
    const permutation = backend_util_exports.getAxesPermutation([axis], xRank);
    let permutedX = x2;
    if (permutation != null) {
      permutedX = transpose2({ inputs: { x: x2 }, backend, attrs: { perm: permutation } });
    }
    const permutedAxis = backend_util_exports.getInnerMostAxes(1, xRank)[0];
    if (permutedAxis !== xRank - 1) {
      throw new Error(`WebGL cumprod shader expects an inner-most axis=${x2.shape.length - 1} but got axis=${axis}`);
    }
    const size = permutedX.shape[permutedAxis];
    let result = identity3({ inputs: { x: permutedX }, backend });
    for (let i2 = 0; i2 <= Math.ceil(Math.log2(size)) - 1; i2++) {
      const program = new CumProgram(op2, permutedX.shape, false, reverse3);
      const customValues = [[i2]];
      const prevResult = result;
      result = backend.runWebGLProgram(program, [result], result.dtype, customValues);
      backend.disposeIntermediateTensorInfo(prevResult);
    }
    if (exclusive) {
      const program = new CumProgram(op2, permutedX.shape, exclusive, reverse3);
      const prevResult = result;
      result = backend.runWebGLProgram(program, [result], result.dtype);
      backend.disposeIntermediateTensorInfo(prevResult);
    }
    if (permutation != null) {
      const reversePermutation = backend_util_exports.getUndoAxesPermutation(permutation);
      const reverseTransposedResult = transpose2({ inputs: { x: result }, backend, attrs: { perm: reversePermutation } });
      backend.disposeIntermediateTensorInfo(result);
      backend.disposeIntermediateTensorInfo(permutedX);
      return reverseTransposedResult;
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cumprod.js
  function cumprod2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { axis, exclusive, reverse: reverse3 } = attrs;
    return cumImpl(CumOpType.Prod, x2, backend, axis, exclusive, reverse3);
  }
  var cumprodConfig = {
    kernelName: Cumprod,
    backendName: "webgl",
    kernelFunc: cumprod2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cumsum.js
  function cumsum2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { axis, exclusive, reverse: reverse3 } = attrs;
    return cumImpl(CumOpType.Sum, x2, backend, axis, exclusive, reverse3);
  }
  var cumsumConfig = {
    kernelName: Cumsum,
    backendName: "webgl",
    kernelFunc: cumsum2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DenseBincount.js
  function denseBincount2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, weights } = inputs;
    const { size, binaryOutput } = attrs;
    if (x2.shape.length === 1) {
      const xVals = backend.readSync(x2.dataId);
      const weightsVals = backend.readSync(weights.dataId);
      const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);
      return backend.makeTensorInfo([size], weights.dtype, outVals);
    } else if (x2.shape.length === 2) {
      const xBuf = backend.bufferSync(x2);
      const weightsBuf = backend.bufferSync(weights);
      const outBuf = bincountReduceImplCPU(xBuf, weightsBuf, size, binaryOutput);
      return backend.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${x2.shape.length}.`);
  }
  var denseBincountConfig = {
    kernelName: DenseBincount,
    backendName: "webgl",
    kernelFunc: denseBincount2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/depth_to_space_gpu.js
  var DepthToSpaceProgram = class {
    constructor(outputShape, blockSize, dataFormat) {
      this.variableNames = ["x"];
      this.outputShape = [];
      this.outputShape = outputShape;
      this.blockSize = blockSize;
      this.dataFormat = dataFormat;
      this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${blockSize};
      int offset_h = imod(h, ${blockSize});
      int in_w = w / ${blockSize};
      int offset_w = imod(w, ${blockSize});
      int offset_d = (offset_h * ${blockSize} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    getHeightCoordString() {
      if (this.dataFormat === "NHWC") {
        return `coords[1]`;
      } else {
        return `coords[2]`;
      }
    }
    getWidthCoordString() {
      if (this.dataFormat === "NHWC") {
        return `coords[2]`;
      } else {
        return `coords[3]`;
      }
    }
    getDepthCoordString() {
      if (this.dataFormat === "NHWC") {
        return `coords[3]`;
      } else {
        return `coords[1]`;
      }
    }
    getOutputDepthSize() {
      if (this.dataFormat === "NHWC") {
        return this.outputShape[3];
      } else {
        return this.outputShape[1];
      }
    }
    getInputSamplingString() {
      if (this.dataFormat === "NHWC") {
        return `getX(b, in_h, in_w, in_d)`;
      } else {
        return `getX(b, in_d, in_h, in_w)`;
      }
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthToSpace.js
  function depthToSpace2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { blockSize, dataFormat } = attrs;
    const batchSize = x2.shape[0];
    const inputHeight = dataFormat === "NHWC" ? x2.shape[1] : x2.shape[2];
    const inputWidth = dataFormat === "NHWC" ? x2.shape[2] : x2.shape[3];
    const inputDepth = dataFormat === "NHWC" ? x2.shape[3] : x2.shape[1];
    const outputHeight = inputHeight * blockSize;
    const outputWidth = inputWidth * blockSize;
    const outputDepth = inputDepth / (blockSize * blockSize);
    const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
    const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);
    return backend.runWebGLProgram(program, [x2], x2.dtype);
  }
  var depthToSpaceConfig = {
    kernelName: DepthToSpace,
    backendName: "webgl",
    kernelFunc: depthToSpace2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js
  var DepthwiseConv2DProgram = class {
    constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.customUniforms = [
        { name: "pads", type: "ivec2" },
        { name: "strides", type: "ivec2" },
        { name: "dilations", type: "ivec2" },
        { name: "inDims", type: "ivec2" }
      ];
      this.outputShape = convInfo.outShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation2) {
        if (hasPreluActivation) {
          activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
        } else if (hasLeakyReluAlpha) {
          activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
        } else {
          activationSnippet = `
          float activation(float x) {
            ${activation2}
          }
        `;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyReluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js
  var DepthwiseConvPacked2DProgram = class {
    constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "pads", type: "ivec2" },
        { name: "strides", type: "ivec2" },
        { name: "dilations", type: "ivec2" },
        { name: "inDims", type: "ivec2" }
      ];
      this.outputShape = convInfo.outShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      const padLeft = convInfo.padInfo.left;
      const strideWidth = convInfo.strideWidth;
      const dilationWidth = convInfo.dilationWidth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const texelsAcross = filterWidth;
      let mainLoop = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
      for (let c2 = 0; c2 < filterWidth; c2++) {
        mainLoop += `
          vec4 xTexelC${c2 * 2};
          int xTexelC${c2 * 2}Ready;
          vec4 xTexelC${c2 * 2 + 1};
          int xTexelC${c2 * 2 + 1}Ready;
          vec4 xC${c2};`;
      }
      mainLoop += `
    for (int r = 0; r < ${filterHeight}; r++) {
      `;
      for (let c2 = 0; c2 < filterWidth; c2++) {
        mainLoop += `
          xTexelC${c2 * 2} = vec4(0.0);
          xTexelC${c2 * 2}Ready = 0;
          xTexelC${c2 * 2 + 1} = vec4(0.0);
          xTexelC${c2 * 2 + 1}Ready = 0;
          xC${c2} = vec4(0.0);`;
      }
      mainLoop += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
      for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {
        const colIndex = texelC * 2;
        mainLoop += `
          xC = xCCorner + ${colIndex * dilationWidth};
          `;
        if (strideWidth === 1) {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }
              `;
              if (dilationWidth === 1 && colIndex > 0) {
                mainLoop += `
                xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);
                `;
              } else {
                mainLoop += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);
                  } else {
                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);
                  }
                  `;
              }
            } else {
              mainLoop += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xC${colIndex} = xTexelC${colIndex};
                `;
            }
            if (colIndex + 1 < filterWidth) {
              const nextTexelOffset = padLeft % 2 === 0 ? util_exports.nearestLargerEven(dilationWidth) : dilationWidth;
              if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
                mainLoop += `
                  xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                    xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${colIndex + 1}.zw = vec2(0.0);
                    }
                    xTexelC${colIndex + 1}Ready = 1;
                  }
                  `;
                if (dilationWidth > 1) {
                  mainLoop += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${colIndex + 1} = vec4(previous.zw, xTexelC${colIndex + 1}.xy);
                    } else {
                     xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${colIndex + 1}.xy);
                    }
                    `;
                } else {
                  mainLoop += `
                    xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);
                    `;
                }
              } else {
                if (nextTexelOffset === 1) {
                  mainLoop += `
                    xC${colIndex + 1} = xTexelC${colIndex};
                    `;
                } else {
                  mainLoop += `
                    xCOffset = xC + ${nextTexelOffset};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                      xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${colIndex + 1}.zw = vec2(0.0);
                      }
                      xTexelC${colIndex + 1}Ready = 1;
                    }

                    xC${colIndex + 1} = xTexelC${colIndex + 1};
                    `;
                }
              }
            }
          }
        } else {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
              `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);
                `;
              }
            } else {
              mainLoop += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(
                  xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);
              `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
                `;
              }
            }
          }
        }
        if (colIndex < filterWidth) {
          mainLoop += `
            wTexel = getW(r, ${colIndex}, d1, q);
            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);
          `;
          if (colIndex + 1 < filterWidth) {
            mainLoop += `
              wTexel = getW(r, ${colIndex + 1}, d1, q);
              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);
            `;
          }
        }
      }
      mainLoop += `
    }
  `;
      mainLoop += `
      }
    `;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation2) {
        if (hasPreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
        } else if (hasLeakyReluAlpha) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
        } else {
          activationSnippet = `vec4 activation(vec4 x) {
          ${activation2}
        }`;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyReluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${mainLoop}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNative.js
  function depthwiseConv2dNative(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, filter } = inputs;
    const { strides, pad: pad2, dilations, dimRoundingMode } = attrs;
    let $dilations = dilations;
    if ($dilations == null) {
      $dilations = [1, 1];
    }
    util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
    const convInfo = backend_util_exports.computeConv2DInfo(
      x2.shape,
      filter.shape,
      strides,
      $dilations,
      pad2,
      dimRoundingMode,
      true
      /* depthwise */
    );
    let program;
    if (env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1) {
      program = new DepthwiseConvPacked2DProgram(convInfo);
    } else {
      program = new DepthwiseConv2DProgram(convInfo);
    }
    const customValues = [
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inHeight, convInfo.inWidth]
    ];
    return backend.runWebGLProgram(program, [x2, filter], "float32", customValues);
  }
  var depthwiseConv2dNativeConfig = {
    kernelName: DepthwiseConv2dNative,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNative
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js
  var DepthwiseConv2DDerFilterProgram = class {
    constructor(convInfo) {
      this.variableNames = ["x", "dy"];
      this.outputShape = convInfo.filterShape;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${channelMul} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var DepthwiseConv2DDerInputProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy", "W"];
      this.outputShape = convInfo.inShape;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padTop = filterHeight - 1 - convInfo.padInfo.top;
      const padLeft = filterWidth - 1 - convInfo.padInfo.left;
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${channelMul}; dm++) {
              int d2 = d1 * ${channelMul} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js
  function depthwiseConv2dNativeBackpropFilter2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, dy } = inputs;
    const { strides, dilations, pad: pad2, dimRoundingMode, filterShape } = attrs;
    const convInfo = backend_util_exports.computeConv2DInfo(
      x2.shape,
      filterShape,
      strides,
      dilations,
      pad2,
      dimRoundingMode,
      true
      /* depthwise */
    );
    const program = new DepthwiseConv2DDerFilterProgram(convInfo);
    return backend.runWebGLProgram(program, [x2, dy], "float32");
  }
  var depthwiseConv2dNativeBackpropFilterConfig = {
    kernelName: DepthwiseConv2dNativeBackpropFilter,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNativeBackpropFilter2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropInput.js
  function depthwiseConv2dNativeBackpropInput2(args) {
    const { inputs, backend, attrs } = args;
    const { dy, filter } = inputs;
    const { strides, dilations, pad: pad2, dimRoundingMode, inputShape } = attrs;
    const convInfo = backend_util_exports.computeConv2DInfo(
      inputShape,
      filter.shape,
      strides,
      dilations,
      pad2,
      dimRoundingMode,
      true
      /* depthwise */
    );
    const program = new DepthwiseConv2DDerInputProgram(convInfo);
    return backend.runWebGLProgram(program, [dy, filter], "float32");
  }
  var depthwiseConv2dNativeBackpropInputConfig = {
    kernelName: DepthwiseConv2dNativeBackpropInput,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNativeBackpropInput2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/diag_gpu.js
  var DiagProgram = class {
    constructor(size) {
      this.variableNames = ["X"];
      this.outputShape = [size, size];
      this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Diag.js
  function diag2(args) {
    const { inputs, backend } = args;
    const { x: x2 } = inputs;
    const outShape = [...x2.shape, ...x2.shape];
    const xSize = util_exports.sizeFromShape(x2.shape);
    const flat = reshape3({ inputs: { x: x2 }, backend, attrs: { shape: [xSize] } });
    const program = new DiagProgram(xSize);
    const res = backend.runWebGLProgram(program, [flat], flat.dtype);
    const out = reshape3({ inputs: { x: res }, backend, attrs: { shape: outShape } });
    backend.disposeIntermediateTensorInfo(flat);
    backend.disposeIntermediateTensorInfo(res);
    return out;
  }
  var diagConfig = {
    kernelName: Diag,
    backendName: "webgl",
    kernelFunc: diag2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/dilation_gpu.js
  var Dilation2DProgram = class {
    constructor(convInfo) {
      this.variableNames = ["x", "W"];
      this.outputShape = convInfo.outShape;
      const { inHeight, inWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth } = convInfo;
      const { top: padTop, left: padLeft } = padInfo;
      this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${filterHeight}; h++) {
          int hIn = hBeg + h * ${dilationHeight};

          if (hIn >= 0 && hIn < ${inHeight}) {
            for (int w = 0; w < ${filterWidth}; w++) {
              int wIn = wBeg + w * ${dilationWidth};

              if (wIn >= 0 && wIn < ${inWidth}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Dilation2D.js
  function dilation2D(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, filter } = inputs;
    const { strides, pad: pad2, dilations } = attrs;
    const convInfo = backend_util_exports.computeDilation2DInfo(x2.shape, filter.shape, strides, pad2, "NHWC", dilations);
    let out;
    const program = new Dilation2DProgram(convInfo);
    out = backend.runWebGLProgram(program, [x2, filter], "float32");
    const outReshaped = reshape3({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });
    backend.disposeIntermediateTensorInfo(out);
    return outReshaped;
  }
  var dilation2DConfig = {
    kernelName: Dilation2D,
    backendName: "webgl",
    kernelFunc: dilation2D
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Einsum.js
  function einsum2(args) {
    const { inputs, backend, attrs } = args;
    const { equation } = attrs;
    const tensors = inputs;
    const { allDims, summedDims, idDims } = backend_util_exports.decodeEinsumEquation(equation, tensors.length);
    backend_util_exports.checkEinsumDimSizes(allDims.length, idDims, tensors);
    const { path, steps } = backend_util_exports.getEinsumComputePath(summedDims, idDims);
    const nSteps = steps.length;
    let out = null;
    let numDimsRemaining = allDims.length;
    const tensorsToDispose = [];
    for (let i2 = 0; i2 < nSteps; ++i2) {
      for (const idTerm of steps[i2]) {
        const { permutationIndices: perm, expandDims: dimsToExpand } = backend_util_exports.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
        let x2;
        if (backend_util_exports.isIdentityPermutation(perm)) {
          x2 = tensors[idTerm];
        } else {
          x2 = transpose2({ inputs: { x: tensors[idTerm] }, backend, attrs: { perm } });
          tensorsToDispose.push(x2);
        }
        const targetShape = x2.shape.slice();
        for (let k4 = 0; k4 < dimsToExpand.length; ++k4) {
          targetShape.splice(dimsToExpand[k4], 0, 1);
        }
        if (!util_exports.arraysEqual(x2.shape, targetShape)) {
          x2 = reshape3({ inputs: { x: x2 }, backend, attrs: { shape: targetShape } });
          tensorsToDispose.push(x2);
        }
        if (out === null) {
          out = x2;
        } else {
          out = multiply2({ inputs: { a: x2, b: out }, backend });
          tensorsToDispose.push(out);
        }
      }
      if (i2 < nSteps - 1) {
        if (path[i2] >= 0) {
          out = sum3({
            inputs: { x: out },
            backend,
            attrs: {
              axis: path[i2] - (allDims.length - numDimsRemaining),
              keepDims: false
            }
          });
          tensorsToDispose.push(out);
        }
        numDimsRemaining--;
      }
    }
    for (const tensorInfo of tensorsToDispose) {
      if (tensorInfo === out) {
        continue;
      }
      backend.disposeIntermediateTensorInfo(tensorInfo);
    }
    return out;
  }
  var einsumConfig = {
    kernelName: Einsum,
    backendName: "webgl",
    kernelFunc: einsum2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Elu.js
  var ELU4 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
  var ELU_PACKED = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
  var elu2 = unaryKernelFunc2({ opSnippet: ELU4, packedOpSnippet: ELU_PACKED });
  var eluConfig = {
    kernelName: Elu2,
    backendName: "webgl",
    kernelFunc: elu2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/EluGrad.js
  var ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;
  var ELU_DER_PACKED = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
  var eluGrad = (args) => {
    const { inputs, backend } = args;
    const { dy, y: y2 } = inputs;
    const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(ELU_DER_PACKED, dy.shape, y2.shape) : new BinaryOpProgram(ELU_DER, dy.shape, y2.shape);
    return backend.runWebGLProgram(program, [dy, y2], dy.dtype);
  };
  var eluGradConfig = {
    kernelName: EluGrad,
    backendName: "webgl",
    kernelFunc: eluGrad
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Equal.js
  var PACKED_EQUAL = `
  return vec4(equal(a, b));
`;
  var EQUAL = `return float(a == b);`;
  var equal3 = binaryKernelFunc2({
    opSnippet: EQUAL,
    packedOpSnippet: PACKED_EQUAL,
    dtype: "bool",
    cpuKernelImpl: equalImplCPU
  });
  var equalConfig = {
    kernelName: Equal,
    backendName: "webgl",
    kernelFunc: equal3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Erf.js
  var ERF = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${backend_util_exports.ERF_P};
  float a1 = ${backend_util_exports.ERF_A1};
  float a2 = ${backend_util_exports.ERF_A2};
  float a3 = ${backend_util_exports.ERF_A3};
  float a4 = ${backend_util_exports.ERF_A4};
  float a5 = ${backend_util_exports.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
  var erf2 = unaryKernelFunc2({ opSnippet: ERF });
  var erfConfig = {
    kernelName: Erf,
    backendName: "webgl",
    kernelFunc: erf2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Exp.js
  var EXP = CHECK_NAN_SNIPPET_UNARY + `
  return exp(x);
`;
  var EXP_PACKED = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var exp3 = unaryKernelFunc2({
    opSnippet: EXP,
    packedOpSnippet: EXP_PACKED,
    cpuKernelImpl: expImplCPU,
    dtype: "float32"
  });
  var expConfig = {
    kernelName: Exp,
    backendName: "webgl",
    kernelFunc: exp3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ExpandDims.js
  function expandDims2(args) {
    const { inputs, attrs, backend } = args;
    const { dim } = attrs;
    const { input: input2 } = inputs;
    const inputRank = input2.shape.length;
    const newShape = input2.shape.slice();
    let $dim = dim;
    if (dim < 0) {
      util_exports.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
      $dim = inputRank + dim + 1;
    }
    newShape.splice($dim, 0, 1);
    return reshape3({ inputs: { x: input2 }, backend, attrs: { shape: newShape } });
  }
  var expandDimsConfig = {
    kernelName: ExpandDims,
    backendName: "webgl",
    kernelFunc: expandDims2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Expm1.js
  var EXPM1 = `return exp(x) - 1.0;`;
  var expm13 = unaryKernelFunc2({ opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: expm1ImplCPU });
  var expm1Config = {
    kernelName: Expm1,
    backendName: "webgl",
    kernelFunc: expm13
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/fft_gpu.js
  var FFTProgram = class {
    constructor(component, inputShape, inverse) {
      this.variableNames = ["real", "imag"];
      const innerDim = inputShape[1];
      this.outputShape = inputShape;
      const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;
      const resultDenominator = inverse ? `${innerDim}.0` : "1.0";
      let opString;
      if (component === "real") {
        opString = "return real * expR - imag * expI;";
      } else if (component === "imag") {
        opString = "return real * expI + imag * expR;";
      } else {
        throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);
      }
      this.userCode = `
      const float exponentMultiplier = ${exponentMultiplierSnippet};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${opString}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${innerDim});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${innerDim}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT_impl.js
  function fftImpl(x2, inverse, backend) {
    const xData = backend.texData.get(x2.dataId);
    const inputSize = util_exports.sizeFromShape(x2.shape);
    const innerDimensionSize = x2.shape[x2.shape.length - 1];
    const batch = inputSize / innerDimensionSize;
    const input2D = reshape3({ inputs: { x: x2 }, backend, attrs: { shape: [batch, innerDimensionSize] } });
    const xShape = input2D.shape;
    const realProgram = new FFTProgram("real", xShape, inverse);
    const imagProgram = new FFTProgram("imag", xShape, inverse);
    const inputs = [
      {
        dataId: xData.complexTensorInfos.real.dataId,
        dtype: xData.complexTensorInfos.real.dtype,
        shape: xShape
      },
      {
        dataId: xData.complexTensorInfos.imag.dataId,
        dtype: xData.complexTensorInfos.imag.dtype,
        shape: xShape
      }
    ];
    const realPart = backend.runWebGLProgram(realProgram, inputs, "float32");
    const imagPart = backend.runWebGLProgram(imagProgram, inputs, "float32");
    const complexOutput = complex3({ inputs: { real: realPart, imag: imagPart }, backend });
    backend.disposeIntermediateTensorInfo(realPart);
    backend.disposeIntermediateTensorInfo(imagPart);
    const complexOutputReshaped = reshape3({ inputs: { x: complexOutput }, backend, attrs: { shape: x2.shape } });
    backend.disposeIntermediateTensorInfo(input2D);
    backend.disposeIntermediateTensorInfo(complexOutput);
    return complexOutputReshaped;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT.js
  function fft2(args) {
    const { inputs, backend } = args;
    const { input: input2 } = inputs;
    return fftImpl(input2, false, backend);
  }
  var fftConfig = {
    kernelName: FFT,
    backendName: "webgl",
    kernelFunc: fft2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/fill_gpu.js
  var FillProgram = class {
    constructor(shape, value) {
      this.outputShape = [];
      this.customUniforms = [{ name: "value", type: "float" }];
      this.variableNames = ["x"];
      this.outputShape = shape;
      this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js
  function fill2(args) {
    const { backend, attrs } = args;
    const { shape, value } = attrs;
    let { dtype } = attrs;
    dtype = dtype || util_exports.inferDtype(value);
    if (dtype === "string") {
      const values = util_exports.getArrayFromDType(dtype, util_exports.sizeFromShape(shape));
      values.fill(value);
      return backend.makeTensorInfo(shape, dtype, values);
    } else {
      const program = new FillProgram(shape, value);
      const customValues = [[value]];
      return backend.runWebGLProgram(program, [], dtype, customValues);
    }
  }
  var fillConfig = {
    kernelName: Fill,
    backendName: "webgl",
    kernelFunc: fill2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/flip_left_right_gpu.js
  var FlipLeftRightProgram = class {
    constructor(imageShape) {
      this.variableNames = ["Image"];
      this.outputShape = [];
      const imageWidth = imageShape[2];
      this.outputShape = imageShape;
      this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${imageWidth} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${imageWidth}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FlipLeftRight.js
  var flipLeftRightConfig = {
    kernelName: FlipLeftRight,
    backendName: "webgl",
    kernelFunc: ({ inputs, backend }) => {
      const { image: image2 } = inputs;
      const webglBackend = backend;
      const program = new FlipLeftRightProgram(image2.shape);
      const output = webglBackend.runWebGLProgram(program, [image2], image2.dtype);
      return output;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Floor.js
  var FLOOR = `return floor(x);`;
  var floor3 = unaryKernelFunc2({ opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: floorImplCPU });
  var floorConfig = {
    kernelName: Floor,
    backendName: "webgl",
    kernelFunc: floor3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FloorDiv.js
  var INT_DIV = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`;
  var INT_DIV_PACKED = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`;
  var floorDiv2 = binaryKernelFunc2({ opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: "int32" });
  var floorDivConfig = {
    kernelName: FloorDiv,
    backendName: "webgl",
    kernelFunc: floorDiv2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_gpu.js
  var FromPixelsProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      const glsl = getGlslDifferences();
      const [height, width] = outputShape;
      this.outputShape = outputShape;
      this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);

        vec4 values = ${glsl.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_packed_gpu.js
  var FromPixelsPackedProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      const glsl = getGlslDifferences();
      const [height, width] = outputShape;
      this.outputShape = outputShape;
      this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${width}.0, ${height}.0);
            vec4 values = ${glsl.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${glsl.output} = result;
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels.js
  var fromPixelsConfig = {
    kernelName: FromPixels,
    backendName: "webgl",
    kernelFunc: fromPixels2
  };
  var fromPixels2DContext2;
  var willReadFrequently = env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
  function fromPixels2(args) {
    const { inputs, backend, attrs } = args;
    let { pixels } = inputs;
    const { numChannels } = attrs;
    const isVideo = typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement;
    const isImage = typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement;
    const [width, height] = isVideo ? [
      pixels.videoWidth,
      pixels.videoHeight
    ] : [pixels.width, pixels.height];
    const texShape = [height, width];
    const outShape = [height, width, numChannels];
    if (isImage || isVideo) {
      const newWillReadFrequently = env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
      if (fromPixels2DContext2 == null || newWillReadFrequently !== willReadFrequently) {
        willReadFrequently = newWillReadFrequently;
        fromPixels2DContext2 = document.createElement("canvas").getContext("2d", { willReadFrequently });
      }
      fromPixels2DContext2.canvas.width = width;
      fromPixels2DContext2.canvas.height = height;
      fromPixels2DContext2.drawImage(pixels, 0, 0, width, height);
      pixels = fromPixels2DContext2.canvas;
    }
    const tempPixelHandle = backend.makeTensorInfo(texShape, "int32");
    backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;
    backend.gpgpu.uploadPixelDataToTexture(backend.getTexture(tempPixelHandle.dataId), pixels);
    const program = env().getBool("WEBGL_PACK") ? new FromPixelsPackedProgram(outShape) : new FromPixelsProgram(outShape);
    const res = backend.runWebGLProgram(program, [tempPixelHandle], "int32");
    backend.disposeData(tempPixelHandle.dataId);
    return res;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedConv2D.js
  function fusedConv2d(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, filter, bias, preluActivationWeights } = inputs;
    const { strides, pad: pad2, dataFormat, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
    const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(x2.shape, filter.shape, strides, dilations, pad2, dimRoundingMode, false, $dataFormat);
    let out;
    const intermediates = [];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation2 === "leakyrelu";
    const prepareInputs = () => {
      const inputs2 = [x2, filter];
      const alignInputWithDataFormat = (input2, dataFormat2) => {
        if (dataFormat2 === "NCHW" && input2.shape.length === 1 && input2.shape[0] !== 1) {
          const alignedInput = reshape3({
            inputs: { x: input2 },
            backend,
            attrs: { shape: [input2.shape[0], 1, 1] }
          });
          intermediates.push(alignedInput);
          return alignedInput;
        }
        return input2;
      };
      if (hasBias) {
        inputs2.push(alignInputWithDataFormat(bias, dataFormat));
      }
      if (hasPreluActivationWeights) {
        inputs2.push(alignInputWithDataFormat(preluActivationWeights, dataFormat));
      }
      if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
        inputs2.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
      }
      return inputs2;
    };
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
      out = conv2dByMatMul({
        x: x2,
        filter,
        convInfo,
        backend,
        bias,
        activation: activation2,
        preluActivationWeights,
        leakyreluAlpha
      });
    } else if (convInfo.strideWidth <= 2 && $dataFormat === "channelsLast" && env().getBool("WEBGL_EXP_CONV")) {
      const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, true) : null;
      const program = new Conv2DPackedProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      const customValues = [
        [convInfo.padInfo.top, convInfo.padInfo.left],
        [convInfo.strideHeight, convInfo.strideWidth],
        [convInfo.dilationHeight, convInfo.dilationWidth],
        [convInfo.inHeight, convInfo.inWidth]
      ];
      const inputs2 = prepareInputs();
      out = backend.runWebGLProgram(program, inputs2, "float32", customValues);
    } else if (env().getBool("WEBGL_CONV_IM2COL")) {
      out = conv2dWithIm2Row({
        x: x2,
        filter,
        convInfo,
        backend,
        bias,
        activation: activation2,
        preluActivationWeights,
        leakyreluAlpha
      });
    } else {
      const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, false) : null;
      const program = new Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      const inputs2 = prepareInputs();
      out = backend.runWebGLProgram(program, inputs2, "float32");
    }
    const outReshaped = reshape3({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });
    intermediates.push(out);
    intermediates.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return outReshaped;
  }
  var fusedConv2DConfig = {
    kernelName: FusedConv2D,
    backendName: "webgl",
    kernelFunc: fusedConv2d
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedDepthwiseConv2D.js
  function fusedDepthwiseConv2D(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, filter, bias, preluActivationWeights } = inputs;
    const { strides, pad: pad2, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
    const intermediates = [];
    let $dilations = dilations;
    if ($dilations == null) {
      $dilations = [1, 1];
    }
    util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
    const convInfo = backend_util_exports.computeConv2DInfo(
      x2.shape,
      filter.shape,
      strides,
      $dilations,
      pad2,
      dimRoundingMode,
      true
      /* depthwise */
    );
    const shouldPackDepthwiseConv = env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1;
    const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, shouldPackDepthwiseConv) : null;
    const programInputs = [x2, filter];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation2 === "leakyrelu";
    if (hasBias) {
      programInputs.push(bias);
    }
    if (hasPreluActivationWeights) {
      programInputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
      const $leakyreluAlpha = backend.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
      programInputs.push($leakyreluAlpha);
      intermediates.push($leakyreluAlpha);
    }
    let program;
    if (shouldPackDepthwiseConv) {
      program = new DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    } else {
      program = new DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    }
    const customValues = [
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inHeight, convInfo.inWidth]
    ];
    const result = backend.runWebGLProgram(program, programInputs, "float32", customValues);
    intermediates.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return result;
  }
  var fusedDepthwiseConv2DConfig = {
    kernelName: FusedDepthwiseConv2D,
    backendName: "webgl",
    kernelFunc: fusedDepthwiseConv2D
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_nd_gpu.js
  var GatherNDProgram = class {
    constructor(sliceDim, strides, shape, paramsShape) {
      this.sliceDim = sliceDim;
      this.strides = strides;
      this.paramsShape = paramsShape;
      this.variableNames = ["x", "indices"];
      this.outputShape = shape;
      const dtype = getCoordsDataType(shape.length);
      let mainLoop = `
    int index;`;
      for (let j3 = 0; j3 < this.sliceDim; j3++) {
        mainLoop += `
          index = round(getIndices(coords[0], ${j3}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[j3]};
          flattenIndex += index * ${this.strides[j3]};`;
      }
      this.userCode = `
         void main() {
          ${dtype} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${mainLoop}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherNd.js
  function gatherNd(args) {
    const { inputs, backend } = args;
    const { params, indices } = inputs;
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    const paramsSize = util_exports.sizeFromShape(params.shape);
    const [resultShape, numSlices, sliceSize, strides] = backend_util_exports.prepareAndValidate(params, indices);
    const flattenIndices = reshape3({ inputs: { x: indices }, backend, attrs: { shape: [numSlices, sliceRank] } });
    const flattenX = reshape3({
      inputs: { x: params },
      backend,
      attrs: { shape: [util_exports.sizeFromShape(params.shape) / sliceSize, sliceSize] }
    });
    if (backend.shouldExecuteOnCPU([params, indices]) || params.dtype === "string") {
      const indicesData = backend.readSync(indices.dataId);
      const paramsBuf = backend.bufferSync(params);
      const outValue = gatherNdImplCPU(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
      return backend.makeTensorInfo(resultShape, params.dtype, outValue.values);
    }
    const program = new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize], params.shape);
    const res = backend.runWebGLProgram(program, [flattenX, flattenIndices], flattenX.dtype);
    const reshaped = reshape3({ inputs: { x: res }, backend, attrs: { shape: resultShape } });
    backend.disposeIntermediateTensorInfo(flattenIndices);
    backend.disposeIntermediateTensorInfo(flattenX);
    backend.disposeIntermediateTensorInfo(res);
    return reshaped;
  }
  var gatherNdConfig = {
    kernelName: GatherNd,
    backendName: "webgl",
    kernelFunc: gatherNd
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_gpu.js
  var GatherProgram = class {
    constructor(aShape, outputShape) {
      this.variableNames = ["A", "indices"];
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      const dtype = getCoordsDataType(this.rank);
      const sourceCoords = getSourceCoords2(aShape, 2);
      this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${aShape[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${sourceCoords}));
      }
    `;
    }
  };
  function getSourceCoords2(aShape, axis) {
    const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
    const sourceCoords = [];
    for (let i2 = 0; i2 < aShape.length; i2++) {
      if (i2 === 2) {
        sourceCoords.push("index");
      } else {
        sourceCoords.push(`${currentCoords[i2]}`);
      }
    }
    return sourceCoords.join();
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherV2.js
  function gatherV2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, indices } = inputs;
    const { axis, batchDims } = attrs;
    const parsedAxis = util_exports.parseAxisParam(axis, x2.shape)[0];
    if (env().get("DEBUG")) {
      const indicesVals = backend.readSync(indices.dataId);
      const axisDim = x2.shape[parsedAxis];
      for (let i2 = 0; i2 < indicesVals.length; ++i2) {
        const index = indicesVals[i2];
        util_exports.assert(index <= axisDim - 1 && index >= 0, () => `GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`);
      }
    }
    const shapeInfo = backend_util_exports.segment_util.collectGatherOpShapeInfo(x2, indices, parsedAxis, batchDims);
    const indicesSize = util_exports.sizeFromShape(indices.shape);
    const toDispose = [];
    const flattenX = reshape3({
      inputs: { x: x2 },
      backend,
      attrs: {
        shape: [
          shapeInfo.batchSize,
          shapeInfo.outerSize,
          shapeInfo.dimSize,
          shapeInfo.sliceSize
        ]
      }
    });
    const flattenIndex = reshape3({
      inputs: { x: indices },
      backend,
      attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
    });
    toDispose.push(flattenX);
    toDispose.push(flattenIndex);
    const flattenOutputShape = [
      shapeInfo.batchSize,
      shapeInfo.outerSize,
      indicesSize / shapeInfo.batchSize,
      shapeInfo.sliceSize
    ];
    if (backend.shouldExecuteOnCPU([x2, indices]) || x2.dtype === "string") {
      const indicesBuf = backend.bufferSync(flattenIndex);
      const xBuf = backend.bufferSync(flattenX);
      const outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);
      toDispose.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
      return backend.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
    }
    const program = new GatherProgram(flattenX.shape, flattenOutputShape);
    const res = backend.runWebGLProgram(program, [flattenX, flattenIndex], flattenX.dtype);
    toDispose.push(res);
    const reshaped = reshape3({ inputs: { x: res }, backend, attrs: { shape: shapeInfo.outputShape } });
    toDispose.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return reshaped;
  }
  var gatherV2Config = {
    kernelName: GatherV2,
    backendName: "webgl",
    kernelFunc: gatherV2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Greater.js
  var GREATER = `return float(a > b);`;
  var GREATER_PACKED = `
  return vec4(greaterThan(a, b));
`;
  var greater3 = binaryKernelFunc2({
    opSnippet: GREATER,
    packedOpSnippet: GREATER_PACKED,
    cpuKernelImpl: greaterImplCPU,
    dtype: "bool"
  });
  var greaterConfig = {
    kernelName: Greater,
    backendName: "webgl",
    kernelFunc: greater3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GreaterEqual.js
  var GREATER_EQUAL = `return float(a >= b);`;
  var GREATER_EQUAL_PACKED = `
  return vec4(greaterThanEqual(a, b));
`;
  var greaterEqual3 = binaryKernelFunc2({
    opSnippet: GREATER_EQUAL,
    packedOpSnippet: GREATER_EQUAL_PACKED,
    dtype: "bool",
    cpuKernelImpl: greaterEqualImplCPU
  });
  var greaterEqualConfig = {
    kernelName: GreaterEqual,
    backendName: "webgl",
    kernelFunc: greaterEqual3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IFFT.js
  function ifft2(args) {
    const { inputs, backend } = args;
    const { input: input2 } = inputs;
    return fftImpl(input2, true, backend);
  }
  var ifftConfig = {
    kernelName: IFFT,
    backendName: "webgl",
    kernelFunc: ifft2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsFinite.js
  var IS_FINITE = `return float(!isnan(x) && !isinf(x));`;
  var isFinite3 = unaryKernelFunc2({ opSnippet: IS_FINITE, dtype: "bool" });
  var isFiniteConfig = {
    kernelName: IsFinite,
    backendName: "webgl",
    kernelFunc: isFinite3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsInf.js
  var IS_INF = `return float(isinf(x));`;
  var isInf2 = unaryKernelFunc2({ opSnippet: IS_INF, dtype: "bool" });
  var isInfConfig = {
    kernelName: IsInf,
    backendName: "webgl",
    kernelFunc: isInf2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsNaN.js
  var IS_NAN = `return float(isnan(x));`;
  var isNaN3 = unaryKernelFunc2({ opSnippet: IS_NAN, dtype: "bool" });
  var isNaNConfig = {
    kernelName: IsNan,
    backendName: "webgl",
    kernelFunc: isNaN3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Less.js
  var LESS = `return float(a < b);`;
  var LESS_PACKED = `
  return vec4(lessThan(a, b));
`;
  var less4 = binaryKernelFunc2({
    opSnippet: LESS,
    packedOpSnippet: LESS_PACKED,
    cpuKernelImpl: lessImplCPU,
    dtype: "bool"
  });
  var lessConfig = {
    kernelName: Less,
    backendName: "webgl",
    kernelFunc: less4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LessEqual.js
  var LESS_EQUAL = `return float(a <= b);`;
  var LESS_EQUAL_PACKED = `
  return vec4(lessThanEqual(a, b));
`;
  var lessEqual3 = binaryKernelFunc2({
    opSnippet: LESS_EQUAL,
    packedOpSnippet: LESS_EQUAL_PACKED,
    cpuKernelImpl: lessEqualImplCPU,
    dtype: "bool"
  });
  var lessEqualConfig = {
    kernelName: LessEqual,
    backendName: "webgl",
    kernelFunc: lessEqual3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LinSpace.js
  function linSpace(args) {
    const { backend, attrs } = args;
    const { start, stop, num } = attrs;
    const outVals = linSpaceImplCPU(start, stop, num);
    return backend.makeTensorInfo([outVals.length], "float32", outVals);
  }
  var linSpaceConfig = {
    kernelName: LinSpace,
    backendName: "webgl",
    kernelFunc: linSpace
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log.js
  var LOG = CHECK_NAN_SNIPPET_UNARY + `
  return x < 0.0 ? 0./0. : log(x);
`;
  var LOG_PACKED = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`;
  var log4 = unaryKernelFunc2({ opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: logImplCPU });
  var logConfig = {
    kernelName: Log,
    backendName: "webgl",
    kernelFunc: log4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log1p.js
  var LOG1P = CHECK_NAN_SNIPPET_UNARY + `
  return log(1.0 + x);
`;
  var log1p2 = unaryKernelFunc2({ opSnippet: LOG1P });
  var log1pConfig = {
    kernelName: Log1p,
    backendName: "webgl",
    kernelFunc: log1p2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalAnd.js
  var LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;
  var LOGICAL_AND_PACKED = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`;
  var logicalAnd2 = binaryKernelFunc2({
    opSnippet: LOGICAL_AND,
    packedOpSnippet: LOGICAL_AND_PACKED,
    dtype: "bool"
  });
  var logicalAndConfig = {
    kernelName: LogicalAnd,
    backendName: "webgl",
    kernelFunc: logicalAnd2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalNot.js
  var LOGICAL_NOT = `return float(!(x >= 1.0));`;
  var logicalNot2 = unaryKernelFunc2({ opSnippet: LOGICAL_NOT });
  var logicalNotConfig = {
    kernelName: LogicalNot,
    backendName: "webgl",
    kernelFunc: logicalNot2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalOr.js
  var LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;
  var LOGICAL_OR_PACKED = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`;
  var logicalOr2 = binaryKernelFunc2({ opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: "bool" });
  var logicalOrConfig = {
    kernelName: LogicalOr,
    backendName: "webgl",
    kernelFunc: logicalOr2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_gpu.js
  var LRNProgram = class {
    constructor(xShape, radius, bias, alpha, beta) {
      this.variableNames = ["x"];
      this.outputShape = [];
      const rad = radius;
      const maxD = xShape[3] - 1;
      this.outputShape = xShape;
      let powOperator;
      const basis = `float(${bias}) + float(${alpha}) * sum`;
      if (beta === 0.5) {
        powOperator = `inversesqrt(${basis})`;
      } else if (beta === 1) {
        powOperator = `1.0/(${basis})`;
      } else {
        powOperator = `exp(log(${basis}) * float(-${beta}));`;
      }
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${rad}; j <= ${rad}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${maxD}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${powOperator};
        setOutput(val);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_packed_gpu.js
  var LRNPackedProgram = class {
    constructor(xShape, radius, bias, alpha, beta) {
      this.variableNames = ["x"];
      this.outputShape = [];
      this.packedInputs = true;
      this.packedOutput = true;
      const rad = radius;
      const maxD = xShape[3] - 1;
      this.outputShape = xShape;
      let powOperator;
      const basis = `float(${bias}) + float(${alpha}) * sum`;
      if (beta === 0.5) {
        powOperator = `inversesqrt(${basis})`;
      } else if (beta === 1) {
        powOperator = `1.0/(${basis})`;
      } else {
        powOperator = `exp(log(${basis}) * float(-${beta}));`;
      }
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${rad};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${rad}; j <= ${rad}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${powOperator};
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRN.js
  var lrn = (args) => {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { depthRadius, bias, alpha, beta } = attrs;
    const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new LRNPackedProgram(x2.shape, depthRadius, bias, alpha, beta) : new LRNProgram(x2.shape, depthRadius, bias, alpha, beta);
    return backend.runWebGLProgram(program, [x2], x2.dtype);
  };
  var LRNConfig = {
    kernelName: LRN,
    backendName: "webgl",
    kernelFunc: lrn
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_grad_gpu.js
  var LRNGradProgram = class {
    constructor(inputShape, depthRadius, bias, alpha, beta) {
      this.variableNames = ["inputImage", "outputImage", "dy"];
      this.outputShape = [];
      this.outputShape = inputShape;
      this.depth = inputShape[3];
      this.depthRadius = depthRadius;
      this.bias = bias;
      this.alpha = alpha;
      this.beta = beta;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${depthRadius})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${depthRadius} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${alpha}) * norm + float(${bias});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${alpha})
                * float(${beta})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${beta});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRNGrad.js
  var lrnGrad = (args) => {
    const { inputs, backend, attrs } = args;
    const { x: x2, y: y2, dy } = inputs;
    const { depthRadius, bias, alpha, beta } = attrs;
    const program = new LRNGradProgram(x2.shape, depthRadius, bias, alpha, beta);
    return backend.runWebGLProgram(program, [x2, y2, dy], x2.dtype);
  };
  var LRNGradConfig = {
    kernelName: LRNGrad,
    backendName: "webgl",
    kernelFunc: lrnGrad
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max_impl.js
  function maxImpl2(x2, reduceShape, outShape, backend) {
    const inSize = util_exports.sizeFromShape(reduceShape);
    const xSize = util_exports.sizeFromShape(x2.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = reshape3({ inputs: { x: x2 }, attrs: { shape: [batchSize, inSize] }, backend });
    const reduced = reduce(reshapedInput, x2.dtype, "max", backend);
    const reshapedOutput = reshape3({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });
    backend.disposeIntermediateTensorInfo(reshapedInput);
    backend.disposeIntermediateTensorInfo(reduced);
    return reshapedOutput;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max.js
  function max2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { reductionIndices, keepDims } = attrs;
    const xRank = x2.shape.length;
    const origAxes = util_exports.parseAxisParam(reductionIndices, x2.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    const maxInputIsTransposed = permutedAxes != null;
    const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([x2]);
    let maxInput = x2;
    if (maxInputIsTransposed) {
      if (shouldExecuteOnCPU) {
        const xTexData = backend.texData.get(maxInput.dataId);
        const values = xTexData.values;
        const newShape = new Array(xRank);
        for (let i2 = 0; i2 < newShape.length; i2++) {
          newShape[i2] = x2.shape[permutedAxes[i2]];
        }
        const maxInputValues = transposeImplCPU(values, x2.shape, x2.dtype, permutedAxes, newShape);
        maxInput = backend.makeTensorInfo(newShape, x2.dtype);
        const maxInputData = backend.texData.get(maxInput.dataId);
        maxInputData.values = maxInputValues;
      } else {
        maxInput = transposeImpl2(x2, permutedAxes, backend);
      }
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    }
    backend_util_exports.assertAxesAreInnerMostDims("max", axes, xRank);
    const [maxOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(maxInput.shape, axes);
    let outShape = maxOutShape;
    if (keepDims) {
      outShape = backend_util_exports.expandShapeToKeepDim(maxOutShape, origAxes);
    }
    let out;
    if (shouldExecuteOnCPU) {
      const xTexData = backend.texData.get(maxInput.dataId);
      const values = xTexData.values;
      const outValues = maxImplCPU(values, util_exports.sizeFromShape(reduceShape), outShape, x2.dtype);
      out = backend.makeTensorInfo(outShape, x2.dtype);
      const outData = backend.texData.get(out.dataId);
      outData.values = outValues;
    } else {
      out = maxImpl2(maxInput, reduceShape, outShape, backend);
    }
    if (maxInputIsTransposed) {
      backend.disposeIntermediateTensorInfo(maxInput);
    }
    return out;
  }
  var maxConfig = {
    kernelName: Max,
    backendName: "webgl",
    kernelFunc: max2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Maximum.js
  var MAXIMUM = CHECK_NAN_SNIPPET2 + `
  return max(a, b);
`;
  var MAXIMUM_PACKED = `
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  var maximum3 = binaryKernelFunc2({
    opSnippet: MAXIMUM,
    packedOpSnippet: MAXIMUM_PACKED,
    cpuKernelImpl: maximumImplCPU
  });
  var maximumConfig = {
    kernelName: Maximum2,
    backendName: "webgl",
    kernelFunc: maximum3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool.js
  function maxPool2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    assertNotComplex(x2, "maxPool");
    const { filterSize, strides, pad: pad2, dimRoundingMode } = attrs;
    const dilations = 1;
    util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, dilations, pad2, dimRoundingMode);
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports.arraysEqual(convInfo.inShape, convInfo.outShape)) {
      return identity3({ inputs: { x: x2 }, backend });
    }
    const maxPoolProgram = new Pool2DProgram(convInfo, "max", false);
    return backend.runWebGLProgram(maxPoolProgram, [x2], x2.dtype);
  }
  var maxPoolConfig = {
    kernelName: MaxPool,
    backendName: "webgl",
    kernelFunc: maxPool2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3D.js
  function maxPool3d2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { filterSize, strides, pad: pad2, dataFormat, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = backend_util_exports.computePool3DInfo(x2.shape, filterSize, strides, dilations, pad2, dimRoundingMode, dataFormat);
    const maxPoolProgram = new Pool3DProgram(convInfo, "max", false);
    return backend.runWebGLProgram(maxPoolProgram, [x2], x2.dtype);
  }
  var maxPool3DConfig = {
    kernelName: MaxPool3D,
    backendName: "webgl",
    kernelFunc: maxPool3d2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js
  var MaxPool2DBackpropProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy", "maxPos"];
      this.outputShape = convInfo.inShape;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
          wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${effectiveFilterWidth} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var MaxPool3DBackpropProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy", "maxPos"];
      this.outputShape = convInfo.inShape;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterDepth = convInfo.effectiveFilterDepth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;
      this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
           wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${lastIndex} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                  wR * ${effectiveFilterWidth} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3DGrad.js
  function maxPool3DGrad(args) {
    const { inputs, backend, attrs } = args;
    const { dy, input: input2 } = inputs;
    const x2 = input2;
    const { filterSize, strides, pad: pad2, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = backend_util_exports.computePool3DInfo(x2.shape, filterSize, strides, dilations, pad2, dimRoundingMode);
    const maxPool3dPositionsProgram = new Pool3DProgram(
      convInfo,
      "max",
      true
      /* get positions */
    );
    const maxPool3dPositions = backend.runWebGLProgram(maxPool3dPositionsProgram, [x2], x2.dtype);
    const maxPoolBackpropProgram = new MaxPool3DBackpropProgram(convInfo);
    const result = backend.runWebGLProgram(maxPoolBackpropProgram, [dy, maxPool3dPositions], x2.dtype);
    backend.disposeIntermediateTensorInfo(maxPool3dPositions);
    return result;
  }
  var maxPool3DGradConfig = {
    kernelName: MaxPool3DGrad,
    backendName: "webgl",
    kernelFunc: maxPool3DGrad
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolGrad.js
  function maxPoolGrad(args) {
    const { inputs, backend, attrs } = args;
    const { dy, input: input2, output } = inputs;
    const x2 = input2;
    assertNotComplex([input2, output], "maxPoolGrad");
    const { filterSize, strides, pad: pad2, dimRoundingMode } = attrs;
    const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, 1, pad2, dimRoundingMode);
    const getPositions = true;
    const maxPoolPositionsProgram = new Pool2DProgram(convInfo, "max", getPositions);
    const maxPoolPositions = backend.runWebGLProgram(maxPoolPositionsProgram, [x2], x2.dtype);
    const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);
    const result = backend.runWebGLProgram(maxPoolBackPropProgram, [dy, maxPoolPositions], x2.dtype);
    backend.disposeIntermediateTensorInfo(maxPoolPositions);
    return result;
  }
  var maxPoolGradConfig = {
    kernelName: MaxPoolGrad,
    backendName: "webgl",
    kernelFunc: maxPoolGrad
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax_impl.js
  function maxPoolWithArgmaxImpl(x2, includeBatchInIndex, convInfo, backend) {
    let program = new Pool2DProgram(convInfo, "max", false);
    const poolOutput = backend.runWebGLProgram(program, [x2], "float32");
    program = new Pool2DProgram(convInfo, "max", true, true, includeBatchInIndex);
    const indexOutput = backend.runWebGLProgram(program, [x2], "float32");
    return [poolOutput, indexOutput];
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax.js
  var maxPoolWithArgmaxConfig = {
    kernelName: MaxPoolWithArgmax,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend }) => {
      const { x: x2 } = inputs;
      const { filterSize, strides, pad: pad2, includeBatchInIndex } = attrs;
      const webglBackend = backend;
      util_exports.assert(x2.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x2.shape.length}.`);
      const dilations = [1, 1];
      util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = backend_util_exports.computePool2DInfo(x2.shape, filterSize, strides, dilations, pad2);
      const [result, indexes] = maxPoolWithArgmaxImpl(x2, includeBatchInIndex, convInfo, webglBackend);
      return [result, indexes];
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean_impl.js
  function meanImpl(x2, reduceShape, outShape, backend) {
    const inSize = util_exports.sizeFromShape(reduceShape);
    const xSize = util_exports.sizeFromShape(x2.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = reshape3({ inputs: { x: x2 }, attrs: { shape: [batchSize, inSize] }, backend });
    const reduced = reduce(reshapedInput, "float32", "mean", backend);
    const reshapedOutput = reshape3({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });
    backend.disposeIntermediateTensorInfo(reshapedInput);
    backend.disposeIntermediateTensorInfo(reduced);
    return reshapedOutput;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean.js
  var meanConfig = {
    kernelName: Mean,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend }) => {
      const { x: x2 } = inputs;
      const { keepDims, axis } = attrs;
      const webglBackend = backend;
      const xRank = x2.shape.length;
      const origAxes = util_exports.parseAxisParam(axis, x2.shape);
      let axes = origAxes;
      const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
      const meanInputIsTransposed = permutedAxes != null;
      const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x2]);
      const intermediates = [];
      let meanInput = x2;
      if (meanInputIsTransposed) {
        if (shouldExecuteOnCPU) {
          const xTexData = webglBackend.texData.get(meanInput.dataId);
          const values = xTexData.values;
          const newShape = new Array(xRank);
          for (let i2 = 0; i2 < newShape.length; i2++) {
            newShape[i2] = x2.shape[permutedAxes[i2]];
          }
          const meanInputValues = transposeImplCPU(values, x2.shape, x2.dtype, permutedAxes, newShape);
          meanInput = webglBackend.makeTensorInfo(newShape, x2.dtype);
          const meanInputData = webglBackend.texData.get(meanInput.dataId);
          meanInputData.values = meanInputValues;
        } else {
          meanInput = transposeImpl2(x2, permutedAxes, webglBackend);
        }
        intermediates.push(meanInput);
        axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
      }
      backend_util_exports.assertAxesAreInnerMostDims("sum", axes, xRank);
      const [meanOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(meanInput.shape, axes);
      let outShape = meanOutShape;
      if (keepDims) {
        outShape = backend_util_exports.expandShapeToKeepDim(meanOutShape, origAxes);
      }
      const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);
      for (const i2 of intermediates) {
        webglBackend.disposeIntermediateTensorInfo(i2);
      }
      return out;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Min.js
  function min2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x2.shape.length;
    const origAxes = util_exports.parseAxisParam(axis, x2.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    let permutedX = x2;
    if (permutedAxes != null) {
      permutedX = transpose2({ inputs: { x: x2 }, backend, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, x2.shape.length);
    }
    backend_util_exports.assertAxesAreInnerMostDims("min", axes, xRank);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = util_exports.sizeFromShape(reduceShape);
    const a2D = reshape3({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
    const reduced = reduce(a2D, a2D.dtype, "min", backend);
    let res;
    if (keepDims) {
      const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
      res = reshape3({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });
    } else {
      res = reshape3({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
    }
    backend.disposeIntermediateTensorInfo(a2D);
    backend.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
      backend.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
  }
  var minConfig = {
    kernelName: Min,
    backendName: "webgl",
    kernelFunc: min2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Minimum.js
  var MINIMUM = CHECK_NAN_SNIPPET2 + `
  return min(a, b);
`;
  var MINIMUM_PACKED = `
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  var minimum3 = binaryKernelFunc2({
    opSnippet: MINIMUM,
    packedOpSnippet: MINIMUM_PACKED,
    cpuKernelImpl: minimumImplCPU
  });
  var minimumConfig = {
    kernelName: Minimum2,
    backendName: "webgl",
    kernelFunc: minimum3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_gpu.js
  var MirrorPadProgram = class {
    constructor(xShape, paddings, mode) {
      this.variableNames = ["x"];
      this.outputShape = paddings.map(
        (p2, i2) => p2[0] + xShape[i2] + p2[1]
        /* afterPad */
      );
      const rank = xShape.length;
      const dtype = getCoordsDataType(rank);
      const start = paddings.map((p2) => p2[0]).join(",");
      const end = paddings.map((p2, i2) => p2[0] + xShape[i2]).join(",");
      const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
      const offset = mode === "reflect" ? 0 : 1;
      if (rank === 1) {
        this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${offset};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${offset};
          }
          setOutput(getX(outC - start));
        }
      `;
        return;
      }
      this.userCode = `
      ${dtype} start = ${dtype}(${start});
      ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outC = getOutputCoords();
        for (int i = 0; i < ${rank}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${offset};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};
          }
        }
        ${dtype} coords = outC - start;
        setOutput(getX(${unpackedCoords}));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js
  var MirrorPadPackedProgram = class {
    constructor(xShape, paddings, mode) {
      this.variableNames = ["x"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = paddings.map(
        (p2, i2) => p2[0] + xShape[i2] + p2[1]
        /* afterPad */
      );
      const rank = xShape.length;
      const dtype = getCoordsDataType(rank);
      const start = paddings.map((p2) => p2[0]).join(",");
      const end = paddings.map((p2, i2) => p2[0] + xShape[i2]).join(",");
      const coords2 = getChannels("rc", rank);
      const source = getChannels("source", rank);
      const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
      const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
      const offset = mode === "reflect" ? 0 : 1;
      let mainLoop = "";
      if (rank === 1) {
        const padSetup = `
        ${dtype} source = rc;
        if (source < start) {
          source = start * 2 - source - ${offset};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${offset};
        }
        source -= start;
      `;
        mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
      } else {
        const padSetup = `
        ${dtype} source = rc;
        ${dtype} lt = ${dtype}(lessThan(source, start));
        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));
        ${dtype} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${offset}) +
                gte * ((end - 1) * 2 - source + ${offset});
        source -= start;
      `;
        mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
        rc = outputLoc;
        ${coords2[rank - 2]} += 1;
        if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {
          ${padSetup}
          result[2] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords2[rank - 1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[3] = getChannel(getX(${source.join()}), ${innerDims});
          }
        }
      `;
      }
      this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MirrorPad.js
  var mirrorPadKernelFunc = ({ inputs, backend, attrs }) => {
    const { x: x2 } = inputs;
    const { paddings, mode } = attrs;
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new MirrorPadPackedProgram(x2.shape, paddings, mode) : new MirrorPadProgram(x2.shape, paddings, mode);
    const output = backend.runWebGLProgram(program, [x2], x2.dtype);
    return output;
  };
  var mirrorPadConfig = {
    kernelName: MirrorPad,
    backendName: "webgl",
    kernelFunc: mirrorPadKernelFunc
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mod.js
  var MOD = `if (b == 0.0) return NAN;
  return mod(a, b);`;
  var MOD_PACKED = `
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  var mod2 = binaryKernelFunc2({
    opSnippet: MOD,
    packedOpSnippet: MOD_PACKED
  });
  var modConfig = {
    kernelName: Mod,
    backendName: "webgl",
    kernelFunc: mod2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/multinomial_gpu.js
  var MultinomialProgram = class {
    constructor(batchSize, numOutcomes, numSamples) {
      this.variableNames = ["probs"];
      this.customUniforms = [{ name: "seed", type: "float" }];
      this.outputShape = [batchSize, numSamples];
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${numOutcomes - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${numOutcomes - 1}));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RealDiv.js
  var DIV = `
if (a == b) {
  return 1.0;
};
return a / b;`;
  var DIV_PACKED = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`;
  var realDiv = binaryKernelFunc2({ opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true });
  var realDivConfig = {
    kernelName: RealDiv,
    backendName: "webgl",
    kernelFunc: realDiv
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sub.js
  var SUB = "return a - b;";
  var sub3 = binaryKernelFunc2({
    opSnippet: SUB,
    packedOpSnippet: SUB,
    supportsComplex: true,
    cpuKernelImpl: subImplCPU
  });
  var subConfig = {
    kernelName: Sub,
    backendName: "webgl",
    kernelFunc: sub3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softmax.js
  function softmax2(args) {
    const { inputs, backend, attrs } = args;
    const { logits } = inputs;
    const { dim } = attrs;
    const axes = util_exports.parseAxisParam([dim], logits.shape);
    const maxLogit = max2({
      inputs: { x: logits },
      backend,
      attrs: { reductionIndices: axes, keepDims: false }
    });
    const expandedShape = backend_util_exports.expandShapeToKeepDim(maxLogit.shape, axes);
    const maxLogitsReshaped = reshape3({ inputs: { x: maxLogit }, backend, attrs: { shape: expandedShape } });
    const a2 = sub3({ inputs: { a: logits, b: maxLogitsReshaped }, backend });
    const b2 = exp3({ inputs: { x: a2 }, backend });
    const sumExp = sum3({ inputs: { x: b2 }, backend, attrs: { axis: axes, keepDims: false } });
    const sumExpReshaped = reshape3({ inputs: { x: sumExp }, backend, attrs: { shape: expandedShape } });
    const res = realDiv({ inputs: { a: b2, b: sumExpReshaped }, backend });
    backend.disposeIntermediateTensorInfo(maxLogit);
    backend.disposeIntermediateTensorInfo(maxLogitsReshaped);
    backend.disposeIntermediateTensorInfo(a2);
    backend.disposeIntermediateTensorInfo(b2);
    backend.disposeIntermediateTensorInfo(sumExp);
    backend.disposeIntermediateTensorInfo(sumExpReshaped);
    return res;
  }
  var softmaxConfig = {
    kernelName: Softmax2,
    backendName: "webgl",
    kernelFunc: softmax2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multinomial.js
  function multinomial2(args) {
    const { inputs, backend, attrs } = args;
    const { logits } = inputs;
    const { numSamples, seed, normalized } = attrs;
    const probs = normalized ? logits : softmax2({ inputs: { logits }, backend, attrs: { dim: logits.shape.length - 1 } });
    const batchSize = probs.shape[0];
    const numOutcomes = probs.shape[1];
    const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);
    const customValues = [[seed]];
    const res = backend.runWebGLProgram(program, [probs], "int32", customValues);
    if (!normalized) {
      backend.disposeIntermediateTensorInfo(probs);
    }
    return res;
  }
  var multinomialConfig = {
    kernelName: Multinomial,
    backendName: "webgl",
    kernelFunc: multinomial2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Neg.js
  var NEG = CHECK_NAN_SNIPPET + `
  return -x;
`;
  var NEG_PACKED = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  function neg2(args) {
    const { inputs, backend } = args;
    const { x: x2 } = inputs;
    if (backend.shouldExecuteOnCPU([x2])) {
      const xData = backend.texData.get(x2.dataId);
      const [outValues, newShape] = negImplCPU(xData.values, x2.shape, x2.dtype);
      return backend.makeTensorInfo(newShape, x2.dtype, outValues);
    }
    let program;
    if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
      program = new UnaryOpPackedProgram(x2.shape, NEG_PACKED);
    } else {
      program = new UnaryOpProgram(x2.shape, NEG);
    }
    return backend.runWebGLProgram(program, [x2], x2.dtype);
  }
  var negConfig = {
    kernelName: Neg,
    backendName: "webgl",
    kernelFunc: neg2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV3.js
  var nonMaxSuppressionV3Impl2 = kernel_impls_exports.nonMaxSuppressionV3Impl;
  function nonMaxSuppressionV3(args) {
    backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs, backend, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
    const boxesVals = backend.readSync(boxes.dataId);
    const scoresVals = backend.readSync(scores.dataId);
    const { selectedIndices } = nonMaxSuppressionV3Impl2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    return backend.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
  }
  var nonMaxSuppressionV3Config = {
    kernelName: NonMaxSuppressionV3,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV4.js
  var nonMaxSuppressionV4Impl2 = kernel_impls_exports.nonMaxSuppressionV4Impl;
  function nonMaxSuppressionV4(args) {
    backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs, backend, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;
    const boxesVals = backend.readSync(boxes.dataId);
    const scoresVals = backend.readSync(scores.dataId);
    const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
    return [
      backend.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
      backend.makeTensorInfo([], "int32", new Int32Array([validOutputs]))
    ];
  }
  var nonMaxSuppressionV4Config = {
    kernelName: NonMaxSuppressionV4,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV5.js
  var nonMaxSuppressionV5Impl2 = kernel_impls_exports.nonMaxSuppressionV5Impl;
  function nonMaxSuppressionV5(args) {
    backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs, backend, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
    const boxesVals = backend.readSync(boxes.dataId);
    const scoresVals = backend.readSync(scores.dataId);
    const maxOutputSizeVal = maxOutputSize;
    const iouThresholdVal = iouThreshold;
    const scoreThresholdVal = scoreThreshold;
    const softNmsSigmaVal = softNmsSigma;
    const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl2(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
    return [
      backend.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
      backend.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
    ];
  }
  var nonMaxSuppressionV5Config = {
    kernelName: NonMaxSuppressionV5,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV5
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/onehot_gpu.js
  var OneHotProgram = class {
    constructor(numIndices, depth, onValue, offValue) {
      this.variableNames = ["indices"];
      this.outputShape = [numIndices, depth];
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${offValue}), float(${onValue}),
                      float(index == coords.y)));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OneHot.js
  var oneHot2 = (args) => {
    const { inputs, backend, attrs } = args;
    const { indices } = inputs;
    const { dtype, depth, onValue, offValue } = attrs;
    const indicesSize = util_exports.sizeFromShape(indices.shape);
    const program = new OneHotProgram(indicesSize, depth, onValue, offValue);
    const reshaped = reshape3({ inputs: { x: indices }, backend, attrs: { shape: [indicesSize] } });
    const result = backend.runWebGLProgram(program, [reshaped], dtype);
    backend.disposeIntermediateTensorInfo(reshaped);
    const outShape = [...indices.shape, depth];
    const out = reshape3({ inputs: { x: result }, backend, attrs: { shape: outShape } });
    backend.disposeIntermediateTensorInfo(result);
    return out;
  };
  var oneHotConfig = {
    kernelName: OneHot,
    backendName: "webgl",
    kernelFunc: oneHot2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ZerosLike.js
  function zerosLike2(args) {
    const { inputs, backend } = args;
    const { x: x2 } = inputs;
    if (x2.dtype === "complex64") {
      const realPart = real3({ inputs: { input: x2 }, backend });
      const r2 = zerosLike2({ inputs: { x: realPart }, backend });
      const imagPart = imag2({ inputs: { input: x2 }, backend });
      const i2 = zerosLike2({ inputs: { x: imagPart }, backend });
      const result = complex3({ inputs: { real: r2, imag: i2 }, backend });
      backend.disposeIntermediateTensorInfo(realPart);
      backend.disposeIntermediateTensorInfo(r2);
      backend.disposeIntermediateTensorInfo(imagPart);
      backend.disposeIntermediateTensorInfo(i2);
      return result;
    } else {
      return fill2({
        attrs: {
          shape: x2.shape,
          dtype: x2.dtype,
          value: x2.dtype === "string" ? "" : 0
        },
        backend
      });
    }
  }
  var zerosLikeConfig = {
    kernelName: ZerosLike,
    backendName: "webgl",
    kernelFunc: zerosLike2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OnesLike.js
  function onesLike2(args) {
    const { inputs, backend } = args;
    const { x: x2 } = inputs;
    if (x2.dtype === "string") {
      throw new Error("onesLike is not supported under string dtype");
    } else if (x2.dtype === "complex64") {
      const realPart = real3({ inputs: { input: x2 }, backend });
      const r2 = onesLike2({ inputs: { x: realPart }, backend });
      const imagPart = imag2({ inputs: { input: x2 }, backend });
      const i2 = zerosLike2({ inputs: { x: imagPart }, backend });
      const result = complex3({ inputs: { real: r2, imag: i2 }, backend });
      backend.disposeIntermediateTensorInfo(realPart);
      backend.disposeIntermediateTensorInfo(r2);
      backend.disposeIntermediateTensorInfo(imagPart);
      backend.disposeIntermediateTensorInfo(i2);
      return result;
    } else {
      return fill2({ attrs: { shape: x2.shape, dtype: x2.dtype, value: 1 }, backend });
    }
  }
  var onesLikeConfig = {
    kernelName: OnesLike,
    backendName: "webgl",
    kernelFunc: onesLike2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pack.js
  function pack(args) {
    const { inputs, backend, attrs } = args;
    const { axis } = attrs;
    if (inputs.length === 1) {
      return expandDims2({ inputs: { input: inputs[0] }, backend, attrs: { dim: axis } });
    }
    const shape = inputs[0].shape;
    const dtype = inputs[0].dtype;
    inputs.forEach((t3) => {
      util_exports.assertShapesMatch(shape, t3.shape, "All tensors passed to stack must have matching shapes");
      util_exports.assert(dtype === t3.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const intermediateTensorInfos = [];
    const expandedTensors = inputs.map((t3) => {
      const expandedT = expandDims2({ inputs: { input: t3 }, backend, attrs: { dim: axis } });
      intermediateTensorInfos.push(expandedT);
      return expandedT;
    });
    const result = concat2({ inputs: expandedTensors, backend, attrs: { axis } });
    intermediateTensorInfos.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return result;
  }
  var packConfig = {
    kernelName: Pack,
    backendName: "webgl",
    kernelFunc: pack
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js
  var PadProgram = class {
    constructor(xShape, paddings, constantValue) {
      this.variableNames = ["x"];
      this.customUniforms = [{ name: "value", type: "float" }];
      this.outputShape = paddings.map(
        (p2, i2) => p2[0] + xShape[i2] + p2[1]
        /* afterPad */
      );
      const rank = xShape.length;
      const type = getCoordsDataType(rank);
      const start = paddings.map((p2) => p2[0]).join(",");
      const end = paddings.map((p2, i2) => p2[0] + xShape[i2]).join(",");
      const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
      if (rank === 1) {
        this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
        return;
      }
      this.userCode = `
      ${type} start = ${type}(${start});
      ${type} end = ${type}(${end});

      void main() {
        ${type} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${type} coords = outC - start;
          setOutput(getX(${unpackedCoords}));
        }
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js
  var PadPackedProgram = class {
    constructor(xShape, paddings, constantValue) {
      this.variableNames = ["x"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [{ name: "value", type: "float" }];
      this.outputShape = paddings.map(
        (p2, i2) => p2[0] + xShape[i2] + p2[1]
        /* afterPad */
      );
      const rank = xShape.length;
      const dtype = getCoordsDataType(rank);
      const start = paddings.map((p2) => p2[0]).join(",");
      const end = paddings.map((p2, i2) => p2[0] + xShape[i2]).join(",");
      const coords2 = getChannels("rc", rank);
      const source = getChannels("source", rank);
      const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
      const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
      const componentSetup = [
        `${dtype} rc = outputLoc;`,
        `${coords2[rank - 1]} += 1;
       if(${cLimit}) {
      `,
        rank === 1 ? "" : `}
       rc = outputLoc;
       ${coords2[rank - 2]} += 1;
       if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {`,
        rank === 1 ? "" : `  ${coords2[rank - 1]} += 1;
         if(${cLimit}) {`
      ];
      const paddingArea = rank === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
      let mainLoop = "";
      for (let i2 = 0, j3 = rank === 1 ? 2 : 4; i2 < j3; i2++) {
        mainLoop += `
        ${componentSetup[i2]}
        if (${paddingArea}) {
          result[${i2}] = float(value);
        } else {
          ${dtype} source = rc - start;
          result[${i2}] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
      }
      mainLoop += rank === 1 ? `} ` : `}}`;
      this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/PadV2.js
  var padV2 = (args) => {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { paddings, constantValue } = attrs;
    if (util_exports.sizeFromShape(x2.shape) === 0) {
      const outputShape = paddings.map(
        (p2, i2) => p2[0] + x2.shape[i2] + p2[1]
        /* afterPad */
      );
      return fill2({
        backend,
        attrs: { shape: outputShape, value: constantValue, dtype: x2.dtype }
      });
    }
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new PadPackedProgram(x2.shape, paddings, constantValue) : new PadProgram(x2.shape, paddings, constantValue);
    const customValues = [[constantValue]];
    return backend.runWebGLProgram(program, [x2], x2.dtype, customValues);
  };
  var padV2Config = {
    kernelName: PadV2,
    backendName: "webgl",
    kernelFunc: padV2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pow.js
  var POW = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`;
  var POW_PACKED = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  var pow2 = binaryKernelFunc2({ opSnippet: POW, packedOpSnippet: POW_PACKED });
  var powConfig = {
    kernelName: Pow,
    backendName: "webgl",
    kernelFunc: pow2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prod.js
  function prod2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x2.shape.length;
    const toDispose = [];
    const origAxes = util_exports.parseAxisParam(axis, x2.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    let permutedX = x2;
    if (permutedAxes != null) {
      permutedX = transpose2({ inputs: { x: x2 }, backend, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
      toDispose.push(permutedX);
    }
    backend_util_exports.assertAxesAreInnerMostDims("prod", axes, xRank);
    let res;
    if (backend.shouldExecuteOnCPU([permutedX])) {
      const xVals = backend.texData.get(permutedX.dataId).values;
      const { outVals, outShape, outDtype } = prodImplCPU(permutedX.shape, permutedX.dtype, xVals, axes);
      res = backend.makeTensorInfo(outShape, outDtype, outVals);
    } else {
      const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
      const inSize = util_exports.sizeFromShape(reduceShape);
      const a2D = reshape3({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
      const outputDType = sumOutType(x2.dtype);
      const reduced = reduce(a2D, outputDType, "prod", backend);
      res = reshape3({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
      toDispose.push(a2D);
      toDispose.push(reduced);
    }
    if (keepDims) {
      toDispose.push(res);
      const newShape = backend_util_exports.expandShapeToKeepDim(res.shape, origAxes);
      res = reshape3({ inputs: { x: res }, backend, attrs: { shape: newShape } });
    }
    toDispose.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return res;
  }
  var prodConfig = {
    kernelName: Prod,
    backendName: "webgl",
    kernelFunc: prod2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedGather.js
  function raggedGather2(args) {
    const { inputs, backend, attrs } = args;
    const { paramsNestedSplits, paramsDenseValues, indices } = inputs;
    const { outputRaggedRank } = attrs;
    const $paramsNestedSplits = paramsNestedSplits.map((t3) => backend.readSync(t3.dataId));
    const $paramsNestedSplitsShapes = paramsNestedSplits.map((t3) => t3.shape);
    const $paramsDenseValues = backend.readSync(paramsDenseValues.dataId);
    const $indices = backend.readSync(indices.dataId);
    const [outputNestedSplits, outputDenseValues, outputDenseValuesShape] = raggedGatherImplCPU($paramsNestedSplits, $paramsNestedSplitsShapes, $paramsDenseValues, paramsDenseValues.shape, paramsDenseValues.dtype, $indices, indices.shape, outputRaggedRank);
    const outputNestedSplitsTensors = outputNestedSplits.map((splits) => backend.makeTensorInfo([splits.length], "int32", splits));
    const outputDenseValuesTensor = backend.makeTensorInfo(outputDenseValuesShape, paramsDenseValues.dtype, outputDenseValues);
    return outputNestedSplitsTensors.concat([outputDenseValuesTensor]);
  }
  var raggedGatherConfig = {
    kernelName: RaggedGather,
    backendName: "webgl",
    kernelFunc: raggedGather2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedRange.js
  function raggedRange2(args) {
    const { inputs, backend } = args;
    const { starts, limits, deltas } = inputs;
    const $starts = backend.readSync(starts.dataId);
    const $limits = backend.readSync(limits.dataId);
    const $deltas = backend.readSync(deltas.dataId);
    const [rtNestedSplitsData, rtDenseValuesData] = raggedRangeImplCPU($starts, starts.shape, starts.dtype, $limits, limits.shape, $deltas, deltas.shape);
    const rtNestedSplits = backend.makeTensorInfo([rtNestedSplitsData.length], "int32", rtNestedSplitsData);
    const rtDenseValues = backend.makeTensorInfo([rtDenseValuesData.length], starts.dtype, rtDenseValuesData);
    return [rtNestedSplits, rtDenseValues];
  }
  var raggedRangeConfig = {
    kernelName: RaggedRange,
    backendName: "webgl",
    kernelFunc: raggedRange2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedTensorToTensor.js
  function raggedTensorToTensor2(args) {
    const { inputs, backend, attrs } = args;
    const { shape, values, defaultValue, rowPartitionTensors } = inputs;
    const { rowPartitionTypes } = attrs;
    const $shape = backend.readSync(shape.dataId);
    const $values = backend.readSync(values.dataId);
    const $defaultValue = backend.readSync(defaultValue.dataId);
    const $rowPartitionValues = rowPartitionTensors.map((t3) => backend.readSync(t3.dataId));
    const rowPartitionValuesShapes = rowPartitionTensors.map((t3) => t3.shape);
    const [outputShape, output] = raggedTensorToTensorImplCPU($shape, shape.shape, $values, values.shape, values.dtype, $defaultValue, defaultValue.shape, $rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes);
    return backend.makeTensorInfo(outputShape, values.dtype, output);
  }
  var raggedTensorToTensorConfig = {
    kernelName: RaggedTensorToTensor,
    backendName: "webgl",
    kernelFunc: raggedTensorToTensor2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Range.js
  var range3 = (args) => {
    const { backend, attrs } = args;
    const { start, stop, step: step3, dtype } = attrs;
    const values = rangeImplCPU(start, stop, step3, dtype);
    return backend.makeTensorInfo([values.length], dtype, values);
  };
  var rangeConfig = {
    kernelName: Range,
    backendName: "webgl",
    kernelFunc: range3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reciprocal.js
  var RECIPROCAL = `return 1.0 / x;`;
  var reciprocal2 = unaryKernelFunc2({ opSnippet: RECIPROCAL });
  var reciprocalConfig = {
    kernelName: Reciprocal,
    backendName: "webgl",
    kernelFunc: reciprocal2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu.js
  var RELU3 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : x;
`;
  var RELU_PACKED = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var relu2 = unaryKernelFunc2({ opSnippet: RELU3, packedOpSnippet: RELU_PACKED });
  var reluConfig = {
    kernelName: Relu2,
    backendName: "webgl",
    kernelFunc: relu2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu6.js
  var RELU63 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  var RELU6_PACKED = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var relu62 = unaryKernelFunc2({ opSnippet: RELU63, packedOpSnippet: RELU6_PACKED });
  var relu6Config = {
    kernelName: Relu62,
    backendName: "webgl",
    kernelFunc: relu62
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_gpu.js
  var ResizeBilinearProgram = class {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)`;
      } else {
        sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js
  var ResizeBilinearPackedProgram = class {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)`;
      } else {
        sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinear.js
  function resizeBilinear2(args) {
    const { inputs, backend, attrs } = args;
    const { images } = inputs;
    const { alignCorners, halfPixelCenters, size } = attrs;
    const [newHeight, newWidth] = size;
    const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeBilinearPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeBilinearProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
    return backend.runWebGLProgram(program, [images], "float32");
  }
  var resizeBilinearConfig = {
    kernelName: ResizeBilinear,
    backendName: "webgl",
    kernelFunc: resizeBilinear2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js
  var ResizeBilinearBackpropProgram = class {
    constructor(dyShape, inputShape, alignCorners) {
      this.variableNames = ["dy"];
      this.outputShape = [];
      this.outputShape = inputShape;
      const [, xHeight, xWidth] = inputShape;
      const [, yHeight, yWidth] = dyShape;
      const effectiveXSize = [
        alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
        alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
      ];
      const effectiveYSize = [
        alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
        alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
      ];
      const heightScale = effectiveXSize[0] / effectiveYSize[0];
      const widthScale = effectiveXSize[1] / effectiveYSize[1];
      const invHeightScale = 1 / heightScale;
      const invWidthScale = 1 / widthScale;
      const winHeight = Math.ceil(invHeightScale) * 2 + 2;
      const winWidth = Math.ceil(invWidthScale) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinearGrad.js
  function resizeBilinearGrad(args) {
    const { inputs, backend, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    const program = new ResizeBilinearBackpropProgram(dy.shape, images.shape, alignCorners);
    return backend.runWebGLProgram(program, [dy], dy.dtype);
  }
  var resizeBilinearGradConfig = {
    kernelName: ResizeBilinearGrad,
    backendName: "webgl",
    kernelFunc: resizeBilinearGrad
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js
  var ResizeNearestNeighborProgram = class {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      const roundBase = alignCorners ? "0.5" : "0.0";
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))`;
      } else {
        sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_packed_gpu.js
  var ResizeNearestNeighborPackedProgram = class {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      const roundBase = alignCorners ? "0.5" : "0.0";
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))`;
      } else {
        sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighbor.js
  function resizeNearestNeighbor2(args) {
    const { inputs, backend, attrs } = args;
    const { images } = inputs;
    const { alignCorners, halfPixelCenters, size } = attrs;
    const [newHeight, newWidth] = size;
    const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeNearestNeighborPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeNearestNeighborProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
    return backend.runWebGLProgram(program, [images], images.dtype);
  }
  var resizeNearestNeighborConfig = {
    kernelName: ResizeNearestNeighbor,
    backendName: "webgl",
    kernelFunc: resizeNearestNeighbor2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js
  var ResizeNearestNeigborBackpropProgram = class {
    constructor(dyShape, inputShape, alignCorners) {
      this.variableNames = ["dy"];
      this.outputShape = [];
      this.outputShape = inputShape;
      const [, xHeight, xWidth] = inputShape;
      const [, yHeight, yWidth] = dyShape;
      const effectiveXSize = [
        alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
        alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
      ];
      const effectiveYSize = [
        alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
        alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
      ];
      const heightScale = effectiveXSize[0] / effectiveYSize[0];
      const widthScale = effectiveXSize[1] / effectiveYSize[1];
      const invHeightScale = 1 / heightScale;
      const invWidthScale = 1 / widthScale;
      const winHeight = Math.ceil(invHeightScale) * 2 + 2;
      const winWidth = Math.ceil(invWidthScale) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float sourceFracRow =
              float(${effectiveXSize[0]}) *
                (float(dyR) / float(${effectiveYSize[0]}));

            float sourceFracCol =
                float(${effectiveXSize[1]}) *
                  (float(dyC) / float(${effectiveYSize[1]}));

            int sourceNearestRow = int(min(
                float(int(${xHeight}) - 1),
                ${alignCorners} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${xWidth}) - 1),
                ${alignCorners} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighborGrad.js
  function resizeNearestNeighborGrad(args) {
    const { inputs, backend, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    const program = new ResizeNearestNeigborBackpropProgram(dy.shape, images.shape, alignCorners);
    return backend.runWebGLProgram(program, [dy], dy.dtype);
  }
  var resizeNearestNeighborGradConfig = {
    kernelName: ResizeNearestNeighborGrad,
    backendName: "webgl",
    kernelFunc: resizeNearestNeighborGrad
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_gpu.js
  var ReverseProgram = class {
    constructor(xShape, axis) {
      this.variableNames = ["x"];
      const rank = xShape.length;
      if (rank > 4) {
        throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
      }
      this.outputShape = xShape;
      if (rank === 1) {
        this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${xShape[0]} - coord - 1));
        }
      `;
        return;
      }
      const getInCoord = (i2) => {
        if (axis.indexOf(i2) !== -1 && xShape[i2] !== 1) {
          return `${xShape[i2]} - coords[${i2}] - 1`;
        }
        return `coords[${i2}]`;
      };
      const inCoords = xShape.map((_3, i2) => getInCoord(i2)).join(",");
      const type = getCoordsDataType(rank);
      this.userCode = `
      void main() {
        ${type} coords = getOutputCoords();
        setOutput(getX(${inCoords}));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_packed_gpu.js
  var ReversePackedProgram = class {
    constructor(xShape, axis) {
      this.variableNames = ["x"];
      this.packedInputs = true;
      this.packedOutput = true;
      const rank = xShape.length;
      if (rank > 4) {
        throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
      }
      this.outputShape = xShape;
      const channels = getChannels("rc", rank);
      const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;
      const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;
      const type = getCoordsDataType(rank);
      if (rank === 1) {
        this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${xShape[0]} - rc - 1),
            ${xShape[0]} - rc - 1);
          if(${nextColumn}){
              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),
                ${xShape[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `;
      } else {
        this.userCode = `
        void main() {
          ${type} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getR(channels.slice())};
          if(${nextColumn}){
            result.g = ${getG(channels.slice())};
          }
          if(${nextRow}) {
            result.b = ${getB(channels.slice())};
            if(${nextColumn}) {
              result.a = ${getA(channels.slice())};
            }
          }
          setOutput(result);
        }
    `;
      }
      function getR(channels2) {
        return getChannel(channels2);
      }
      function getG(channels2) {
        channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
        return getChannel(channels2);
      }
      function getB(channels2) {
        channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
        return getChannel(channels2);
      }
      function getA(channels2) {
        channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
        channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
        return getChannel(channels2);
      }
      function getChannel(channels2) {
        const inCoordsArray = xShape.map((_3, i2) => getInCoord(i2, channels2));
        const inCoords = inCoordsArray.join(",");
        const innerDims = inCoordsArray.slice(-2).join(",");
        return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;
      }
      function getInCoord(i2, channels1) {
        if (axis.indexOf(i2) !== -1 && xShape[i2] !== 1) {
          return `${xShape[i2]} - ${channels1[i2]} - 1`;
        } else {
          return `${channels1[i2]}`;
        }
      }
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reverse.js
  function reverse2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { dims } = attrs;
    const xRank = x2.shape.length;
    const $dims = util_exports.parseAxisParam(dims, x2.shape);
    if (xRank === 0) {
      return identity3({ inputs: { x: x2 }, backend });
    }
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ReversePackedProgram(x2.shape, $dims) : new ReverseProgram(x2.shape, $dims);
    return backend.runWebGLProgram(program, [x2], x2.dtype);
  }
  var reverseConfig = {
    kernelName: Reverse,
    backendName: "webgl",
    kernelFunc: reverse2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/rotate_gpu.js
  var RotateProgram = class {
    constructor(imageShape, fillValue) {
      this.variableNames = ["Image"];
      this.outputShape = [];
      this.customUniforms = [{ name: "params", type: "vec4" }];
      const imageHeight = imageShape[1];
      const imageWidth = imageShape[2];
      this.outputShape = imageShape;
      let fillSnippet = "";
      if (typeof fillValue === "number") {
        fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;
      } else {
        fillSnippet = `
        vec3 fill = vec3(${fillValue.join(",")});
        float outputValue = fill[coords[3]];`;
      }
      this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${fillSnippet}
          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RotateWithOffset.js
  var rotateWithOffsetConfig = {
    kernelName: RotateWithOffset,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend }) => {
      const { image: image2 } = inputs;
      const { radians, fillValue, center } = attrs;
      const webglBackend = backend;
      const program = new RotateProgram(image2.shape, fillValue);
      const [centerX, centerY] = backend_util_exports.getImageCenter(center, image2.shape[1], image2.shape[2]);
      const customValues = [[centerX, centerY, Math.sin(radians), Math.cos(radians)]];
      const output = webglBackend.runWebGLProgram(program, [image2], image2.dtype, customValues);
      return output;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Round.js
  var ROUND = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`;
  var round3 = unaryKernelFunc2({ opSnippet: ROUND });
  var roundConfig = {
    kernelName: Round,
    backendName: "webgl",
    kernelFunc: round3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Rsqrt.js
  var RSQRT = `return inversesqrt(x);`;
  var rsqrt3 = unaryKernelFunc2({ opSnippet: RSQRT, cpuKernelImpl: rsqrtImplCPU });
  var rsqrtConfig = {
    kernelName: Rsqrt,
    backendName: "webgl",
    kernelFunc: rsqrt3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js
  var ScatterProgram = class {
    constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true) {
      this.variableNames = ["updates", "indices", "defaultValue"];
      this.outputShape = shape;
      const stridesType = getCoordsDataType(strides.length);
      const dtype = getCoordsDataType(shape.length);
      let indicesString = "";
      if (indicesRank === 1) {
        indicesString = "i";
      } else if (indicesRank === 2) {
        indicesString = "i, j";
      }
      const indicesSnippet = `getIndices(${indicesString})`;
      let updatesString = "";
      if (updatesRank === 1) {
        updatesString = "i";
      } else if (updatesRank === 2) {
        updatesString = "i, coords[1]";
      }
      const updatesSnippet = `getUpdates(${updatesString})`;
      const strideString = sliceDim > 1 ? "strides[j]" : "strides";
      this.userCode = `
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${updateSize}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${sliceDim}; j++) {
              int index = round(${indicesSnippet});
              flattenedIndex += index * ${strideString};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${updatesSnippet};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ScatterNd.js
  function scatterNd(args) {
    const { inputs, backend, attrs } = args;
    const { indices, updates } = inputs;
    const { shape } = attrs;
    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util_exports.calculateShapes(updates, indices, shape);
    const flattenShape = [outputSize / sliceSize, sliceSize];
    if (outputSize === 0) {
      return backend.makeTensorInfo(shape, indices.dtype);
    }
    const flattenIndices = reshape3({ inputs: { x: indices }, backend, attrs: { shape: [numUpdates, sliceRank] } });
    const flattenX = reshape3({ inputs: { x: updates }, backend, attrs: { shape: [numUpdates, sliceSize] } });
    const defaultValue = backend.makeTensorInfo([], "float32", new Float32Array([0]));
    const program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
    const res = backend.runWebGLProgram(program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);
    const reshaped = reshape3({ inputs: { x: res }, backend, attrs: { shape } });
    backend.disposeIntermediateTensorInfo(flattenIndices);
    backend.disposeIntermediateTensorInfo(flattenX);
    backend.disposeIntermediateTensorInfo(res);
    backend.disposeIntermediateTensorInfo(defaultValue);
    return reshaped;
  }
  var scatterNdConfig = {
    kernelName: ScatterNd,
    backendName: "webgl",
    kernelFunc: scatterNd
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/search_sorted_gpu.js
  var SearchSortedProgram = class {
    constructor(batchSize, numInputs, numValues, side) {
      this.variableNames = ["sortedSequence", "values"];
      this.customUniforms = [{ name: "numInputs", type: "int" }];
      this.outputShape = [batchSize, numValues];
      const webGL2LoopHead = "while (left < right) {";
      const webGL1LoopHead = `for (int i = 0; i < ${Math.ceil(Math.log2(numInputs + 1))}; ++i) { if (left >= right) break;`;
      const loopHead = env().getNumber("WEBGL_VERSION") === 2 ? webGL2LoopHead : webGL1LoopHead;
      const boundComparator = side === "left" ? "<" : "<=";
      this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${loopHead}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${boundComparator} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SearchSorted.js
  function searchSorted2(args) {
    const { inputs, backend, attrs } = args;
    const { sortedSequence, values } = inputs;
    const { side } = attrs;
    const program = new SearchSortedProgram(sortedSequence.shape[0], sortedSequence.shape[1], values.shape[1], side);
    const customValues = [[sortedSequence.shape[1]]];
    return backend.runWebGLProgram(program, [sortedSequence, values], "int32", customValues);
  }
  var searchSortedConfig = {
    kernelName: SearchSorted,
    backendName: "webgl",
    kernelFunc: searchSorted2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/select_gpu.js
  var SelectProgram = class {
    constructor(cRank, shape, rank) {
      this.variableNames = ["c", "a", "b"];
      this.outputShape = shape;
      let cCoords;
      let abCoords;
      if (rank > 4) {
        throw Error(`Where for rank ${rank} is not yet supported`);
      }
      if (rank === 1) {
        abCoords = `resRC`;
        cCoords = `resRC`;
      } else {
        const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
        const cCoordVars = [];
        const abCoordVars = [];
        for (let i2 = 0; i2 < shape.length; i2++) {
          abCoordVars.push(`${currentCoords[i2]}`);
          if (i2 < cRank) {
            cCoordVars.push(`${currentCoords[i2]}`);
          }
        }
        cCoords = cCoordVars.join();
        abCoords = abCoordVars.join();
      }
      const dtype = getCoordsDataType(rank);
      this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        float cVal = getC(${cCoords});
        if (cVal >= 1.0) {
          setOutput(getA(${abCoords}));
        } else {
          setOutput(getB(${abCoords}));
        }
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Select.js
  function select2(args) {
    const { inputs, backend } = args;
    const { condition, t: t3, e: e2 } = inputs;
    const program = new SelectProgram(condition.shape.length, t3.shape, t3.shape.length);
    return backend.runWebGLProgram(program, [condition, t3, e2], upcastType(t3.dtype, e2.dtype));
  }
  var selectConfig = {
    kernelName: Select,
    backendName: "webgl",
    kernelFunc: select2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Selu.js
  var SELU = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${backend_util_exports.SELU_SCALEALPHA};
  float scale = ${backend_util_exports.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
  var selu2 = unaryKernelFunc2({ opSnippet: SELU });
  var seluConfig = {
    kernelName: Selu2,
    backendName: "webgl",
    kernelFunc: selu2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sigmoid.js
  var SIGMOID3 = CHECK_NAN_SNIPPET_UNARY + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`;
  var SIGMOID_PACKED = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var sigmoid3 = unaryKernelFunc2({
    opSnippet: SIGMOID3,
    packedOpSnippet: SIGMOID_PACKED,
    cpuKernelImpl: sigmoidImplCPU
  });
  var sigmoidConfig = {
    kernelName: Sigmoid2,
    backendName: "webgl",
    kernelFunc: sigmoid3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sign.js
  var SIGN = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`;
  var sign2 = unaryKernelFunc2({ opSnippet: SIGN });
  var signConfig = {
    kernelName: Sign,
    backendName: "webgl",
    kernelFunc: sign2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sin.js
  var SIN = CHECK_NAN_SNIPPET_UNARY + `
  return sin(x);
`;
  var sin2 = unaryKernelFunc2({ opSnippet: SIN });
  var sinConfig = {
    kernelName: Sin,
    backendName: "webgl",
    kernelFunc: sin2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sinh.js
  var SINH = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`;
  var sinh2 = unaryKernelFunc2({ opSnippet: SINH });
  var sinhConfig = {
    kernelName: Sinh,
    backendName: "webgl",
    kernelFunc: sinh2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softplus.js
  var SOFTPLUS = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`;
  var softplus2 = unaryKernelFunc2({ opSnippet: SOFTPLUS });
  var softplusConfig = {
    kernelName: Softplus2,
    backendName: "webgl",
    kernelFunc: softplus2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SpaceToBatchND.js
  var spaceToBatchND2 = (args) => {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { blockShape, paddings } = attrs;
    util_exports.assert(x2.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
    const prod3 = blockShape.reduce((a2, b2) => a2 * b2);
    const completePaddings = [[0, 0]];
    completePaddings.push(...paddings);
    for (let i2 = 1 + blockShape.length; i2 < x2.shape.length; ++i2) {
      completePaddings.push([0, 0]);
    }
    const toDispose = [];
    const paddedX = padV2({
      inputs: { x: x2 },
      backend,
      attrs: { paddings: completePaddings, constantValue: 0 }
    });
    const reshapedPaddedShape = backend_util_exports.getReshaped(paddedX.shape, blockShape, prod3, false);
    const permutedReshapedPaddedPermutation = backend_util_exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
    const flattenShape = backend_util_exports.getReshapedPermuted(paddedX.shape, blockShape, prod3, false);
    const reshapedPaddedX = reshape3({ inputs: { x: paddedX }, backend, attrs: { shape: reshapedPaddedShape } });
    const paddedXT = transpose2({
      inputs: { x: reshapedPaddedX },
      backend,
      attrs: { perm: permutedReshapedPaddedPermutation }
    });
    const result = reshape3({ inputs: { x: paddedXT }, backend, attrs: { shape: flattenShape } });
    toDispose.push(paddedX);
    toDispose.push(reshapedPaddedX);
    toDispose.push(paddedXT);
    toDispose.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return result;
  };
  var spaceToBatchNDConfig = {
    kernelName: SpaceToBatchND,
    backendName: "webgl",
    kernelFunc: spaceToBatchND2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseFillEmptyRows.js
  function sparseFillEmptyRows2(args) {
    const { inputs, backend } = args;
    const { indices, values, denseShape, defaultValue } = inputs;
    if (denseShape.shape.length !== 1) {
      throw new Error(`Dense shape must be a vector, saw:
         ${denseShape.shape}`);
    }
    if (indices.shape.length !== 2) {
      throw new Error(`Indices must be a matrix, saw:
         ${indices.shape}`);
    }
    if (values.shape.length !== 1) {
      throw new Error(`Values must be a vector, saw:
         ${values.shape}`);
    }
    if (defaultValue.shape.length !== 0) {
      throw new Error(`Default value must be a scalar, saw:
        ${defaultValue.shape}`);
    }
    const $indices = backend.readSync(indices.dataId);
    const $values = backend.readSync(values.dataId);
    const $denseShape = backend.readSync(denseShape.dataId);
    const $defaultValue = backend.readSync(defaultValue.dataId)[0];
    const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImplCPU($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);
    return [
      backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
      backend.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues),
      backend.makeTensorInfo([emptyRowIndicator.length], "bool", new Uint8Array(emptyRowIndicator.map((value) => Number(value)))),
      backend.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))
    ];
  }
  var sparseFillEmptyRowsConfig = {
    kernelName: SparseFillEmptyRows,
    backendName: "webgl",
    kernelFunc: sparseFillEmptyRows2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseReshape.js
  function sparseReshape2(args) {
    const { inputs, backend } = args;
    const { inputIndices, inputShape, newShape } = inputs;
    if (inputIndices.shape.length !== 2) {
      throw new Error(`Input indices should be a matrix but received shape ${inputIndices.shape}`);
    }
    if (inputShape.shape.length !== 1) {
      throw new Error(`Input shape should be a vector but received shape ${inputShape.shape}`);
    }
    if (newShape.shape.length !== 1) {
      throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
    }
    const $inputShape = Array.from(backend.readSync(inputShape.dataId));
    const $inputIndices = backend.readSync(inputIndices.dataId);
    const targetShape = Array.from(backend.readSync(newShape.dataId));
    const [newIndices, indicesShape, outputShape] = sparseReshapeImplCPU($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
    return [
      backend.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
      backend.makeTensorInfo([outputShape.length], newShape.dtype, new Int32Array(outputShape))
    ];
  }
  var sparseReshapeConfig = {
    kernelName: SparseReshape,
    backendName: "webgl",
    kernelFunc: sparseReshape2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseSegmentMean.js
  function sparseSegmentMean2(args) {
    const { inputs, backend } = args;
    const { data, indices, segmentIds } = inputs;
    if (data.shape.length < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if (indices.shape.length !== 1) {
      throw new Error(`Indices should be a vector but received shape
              ${indices.shape}`);
    }
    if (segmentIds.shape.length !== 1) {
      throw new Error(`Segment ids should be a vector but received shape
              ${segmentIds.shape}`);
    }
    const $data = backend.readSync(data.dataId);
    const $indices = backend.readSync(indices.dataId);
    const $segmentIds = backend.readSync(segmentIds.dataId);
    const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds, true);
    return backend.makeTensorInfo(outputDataShape, data.dtype, outputData);
  }
  var sparseSegmentMeanConfig = {
    kernelName: SparseSegmentMean,
    backendName: "webgl",
    kernelFunc: sparseSegmentMean2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseSegmentSum.js
  function sparseSegmentSum2(args) {
    const { inputs, backend } = args;
    const { data, indices, segmentIds } = inputs;
    if (data.shape.length < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if (indices.shape.length !== 1) {
      throw new Error(`Indices should be a vector but received shape
             ${indices.shape}`);
    }
    if (segmentIds.shape.length !== 1) {
      throw new Error(`Segment ids should be a vector but received shape
             ${segmentIds.shape}`);
    }
    const $data = backend.readSync(data.dataId);
    const $indices = backend.readSync(indices.dataId);
    const $segmentIds = backend.readSync(segmentIds.dataId);
    const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds);
    return backend.makeTensorInfo(outputDataShape, data.dtype, outputData);
  }
  var sparseSegmentSumConfig = {
    kernelName: SparseSegmentSum,
    backendName: "webgl",
    kernelFunc: sparseSegmentSum2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseToDense.js
  function sparseToDense2(args) {
    const { inputs, backend, attrs } = args;
    const { sparseIndices, sparseValues, defaultValue } = inputs;
    const { outputShape } = attrs;
    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util_exports.calculateShapes(sparseValues, sparseIndices, outputShape);
    const sumDupeIndices = false;
    if (sparseValues.dtype === "string") {
      const indicesBuf = backend.bufferSync(sparseIndices);
      const updatesBuf = backend.bufferSync(sparseValues);
      const $defaultValue = util_exports.decodeString(backend.readSync(defaultValue.dataId)[0]);
      const outBuf = scatterImplCPU(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);
      return backend.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);
    }
    const program = new ScatterProgram(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [outputSize, 1], sumDupeIndices);
    const res = backend.runWebGLProgram(program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);
    const reshaped = reshape3({ inputs: { x: res }, backend, attrs: { shape: outputShape } });
    backend.disposeIntermediateTensorInfo(res);
    return reshaped;
  }
  var sparseToDenseConfig = {
    kernelName: SparseToDense,
    backendName: "webgl",
    kernelFunc: sparseToDense2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SplitV.js
  function splitV(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { numOrSizeSplits, axis } = attrs;
    const $axis = util_exports.parseAxisParam(axis, x2.shape)[0];
    const splitSizes = backend_util_exports.prepareSplitSize(x2, numOrSizeSplits, $axis);
    const xRank = x2.shape.length;
    const begin = new Array(xRank).fill(0);
    const size = x2.shape.slice();
    return splitSizes.map((s2) => {
      const sliceSize = [...size];
      sliceSize[$axis] = s2;
      const sliceT = slice2({ inputs: { x: x2 }, backend, attrs: { begin, size: sliceSize } });
      begin[$axis] += s2;
      return sliceT;
    });
  }
  var splitVConfig = {
    kernelName: SplitV,
    backendName: "webgl",
    kernelFunc: splitV
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sqrt.js
  var SQRT = `return sqrt(x);`;
  var sqrt3 = unaryKernelFunc2({ opSnippet: SQRT, packedOpSnippet: SQRT, cpuKernelImpl: sqrtImplCPU });
  var sqrtConfig = {
    kernelName: Sqrt,
    backendName: "webgl",
    kernelFunc: sqrt3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Square.js
  var SQUARE = `return x * x;`;
  var square3 = unaryKernelFunc2({ opSnippet: SQUARE });
  var squareConfig = {
    kernelName: Square,
    backendName: "webgl",
    kernelFunc: square3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SquaredDifference.js
  var SQUARED_DIFFERENCE = "return (a - b) * (a - b);";
  var squaredDifference3 = binaryKernelFunc2({ opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE });
  var squaredDifferenceConfig = {
    kernelName: SquaredDifference,
    backendName: "webgl",
    kernelFunc: squaredDifference3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Step.js
  function step2({ inputs, attrs, backend }) {
    const { x: x2 } = inputs;
    const opSnippet = CHECK_NAN_SNIPPET + `
    return x > 0.0 ? 1.0 : float(${attrs.alpha});
  `;
    const program = new UnaryOpProgram(x2.shape, opSnippet);
    return backend.runWebGLProgram(program, [x2], x2.dtype);
  }
  var stepConfig = {
    kernelName: Step,
    backendName: "webgl",
    kernelFunc: step2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/strided_slice_gpu.js
  var StridedSliceProgram = class {
    constructor(begin, strides, size) {
      this.variableNames = ["x"];
      this.outputShape = size;
      const rank = size.length;
      const inputDtype = getCoordsDataType(size.length);
      const dtype = getCoordsDataType(size.length);
      let newCoords = "";
      if (rank === 1) {
        newCoords = "coords * strides + begin";
      } else {
        let outputAxis = 0;
        newCoords = size.map((_3, i2) => {
          outputAxis++;
          return size.length === 1 ? `coords * strides[${i2}] + begin[${i2}]` : `coords[${outputAxis - 1}] * strides[${i2}] + begin[${i2}]`;
        }).join(",");
      }
      this.userCode = `
      ${inputDtype} begin = ${inputDtype}(${begin});
      ${inputDtype} strides = ${inputDtype}(${strides});

      void main() {
        ${dtype} coords = getOutputCoords();
        setOutput(getX(${newCoords}));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StridedSlice.js
  function stridedSlice2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
    const { finalShapeSparse, finalShape, isIdentity, sliceDim0, isSimpleSlice, begin: $begin, end: $end, strides: $strides } = slice_util_exports.sliceInfo(x2.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
    let result;
    if (isIdentity) {
      result = reshape3({ inputs: { x: x2 }, backend, attrs: { shape: finalShape } });
    } else if (sliceDim0 || isSimpleSlice) {
      util_exports.assert(x2.shape.length >= 1, () => `Input must have rank at least 1, got: ${x2.shape.length}`);
      const size = slice_util_exports.computeOutShape($begin, $end, $strides);
      const sliced = slice2({ inputs: { x: x2 }, backend, attrs: { begin: $begin, size } });
      result = reshape3({ inputs: { x: sliced }, backend, attrs: { shape: finalShape } });
      backend.disposeIntermediateTensorInfo(sliced);
    } else {
      const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([x2]);
      if (shouldExecuteOnCPU) {
        const values = backend.readSync(x2.dataId);
        const xBuf = buffer(x2.shape, x2.dtype, values);
        const resultValues = stridedSliceImplCPU(finalShapeSparse, xBuf, $strides, $begin);
        result = backend.makeTensorInfo(finalShape, x2.dtype, resultValues.values);
      } else {
        const program = new StridedSliceProgram($begin, $strides, finalShapeSparse);
        result = backend.runWebGLProgram(program, [x2], x2.dtype);
      }
    }
    const resultReshaped = reshape3({ inputs: { x: result }, backend, attrs: { shape: finalShape } });
    backend.disposeIntermediateTensorInfo(result);
    return resultReshaped;
  }
  var stridedSliceConfig = {
    kernelName: StridedSlice,
    backendName: "webgl",
    kernelFunc: stridedSlice2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StringNGrams.js
  function stringNGrams2(args) {
    const { inputs, backend, attrs } = args;
    const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
    const { data, dataSplits } = inputs;
    const $data = backend.readSync(data.dataId);
    const $dataSplits = backend.readSync(dataSplits.dataId);
    const [nGrams, nGramsSplits] = stringNGramsImplCPU($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
    return [
      backend.makeTensorInfo([nGrams.length], "string", nGrams),
      backend.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
    ];
  }
  var stringNGramsConfig = {
    kernelName: StringNGrams,
    backendName: "webgl",
    kernelFunc: stringNGrams2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StringSplit.js
  function stringSplit2(args) {
    const { inputs, backend, attrs } = args;
    const { skipEmpty } = attrs;
    const { input: input2, delimiter } = inputs;
    if (input2.dtype !== "string") {
      throw new Error("Input must be of datatype string");
    }
    if (input2.shape.length !== 1) {
      throw new Error(`Input must be a vector, got shape: ${input2.shape}`);
    }
    if (delimiter.shape.length !== 0) {
      throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
    }
    const $input = backend.readSync(input2.dataId);
    const $delimiter = backend.readSync(delimiter.dataId)[0];
    const [indices, values, shape] = stringSplitImplCPU($input, $delimiter, skipEmpty);
    const outputSize = values.length;
    return [
      backend.makeTensorInfo([outputSize, 2], "int32", indices),
      backend.makeTensorInfo([outputSize], "string", values),
      backend.makeTensorInfo([2], "int32", new Int32Array(shape))
    ];
  }
  var stringSplitConfig = {
    kernelName: StringSplit,
    backendName: "webgl",
    kernelFunc: stringSplit2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StringToHashBucketFast.js
  function stringToHashBucketFast2(args) {
    const { inputs, backend, attrs } = args;
    const { numBuckets } = attrs;
    const { input: input2 } = inputs;
    if (input2.dtype !== "string") {
      throw new Error("Input must be of datatype string");
    }
    if (numBuckets <= 0) {
      throw new Error(`Number of buckets must be at least 1`);
    }
    const $input = backend.readSync(input2.dataId);
    const output = stringToHashBucketFastImplCPU($input, numBuckets);
    return backend.makeTensorInfo(input2.shape, "int32", output);
  }
  var stringToHashBucketFastConfig = {
    kernelName: StringToHashBucketFast,
    backendName: "webgl",
    kernelFunc: stringToHashBucketFast2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tan.js
  var TAN = `return tan(x);`;
  var tan2 = unaryKernelFunc2({ opSnippet: TAN });
  var tanConfig = {
    kernelName: Tan,
    backendName: "webgl",
    kernelFunc: tan2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tanh.js
  var TANH = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`;
  var tanh3 = unaryKernelFunc2({ opSnippet: TANH });
  var tanhConfig = {
    kernelName: Tanh2,
    backendName: "webgl",
    kernelFunc: tanh3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/tile_gpu.js
  var TileProgram = class {
    constructor(aShape, reps) {
      this.variableNames = ["A"];
      const outputShape = new Array(aShape.length);
      for (let i2 = 0; i2 < outputShape.length; i2++) {
        outputShape[i2] = aShape[i2] * reps[i2];
      }
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      const dtype = getCoordsDataType(this.rank);
      const sourceCoords = getSourceCoords3(aShape);
      this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
    }
  };
  function getSourceCoords3(aShape) {
    const rank = aShape.length;
    if (rank > 5) {
      throw Error(`Tile for rank ${rank} is not yet supported`);
    }
    if (rank === 1) {
      return `imod(resRC, ${aShape[0]})`;
    }
    const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"];
    const sourceCoords = [];
    for (let i2 = 0; i2 < aShape.length; i2++) {
      sourceCoords.push(`imod(${currentCoords[i2]}, ${aShape[i2]})`);
    }
    return sourceCoords.join();
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tile.js
  function tile2(params) {
    const { inputs, backend, attrs } = params;
    const { x: x2 } = inputs;
    const { reps } = attrs;
    if (x2.dtype === "string" || x2.shape.length > 5) {
      const data = backend.readSync(x2.dataId);
      const value = x2.dtype === "string" ? data.map((d2) => util_exports.decodeString(d2)) : data;
      const buf = buffer(x2.shape, x2.dtype, value);
      const outBuf = tileImplCPU(buf, reps);
      return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
    }
    const program = new TileProgram(x2.shape, reps);
    const output = backend.runWebGLProgram(program, [x2], x2.dtype);
    return output;
  }
  var tileConfig = {
    kernelName: Tile,
    backendName: "webgl",
    kernelFunc: tile2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/top_k_gpu.js
  var SwapProgram = class {
    /**
     * @param shape desired output shape (can be larger than input shape, output
     *                                    will be padded with -Infinity)
     */
    constructor(shape) {
      this.variableNames = ["x", "indices"];
      this.customUniforms = [
        { name: "n", type: "int" },
        { name: "firstPass", type: "int" },
        { name: "negativeInf", type: "float" },
        { name: "dir", type: "int" },
        { name: "inc", type: "int" }
      ];
      this.outputShape = shape;
      this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
    }
  };
  var MergeProgram = class {
    /**
     * @param shape desired output shape (must be half of the input size)
     */
    constructor(shape) {
      this.variableNames = ["x", "indices"];
      this.customUniforms = [
        { name: "n", type: "int" },
        { name: "firstPass", type: "int" },
        { name: "k", type: "int" }
      ];
      this.outputShape = shape;
      this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/TopK.js
  function disposeIntermediateTensorInfoOrNull(backend, tensorInfo) {
    if (tensorInfo !== null) {
      backend.disposeIntermediateTensorInfo(tensorInfo);
    }
  }
  function roundUpToPow2(num) {
    let pow22 = 1;
    while (pow22 < num) {
      pow22 *= 2;
    }
    return pow22;
  }
  function topK(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2 } = inputs;
    const { k: k4, sorted } = attrs;
    const TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD");
    const TOPK_K_CPU_HANDOFF_THRESHOLD = env().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD");
    const xShape = x2.shape;
    const lastDim = xShape[xShape.length - 1];
    if (backend.shouldExecuteOnCPU([x2]) || lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD || k4 > TOPK_K_CPU_HANDOFF_THRESHOLD) {
      const xVals = backend.readSync(x2.dataId);
      const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, xShape, x2.dtype, k4, sorted);
      return [
        backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
        backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
      ];
    }
    if (k4 === 0) {
      xShape[xShape.length - 1] = 0;
      return [
        backend.makeTensorInfo(xShape, x2.dtype, []),
        backend.makeTensorInfo(xShape, "int32", [])
      ];
    }
    if (lastDim === 1) {
      return [
        x2,
        fill2({ attrs: { shape: xShape, dtype: "int32", value: 0 }, backend })
      ];
    }
    const xtexData = backend.texData.get(x2.dataId);
    const xIsPacked = xtexData !== null && xtexData.isPacked;
    const xUnPacked = xIsPacked ? backend.unpackTensor(x2) : x2;
    const xSize = util_exports.sizeFromShape(xShape);
    const batch = xSize / lastDim;
    const x2D = reshape3({ inputs: { x: xUnPacked }, attrs: { shape: [batch, lastDim] }, backend });
    if (xIsPacked) {
      disposeIntermediateTensorInfoOrNull(backend, xUnPacked);
    }
    const kPow2 = roundUpToPow2(k4);
    const lastDimPow2 = roundUpToPow2(lastDim);
    let indices = null;
    const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];
    const runSwap = (dir, inc, shape) => {
      const inputs2 = getInputs();
      const program = new SwapProgram(shape);
      const fistPass = indices === null ? 1 : 0;
      const customValues = [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];
      const prevIndices2 = indices;
      indices = backend.runWebGLProgram(program, inputs2, "int32", customValues);
      disposeIntermediateTensorInfoOrNull(backend, prevIndices2);
    };
    for (let len = 1; len < kPow2; len *= 2) {
      const dir = len * 2;
      for (let inc = len; inc >= 1; inc /= 2) {
        runSwap(dir, inc, [batch, lastDimPow2]);
      }
    }
    for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {
      const inputs2 = getInputs();
      const mergeProgram = new MergeProgram([batch, indicesSize / 2]);
      const firstPass = indices === null ? 1 : 0;
      const customValues = [[lastDim], [firstPass], [kPow2]];
      const prevIndices2 = indices;
      indices = backend.runWebGLProgram(mergeProgram, inputs2, "int32", customValues);
      disposeIntermediateTensorInfoOrNull(backend, prevIndices2);
      const len = kPow2 / 2;
      const dir = len * 2;
      for (let inc = len; inc >= 1; inc /= 2) {
        runSwap(dir, inc, indices.shape);
      }
    }
    let prevIndices = indices;
    indices = slice2({ inputs: { x: indices }, backend, attrs: { begin: 0, size: [batch, k4] } });
    disposeIntermediateTensorInfoOrNull(backend, prevIndices);
    let values = gatherV2({ inputs: { x: x2D, indices }, backend, attrs: { axis: 1, batchDims: 1 } });
    disposeIntermediateTensorInfoOrNull(backend, x2D);
    const newShape = xShape.slice(0, -1);
    newShape.push(k4);
    prevIndices = indices;
    indices = reshape3({ inputs: { x: indices }, attrs: { shape: newShape }, backend });
    disposeIntermediateTensorInfoOrNull(backend, prevIndices);
    const prevValues = values;
    values = reshape3({ inputs: { x: values }, attrs: { shape: newShape }, backend });
    disposeIntermediateTensorInfoOrNull(backend, prevValues);
    return [values, indices];
  }
  var topKConfig = {
    kernelName: TopK,
    backendName: "webgl",
    kernelFunc: topK
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/transform_gpu.js
  var TransformProgram = class {
    constructor(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape) {
      this.variableNames = ["Image", "Transforms"];
      this.outputShape = outShape;
      const interpolationModeId = interpolation === "nearest" ? 1 : 2;
      let fillModeId;
      switch (fillMode) {
        case "constant":
          fillModeId = 1;
          break;
        case "reflect":
          fillModeId = 2;
          break;
        case "wrap":
          fillModeId = 3;
          break;
        case "nearest":
          fillModeId = 4;
          break;
        default:
          fillModeId = 1;
          break;
      }
      this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${fillModeId} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${imageHeight} && 0 <= coordX && coordX < ${imageWidth}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${fillValue});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${fillValue});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${imageWidth}));
                float mapY = mapCoord(inY, float(${imageHeight}));

                if (${interpolationModeId} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transform.js
  function transform2(args) {
    const { inputs, backend, attrs } = args;
    const { image: image2, transforms } = inputs;
    const { interpolation, fillMode, fillValue, outputShape } = attrs;
    const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
    const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
    const outShape = [
      batch,
      outHeight,
      outWidth,
      numChannels
    ];
    const program = new TransformProgram(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape);
    return backend.runWebGLProgram(program, [image2, transforms], "float32");
  }
  var transformConfig = {
    kernelName: Transform,
    backendName: "webgl",
    kernelFunc: transform2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unique.js
  function unique3(args) {
    const { inputs, attrs, backend } = args;
    const { axis } = attrs;
    const { x: x2 } = inputs;
    assertNotComplex(x2, "unique");
    console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
    const values = backend.readSync(x2.dataId);
    const { outputValues, outputShape, indices } = uniqueImplCPU(values, axis, x2.shape, x2.dtype);
    return [
      backend.makeTensorInfo(outputShape, x2.dtype, outputValues),
      backend.makeTensorInfo([indices.length], "int32", indices)
    ];
  }
  var uniqueConfig = {
    kernelName: Unique,
    backendName: "webgl",
    kernelFunc: unique3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unpack.js
  function unpack(args) {
    const { inputs, backend, attrs } = args;
    const { value } = inputs;
    let { axis } = attrs;
    if (axis < 0) {
      axis += value.shape.length;
    }
    const x2 = value;
    const xRank = x2.shape.length;
    const num = value.shape[axis];
    const outShape = new Array(xRank - 1);
    let outIndex = 0;
    for (let i2 = 0; i2 < xRank; i2++) {
      if (i2 !== axis) {
        outShape[outIndex++] = x2.shape[i2];
      }
    }
    const toDispose = [];
    const begin = new Array(xRank).fill(0);
    const size = x2.shape.slice();
    size[axis] = 1;
    const res = new Array(num);
    for (let i2 = 0; i2 < res.length; i2++) {
      begin[axis] = i2;
      const sliced = slice2({ inputs: { x: x2 }, backend, attrs: { begin, size } });
      const reshaped = reshape3({ inputs: { x: sliced }, backend, attrs: { shape: outShape } });
      res[i2] = reshaped;
      toDispose.push(sliced);
    }
    toDispose.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return res;
  }
  var unpackConfig = {
    kernelName: Unpack,
    backendName: "webgl",
    kernelFunc: unpack
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/segment_gpu.js
  var SegmentOpProgram = class {
    constructor(segOpInfo, segOpType) {
      this.variableNames = ["x", "segmentIds"];
      const windowSize = segOpInfo.windowSize;
      const batchSize = segOpInfo.batchSize;
      const inSize = segOpInfo.inSize;
      const numSegments = segOpInfo.numSegments;
      const outSize = numSegments * Math.ceil(inSize / windowSize);
      this.outputShape = [batchSize, outSize];
      const initializationValue = "0.0";
      const returnValue = `sumValue`;
      const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
      const windowSizeVec4Remainder = windowSize % 4;
      const updateSnippet = `
        sumValue += dot(values, segFilter);
    `;
      let checkValueOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkValueOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
      }
      let checkSegmentIdOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkSegmentIdOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return -1.0;
        }
      `;
      }
      this.userCode = `
      const float initializationValue = ${initializationValue};

      float getValue(int batch, int inIdx) {
        ${checkValueOutOfBounds}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${checkSegmentIdOutOfBounds}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${numSegments})) * float(${windowSize}));
        int currentSeg = int(mod(float(outIdx), float(${numSegments})));

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js
  function unsortedSegmentSum2(args) {
    const { inputs, backend, attrs } = args;
    const { x: x2, segmentIds } = inputs;
    const { numSegments } = attrs;
    const xRank = x2.shape.length;
    const toDispose = [];
    let axis = 0;
    const permutation = backend_util_exports.getAxesPermutation([axis], xRank);
    let permutedX = x2;
    if (permutation != null) {
      permutedX = transpose2({ inputs: { x: x2 }, backend, attrs: { perm: permutation } });
      toDispose.push(permutedX);
      axis = backend_util_exports.getInnerMostAxes(1, xRank)[0];
    }
    const outShape = backend_util_exports.segment_util.computeOutShape(permutedX.shape, axis, numSegments);
    const inSize = util_exports.sizeFromShape([permutedX.shape[axis]]);
    const a2D = reshape3({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
    toDispose.push(a2D);
    const outputDType = sumOutType(x2.dtype);
    const segOpCompute = (x3, segOpType, segmentIds2, dtype, numSegments2) => {
      const batchSize = x3.shape[0];
      const inSize2 = x3.shape[1];
      const windowSize = backend_util_exports.segment_util.segOpComputeOptimalWindowSize(inSize2, numSegments2);
      const segOpInfo = { windowSize, inSize: inSize2, batchSize, numSegments: numSegments2 };
      const program = new SegmentOpProgram(segOpInfo, segOpType);
      const output = backend.compileAndRun(program, [x3, segmentIds2], dtype);
      toDispose.push(output);
      if (output.shape[1] === numSegments2) {
        return output;
      }
      const rangeInfo = range3({
        backend,
        attrs: { start: 0, stop: numSegments2, step: 1, dtype: "float32" }
      });
      const tileInfo = tile2({
        inputs: { x: rangeInfo },
        backend,
        attrs: { reps: [inSize2 / windowSize] }
      });
      toDispose.push(rangeInfo);
      toDispose.push(tileInfo);
      const result2 = segOpCompute(output, segOpType, tileInfo, dtype, numSegments2);
      return result2;
    };
    const segOpResult = segOpCompute(a2D, "unsortedSegmentSum", segmentIds, outputDType, numSegments);
    const reshaped = reshape3({ inputs: { x: segOpResult }, backend, attrs: { shape: outShape } });
    let result = reshaped;
    if (permutation != null) {
      toDispose.push(reshaped);
      const perm = backend_util_exports.getUndoAxesPermutation(permutation);
      result = transpose2({ inputs: { x: result }, backend, attrs: { perm } });
    }
    toDispose.forEach((t3) => backend.disposeIntermediateTensorInfo(t3));
    return result;
  }
  var unsortedSegmentSumConfig = {
    kernelName: UnsortedSegmentSum,
    backendName: "webgl",
    kernelFunc: unsortedSegmentSum2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/register_all_kernels.js
  var kernelConfigs = [
    _fusedMatMulConfig,
    absConfig,
    acosConfig,
    acoshConfig,
    addConfig,
    addNConfig,
    allConfig,
    anyConfig,
    argMaxConfig,
    argMinConfig,
    asinConfig,
    asinhConfig,
    atanConfig,
    atan2Config,
    atanhConfig,
    avgPoolConfig,
    avgPool3DConfig,
    avgPool3DGradConfig,
    avgPoolGradConfig,
    batchMatMulConfig,
    batchNormConfig,
    batchToSpaceNDConfig,
    bincountConfig,
    broadcastArgsConfig,
    castConfig,
    ceilConfig,
    clipByValueConfig,
    complexConfig,
    complexAbsConfig,
    concatConfig,
    conv2DConfig,
    conv2DBackpropFilterConfig,
    conv2DBackpropInputConfig,
    conv3DConfig,
    conv3DBackpropFilterV2Config,
    conv3DBackpropInputConfig,
    cosConfig,
    coshConfig,
    cropAndResizeConfig,
    cumprodConfig,
    cumsumConfig,
    denseBincountConfig,
    depthToSpaceConfig,
    depthwiseConv2dNativeConfig,
    depthwiseConv2dNativeBackpropFilterConfig,
    depthwiseConv2dNativeBackpropInputConfig,
    diagConfig,
    dilation2DConfig,
    einsumConfig,
    eluConfig,
    eluGradConfig,
    equalConfig,
    erfConfig,
    expConfig,
    expandDimsConfig,
    expm1Config,
    fftConfig,
    fillConfig,
    flipLeftRightConfig,
    floorConfig,
    floorDivConfig,
    fromPixelsConfig,
    fusedConv2DConfig,
    fusedDepthwiseConv2DConfig,
    gatherNdConfig,
    gatherV2Config,
    greaterConfig,
    greaterEqualConfig,
    identityConfig,
    ifftConfig,
    imagConfig,
    isFiniteConfig,
    isInfConfig,
    isNaNConfig,
    leakyReluConfig,
    lessConfig,
    lessEqualConfig,
    linSpaceConfig,
    logConfig,
    log1pConfig,
    logicalAndConfig,
    logicalNotConfig,
    logicalOrConfig,
    LRNConfig,
    LRNGradConfig,
    maxConfig,
    maximumConfig,
    maxPoolConfig,
    maxPool3DConfig,
    maxPool3DGradConfig,
    maxPoolGradConfig,
    maxPoolWithArgmaxConfig,
    meanConfig,
    minConfig,
    minimumConfig,
    mirrorPadConfig,
    modConfig,
    multinomialConfig,
    multiplyConfig,
    negConfig,
    nonMaxSuppressionV3Config,
    nonMaxSuppressionV4Config,
    nonMaxSuppressionV5Config,
    notEqualConfig,
    oneHotConfig,
    onesLikeConfig,
    packConfig,
    padV2Config,
    powConfig,
    preluConfig,
    prodConfig,
    raggedGatherConfig,
    raggedRangeConfig,
    raggedTensorToTensorConfig,
    rangeConfig,
    realConfig,
    realDivConfig,
    reciprocalConfig,
    reluConfig,
    relu6Config,
    reshapeConfig,
    resizeBilinearConfig,
    resizeBilinearGradConfig,
    resizeNearestNeighborConfig,
    resizeNearestNeighborGradConfig,
    reverseConfig,
    rotateWithOffsetConfig,
    roundConfig,
    rsqrtConfig,
    scatterNdConfig,
    searchSortedConfig,
    selectConfig,
    seluConfig,
    sigmoidConfig,
    signConfig,
    sinConfig,
    sinhConfig,
    sliceConfig,
    softmaxConfig,
    softplusConfig,
    spaceToBatchNDConfig,
    sparseFillEmptyRowsConfig,
    sparseReshapeConfig,
    sparseSegmentMeanConfig,
    sparseSegmentSumConfig,
    sparseToDenseConfig,
    splitVConfig,
    sqrtConfig,
    squareConfig,
    squaredDifferenceConfig,
    stepConfig,
    stridedSliceConfig,
    stringNGramsConfig,
    stringSplitConfig,
    stringToHashBucketFastConfig,
    subConfig,
    sumConfig,
    tanConfig,
    tanhConfig,
    tileConfig,
    topKConfig,
    transformConfig,
    transposeConfig,
    uniqueConfig,
    unpackConfig,
    unsortedSegmentSumConfig,
    zerosLikeConfig
  ];
  for (const kernelConfig of kernelConfigs) {
    registerKernel(kernelConfig);
  }

  // node_modules/@tensorflow-models/face-landmarks-detection/dist/face-landmarks-detection.esm.js
  var t2 = __toESM(require_face_mesh());

  // node_modules/@tensorflow/tfjs-converter/dist/flags.js
  var ENV4 = env();
  ENV4.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (debugValue) => {
    if (debugValue) {
      console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
    }
  });

  // node_modules/@tensorflow/tfjs-converter/dist/data/compiled_api.js
  var DataType2;
  (function(DataType3) {
    DataType3[DataType3["DT_INVALID"] = 0] = "DT_INVALID";
    DataType3[DataType3["DT_FLOAT"] = 1] = "DT_FLOAT";
    DataType3[DataType3["DT_DOUBLE"] = 2] = "DT_DOUBLE";
    DataType3[DataType3["DT_INT32"] = 3] = "DT_INT32";
    DataType3[DataType3["DT_UINT8"] = 4] = "DT_UINT8";
    DataType3[DataType3["DT_INT16"] = 5] = "DT_INT16";
    DataType3[DataType3["DT_INT8"] = 6] = "DT_INT8";
    DataType3[DataType3["DT_STRING"] = 7] = "DT_STRING";
    DataType3[DataType3["DT_COMPLEX64"] = 8] = "DT_COMPLEX64";
    DataType3[DataType3["DT_INT64"] = 9] = "DT_INT64";
    DataType3[DataType3["DT_BOOL"] = 10] = "DT_BOOL";
    DataType3[DataType3["DT_QINT8"] = 11] = "DT_QINT8";
    DataType3[DataType3["DT_QUINT8"] = 12] = "DT_QUINT8";
    DataType3[DataType3["DT_QINT32"] = 13] = "DT_QINT32";
    DataType3[DataType3["DT_BFLOAT16"] = 14] = "DT_BFLOAT16";
    DataType3[DataType3["DT_QINT16"] = 15] = "DT_QINT16";
    DataType3[DataType3["DT_QUINT16"] = 16] = "DT_QUINT16";
    DataType3[DataType3["DT_UINT16"] = 17] = "DT_UINT16";
    DataType3[DataType3["DT_COMPLEX128"] = 18] = "DT_COMPLEX128";
    DataType3[DataType3["DT_HALF"] = 19] = "DT_HALF";
    DataType3[DataType3["DT_RESOURCE"] = 20] = "DT_RESOURCE";
    DataType3[DataType3["DT_VARIANT"] = 21] = "DT_VARIANT";
    DataType3[DataType3["DT_UINT32"] = 22] = "DT_UINT32";
    DataType3[DataType3["DT_UINT64"] = 23] = "DT_UINT64";
    DataType3[DataType3["DT_FLOAT_REF"] = 101] = "DT_FLOAT_REF";
    DataType3[DataType3["DT_DOUBLE_REF"] = 102] = "DT_DOUBLE_REF";
    DataType3[DataType3["DT_INT32_REF"] = 103] = "DT_INT32_REF";
    DataType3[DataType3["DT_UINT8_REF"] = 104] = "DT_UINT8_REF";
    DataType3[DataType3["DT_INT16_REF"] = 105] = "DT_INT16_REF";
    DataType3[DataType3["DT_INT8_REF"] = 106] = "DT_INT8_REF";
    DataType3[DataType3["DT_STRING_REF"] = 107] = "DT_STRING_REF";
    DataType3[DataType3["DT_COMPLEX64_REF"] = 108] = "DT_COMPLEX64_REF";
    DataType3[DataType3["DT_INT64_REF"] = 109] = "DT_INT64_REF";
    DataType3[DataType3["DT_BOOL_REF"] = 110] = "DT_BOOL_REF";
    DataType3[DataType3["DT_QINT8_REF"] = 111] = "DT_QINT8_REF";
    DataType3[DataType3["DT_QUINT8_REF"] = 112] = "DT_QUINT8_REF";
    DataType3[DataType3["DT_QINT32_REF"] = 113] = "DT_QINT32_REF";
    DataType3[DataType3["DT_BFLOAT16_REF"] = 114] = "DT_BFLOAT16_REF";
    DataType3[DataType3["DT_QINT16_REF"] = 115] = "DT_QINT16_REF";
    DataType3[DataType3["DT_QUINT16_REF"] = 116] = "DT_QUINT16_REF";
    DataType3[DataType3["DT_UINT16_REF"] = 117] = "DT_UINT16_REF";
    DataType3[DataType3["DT_COMPLEX128_REF"] = 118] = "DT_COMPLEX128_REF";
    DataType3[DataType3["DT_HALF_REF"] = 119] = "DT_HALF_REF";
    DataType3[DataType3["DT_RESOURCE_REF"] = 120] = "DT_RESOURCE_REF";
    DataType3[DataType3["DT_VARIANT_REF"] = 121] = "DT_VARIANT_REF";
    DataType3[DataType3["DT_UINT32_REF"] = 122] = "DT_UINT32_REF";
    DataType3[DataType3["DT_UINT64_REF"] = 123] = "DT_UINT64_REF";
  })(DataType2 || (DataType2 = {}));
  var SaverDef2;
  (function(SaverDef3) {
    let CheckpointFormatVersion;
    (function(CheckpointFormatVersion2) {
      CheckpointFormatVersion2[CheckpointFormatVersion2["LEGACY"] = 0] = "LEGACY";
      CheckpointFormatVersion2[CheckpointFormatVersion2["V1"] = 1] = "V1";
      CheckpointFormatVersion2[CheckpointFormatVersion2["V2"] = 2] = "V2";
    })(CheckpointFormatVersion = SaverDef3.CheckpointFormatVersion || (SaverDef3.CheckpointFormatVersion = {}));
  })(SaverDef2 || (SaverDef2 = {}));

  // node_modules/@tensorflow/tfjs-converter/dist/operations/custom_op/register.js
  var CUSTOM_OPS2 = {};
  function getRegisteredOp2(name) {
    return CUSTOM_OPS2[name];
  }

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/utils.js
  function getParamValue2(paramName, node, tensorMap, context, resourceManager) {
    const inputParam = node.inputParams[paramName];
    if (inputParam && inputParam.inputIndexStart !== void 0) {
      const start = inputParam.inputIndexStart;
      const end = inputParam.inputIndexEnd === 0 ? void 0 : inputParam.inputIndexEnd === void 0 ? start + 1 : inputParam.inputIndexEnd;
      if (inputParam.type === "tensor") {
        return getTensor2(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);
      }
      if (inputParam.type === "tensors") {
        const inputs = node.inputNames.slice(start, end);
        return inputs.map((name) => getTensor2(name, tensorMap, context, resourceManager));
      }
      const tensor2 = getTensor2(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);
      const data = tensor2.dataSync();
      return inputParam.type === "number" ? data[0] : util_exports.toNestedArray(tensor2.shape, data);
    }
    const attrParam = node.attrParams[paramName];
    return attrParam && attrParam.value;
  }
  function getTensor2(name, tensorsMap, context, resourceManager) {
    const [nodeName, index] = parseNodeName2(name);
    if (resourceManager != null) {
      const tensor2 = resourceManager.getHashTableHandleByName(nodeName);
      if (tensor2 != null) {
        return tensor2;
      }
    }
    const contextId = context.currentContextIds.find((contextId2) => {
      return !!tensorsMap[getNodeNameWithContextId2(nodeName, contextId2)];
    });
    return contextId !== void 0 ? tensorsMap[getNodeNameWithContextId2(nodeName, contextId)][index] : void 0;
  }
  function getTensorsForCurrentContenxt2(name, tensorsMap, context) {
    return tensorsMap[getNodeNameWithContextId2(name, context.currentContextId)];
  }
  function getNodeNameAndIndex2(inputName, context) {
    const [nodeName, index, outputName] = parseNodeName2(inputName);
    return [
      getNodeNameWithContextId2(nodeName, context && context.currentContextId),
      index,
      outputName
    ];
  }
  function getNodeNameWithContextId2(name, contextId) {
    return !!contextId ? `${name}-${contextId}` : name;
  }
  function parseNodeName2(name) {
    const parts = name.split(":");
    if (parts.length === 1) {
      return [name, 0, void 0];
    }
    const nodeName = parts[0];
    const outputName = parts.length === 3 ? parts[1] : void 0;
    const index = Number(parts[parts.length - 1]);
    return [nodeName, index, outputName];
  }
  function getPadding(node, tensorMap, context) {
    let pad2 = getParamValue2("pad", node, tensorMap, context);
    if (pad2 === "explicit") {
      pad2 = getParamValue2("explicitPaddings", node, tensorMap, context);
      const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];
      for (let i2 = 0; i2 < 4; i2++) {
        explicitPadding[i2][0] = pad2[i2 * 2];
        explicitPadding[i2][1] = pad2[i2 * 2 + 1];
      }
      return explicitPadding;
    }
    return pad2;
  }
  function cloneTensor(tensor2) {
    return tensor2.kept ? tensor2 : clone(tensor2);
  }

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/arithmetic.js
  var arithmetic_exports = {};
  __export(arithmetic_exports, {
    json: () => json2
  });
  var json2 = [
    {
      "tfOpName": "Add",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "AddV2",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "AddN",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "tensors",
          "type": "tensors"
        }
      ]
    },
    {
      "tfOpName": "BiasAdd",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sub",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "RealDiv",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Div",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "DivNoNan",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "FloorDiv",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Mul",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Maximum",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Minimum",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Pow",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "SquaredDifference",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Mod",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "FloorMod",
      "category": "arithmetic",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/basic_math.js
  var basic_math_exports = {};
  __export(basic_math_exports, {
    json: () => json3
  });
  var json3 = [
    {
      "tfOpName": "Abs",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Acos",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Asin",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Atan",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Atan2",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "y",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Ceil",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "ClipByValue",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "clipValueMin",
          "type": "number"
        },
        {
          "start": 2,
          "name": "clipValueMax",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Complex",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "real",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "imag",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "ComplexAbs",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Cos",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Cosh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Elu",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Exp",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Floor",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Log",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Imag",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "outputType",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Neg",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Real",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "outputType",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Prelu",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "alpha",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Relu",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Relu6",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Selu",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sigmoid",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sin",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sinh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sqrt",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Rsqrt",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Square",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Tan",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Tanh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Sign",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Round",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Expm1",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Log1p",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Reciprocal",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Softplus",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Asinh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Acosh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Atanh",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Erf",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Prod",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axes",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool",
          "notSupported": true
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LeakyRelu",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "alpha",
          "name": "alpha",
          "type": "number",
          "defaultValue": 0.2
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "IsNan",
      "category": "basic_math",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/control.js
  var control_exports = {};
  __export(control_exports, {
    json: () => json4
  });
  var json4 = [
    {
      "tfOpName": "EmptyTensorList",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "elementShape",
          "type": "shape"
        },
        {
          "start": 1,
          "name": "maxNumElements",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "LoopCond",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "pred",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Switch",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "data",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "pred",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Merge",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "tensors",
          "type": "tensors"
        }
      ]
    },
    {
      "tfOpName": "Enter",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "frame_name",
          "name": "frameName",
          "type": "string"
        },
        {
          "tfName": "is_constant",
          "name": "isConstant",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Exit",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "NextIteration",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "TensorArrayV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "size",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "element_shape",
          "name": "elementShape",
          "type": "shape"
        },
        {
          "tfName": "dynamic_size",
          "name": "dynamicSize",
          "type": "bool"
        },
        {
          "tfName": "clear_after_read",
          "name": "clearAfterRead",
          "type": "bool"
        },
        {
          "tfName": "identical_element_shapes",
          "name": "identicalElementShapes",
          "type": "bool"
        },
        {
          "tfName": "tensor_array_name",
          "name": "name",
          "type": "string"
        }
      ]
    },
    {
      "tfOpName": "TensorArrayWriteV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "index",
          "type": "number"
        },
        {
          "start": 2,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "TensorArrayReadV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "index",
          "type": "number"
        },
        {
          "start": 2,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "TensorArrayGatherV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "element_shape",
          "name": "elementShape",
          "type": "shape"
        }
      ]
    },
    {
      "tfOpName": "TensorArrayScatterV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorArrayConcatV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "element_shape_except0",
          "name": "elementShapeExcept0",
          "type": "shape",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "TensorArraySplitV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "lengths",
          "type": "number[]"
        },
        {
          "start": 3,
          "name": "flowIn",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorArraySizeV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "flowIn",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "TensorArrayCloseV3",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorArrayId",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "StatelessIf",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "cond",
          "type": "tensor"
        },
        {
          "start": 1,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "then_branch",
          "name": "thenBranch",
          "type": "func"
        },
        {
          "tfName": "else_branch",
          "name": "elseBranch",
          "type": "func"
        }
      ]
    },
    {
      "tfOpName": "If",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "cond",
          "type": "tensor"
        },
        {
          "start": 1,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "then_branch",
          "name": "thenBranch",
          "type": "func"
        },
        {
          "tfName": "else_branch",
          "name": "elseBranch",
          "type": "func"
        }
      ]
    },
    {
      "tfOpName": "StatelessWhile",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "cond",
          "name": "cond",
          "type": "func"
        },
        {
          "tfName": "body",
          "name": "body",
          "type": "func"
        }
      ]
    },
    {
      "tfOpName": "While",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "cond",
          "name": "cond",
          "type": "func"
        },
        {
          "tfName": "body",
          "name": "body",
          "type": "func"
        }
      ]
    },
    {
      "tfOpName": "TensorListScatter",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListScatterV2",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "elementShape",
          "type": "shape"
        },
        {
          "start": 3,
          "name": "numElements",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListGather",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListGetItem",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "index",
          "type": "number"
        },
        {
          "start": 2,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListSetItem",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "index",
          "type": "number"
        },
        {
          "start": 2,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListReserve",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "elementShape",
          "type": "shape"
        },
        {
          "start": 1,
          "name": "numElements",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListFromTensor",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListStack",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        },
        {
          "tfName": "num_elements",
          "name": "numElements",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListSplit",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "elementShape",
          "type": "shape"
        },
        {
          "start": 2,
          "name": "lengths",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListConcat",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "element_shape",
          "name": "elementShape",
          "type": "shape"
        },
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListConcatV2",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "element_shape",
          "name": "elementShape",
          "type": "shape"
        },
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListPopBack",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "elementShape",
          "type": "shape"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListPushBack",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "element_dtype",
          "name": "elementDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TensorListLength",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "TensorListResize",
      "category": "control",
      "inputs": [
        {
          "start": 0,
          "name": "tensorListId",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "size",
          "type": "number"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/convolution.js
  var convolution_exports = {};
  __export(convolution_exports, {
    json: () => json5
  });
  var json5 = [
    {
      "tfOpName": "AvgPool",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        },
        {
          "tfName": "ksize",
          "name": "kernelSize",
          "type": "number[]"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "MaxPool",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        },
        {
          "tfName": "ksize",
          "name": "kernelSize",
          "type": "number[]"
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": [],
          "notSupported": true
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "MaxPoolWithArgmax",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "ksize",
          "name": "kernelSize",
          "type": "number[]"
        },
        {
          "tfName": "include_batch_in_index",
          "name": "includeBatchInIndex",
          "type": "bool"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "AvgPool3D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        },
        {
          "tfName": "ksize",
          "name": "kernelSize",
          "type": "number[]"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "MaxPool3D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        },
        {
          "tfName": "ksize",
          "name": "kernelSize",
          "type": "number[]"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Conv1D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "stride",
          "name": "stride",
          "type": "number"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NWC"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "dilation",
          "name": "dilation",
          "type": "number",
          "defaultValue": 1
        }
      ]
    },
    {
      "tfOpName": "Conv2D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "useCudnnOnGpu",
          "name": "useCudnnOnGpu",
          "type": "bool"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "_FusedConv2D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        },
        {
          "start": 2,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "num_args",
          "name": "numArgs",
          "type": "number"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        },
        {
          "tfName": "use_cudnn_on_gpu",
          "name": "useCudnnOnGpu",
          "type": "bool",
          "defaultValue": true
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]",
          "defaultValue": [
            1,
            1,
            1,
            1
          ]
        },
        {
          "tfName": "fused_ops",
          "name": "fusedOps",
          "type": "string[]",
          "defaultValue": []
        },
        {
          "tfName": "epsilon",
          "name": "epsilon",
          "type": "number",
          "defaultValue": 1e-4
        },
        {
          "tfName": "leakyrelu_alpha",
          "name": "leakyreluAlpha",
          "type": "number",
          "defaultValue": 0.2
        }
      ]
    },
    {
      "tfOpName": "Conv2DBackpropInput",
      "category": "convolution",
      "inputs": [
        {
          "start": 2,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        },
        {
          "start": 0,
          "name": "outputShape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "DepthwiseConv2d",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "input",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "DepthwiseConv2dNative",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "input",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "FusedDepthwiseConv2dNative",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        },
        {
          "start": 2,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "num_args",
          "name": "numArgs",
          "type": "number"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]",
          "defaultValue": [
            1,
            1,
            1,
            1
          ]
        },
        {
          "tfName": "fused_ops",
          "name": "fusedOps",
          "type": "string[]",
          "defaultValue": []
        },
        {
          "tfName": "explicit_paddings",
          "name": "explicitPaddings",
          "type": "number[]",
          "defaultValue": []
        }
      ]
    },
    {
      "tfOpName": "Conv3D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "defaultValue": "NHWC"
        },
        {
          "tfName": "dilations",
          "name": "dilations",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "Dilation2D",
      "category": "convolution",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "filter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "strides",
          "name": "strides",
          "type": "number[]"
        },
        {
          "tfName": "rates",
          "name": "dilations",
          "type": "number[]"
        },
        {
          "tfName": "padding",
          "name": "pad",
          "type": "string"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/creation.js
  var creation_exports = {};
  __export(creation_exports, {
    json: () => json6
  });
  var json6 = [
    {
      "tfOpName": "Fill",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        },
        {
          "start": 1,
          "name": "value",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "LinSpace",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "start",
          "type": "number"
        },
        {
          "start": 1,
          "name": "stop",
          "type": "number"
        },
        {
          "start": 2,
          "name": "num",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "OneHot",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "depth",
          "type": "number"
        },
        {
          "start": 2,
          "name": "onValue",
          "type": "number",
          "defaultValue": 1
        },
        {
          "start": 3,
          "name": "offValue",
          "type": "number",
          "defaultValue": 0
        }
      ],
      "attrs": [
        {
          "tfName": "axis",
          "name": "axis",
          "type": "number",
          "notSupported": true
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "Ones",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "OnesLike",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "RandomStandardNormal",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "seed",
          "name": "seed",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "seed2",
          "name": "seed2",
          "type": "number",
          "defaultValue": 0,
          "notSupported": true
        },
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "T",
          "name": "T",
          "type": "number",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "RandomUniform",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "minval",
          "name": "minval",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "maxval",
          "name": "maxval",
          "type": "number",
          "defaultValue": 1
        },
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "seed",
          "name": "seed",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "seed2",
          "name": "seed2",
          "type": "number",
          "defaultValue": 0,
          "notSupported": true
        },
        {
          "tfName": "T",
          "name": "T",
          "type": "number",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Range",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "start",
          "type": "number"
        },
        {
          "start": 1,
          "name": "stop",
          "type": "number"
        },
        {
          "start": 2,
          "name": "step",
          "type": "number",
          "defaultValue": 0
        }
      ],
      "attrs": [
        {
          "tfName": "Tidx",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "TruncatedNormal",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "means",
          "name": "mean",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "stddev",
          "name": "stdDev",
          "type": "number",
          "defaultValue": 1
        },
        {
          "tfName": "seed",
          "name": "seed",
          "type": "number"
        },
        {
          "tfName": "seed2",
          "name": "seed2",
          "type": "number",
          "defaultValue": 0,
          "notSupported": true
        },
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "T",
          "name": "T",
          "type": "number",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Zeros",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "ZerosLike",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "Multinomial",
      "category": "creation",
      "inputs": [
        {
          "start": 0,
          "name": "logits",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "numSamples",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "seed",
          "name": "seed",
          "type": "number"
        },
        {
          "tfName": "seed2",
          "name": "seed2",
          "type": "number"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        },
        {
          "tfName": "output_dtype",
          "name": "output_dtype",
          "type": "dtype"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/dynamic.js
  var dynamic_exports = {};
  __export(dynamic_exports, {
    json: () => json7
  });
  var json7 = [
    {
      "tfOpName": "NonMaxSuppressionV2",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "boxes",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scores",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "maxOutputSize",
          "type": "number"
        },
        {
          "start": 3,
          "name": "iouThreshold",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "NonMaxSuppressionV3",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "boxes",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scores",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "maxOutputSize",
          "type": "number"
        },
        {
          "start": 3,
          "name": "iouThreshold",
          "type": "number"
        },
        {
          "start": 4,
          "name": "scoreThreshold",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "NonMaxSuppressionV4",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "boxes",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scores",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "maxOutputSize",
          "type": "number"
        },
        {
          "start": 3,
          "name": "iouThreshold",
          "type": "number"
        },
        {
          "start": 4,
          "name": "scoreThreshold",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "T_threshold",
          "name": "threshold",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "pad_to_max_output_size",
          "name": "padToMaxOutputSize",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "NonMaxSuppressionV5",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "boxes",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scores",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "maxOutputSize",
          "type": "number"
        },
        {
          "start": 3,
          "name": "iouThreshold",
          "type": "number"
        },
        {
          "start": 4,
          "name": "scoreThreshold",
          "type": "number"
        },
        {
          "start": 5,
          "name": "softNmsSigma",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "Where",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "condition",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "ListDiff",
      "category": "dynamic",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "y",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/evaluation.js
  var evaluation_exports = {};
  __export(evaluation_exports, {
    json: () => json8
  });
  var json8 = [
    {
      "tfOpName": "LowerBound",
      "category": "evaluation",
      "inputs": [
        {
          "start": 0,
          "name": "sortedSequence",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "values",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "TopKV2",
      "category": "evaluation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "k",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "sorted",
          "name": "sorted",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "UpperBound",
      "category": "evaluation",
      "inputs": [
        {
          "start": 0,
          "name": "sortedSequence",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "values",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Unique",
      "category": "evaluation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "UniqueV2",
      "category": "evaluation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/graph.js
  var graph_exports = {};
  __export(graph_exports, {
    json: () => json9
  });
  var json9 = [
    {
      "tfOpName": "PlaceholderWithDefault",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "default",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "shape",
          "name": "shape",
          "type": "shape"
        },
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "Placeholder",
      "category": "graph",
      "attrs": [
        {
          "tfName": "shape",
          "name": "shape",
          "type": "shape"
        },
        {
          "tfName": "dtype",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "Const",
      "category": "graph"
    },
    {
      "tfOpName": "Identity",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "IdentityN",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "x",
          "type": "tensors"
        }
      ]
    },
    {
      "tfOpName": "Snapshot",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Rank",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Size",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "Shape",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "ShapeN",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "x",
          "type": "tensors"
        }
      ]
    },
    {
      "tfOpName": "Print",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "data",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "message",
          "name": "message",
          "type": "string"
        },
        {
          "tfName": "first_n",
          "name": "firstN",
          "type": "number",
          "notSupported": true
        },
        {
          "tfName": "summarize",
          "name": "summarize",
          "type": "number",
          "defaultValue": 3
        }
      ]
    },
    {
      "tfOpName": "NoOp",
      "category": "graph",
      "inputs": []
    },
    {
      "tfOpName": "StopGradient",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "FakeQuantWithMinMaxVars",
      "category": "graph",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "min",
          "name": "min",
          "type": "number"
        },
        {
          "tfName": "max",
          "name": "max",
          "type": "number"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/hash_table.js
  var hash_table_exports = {};
  __export(hash_table_exports, {
    json: () => json10
  });
  var json10 = [
    {
      "tfOpName": "HashTable",
      "category": "hash_table",
      "inputs": [],
      "attrs": [
        {
          "tfName": "shared_name",
          "name": "sharedName",
          "type": "string"
        },
        {
          "tfName": "use_node_name_sharing",
          "name": "useNodeNameSharing",
          "type": "bool"
        },
        {
          "tfName": "key_dtype",
          "name": "keyDType",
          "type": "dtype"
        },
        {
          "tfName": "value_dtype",
          "name": "valueDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "HashTableV2",
      "category": "hash_table",
      "inputs": [],
      "attrs": [
        {
          "tfName": "shared_name",
          "name": "sharedName",
          "type": "string"
        },
        {
          "tfName": "use_node_name_sharing",
          "name": "useNodeNameSharing",
          "type": "bool"
        },
        {
          "tfName": "key_dtype",
          "name": "keyDType",
          "type": "dtype"
        },
        {
          "tfName": "value_dtype",
          "name": "valueDType",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "LookupTableImport",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "values",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "Tin",
          "name": "tIn",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "tOut",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LookupTableImportV2",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "values",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "Tin",
          "name": "tIn",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "tOut",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LookupTableFind",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "defaultValue",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "Tin",
          "name": "tIn",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "tOut",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LookupTableFindV2",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "defaultValue",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "Tin",
          "name": "tIn",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "Tout",
          "name": "tOut",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LookupTableSize",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "LookupTableSizeV2",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "InitializeTable",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "values",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "InitializeTableV2",
      "category": "hash_table",
      "inputs": [
        {
          "start": 0,
          "name": "tableHandle",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "keys",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "values",
          "type": "tensor"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/image.js
  var image_exports = {};
  __export(image_exports, {
    json: () => json11
  });
  var json11 = [
    {
      "tfOpName": "ResizeBilinear",
      "category": "image",
      "inputs": [
        {
          "start": 0,
          "name": "images",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "size",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "align_corners",
          "name": "alignCorners",
          "type": "bool"
        },
        {
          "tfName": "half_pixel_centers",
          "name": "halfPixelCenters",
          "type": "bool"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "ResizeNearestNeighbor",
      "category": "image",
      "inputs": [
        {
          "start": 0,
          "name": "images",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "size",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "align_corners",
          "name": "alignCorners",
          "type": "bool"
        },
        {
          "tfName": "half_pixel_centers",
          "name": "halfPixelCenters",
          "type": "bool"
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "CropAndResize",
      "category": "image",
      "inputs": [
        {
          "start": 0,
          "name": "image",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "boxes",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "boxInd",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "cropSize",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "method",
          "name": "method",
          "type": "string"
        },
        {
          "tfName": "extrapolation_value",
          "name": "extrapolationValue",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "ImageProjectiveTransformV3",
      "category": "image",
      "inputs": [
        {
          "start": 0,
          "name": "images",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "transforms",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "outputShape",
          "type": "number[]"
        },
        {
          "start": 3,
          "name": "fillValue",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "interpolation",
          "name": "interpolation",
          "type": "string"
        },
        {
          "tfName": "fill_mode",
          "name": "fillMode",
          "type": "string"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/logical.js
  var logical_exports = {};
  __export(logical_exports, {
    json: () => json12
  });
  var json12 = [
    {
      "tfOpName": "Equal",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "NotEqual",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Greater",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "GreaterEqual",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Less",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LessEqual",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LogicalAnd",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LogicalNot",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LogicalOr",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Select",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "condition",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "SelectV2",
      "category": "logical",
      "inputs": [
        {
          "start": 0,
          "name": "condition",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/matrices.js
  var matrices_exports = {};
  __export(matrices_exports, {
    json: () => json13
  });
  var json13 = [
    {
      "tfOpName": "_FusedMatMul",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        },
        {
          "start": 2,
          "end": 0,
          "name": "args",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "num_args",
          "name": "numArgs",
          "type": "number"
        },
        {
          "tfName": "fused_ops",
          "name": "fusedOps",
          "type": "string[]",
          "defaultValue": []
        },
        {
          "tfName": "epsilon",
          "name": "epsilon",
          "type": "number",
          "defaultValue": 1e-4
        },
        {
          "tfName": "transpose_a",
          "name": "transposeA",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "transpose_b",
          "name": "transposeB",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "leakyrelu_alpha",
          "name": "leakyreluAlpha",
          "type": "number",
          "defaultValue": 0.2
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "MatMul",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "transpose_a",
          "name": "transposeA",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "transpose_b",
          "name": "transposeB",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "BatchMatMul",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "adj_x",
          "name": "transposeA",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "adj_y",
          "name": "transposeB",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "BatchMatMulV2",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "a",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "b",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "adj_x",
          "name": "transposeA",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "adj_y",
          "name": "transposeB",
          "type": "bool",
          "defaultValue": false
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Transpose",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "perm",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Einsum",
      "category": "matrices",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "tensors",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "equation",
          "name": "equation",
          "type": "string"
        },
        {
          "tfName": "N",
          "name": "n",
          "type": "number",
          "defaultValue": 2
        },
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/normalization.js
  var normalization_exports = {};
  __export(normalization_exports, {
    json: () => json14
  });
  var json14 = [
    {
      "tfOpName": "EuclideanNorm",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool",
          "defaultValue": false
        }
      ]
    },
    {
      "tfOpName": "FusedBatchNorm",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scale",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "offset",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "mean",
          "type": "tensor"
        },
        {
          "start": 4,
          "name": "variance",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "epsilon",
          "name": "epsilon",
          "type": "number",
          "defaultValue": 1e-3
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "FusedBatchNormV2",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scale",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "offset",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "mean",
          "type": "tensor"
        },
        {
          "start": 4,
          "name": "variance",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "epsilon",
          "name": "epsilon",
          "type": "number",
          "defaultValue": 1e-3
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "FusedBatchNormV3",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "scale",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "offset",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "mean",
          "type": "tensor"
        },
        {
          "start": 4,
          "name": "variance",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "epsilon",
          "name": "epsilon",
          "type": "number",
          "defaultValue": 1e-3
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "LRN",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "depth_radius",
          "name": "radius",
          "type": "number",
          "defaultValue": 5
        },
        {
          "tfName": "bias",
          "name": "bias",
          "type": "number",
          "defaultValue": 1
        },
        {
          "tfName": "alpha",
          "name": "alpha",
          "type": "number",
          "defaultValue": 1
        },
        {
          "tfName": "beta",
          "name": "beta",
          "type": "number",
          "defaultValue": 0.5
        }
      ]
    },
    {
      "tfOpName": "Softmax",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "LogSoftmax",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "SparseToDense",
      "category": "normalization",
      "inputs": [
        {
          "start": 0,
          "name": "sparseIndices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "outputShape",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "sparseValues",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "defaultValue",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "validate_indices",
          "name": "validateIndices",
          "type": "bool",
          "defaultValue": true,
          "notSupported": true
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/reduction.js
  var reduction_exports = {};
  __export(reduction_exports, {
    json: () => json15
  });
  var json15 = [
    {
      "tfOpName": "Bincount",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "size",
          "type": "number"
        },
        {
          "start": 2,
          "name": "weights",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "DenseBincount",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "size",
          "type": "number"
        },
        {
          "start": 2,
          "name": "weights",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "binary_output",
          "name": "binaryOutput",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Max",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Mean",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Min",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Sum",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "All",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Any",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "ArgMax",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "ArgMin",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "Prod",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "keep_dims",
          "name": "keepDims",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Cumprod",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "exclusive",
          "name": "exclusive",
          "type": "bool"
        },
        {
          "tfName": "reverse",
          "name": "reverse",
          "type": "bool"
        }
      ]
    },
    {
      "tfOpName": "Cumsum",
      "category": "reduction",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "exclusive",
          "name": "exclusive",
          "type": "bool"
        },
        {
          "tfName": "reverse",
          "name": "reverse",
          "type": "bool"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/slice_join.js
  var slice_join_exports = {};
  __export(slice_join_exports, {
    json: () => json16
  });
  var json16 = [
    {
      "tfOpName": "ConcatV2",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "end": -1,
          "name": "tensors",
          "type": "tensors"
        },
        {
          "start": -1,
          "name": "axis",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "N",
          "name": "n",
          "type": "number",
          "defaultValue": 2
        }
      ]
    },
    {
      "tfOpName": "Concat",
      "category": "slice_join",
      "inputs": [
        {
          "start": 1,
          "end": 0,
          "name": "tensors",
          "type": "tensors"
        },
        {
          "start": 0,
          "name": "axis",
          "type": "number"
        }
      ],
      "attrs": [
        {
          "tfName": "N",
          "name": "n",
          "type": "number",
          "defaultValue": 2
        }
      ]
    },
    {
      "tfOpName": "GatherV2",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "axis",
          "type": "number",
          "defaultValue": 0
        }
      ],
      "attrs": [
        {
          "tfName": "batch_dims",
          "name": "batchDims",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "Gather",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "validate_indices",
          "name": "validateIndices",
          "type": "bool",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Reverse",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "dims",
          "type": "bool[]"
        }
      ]
    },
    {
      "tfOpName": "ReverseV2",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "Slice",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "begin",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "size",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "StridedSlice",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "begin",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "end",
          "type": "number[]"
        },
        {
          "start": 3,
          "name": "strides",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "begin_mask",
          "name": "beginMask",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "end_mask",
          "name": "endMask",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "new_axis_mask",
          "name": "newAxisMask",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "ellipsis_mask",
          "name": "ellipsisMask",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "shrink_axis_mask",
          "name": "shrinkAxisMask",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "Pack",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "end": 0,
          "name": "tensors",
          "type": "tensors"
        }
      ],
      "attrs": [
        {
          "tfName": "axis",
          "name": "axis",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "Unpack",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "tensor",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "axis",
          "name": "axis",
          "type": "number",
          "defaultValue": 0
        },
        {
          "tfName": "num",
          "name": "num",
          "type": "number",
          "defaultValue": 0,
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "Tile",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "reps",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "Split",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "axis",
          "type": "number",
          "defaultValue": 0
        },
        {
          "start": 1,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "num_split",
          "name": "numOrSizeSplits",
          "type": "number",
          "defaultValue": 1
        }
      ]
    },
    {
      "tfOpName": "SplitV",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "numOrSizeSplits",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "axis",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "ScatterNd",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "values",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "shape",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "GatherNd",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "SparseToDense",
      "category": "slice_join",
      "inputs": [
        {
          "start": 0,
          "name": "sparseIndices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "outputShape",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "sparseValues",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "defaultValue",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "validate_indices",
          "name": "validateIndices",
          "type": "bool",
          "defaultValue": false,
          "notSupported": true
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/sparse.js
  var sparse_exports = {};
  __export(sparse_exports, {
    json: () => json17
  });
  var json17 = [
    {
      "tfOpName": "SparseFillEmptyRows",
      "category": "sparse",
      "inputs": [
        {
          "start": 0,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "values",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "denseShape",
          "type": "tensor"
        },
        {
          "start": 3,
          "name": "defaultValue",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "SparseReshape",
      "category": "sparse",
      "inputs": [
        {
          "start": 0,
          "name": "inputIndices",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "inputShape",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "newShape",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "T",
          "name": "dtype",
          "type": "dtype",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "SparseSegmentMean",
      "category": "sparse",
      "inputs": [
        {
          "start": 0,
          "name": "data",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "segmentIds",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "SparseSegmentSum",
      "category": "sparse",
      "inputs": [
        {
          "start": 0,
          "name": "data",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "indices",
          "type": "tensor"
        },
        {
          "start": 2,
          "name": "segmentIds",
          "type": "tensor"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/spectral.js
  var spectral_exports = {};
  __export(spectral_exports, {
    json: () => json18
  });
  var json18 = [
    {
      "tfOpName": "FFT",
      "category": "spectral",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "IFFT",
      "category": "spectral",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ]
    },
    {
      "tfOpName": "RFFT",
      "category": "spectral",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "fft_length",
          "type": "number",
          "notSupported": true
        }
      ]
    },
    {
      "tfOpName": "IRFFT",
      "category": "spectral",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "fft_length",
          "type": "number",
          "notSupported": true
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/string.js
  var string_exports = {};
  __export(string_exports, {
    json: () => json19
  });
  var json19 = [
    {
      "tfOpName": "StringNGrams",
      "category": "string",
      "inputs": [
        {
          "start": 0,
          "name": "data",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "dataSplits",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "separator",
          "name": "separator",
          "type": "string"
        },
        {
          "tfName": "ngram_widths",
          "name": "nGramWidths",
          "type": "number[]"
        },
        {
          "tfName": "left_pad",
          "name": "leftPad",
          "type": "string"
        },
        {
          "tfName": "right_pad",
          "name": "rightPad",
          "type": "string"
        },
        {
          "tfName": "pad_width",
          "name": "padWidth",
          "type": "number"
        },
        {
          "tfName": "preserve_short_sequences",
          "name": "preserveShortSequences",
          "type": "bool"
        }
      ],
      "outputs": [
        "ngrams",
        "ngrams_splits"
      ]
    },
    {
      "tfOpName": "StringSplit",
      "category": "string",
      "inputs": [
        {
          "start": 0,
          "name": "input",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "delimiter",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "skip_empty",
          "name": "skipEmpty",
          "type": "bool"
        }
      ],
      "outputs": [
        "indices",
        "values",
        "shape"
      ]
    },
    {
      "tfOpName": "StringToHashBucketFast",
      "category": "string",
      "inputs": [
        {
          "start": 0,
          "name": "input",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "num_buckets",
          "name": "numBuckets",
          "type": "number"
        }
      ]
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/transformation.js
  var transformation_exports = {};
  __export(transformation_exports, {
    json: () => json20
  });
  var json20 = [
    {
      "tfOpName": "Cast",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "SrcT",
          "name": "sdtype",
          "type": "dtype",
          "notSupported": true
        },
        {
          "tfName": "DstT",
          "name": "dtype",
          "type": "dtype"
        }
      ]
    },
    {
      "tfOpName": "ExpandDims",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "axis",
          "type": "number"
        }
      ]
    },
    {
      "tfOpName": "MirrorPad",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "padding",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "mode",
          "name": "mode",
          "type": "string"
        }
      ]
    },
    {
      "tfOpName": "Pad",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "padding",
          "type": "number[]"
        }
      ],
      "attrs": [
        {
          "tfName": "constant_value",
          "name": "constantValue",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "PadV2",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "padding",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "constantValue",
          "type": "number",
          "defaultValue": 0
        }
      ]
    },
    {
      "tfOpName": "Reshape",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "shape",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "Squeeze",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "axis",
          "tfDeprecatedName": "squeeze_dims",
          "name": "axis",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "SpaceToBatchND",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "blockShape",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "paddings",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "BatchToSpaceND",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "blockShape",
          "type": "number[]"
        },
        {
          "start": 2,
          "name": "crops",
          "type": "number[]"
        }
      ]
    },
    {
      "tfOpName": "DepthToSpace",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        }
      ],
      "attrs": [
        {
          "tfName": "block_size",
          "name": "blockSize",
          "type": "number"
        },
        {
          "tfName": "data_format",
          "name": "dataFormat",
          "type": "string"
        }
      ]
    },
    {
      "tfOpName": "BroadcastTo",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "x",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "shape",
          "type": "number[]"
        }
      ],
      "attrs": []
    },
    {
      "tfOpName": "BroadcastArgs",
      "category": "transformation",
      "inputs": [
        {
          "start": 0,
          "name": "s0",
          "type": "tensor"
        },
        {
          "start": 1,
          "name": "s1",
          "type": "tensor"
        }
      ],
      "attrs": []
    }
  ];

  // node_modules/@tensorflow/tfjs-converter/dist/operations/operation_mapper.js
  var OperationMapper2 = class {
    // Loads the op mapping from the JSON file.
    constructor() {
      const ops = [
        arithmetic_exports,
        basic_math_exports,
        control_exports,
        convolution_exports,
        creation_exports,
        dynamic_exports,
        evaluation_exports,
        graph_exports,
        hash_table_exports,
        image_exports,
        logical_exports,
        matrices_exports,
        normalization_exports,
        reduction_exports,
        slice_join_exports,
        sparse_exports,
        spectral_exports,
        string_exports,
        transformation_exports
      ];
      const mappersJson = [].concat(...ops.map((op2) => op2.json));
      this.opMappers = mappersJson.reduce((map, mapper) => {
        map[mapper.tfOpName] = mapper;
        return map;
      }, {});
    }
    // Singleton instance for the mapper
    static get Instance() {
      return this._instance || (this._instance = new this());
    }
    // Converts the model inference graph from Tensorflow GraphDef to local
    // representation for TensorFlow.js API
    transformGraph(graph2, signature = {}) {
      const tfNodes = graph2.node;
      const placeholders = [];
      const weights = [];
      const initNodes = [];
      const nodes = tfNodes.reduce((map, node) => {
        map[node.name] = this.mapNode(node);
        if (node.op.startsWith("Placeholder")) {
          placeholders.push(map[node.name]);
        } else if (node.op === "Const") {
          weights.push(map[node.name]);
        } else if (node.input == null || node.input.length === 0) {
          initNodes.push(map[node.name]);
        }
        return map;
      }, {});
      let inputs = [];
      const outputs = [];
      let inputNodeNameToKey = {};
      let outputNodeNameToKey = {};
      if (signature != null) {
        inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);
        outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);
      }
      const allNodes = Object.keys(nodes);
      allNodes.forEach((key) => {
        const node = nodes[key];
        node.inputNames.forEach((name, index) => {
          const [nodeName, , outputName] = getNodeNameAndIndex2(name);
          const inputNode = nodes[nodeName];
          if (inputNode.outputs != null) {
            const outputIndex = inputNode.outputs.indexOf(outputName);
            if (outputIndex !== -1) {
              const inputName = `${nodeName}:${outputIndex}`;
              node.inputNames[index] = inputName;
            }
          }
          node.inputs.push(inputNode);
          inputNode.children.push(node);
        });
      });
      if (Object.keys(outputNodeNameToKey).length === 0) {
        allNodes.forEach((key) => {
          const node = nodes[key];
          if (node.children.length === 0) {
            outputs.push(node);
          }
        });
      } else {
        Object.keys(outputNodeNameToKey).forEach((name) => {
          const [nodeName] = getNodeNameAndIndex2(name);
          const node = nodes[nodeName];
          if (node != null) {
            node.signatureKey = outputNodeNameToKey[name];
            outputs.push(node);
          }
        });
      }
      if (Object.keys(inputNodeNameToKey).length > 0) {
        Object.keys(inputNodeNameToKey).forEach((name) => {
          const [nodeName] = getNodeNameAndIndex2(name);
          const node = nodes[nodeName];
          if (node) {
            node.signatureKey = inputNodeNameToKey[name];
            inputs.push(node);
          }
        });
      } else {
        inputs = placeholders;
      }
      let functions = {};
      if (graph2.library != null && graph2.library.function != null) {
        functions = graph2.library.function.reduce((functions2, func) => {
          functions2[func.signature.name] = this.mapFunction(func);
          return functions2;
        }, {});
      }
      const result = { nodes, inputs, outputs, weights, placeholders, signature, functions };
      if (initNodes.length > 0) {
        result.initNodes = initNodes;
      }
      return result;
    }
    mapSignatureEntries(entries) {
      return Object.keys(entries || {}).reduce((prev, curr) => {
        prev[entries[curr].name] = curr;
        return prev;
      }, {});
    }
    mapNode(node) {
      const mapper = getRegisteredOp2(node.op) || this.opMappers[node.op] || {};
      if (node.attr == null) {
        node.attr = {};
      }
      const newNode = {
        name: node.name,
        op: node.op,
        category: mapper.category,
        inputNames: (node.input || []).map((input2) => input2.startsWith("^") ? input2.slice(1) : input2),
        inputs: [],
        children: [],
        inputParams: {},
        attrParams: {},
        rawAttrs: node.attr,
        outputs: mapper.outputs
      };
      if (mapper.inputs != null) {
        newNode.inputParams = mapper.inputs.reduce((map, param) => {
          map[param.name] = {
            type: param.type,
            inputIndexStart: param.start,
            inputIndexEnd: param.end
          };
          return map;
        }, {});
      }
      if (mapper.attrs != null) {
        newNode.attrParams = mapper.attrs.reduce((map, param) => {
          const type = param.type;
          let value = void 0;
          switch (param.type) {
            case "string":
              value = getStringParam2(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getStringParam2(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "string[]":
              value = getStringArrayParam2(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getStringArrayParam2(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "number":
              value = getNumberParam2(node.attr, param.tfName, param.defaultValue || 0);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getNumberParam2(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "number[]":
              value = getNumericArrayParam2(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getNumericArrayParam2(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "bool":
              value = getBoolParam2(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getBoolParam2(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "bool[]":
              value = getBoolArrayParam2(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getBoolArrayParam2(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "shape":
              value = getTensorShapeParam2(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getTensorShapeParam2(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "shape[]":
              value = getTensorShapeArrayParam2(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getTensorShapeArrayParam2(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "dtype":
              value = getDtypeParam2(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getDtypeParam2(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "dtype[]":
              value = getDtypeArrayParam2(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getDtypeArrayParam2(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "func":
              value = getFuncParam(node.attr, param.tfName, param.defaultValue);
              if (value === void 0 && !!param.tfDeprecatedName) {
                value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);
              }
              break;
            case "tensor":
            case "tensors":
              break;
            default:
              throw new Error(`Unsupported param type: ${param.type} for op: ${node.op}`);
          }
          map[param.name] = { value, type };
          return map;
        }, {});
      }
      return newNode;
    }
    // map the TFunctionDef to TFJS graph object
    mapFunction(functionDef) {
      const tfNodes = functionDef.nodeDef;
      const placeholders = [];
      const weights = [];
      let nodes = {};
      if (tfNodes != null) {
        nodes = tfNodes.reduce((map, node) => {
          map[node.name] = this.mapNode(node);
          if (node.op === "Const") {
            weights.push(map[node.name]);
          }
          return map;
        }, {});
      }
      const inputs = [];
      const outputs = [];
      functionDef.signature.inputArg.forEach((arg) => {
        const [nodeName] = getNodeNameAndIndex2(arg.name);
        const node = {
          name: nodeName,
          op: "Placeholder",
          inputs: [],
          inputNames: [],
          category: "graph",
          inputParams: {},
          attrParams: { dtype: { value: parseDtypeParam2(arg.type), type: "dtype" } },
          children: []
        };
        node.signatureKey = arg.name;
        inputs.push(node);
        nodes[nodeName] = node;
      });
      const allNodes = Object.keys(nodes);
      allNodes.forEach((key) => {
        const node = nodes[key];
        node.inputNames.forEach((name, index) => {
          const [nodeName, , outputName] = getNodeNameAndIndex2(name);
          const inputNode = nodes[nodeName];
          if (inputNode.outputs != null) {
            const outputIndex = inputNode.outputs.indexOf(outputName);
            if (outputIndex !== -1) {
              const inputName = `${nodeName}:${outputIndex}`;
              node.inputNames[index] = inputName;
            }
          }
          node.inputs.push(inputNode);
          inputNode.children.push(node);
        });
      });
      const returnNodeMap = functionDef.ret;
      functionDef.signature.outputArg.forEach((output) => {
        const [nodeName, index] = getNodeNameAndIndex2(returnNodeMap[output.name]);
        const node = nodes[nodeName];
        if (node != null) {
          node.defaultOutput = index;
          outputs.push(node);
        }
      });
      const signature = this.mapArgsToSignature(functionDef);
      return { nodes, inputs, outputs, weights, placeholders, signature };
    }
    mapArgsToSignature(functionDef) {
      return {
        methodName: functionDef.signature.name,
        inputs: functionDef.signature.inputArg.reduce((map, arg) => {
          map[arg.name] = this.mapArgToTensorInfo(arg);
          return map;
        }, {}),
        outputs: functionDef.signature.outputArg.reduce((map, arg) => {
          map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);
          return map;
        }, {})
      };
    }
    mapArgToTensorInfo(arg, nameMap2) {
      let name = arg.name;
      if (nameMap2 != null) {
        name = nameMap2[name];
      }
      return { name, dtype: arg.type };
    }
  };
  function decodeBase642(text) {
    const global2 = env().global;
    if (typeof global2.atob !== "undefined") {
      return global2.atob(text);
    } else if (typeof Buffer !== "undefined") {
      return new Buffer(text, "base64").toString();
    } else {
      throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
    }
  }
  function parseStringParam2(s2, keepCase) {
    const value = Array.isArray(s2) ? String.fromCharCode.apply(null, s2) : decodeBase642(s2);
    return keepCase ? value : value.toLowerCase();
  }
  function getStringParam2(attrs, name, def, keepCase = false) {
    const param = attrs[name];
    if (param != null) {
      return parseStringParam2(param.s, keepCase);
    }
    return def;
  }
  function getBoolParam2(attrs, name, def) {
    const param = attrs[name];
    return param ? param.b : def;
  }
  function getNumberParam2(attrs, name, def) {
    const param = attrs[name] || {};
    const value = param["i"] != null ? param["i"] : param["f"] != null ? param["f"] : def;
    return typeof value === "number" ? value : parseInt(value, 10);
  }
  function parseDtypeParam2(value) {
    if (typeof value === "string") {
      value = DataType2[value];
    }
    switch (value) {
      case DataType2.DT_FLOAT:
      case DataType2.DT_HALF:
        return "float32";
      case DataType2.DT_INT32:
      case DataType2.DT_INT64:
      case DataType2.DT_INT8:
      case DataType2.DT_UINT8:
        return "int32";
      case DataType2.DT_BOOL:
        return "bool";
      case DataType2.DT_DOUBLE:
        return "float32";
      case DataType2.DT_STRING:
        return "string";
      default:
        return null;
    }
  }
  function getFuncParam(attrs, name, def) {
    const param = attrs[name];
    if (param && param.func) {
      return param.func.name;
    }
    return def;
  }
  function getDtypeParam2(attrs, name, def) {
    const param = attrs[name];
    if (param && param.type) {
      return parseDtypeParam2(param.type);
    }
    return def;
  }
  function getDtypeArrayParam2(attrs, name, def) {
    const param = attrs[name];
    if (param && param.list && param.list.type) {
      return param.list.type.map((v2) => parseDtypeParam2(v2));
    }
    return def;
  }
  function parseTensorShapeParam2(shape) {
    if (shape.unknownRank) {
      return void 0;
    }
    if (shape.dim != null) {
      return shape.dim.map((dim) => typeof dim.size === "number" ? dim.size : parseInt(dim.size, 10));
    }
    return [];
  }
  function getTensorShapeParam2(attrs, name, def) {
    const param = attrs[name];
    if (param && param.shape) {
      return parseTensorShapeParam2(param.shape);
    }
    return def;
  }
  function getNumericArrayParam2(attrs, name, def) {
    const param = attrs[name];
    if (param) {
      return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map((v2) => typeof v2 === "number" ? v2 : parseInt(v2, 10));
    }
    return def;
  }
  function getStringArrayParam2(attrs, name, def, keepCase = false) {
    const param = attrs[name];
    if (param && param.list && param.list.s) {
      return param.list.s.map((v2) => {
        return parseStringParam2(v2, keepCase);
      });
    }
    return def;
  }
  function getTensorShapeArrayParam2(attrs, name, def) {
    const param = attrs[name];
    if (param && param.list && param.list.shape) {
      return param.list.shape.map((v2) => {
        return parseTensorShapeParam2(v2);
      });
    }
    return def;
  }
  function getBoolArrayParam2(attrs, name, def) {
    const param = attrs[name];
    if (param && param.list && param.list.b) {
      return param.list.b;
    }
    return def;
  }

  // node_modules/@tensorflow/tfjs-converter/dist/operations/custom_op/node_value_impl.js
  var NodeValueImpl2 = class {
    constructor(node, tensorMap, context) {
      this.node = node;
      this.tensorMap = tensorMap;
      this.context = context;
      this.inputs = [];
      this.attrs = {};
      this.inputs = node.inputNames.map((name) => this.getInput(name));
      if (node.rawAttrs != null) {
        this.attrs = Object.keys(node.rawAttrs).reduce((attrs, key) => {
          attrs[key] = this.getAttr(key);
          return attrs;
        }, {});
      }
    }
    /**
     * Return the value of the attribute or input param.
     * @param name String: name of attribute or input param.
     */
    getInput(name) {
      return getTensor2(name, this.tensorMap, this.context);
    }
    /**
     * Return the value of the attribute or input param.
     * @param name String: name of attribute or input param.
     */
    getAttr(name, defaultValue) {
      const value = this.node.rawAttrs[name];
      if (value.tensor != null) {
        return getTensor2(name, this.tensorMap, this.context);
      }
      if (value.i != null || value.f != null) {
        return getNumberParam2(this.node.rawAttrs, name, defaultValue);
      }
      if (value.s != null) {
        return getStringParam2(this.node.rawAttrs, name, defaultValue);
      }
      if (value.b != null) {
        return getBoolParam2(this.node.rawAttrs, name, defaultValue);
      }
      if (value.shape != null) {
        return getTensorShapeParam2(this.node.rawAttrs, name, defaultValue);
      }
      if (value.type != null) {
        return getDtypeParam2(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list != null) {
        if (value.list.i != null || value.list.f != null) {
          return getNumericArrayParam2(this.node.rawAttrs, name, defaultValue);
        }
        if (value.list.s != null) {
          return getStringArrayParam2(this.node.rawAttrs, name, defaultValue);
        }
        if (value.list.shape != null) {
          return getTensorShapeArrayParam2(this.node.rawAttrs, name, defaultValue);
        }
        if (value.list.b != null) {
          return getBoolArrayParam2(this.node.rawAttrs, name, defaultValue);
        }
        if (value.list.type != null) {
          return getDtypeArrayParam2(this.node.rawAttrs, name, defaultValue);
        }
      }
      return defaultValue;
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/ops_for_converter.js
  var ops_for_converter_exports = {};
  __export(ops_for_converter_exports, {
    OP_SCOPE_SUFFIX: () => OP_SCOPE_SUFFIX,
    abs: () => abs,
    acos: () => acos,
    acosh: () => acosh,
    add: () => add2,
    addN: () => addN,
    all: () => all,
    any: () => any,
    argMax: () => argMax,
    argMin: () => argMin,
    asin: () => asin,
    asinh: () => asinh,
    atan: () => atan,
    atan2: () => atan2,
    atanh: () => atanh,
    avgPool: () => avgPool,
    avgPool3d: () => avgPool3d,
    basicLSTMCell: () => basicLSTMCell,
    batchNorm: () => batchNorm,
    batchNorm2d: () => batchNorm2d,
    batchNorm3d: () => batchNorm3d,
    batchNorm4d: () => batchNorm4d,
    batchToSpaceND: () => batchToSpaceND,
    bincount: () => bincount,
    booleanMaskAsync: () => booleanMaskAsync,
    broadcastArgs: () => broadcastArgs,
    broadcastTo: () => broadcastTo,
    buffer: () => buffer,
    cast: () => cast,
    ceil: () => ceil,
    clipByValue: () => clipByValue,
    clone: () => clone,
    complex: () => complex,
    concat: () => concat,
    concat1d: () => concat1d,
    concat2d: () => concat2d,
    concat3d: () => concat3d,
    concat4d: () => concat4d,
    conv1d: () => conv1d,
    conv2d: () => conv2d,
    conv2dTranspose: () => conv2dTranspose,
    conv3d: () => conv3d,
    conv3dTranspose: () => conv3dTranspose,
    cos: () => cos,
    cosh: () => cosh,
    cosineWindow: () => cosineWindow,
    cumprod: () => cumprod,
    cumsum: () => cumsum,
    denseBincount: () => denseBincount,
    depthToSpace: () => depthToSpace,
    depthwiseConv2d: () => depthwiseConv2d,
    diag: () => diag,
    dilation2d: () => dilation2d,
    div: () => div,
    divNoNan: () => divNoNan,
    dot: () => dot2,
    dropout: () => dropout,
    einsum: () => einsum,
    elu: () => elu,
    enclosingPowerOfTwo: () => enclosingPowerOfTwo,
    equal: () => equal,
    erf: () => erf,
    euclideanNorm: () => euclideanNorm,
    exp: () => exp,
    expandDims: () => expandDims,
    expm1: () => expm1,
    eye: () => eye,
    fft: () => fft,
    fill: () => fill,
    floor: () => floor,
    floorDiv: () => floorDiv,
    fused: () => fused_ops_exports,
    gather: () => gather,
    gatherND: () => gatherND,
    greater: () => greater,
    greaterEqual: () => greaterEqual,
    ifft: () => ifft,
    imag: () => imag,
    image: () => image,
    inTopKAsync: () => inTopKAsync,
    irfft: () => irfft,
    isFinite: () => isFinite2,
    isInf: () => isInf,
    isNaN: () => isNaN2,
    leakyRelu: () => leakyRelu,
    less: () => less2,
    lessEqual: () => lessEqual,
    linalg: () => linalg,
    linspace: () => linspace,
    localResponseNormalization: () => localResponseNormalization,
    log: () => log2,
    log1p: () => log1p,
    logSigmoid: () => logSigmoid,
    logSoftmax: () => logSoftmax,
    logSumExp: () => logSumExp,
    logicalAnd: () => logicalAnd,
    logicalNot: () => logicalNot,
    logicalOr: () => logicalOr,
    logicalXor: () => logicalXor,
    losses: () => losses,
    lowerBound: () => lowerBound,
    matMul: () => matMul,
    max: () => max,
    maxPool: () => maxPool,
    maxPool3d: () => maxPool3d,
    maxPoolWithArgmax: () => maxPoolWithArgmax,
    maximum: () => maximum,
    mean: () => mean,
    meshgrid: () => meshgrid,
    min: () => min,
    minimum: () => minimum,
    mirrorPad: () => mirrorPad,
    mod: () => mod,
    moments: () => moments,
    movingAverage: () => movingAverage,
    mul: () => mul,
    multiRNNCell: () => multiRNNCell,
    multinomial: () => multinomial,
    neg: () => neg,
    norm: () => norm,
    notEqual: () => notEqual,
    oneHot: () => oneHot,
    ones: () => ones2,
    onesLike: () => onesLike,
    op: () => op,
    outerProduct: () => outerProduct,
    pad: () => pad,
    pad1d: () => pad1d,
    pad2d: () => pad2d,
    pad3d: () => pad3d,
    pad4d: () => pad4d,
    pool: () => pool,
    pow: () => pow,
    prelu: () => prelu,
    print: () => print,
    prod: () => prod,
    raggedGather: () => raggedGather,
    raggedRange: () => raggedRange,
    raggedTensorToTensor: () => raggedTensorToTensor,
    rand: () => rand,
    randomGamma: () => randomGamma,
    randomNormal: () => randomNormal,
    randomStandardNormal: () => randomStandardNormal,
    randomUniform: () => randomUniform,
    range: () => range2,
    real: () => real,
    reciprocal: () => reciprocal,
    relu: () => relu,
    relu6: () => relu6,
    reshape: () => reshape2,
    reverse: () => reverse,
    reverse1d: () => reverse1d,
    reverse2d: () => reverse2d,
    reverse3d: () => reverse3d,
    reverse4d: () => reverse4d,
    rfft: () => rfft,
    round: () => round2,
    rsqrt: () => rsqrt,
    scalar: () => scalar,
    scatterND: () => scatterND,
    searchSorted: () => searchSorted,
    selu: () => selu,
    separableConv2d: () => separableConv2d,
    setdiff1dAsync: () => setdiff1dAsync,
    sigmoid: () => sigmoid,
    sign: () => sign,
    signal: () => signal,
    sin: () => sin,
    sinh: () => sinh,
    slice: () => slice,
    slice1d: () => slice1d,
    slice2d: () => slice2d,
    slice3d: () => slice3d,
    slice4d: () => slice4d,
    softmax: () => softmax,
    softplus: () => softplus,
    spaceToBatchND: () => spaceToBatchND,
    sparse: () => sparse,
    sparseToDense: () => sparseToDense,
    spectral: () => spectral2,
    split: () => split,
    sqrt: () => sqrt,
    square: () => square2,
    squaredDifference: () => squaredDifference,
    squeeze: () => squeeze,
    stack: () => stack,
    step: () => step,
    stridedSlice: () => stridedSlice,
    string: () => string,
    sub: () => sub,
    sum: () => sum2,
    tan: () => tan,
    tanh: () => tanh2,
    tensor: () => tensor,
    tensor1d: () => tensor1d,
    tensor2d: () => tensor2d,
    tensor3d: () => tensor3d,
    tensor4d: () => tensor4d,
    tensor5d: () => tensor5d,
    tensor6d: () => tensor6d,
    tile: () => tile,
    topk: () => topk,
    transpose: () => transpose,
    truncatedNormal: () => truncatedNormal,
    unique: () => unique2,
    unsortedSegmentSum: () => unsortedSegmentSum,
    unstack: () => unstack,
    upperBound: () => upperBound,
    variable: () => variable,
    where: () => where,
    whereAsync: () => whereAsync,
    zeros: () => zeros,
    zerosLike: () => zerosLike
  });

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/arithmetic_executor.js
  var executeOp2 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "BiasAdd":
      case "AddV2":
      case "Add": {
        return [ops.add(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "AddN": {
        return [ops.addN(getParamValue2("tensors", node, tensorMap, context))];
      }
      case "FloorMod":
      case "Mod":
        return [ops.mod(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      case "Mul":
        return [ops.mul(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      case "RealDiv":
      case "Div": {
        return [ops.div(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "DivNoNan": {
        return [ops.divNoNan(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "FloorDiv": {
        return [ops.floorDiv(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "Sub": {
        return [ops.sub(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "Minimum": {
        return [ops.minimum(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "Maximum": {
        return [ops.maximum(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "Pow": {
        return [ops.pow(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "SquaredDifference": {
        return [ops.squaredDifference(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/basic_math_executor.js
  var executeOp3 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "Abs":
      case "ComplexAbs":
        return [ops.abs(getParamValue2("x", node, tensorMap, context))];
      case "Acos":
        return [ops.acos(getParamValue2("x", node, tensorMap, context))];
      case "Acosh":
        return [ops.acosh(getParamValue2("x", node, tensorMap, context))];
      case "Asin":
        return [ops.asin(getParamValue2("x", node, tensorMap, context))];
      case "Asinh":
        return [ops.asinh(getParamValue2("x", node, tensorMap, context))];
      case "Atan":
        return [ops.atan(getParamValue2("x", node, tensorMap, context))];
      case "Atan2":
        return [ops.atan2(getParamValue2("x", node, tensorMap, context), getParamValue2("y", node, tensorMap, context))];
      case "Atanh":
        return [ops.atanh(getParamValue2("x", node, tensorMap, context))];
      case "Ceil":
        return [ops.ceil(getParamValue2("x", node, tensorMap, context))];
      case "Complex":
        return [ops.complex(getParamValue2("real", node, tensorMap, context), getParamValue2("imag", node, tensorMap, context))];
      case "Cos":
        return [ops.cos(getParamValue2("x", node, tensorMap, context))];
      case "Cosh":
        return [ops.cosh(getParamValue2("x", node, tensorMap, context))];
      case "Elu":
        return [ops.elu(getParamValue2("x", node, tensorMap, context))];
      case "Erf":
        return [ops.erf(getParamValue2("x", node, tensorMap, context))];
      case "Exp":
        return [ops.exp(getParamValue2("x", node, tensorMap, context))];
      case "Expm1": {
        return [ops.expm1(getParamValue2("x", node, tensorMap, context))];
      }
      case "Floor":
        return [ops.floor(getParamValue2("x", node, tensorMap, context))];
      case "Log":
        return [ops.log(getParamValue2("x", node, tensorMap, context))];
      case "Log1p": {
        return [ops.log1p(getParamValue2("x", node, tensorMap, context))];
      }
      case "Imag":
        return [ops.imag(getParamValue2("x", node, tensorMap, context))];
      case "Neg":
        return [ops.neg(getParamValue2("x", node, tensorMap, context))];
      case "Reciprocal": {
        return [ops.reciprocal(getParamValue2("x", node, tensorMap, context))];
      }
      case "Real":
        return [ops.real(getParamValue2("x", node, tensorMap, context))];
      case "Relu":
        return [ops.relu(getParamValue2("x", node, tensorMap, context))];
      case "Round": {
        return [ops.round(getParamValue2("x", node, tensorMap, context))];
      }
      case "Selu":
        return [ops.selu(getParamValue2("x", node, tensorMap, context))];
      case "Sigmoid":
        return [ops.sigmoid(getParamValue2("x", node, tensorMap, context))];
      case "Sin":
        return [ops.sin(getParamValue2("x", node, tensorMap, context))];
      case "Sign": {
        return [ops.sign(getParamValue2("x", node, tensorMap, context))];
      }
      case "Sinh": {
        return [ops.sinh(getParamValue2("x", node, tensorMap, context))];
      }
      case "Softplus": {
        return [ops.softplus(getParamValue2("x", node, tensorMap, context))];
      }
      case "Sqrt": {
        return [ops.sqrt(getParamValue2("x", node, tensorMap, context))];
      }
      case "Square": {
        return [ops.square(getParamValue2("x", node, tensorMap, context))];
      }
      case "Tanh": {
        return [ops.tanh(getParamValue2("x", node, tensorMap, context))];
      }
      case "Tan":
        return [ops.tan(getParamValue2("x", node, tensorMap, context))];
      case "ClipByValue":
        return [ops.clipByValue(getParamValue2("x", node, tensorMap, context), getParamValue2("clipValueMin", node, tensorMap, context), getParamValue2("clipValueMax", node, tensorMap, context))];
      case "Relu6":
        return [ops.relu6(getParamValue2("x", node, tensorMap, context))];
      case "Rsqrt":
        return [ops.rsqrt(getTensor2(node.inputNames[0], tensorMap, context))];
      case "Prod":
        return [ops.prod(getParamValue2("x", node, tensorMap, context), getParamValue2("axes", node, tensorMap, context))];
      case "LeakyRelu":
        return [ops.leakyRelu(getParamValue2("x", node, tensorMap, context), getParamValue2("alpha", node, tensorMap, context))];
      case "Prelu":
        return [ops.prelu(getParamValue2("x", node, tensorMap, context), getParamValue2("alpha", node, tensorMap, context))];
      case "IsNan":
        return [ops.isNaN(getTensor2(node.inputNames[0], tensorMap, context))];
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_utils.js
  function assertShapesMatchAllowUndefinedSize(shapeA, shapeB, errorMessagePrefix = "") {
    if (typeof shapeA === "number" || typeof shapeB === "number") {
      return;
    }
    util_exports.assert(shapeA.length === shapeB.length, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
    for (let i2 = 0; i2 < shapeA.length; i2++) {
      const dim0 = shapeA[i2];
      const dim1 = shapeB[i2];
      util_exports.assert(dim0 < 0 || dim1 < 0 || dim0 === dim1, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
    }
  }
  function fullDefinedShape(elementShape) {
    if (typeof elementShape === "number" || elementShape.some((dim) => dim < 0)) {
      return false;
    }
    return true;
  }
  function inferElementShape(listElementShape, tensors, elementShape) {
    let partialShape = mergeElementShape(listElementShape, elementShape);
    const notfullDefinedShape = !fullDefinedShape(partialShape);
    if (notfullDefinedShape && tensors.length === 0) {
      throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${partialShape}`);
    }
    if (notfullDefinedShape) {
      tensors.forEach((tensor2) => {
        partialShape = mergeElementShape(tensor2.shape, partialShape);
      });
    }
    if (!fullDefinedShape(partialShape)) {
      throw new Error(`Non-fully-defined elementShape: ${partialShape}`);
    }
    return partialShape;
  }
  function mergeElementShape(elementShapeA, elementShapeB) {
    if (typeof elementShapeA === "number") {
      return elementShapeB;
    }
    if (typeof elementShapeB === "number") {
      return elementShapeA;
    }
    if (elementShapeA.length !== elementShapeB.length) {
      throw new Error(`Incompatible ranks during merge: ${elementShapeA} vs. ${elementShapeB}`);
    }
    const result = [];
    for (let i2 = 0; i2 < elementShapeA.length; ++i2) {
      const dim0 = elementShapeA[i2];
      const dim1 = elementShapeB[i2];
      if (dim0 >= 0 && dim1 >= 0 && dim0 !== dim1) {
        throw new Error(`Incompatible shape during merge: ${elementShapeA} vs. ${elementShapeB}`);
      }
      result[i2] = dim0 >= 0 ? dim0 : dim1;
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_array.js
  var TensorArray2 = class {
    constructor(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {
      this.name = name;
      this.dtype = dtype;
      this.maxSize = maxSize;
      this.elementShape = elementShape;
      this.identicalElementShapes = identicalElementShapes;
      this.dynamicSize = dynamicSize;
      this.clearAfterRead = clearAfterRead;
      this.tensors = [];
      this.closed_ = false;
      this.idTensor = scalar(0);
      keep(this.idTensor);
    }
    get id() {
      return this.idTensor.id;
    }
    get closed() {
      return this.closed_;
    }
    /**
     * Dispose the tensors and idTensor and mark the TensoryArray as closed.
     */
    clearAndClose(keepIds) {
      this.tensors.forEach((tensor2) => {
        if (keepIds == null || !keepIds.has(tensor2.tensor.id)) {
          tensor2.tensor.dispose();
        }
      });
      this.tensors = [];
      this.closed_ = true;
      this.idTensor.dispose();
    }
    size() {
      return this.tensors.length;
    }
    /**
     * Read the value at location index in the TensorArray.
     * @param index Number the index to read from.
     */
    read(index) {
      if (this.closed_) {
        throw new Error(`TensorArray ${this.name} has already been closed.`);
      }
      if (index < 0 || index >= this.size()) {
        throw new Error(`Tried to read from index ${index}, but array size is: ${this.size()}`);
      }
      const tensorWithState = this.tensors[index];
      if (tensorWithState.cleared) {
        throw new Error(`TensorArray ${this.name}: Could not read index ${index} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
      }
      if (this.clearAfterRead) {
        tensorWithState.cleared = true;
      }
      tensorWithState.read = true;
      return tensorWithState.tensor;
    }
    /**
     * Helper method to read multiple tensors from the specified indices.
     */
    readMany(indices) {
      return indices.map((index) => this.read(index));
    }
    /**
     * Write value into the index of the TensorArray.
     * @param index number the index to write to.
     * @param tensor
     */
    write(index, tensor2) {
      if (this.closed_) {
        throw new Error(`TensorArray ${this.name} has already been closed.`);
      }
      if (index < 0 || !this.dynamicSize && index >= this.maxSize) {
        throw new Error(`Tried to write to index ${index}, but array is not resizeable and size is: ${this.maxSize}`);
      }
      const t3 = this.tensors[index] || {};
      if (tensor2.dtype !== this.dtype) {
        throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index},
          because the value dtype is ${tensor2.dtype}, but TensorArray dtype is ${this.dtype}.`);
      }
      if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0)) {
        this.elementShape = tensor2.shape;
      }
      assertShapesMatchAllowUndefinedSize(this.elementShape, tensor2.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${index}.`);
      if (t3.read) {
        throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index}, because it has already been read.`);
      }
      if (t3.written) {
        throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index}, because it has already been written.`);
      }
      t3.tensor = tensor2;
      keep(tensor2);
      t3.written = true;
      this.tensors[index] = t3;
    }
    /**
     * Helper method to write multiple tensors to the specified indices.
     */
    writeMany(indices, tensors) {
      if (indices.length !== tensors.length) {
        throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${indices.length} is not the same as tensors size: ${tensors.length}.`);
      }
      indices.forEach((i2, index) => this.write(i2, tensors[index]));
    }
    /**
     * Return selected values in the TensorArray as a packed Tensor. All of
     * selected values must have been written and their shapes must all match.
     * @param [indices] number[] Optional. Taking values in [0, max_value). If the
     *    TensorArray is not dynamic, max_value=size(). If not specified returns
     *    all tensors in the original order.
     * @param [dtype]
     */
    gather(indices, dtype) {
      if (!!dtype && dtype !== this.dtype) {
        throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${dtype}`);
      }
      if (!indices) {
        indices = [];
        for (let i2 = 0; i2 < this.size(); i2++) {
          indices.push(i2);
        }
      } else {
        indices = indices.slice(0, this.size());
      }
      if (indices.length === 0) {
        return tensor([], [0].concat(this.elementShape));
      }
      const tensors = this.readMany(indices);
      assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, "TensorArray shape mismatch: ");
      return stack(tensors, 0);
    }
    /**
     * Return the values in the TensorArray as a concatenated Tensor.
     */
    concat(dtype) {
      if (!!dtype && dtype !== this.dtype) {
        throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${dtype}`);
      }
      if (this.size() === 0) {
        return tensor([], [0].concat(this.elementShape));
      }
      const indices = [];
      for (let i2 = 0; i2 < this.size(); i2++) {
        indices.push(i2);
      }
      const tensors = this.readMany(indices);
      assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${tensors[0].shape})`);
      return concat(tensors, 0);
    }
    /**
     * Scatter the values of a Tensor in specific indices of a TensorArray.
     * @param indices nummber[] values in [0, max_value). If the
     *    TensorArray is not dynamic, max_value=size().
     * @param tensor Tensor input tensor.
     */
    scatter(indices, tensor2) {
      if (tensor2.dtype !== this.dtype) {
        throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor2.dtype}`);
      }
      if (indices.length !== tensor2.shape[0]) {
        throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor2.shape[0]}`);
      }
      const maxIndex = Math.max(...indices);
      if (!this.dynamicSize && maxIndex >= this.maxSize) {
        throw new Error(`Max index must be < array size (${maxIndex}  vs. ${this.maxSize})`);
      }
      this.writeMany(indices, unstack(tensor2, 0));
    }
    /**
     * Split the values of a Tensor into the TensorArray.
     * @param length number[] with the lengths to use when splitting value along
     *    its first dimension.
     * @param tensor Tensor, the tensor to split.
     */
    split(length, tensor2) {
      if (tensor2.dtype !== this.dtype) {
        throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor2.dtype}`);
      }
      let totalLength = 0;
      const cumulativeLengths = length.map((len) => {
        totalLength += len;
        return totalLength;
      });
      if (totalLength !== tensor2.shape[0]) {
        throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor2.shape}`);
      }
      if (!this.dynamicSize && length.length !== this.maxSize) {
        throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${length.length}), and the TensorArray is not marked as dynamically resizeable`);
      }
      const elementPerRow = totalLength === 0 ? 0 : tensor2.size / totalLength;
      const tensors = [];
      tidy(() => {
        tensor2 = reshape2(tensor2, [1, totalLength, elementPerRow]);
        for (let i2 = 0; i2 < length.length; ++i2) {
          const previousLength = i2 === 0 ? 0 : cumulativeLengths[i2 - 1];
          const indices2 = [0, previousLength, 0];
          const sizes = [1, length[i2], elementPerRow];
          tensors[i2] = reshape2(slice(tensor2, indices2, sizes), this.elementShape);
        }
        return tensors;
      });
      const indices = [];
      for (let i2 = 0; i2 < length.length; i2++) {
        indices[i2] = i2;
      }
      this.writeMany(indices, tensors);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_list.js
  var TensorList = class {
    /**
     *
     * @param tensors list of tensors
     * @param elementShape shape of each tensor, this can be a single number (any
     * shape is allowed) or partial shape (dim = -1).
     * @param elementDtype data type of each tensor
     * @param maxNumElements The maximum allowed size of `tensors`. Defaults to -1
     *   meaning that the size of `tensors` is unbounded.
     */
    constructor(tensors, elementShape, elementDtype, maxNumElements = -1) {
      this.tensors = tensors;
      this.elementShape = elementShape;
      this.elementDtype = elementDtype;
      if (tensors != null) {
        tensors.forEach((tensor2) => {
          if (elementDtype !== tensor2.dtype) {
            throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${tensor2.dtype}`);
          }
          assertShapesMatchAllowUndefinedSize(elementShape, tensor2.shape, "TensorList shape mismatch: ");
          keep(tensor2);
        });
      }
      this.idTensor = scalar(0);
      this.maxNumElements = maxNumElements;
      keep(this.idTensor);
    }
    get id() {
      return this.idTensor.id;
    }
    /**
     * Get a new TensorList containing a copy of the underlying tensor container.
     */
    copy() {
      return new TensorList([...this.tensors], this.elementShape, this.elementDtype);
    }
    /**
     * Dispose the tensors and idTensor and clear the tensor list.
     */
    clearAndClose(keepIds) {
      this.tensors.forEach((tensor2) => {
        if (keepIds == null || !keepIds.has(tensor2.id)) {
          tensor2.dispose();
        }
      });
      this.tensors.length = 0;
      this.idTensor.dispose();
    }
    /**
     * The size of the tensors in the tensor list.
     */
    size() {
      return this.tensors.length;
    }
    /**
     * Return a tensor that stacks a list of rank-R tf.Tensors into one rank-(R+1)
     * tf.Tensor.
     * @param elementShape shape of each tensor
     * @param elementDtype data type of each tensor
     * @param numElements the number of elements to stack
     */
    stack(elementShape, elementDtype, numElements = -1) {
      if (elementDtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
      }
      if (numElements !== -1 && this.tensors.length !== numElements) {
        throw new Error(`Operation expected a list with ${numElements} elements but got a list with ${this.tensors.length} elements.`);
      }
      assertShapesMatchAllowUndefinedSize(elementShape, this.elementShape, "TensorList shape mismatch: ");
      const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
      return tidy(() => {
        const reshapedTensors = this.tensors.map((tensor2) => reshape2(tensor2, outputElementShape));
        return stack(reshapedTensors, 0);
      });
    }
    /**
     * Pop a tensor from the end of the list.
     * @param elementShape shape of the tensor
     * @param elementDtype data type of the tensor
     */
    popBack(elementShape, elementDtype) {
      if (elementDtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
      }
      if (this.size() === 0) {
        throw new Error("Trying to pop from an empty list.");
      }
      const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
      const tensor2 = this.tensors.pop();
      tensor2.kept = false;
      assertShapesMatchAllowUndefinedSize(tensor2.shape, elementShape, "TensorList shape mismatch: ");
      return reshape2(tensor2, outputElementShape);
    }
    /**
     * Push a tensor to the end of the list.
     * @param tensor Tensor to be pushed.
     */
    pushBack(tensor2) {
      if (tensor2.dtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${this.elementDtype}`);
      }
      assertShapesMatchAllowUndefinedSize(tensor2.shape, this.elementShape, "TensorList shape mismatch: ");
      if (this.maxNumElements === this.size()) {
        throw new Error(`Trying to push element into a full list.`);
      }
      keep(tensor2);
      this.tensors.push(tensor2);
    }
    /**
     * Update the size of the list.
     * @param size the new size of the list.
     */
    resize(size) {
      if (size < 0) {
        throw new Error(`TensorListResize expects size to be non-negative. Got: ${size}`);
      }
      if (this.maxNumElements !== -1 && size > this.maxNumElements) {
        throw new Error(`TensorListResize input size ${size} is greater maxNumElement ${this.maxNumElements}.`);
      }
      const destTensorList = new TensorList([], this.elementShape, this.elementDtype, this.maxNumElements);
      destTensorList.tensors.length = size;
      for (let i2 = 0; i2 < Math.min(this.tensors.length, size); ++i2) {
        destTensorList.tensors[i2] = this.tensors[i2];
      }
      return destTensorList;
    }
    /**
     * Retrieve the element at the provided index
     * @param elementShape shape of the tensor
     * @param elementDtype dtype of the tensor
     * @param elementIndex index of the tensor
     */
    getItem(elementIndex, elementShape, elementDtype) {
      if (elementDtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
      }
      if (elementIndex < 0 || elementIndex > this.tensors.length) {
        throw new Error(`Trying to access element ${elementIndex} in a list with ${this.tensors.length} elements.`);
      }
      if (this.tensors[elementIndex] == null) {
        throw new Error(`element at index ${elementIndex} is null.`);
      }
      assertShapesMatchAllowUndefinedSize(this.tensors[elementIndex].shape, elementShape, "TensorList shape mismatch: ");
      const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
      return reshape2(this.tensors[elementIndex], outputElementShape);
    }
    /**
     * Set the tensor at the index
     * @param elementIndex index of the tensor
     * @param tensor the tensor to be inserted into the list
     */
    setItem(elementIndex, tensor2) {
      if (tensor2.dtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${this.elementDtype}`);
      }
      if (elementIndex < 0 || this.maxNumElements !== -1 && elementIndex >= this.maxNumElements) {
        throw new Error(`Trying to set element ${elementIndex} in a list with max ${this.maxNumElements} elements.`);
      }
      assertShapesMatchAllowUndefinedSize(this.elementShape, tensor2.shape, "TensorList shape mismatch: ");
      keep(tensor2);
      if (this.tensors[elementIndex] != null) {
        this.tensors[elementIndex].kept = false;
      }
      this.tensors[elementIndex] = tensor2;
    }
    /**
     * Return selected values in the TensorList as a stacked Tensor. All of
     * selected values must have been written and their shapes must all match.
     * @param indices indices of tensors to gather
     * @param elementDtype output tensor dtype
     * @param elementShape output tensor element shape
     */
    gather(indices, elementDtype, elementShape) {
      if (elementDtype !== this.elementDtype) {
        throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
      }
      assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
      indices = indices.slice(0, this.size());
      const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
      if (indices.length === 0) {
        return tensor([], [0].concat(outputElementShape));
      }
      return tidy(() => {
        const tensors = indices.map((i2) => reshape2(this.tensors[i2], outputElementShape));
        return stack(tensors, 0);
      });
    }
    /**
     * Return the values in the TensorList as a concatenated Tensor.
     * @param elementDtype output tensor dtype
     * @param elementShape output tensor element shape
     */
    concat(elementDtype, elementShape) {
      if (!!elementDtype && elementDtype !== this.elementDtype) {
        throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${elementDtype}`);
      }
      assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
      const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
      if (this.size() === 0) {
        return tensor([], [0].concat(outputElementShape));
      }
      return tidy(() => {
        const tensors = this.tensors.map((t3) => reshape2(t3, outputElementShape));
        return concat(tensors, 0);
      });
    }
  };
  function fromTensor(tensor2, elementShape, elementDtype) {
    const dtype = tensor2.dtype;
    if (tensor2.shape.length < 1) {
      throw new Error(`Tensor must be at least a vector, but saw shape: ${tensor2.shape}`);
    }
    if (tensor2.dtype !== elementDtype) {
      throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${elementDtype}`);
    }
    const tensorElementShape = tensor2.shape.slice(1);
    assertShapesMatchAllowUndefinedSize(tensorElementShape, elementShape, "TensorList shape mismatch: ");
    const tensorList = unstack(tensor2);
    return new TensorList(tensorList, elementShape, dtype);
  }
  function reserve(elementShape, elementDtype, numElements, maxNumElements) {
    return new TensorList([], elementShape, elementDtype, maxNumElements);
  }
  function scatter(tensor2, indices, elementShape, numElements) {
    if (indices.length !== tensor2.shape[0]) {
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor2.shape[0]}`);
    }
    const maxIndex = Math.max(...indices);
    if (numElements != null && numElements !== -1 && maxIndex >= numElements) {
      throw new Error(`Max index must be < array size (${maxIndex}  vs. ${numElements})`);
    }
    const list = new TensorList([], elementShape, tensor2.dtype, numElements);
    const tensors = unstack(tensor2, 0);
    indices.forEach((value, index) => {
      list.setItem(value, tensors[index]);
    });
    return list;
  }
  function split3(tensor2, length, elementShape) {
    let totalLength = 0;
    const cumulativeLengths = length.map((len) => {
      totalLength += len;
      return totalLength;
    });
    if (totalLength !== tensor2.shape[0]) {
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor2.shape}`);
    }
    const shapeWithoutFirstDim = tensor2.shape.slice(1);
    const outputElementShape = mergeElementShape(shapeWithoutFirstDim, elementShape);
    const elementPerRow = totalLength === 0 ? 0 : tensor2.size / totalLength;
    const tensors = tidy(() => {
      const tensors2 = [];
      tensor2 = reshape2(tensor2, [1, totalLength, elementPerRow]);
      for (let i2 = 0; i2 < length.length; ++i2) {
        const previousLength = i2 === 0 ? 0 : cumulativeLengths[i2 - 1];
        const indices = [0, previousLength, 0];
        const sizes = [1, length[i2], elementPerRow];
        tensors2[i2] = reshape2(slice(tensor2, indices, sizes), outputElementShape);
      }
      tensor2.dispose();
      return tensors2;
    });
    const list = new TensorList([], elementShape, tensor2.dtype, length.length);
    for (let i2 = 0; i2 < tensors.length; i2++) {
      list.setItem(i2, tensors[i2]);
    }
    return list;
  }

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/control_executor.js
  var executeOp4 = async (node, tensorMap, context) => {
    switch (node.op) {
      case "If":
      case "StatelessIf": {
        const thenFunc = getParamValue2("thenBranch", node, tensorMap, context);
        const elseFunc = getParamValue2("elseBranch", node, tensorMap, context);
        const cond = getParamValue2("cond", node, tensorMap, context);
        const args = getParamValue2("args", node, tensorMap, context);
        const condValue = await cond.data();
        if (condValue[0]) {
          return context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
        } else {
          return context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
        }
      }
      case "While":
      case "StatelessWhile": {
        const bodyFunc = getParamValue2("body", node, tensorMap, context);
        const condFunc = getParamValue2("cond", node, tensorMap, context);
        const args = getParamValue2("args", node, tensorMap, context);
        const condResult = await context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
        const argIds = args.map((tensor2) => tensor2.id);
        let condValue = await condResult[0].data();
        condResult.forEach((tensor2) => {
          if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1) {
            tensor2.dispose();
          }
        });
        let result = args;
        while (condValue[0]) {
          const origResult = result;
          result = await context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);
          const resultIds = result.map((tensor2) => tensor2.id);
          origResult.forEach((tensor2) => {
            if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1 && resultIds.indexOf(tensor2.id) === -1) {
              tensor2.dispose();
            }
          });
          const condResult2 = await context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);
          condValue = await condResult2[0].data();
          condResult2.forEach((tensor2) => {
            if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1 && resultIds.indexOf(tensor2.id) === -1) {
              tensor2.dispose();
            }
          });
        }
        return result;
      }
      case "LoopCond": {
        const pred = getParamValue2("pred", node, tensorMap, context);
        return [cloneTensor(pred)];
      }
      case "Switch": {
        const pred = getParamValue2("pred", node, tensorMap, context);
        let data = getParamValue2("data", node, tensorMap, context);
        if (!data.kept) {
          data = cloneTensor(data);
        }
        return (await pred.data())[0] ? [void 0, data] : [data, void 0];
      }
      case "Merge": {
        const inputName = node.inputNames.find((name) => getTensor2(name, tensorMap, context) !== void 0);
        if (inputName) {
          const data = getTensor2(inputName, tensorMap, context);
          return [cloneTensor(data)];
        }
        return void 0;
      }
      case "Enter": {
        const frameId = getParamValue2("frameName", node, tensorMap, context);
        const data = getParamValue2("tensor", node, tensorMap, context);
        context.enterFrame(frameId);
        return [cloneTensor(data)];
      }
      case "Exit": {
        const data = getParamValue2("tensor", node, tensorMap, context);
        context.exitFrame();
        return [cloneTensor(data)];
      }
      case "NextIteration": {
        const data = getParamValue2("tensor", node, tensorMap, context);
        context.nextIteration();
        return [cloneTensor(data)];
      }
      case "TensorArrayV3": {
        const size = getParamValue2("size", node, tensorMap, context);
        const dtype = getParamValue2("dtype", node, tensorMap, context);
        const elementShape = getParamValue2("elementShape", node, tensorMap, context);
        const dynamicSize = getParamValue2("dynamicSize", node, tensorMap, context);
        const clearAfterRead = getParamValue2("clearAfterRead", node, tensorMap, context);
        const identicalElementShapes = getParamValue2("identicalElementShapes", node, tensorMap, context);
        const name = getParamValue2("name", node, tensorMap, context);
        const tensorArray = new TensorArray2(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);
        context.addTensorArray(tensorArray);
        return [tensorArray.idTensor, scalar(1)];
      }
      case "TensorArrayWriteV3": {
        const id = getParamValue2("tensorArrayId", node, tensorMap, context);
        const index = getParamValue2("index", node, tensorMap, context);
        const writeTensor = getParamValue2("tensor", node, tensorMap, context);
        const writeTensorArray = context.getTensorArray(id.id);
        writeTensorArray.write(index, writeTensor);
        return [writeTensorArray.idTensor];
      }
      case "TensorArrayReadV3": {
        const readId = getParamValue2("tensorArrayId", node, tensorMap, context);
        const readIndex = getParamValue2("index", node, tensorMap, context);
        const readTensorArray = context.getTensorArray(readId.id);
        return [readTensorArray.read(readIndex)];
      }
      case "TensorArrayGatherV3": {
        const gatherId = getParamValue2("tensorArrayId", node, tensorMap, context);
        const gatherIndices = getParamValue2("indices", node, tensorMap, context);
        const gatherDtype = getParamValue2("dtype", node, tensorMap, context);
        const gatherTensorArray = context.getTensorArray(gatherId.id);
        return [gatherTensorArray.gather(gatherIndices, gatherDtype)];
      }
      case "TensorArrayScatterV3": {
        const scatterId = getParamValue2("tensorArrayId", node, tensorMap, context);
        const scatterIndices = getParamValue2("indices", node, tensorMap, context);
        const scatterTensor = getParamValue2("tensor", node, tensorMap, context);
        const scatterTensorArray = context.getTensorArray(scatterId.id);
        scatterTensorArray.scatter(scatterIndices, scatterTensor);
        return [scatterTensorArray.idTensor];
      }
      case "TensorArrayConcatV3": {
        const concatId = getParamValue2("tensorArrayId", node, tensorMap, context);
        const concatTensorArray = context.getTensorArray(concatId.id);
        const concatDtype = getParamValue2("dtype", node, tensorMap, context);
        return [concatTensorArray.concat(concatDtype)];
      }
      case "TensorArraySplitV3": {
        const splitId = getParamValue2("tensorArrayId", node, tensorMap, context);
        const splitTensor = getParamValue2("tensor", node, tensorMap, context);
        const lengths = getParamValue2("lengths", node, tensorMap, context);
        const splitTensorArray = context.getTensorArray(splitId.id);
        splitTensorArray.split(lengths, splitTensor);
        return [splitTensorArray.idTensor];
      }
      case "TensorArraySizeV3": {
        const sizeId = getParamValue2("tensorArrayId", node, tensorMap, context);
        const sizeTensorArray = context.getTensorArray(sizeId.id);
        return [scalar(sizeTensorArray.size(), "int32")];
      }
      case "TensorArrayCloseV3": {
        const closeId = getParamValue2("tensorArrayId", node, tensorMap, context);
        const closeTensorArray = context.getTensorArray(closeId.id);
        closeTensorArray.clearAndClose();
        return [closeTensorArray.idTensor];
      }
      case "TensorListSetItem": {
        const idTensor = getParamValue2("tensorListId", node, tensorMap, context);
        const index = getParamValue2("index", node, tensorMap, context);
        const writeTensor = getParamValue2("tensor", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        tensorList.setItem(index, writeTensor);
        return [tensorList.idTensor];
      }
      case "TensorListGetItem": {
        const idTensor = getParamValue2("tensorListId", node, tensorMap, context);
        const readIndex = getParamValue2("index", node, tensorMap, context);
        const elementShape = getParamValue2("elementShape", node, tensorMap, context);
        const elementDType = getParamValue2("elementDType", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        return [tensorList.getItem(readIndex, elementShape, elementDType)];
      }
      case "TensorListScatterV2":
      case "TensorListScatter": {
        const scatterIndices = getParamValue2("indices", node, tensorMap, context);
        const scatterTensor = getParamValue2("tensor", node, tensorMap, context);
        const elementShape = getParamValue2("elementShape", node, tensorMap, context);
        const numElements = getParamValue2("numElements", node, tensorMap, context);
        const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);
        context.addTensorList(tensorList);
        return [tensorList.idTensor];
      }
      case "TensorListReserve":
      case "EmptyTensorList": {
        const elementShape = getParamValue2("elementShape", node, tensorMap, context);
        const elementDtype = getParamValue2("elementDType", node, tensorMap, context);
        let numElementsParam;
        if (node.op === "TensorListReserve") {
          numElementsParam = "numElements";
        } else {
          numElementsParam = "maxNumElements";
        }
        const numElements = getParamValue2(numElementsParam, node, tensorMap, context);
        const maxNumElements = node.op === "TensorListReserve" ? -1 : numElements;
        const tensorList = reserve(elementShape, elementDtype, numElements, maxNumElements);
        context.addTensorList(tensorList);
        return [tensorList.idTensor];
      }
      case "TensorListGather": {
        const gatherId = getParamValue2("tensorListId", node, tensorMap, context);
        const gatherIndices = getParamValue2("indices", node, tensorMap, context);
        const elementShape = getParamValue2("elementShape", node, tensorMap, context);
        const elementDtype = getParamValue2("elementDType", node, tensorMap, context);
        const tensorList = context.getTensorList(gatherId.id);
        return [tensorList.gather(gatherIndices, elementDtype, elementShape)];
      }
      case "TensorListStack": {
        const idTensor = getParamValue2("tensorListId", node, tensorMap, context);
        const elementShape = getParamValue2("elementShape", node, tensorMap, context);
        const elementDtype = getParamValue2("elementDType", node, tensorMap, context);
        const numElements = getParamValue2("numElements", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        return [tensorList.stack(elementShape, elementDtype, numElements)];
      }
      case "TensorListFromTensor": {
        const tensor2 = getParamValue2("tensor", node, tensorMap, context);
        const elementShape = getParamValue2("elementShape", node, tensorMap, context);
        const elementDtype = getParamValue2("elementDType", node, tensorMap, context);
        const tensorList = fromTensor(tensor2, elementShape, elementDtype);
        context.addTensorList(tensorList);
        return [tensorList.idTensor];
      }
      case "TensorListConcat":
      case "TensorListConcatV2": {
        const concatId = getParamValue2("tensorListId", node, tensorMap, context);
        const tensorList = context.getTensorList(concatId.id);
        const concatDtype = getParamValue2("dtype", node, tensorMap, context);
        const elementShape = getParamValue2("elementShape", node, tensorMap, context);
        return [tensorList.concat(concatDtype, elementShape)];
      }
      case "TensorListPushBack": {
        const idTensor = getParamValue2("tensorListId", node, tensorMap, context);
        const writeTensor = getParamValue2("tensor", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        tensorList.pushBack(writeTensor);
        return [tensorList.idTensor];
      }
      case "TensorListPopBack": {
        const idTensor = getParamValue2("tensorListId", node, tensorMap, context);
        const elementShape = getParamValue2("elementShape", node, tensorMap, context);
        const elementDType = getParamValue2("elementDType", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        return [tensorList.popBack(elementShape, elementDType)];
      }
      case "TensorListSplit": {
        const splitTensor = getParamValue2("tensor", node, tensorMap, context);
        const elementShape = getParamValue2("elementShape", node, tensorMap, context);
        const lengths = getParamValue2("lengths", node, tensorMap, context);
        const tensorList = split3(splitTensor, lengths, elementShape);
        context.addTensorList(tensorList);
        return [tensorList.idTensor];
      }
      case "TensorListLength": {
        const idTensor = getParamValue2("tensorListId", node, tensorMap, context);
        const tensorList = context.getTensorList(idTensor.id);
        return [scalar(tensorList.size(), "int32")];
      }
      case "TensorListResize": {
        const idTensor = getParamValue2("tensorListId", node, tensorMap, context);
        const size = getParamValue2("size", node, tensorMap, context);
        const srcTensorList = context.getTensorList(idTensor.id);
        const destTensorList = srcTensorList.resize(size);
        context.addTensorList(destTensorList);
        return [destTensorList.idTensor];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/convolution_executor.js
  function fusedConvAndDepthWiseParams(node, tensorMap, context) {
    const [extraOp, activationFunc] = getParamValue2("fusedOps", node, tensorMap, context);
    const isBiasAdd = extraOp === "biasadd";
    const noBiasAdd = !isBiasAdd;
    const isPrelu = activationFunc === "prelu";
    const isBatchNorm = extraOp === "fusedbatchnorm";
    const numArgs = getParamValue2("numArgs", node, tensorMap, context);
    if (isBiasAdd) {
      if (isPrelu && numArgs !== 2) {
        throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
      }
      if (!isPrelu && isBiasAdd && numArgs !== 1) {
        throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
      }
    }
    if (isBatchNorm) {
      throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
    }
    const stride = getParamValue2("strides", node, tensorMap, context);
    const pad2 = getPadding(node, tensorMap, context);
    const dataFormat = getParamValue2("dataFormat", node, tensorMap, context).toUpperCase();
    const dilations = getParamValue2("dilations", node, tensorMap, context);
    let [biasArg, preluArg] = getParamValue2("args", node, tensorMap, context);
    if (noBiasAdd) {
      preluArg = biasArg;
      biasArg = void 0;
    }
    const leakyreluAlpha = getParamValue2("leakyreluAlpha", node, tensorMap, context);
    return {
      stride,
      pad: pad2,
      dataFormat,
      dilations,
      biasArg,
      preluArg,
      activationFunc,
      leakyreluAlpha
    };
  }
  var executeOp5 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "Conv1D": {
        const stride = getParamValue2("stride", node, tensorMap, context);
        const pad2 = getParamValue2("pad", node, tensorMap, context);
        const dataFormat = getParamValue2("dataFormat", node, tensorMap, context).toUpperCase();
        const dilation = getParamValue2("dilation", node, tensorMap, context);
        return [ops.conv1d(getParamValue2("x", node, tensorMap, context), getParamValue2("filter", node, tensorMap, context), stride, pad2, dataFormat, dilation)];
      }
      case "Conv2D": {
        const stride = getParamValue2("strides", node, tensorMap, context);
        const pad2 = getPadding(node, tensorMap, context);
        const dataFormat = getParamValue2("dataFormat", node, tensorMap, context).toUpperCase();
        const dilations = getParamValue2("dilations", node, tensorMap, context);
        return [ops.conv2d(getParamValue2("x", node, tensorMap, context), getParamValue2("filter", node, tensorMap, context), [stride[1], stride[2]], pad2, dataFormat, [dilations[1], dilations[2]])];
      }
      case "_FusedConv2D": {
        const { stride, pad: pad2, dataFormat, dilations, biasArg, preluArg, activationFunc, leakyreluAlpha } = fusedConvAndDepthWiseParams(node, tensorMap, context);
        return [ops.fused.conv2d({
          x: getParamValue2("x", node, tensorMap, context),
          filter: getParamValue2("filter", node, tensorMap, context),
          strides: [stride[1], stride[2]],
          pad: pad2,
          dataFormat,
          dilations: [dilations[1], dilations[2]],
          bias: biasArg,
          activation: activationFunc,
          preluActivationWeights: preluArg,
          leakyreluAlpha
        })];
      }
      case "FusedDepthwiseConv2dNative": {
        const { stride, pad: pad2, dataFormat, dilations, biasArg, preluArg, activationFunc, leakyreluAlpha } = fusedConvAndDepthWiseParams(node, tensorMap, context);
        return [ops.fused.depthwiseConv2d({
          x: getParamValue2("x", node, tensorMap, context),
          filter: getParamValue2("filter", node, tensorMap, context),
          strides: [stride[1], stride[2]],
          pad: pad2,
          dataFormat,
          dilations: [dilations[1], dilations[2]],
          bias: biasArg,
          activation: activationFunc,
          preluActivationWeights: preluArg,
          leakyreluAlpha
        })];
      }
      case "Conv2DBackpropInput":
      case "Conv2dTranspose": {
        const shape = getParamValue2("outputShape", node, tensorMap, context);
        const stride = getParamValue2("strides", node, tensorMap, context);
        const pad2 = getPadding(node, tensorMap, context);
        return [ops.conv2dTranspose(getParamValue2("x", node, tensorMap, context), getParamValue2("filter", node, tensorMap, context), shape, [stride[1], stride[2]], pad2)];
      }
      case "DepthwiseConv2dNative":
      case "DepthwiseConv2d": {
        const stride = getParamValue2("strides", node, tensorMap, context);
        const pad2 = getPadding(node, tensorMap, context);
        const dilations = getParamValue2("dilations", node, tensorMap, context);
        const dataFormat = getParamValue2("dataFormat", node, tensorMap, context).toUpperCase();
        return [ops.depthwiseConv2d(getParamValue2("input", node, tensorMap, context), getParamValue2("filter", node, tensorMap, context), [stride[1], stride[2]], pad2, dataFormat, [dilations[1], dilations[2]])];
      }
      case "Conv3D": {
        const stride = getParamValue2("strides", node, tensorMap, context);
        const pad2 = getParamValue2("pad", node, tensorMap, context);
        const dataFormat = getParamValue2("dataFormat", node, tensorMap, context).toUpperCase();
        const dilations = getParamValue2("dilations", node, tensorMap, context);
        return [ops.conv3d(getParamValue2("x", node, tensorMap, context), getParamValue2("filter", node, tensorMap, context), [stride[1], stride[2], stride[3]], pad2, dataFormat, [dilations[1], dilations[2], dilations[3]])];
      }
      case "AvgPool": {
        const stride = getParamValue2("strides", node, tensorMap, context);
        const pad2 = getParamValue2("pad", node, tensorMap, context);
        const kernelSize = getParamValue2("kernelSize", node, tensorMap, context);
        return [ops.avgPool(getParamValue2("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad2)];
      }
      case "MaxPool": {
        const stride = getParamValue2("strides", node, tensorMap, context);
        const pad2 = getParamValue2("pad", node, tensorMap, context);
        const kernelSize = getParamValue2("kernelSize", node, tensorMap, context);
        return [ops.maxPool(getParamValue2("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad2)];
      }
      case "MaxPoolWithArgmax": {
        const stride = getParamValue2("strides", node, tensorMap, context);
        const pad2 = getParamValue2("pad", node, tensorMap, context);
        const kernelSize = getParamValue2("kernelSize", node, tensorMap, context);
        const includeBatchInIndex = getParamValue2("includeBatchInIndex", node, tensorMap, context);
        const { result, indexes } = ops.maxPoolWithArgmax(getParamValue2("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad2, includeBatchInIndex);
        return [result, indexes];
      }
      case "AvgPool3D": {
        const stride = getParamValue2("strides", node, tensorMap, context);
        const pad2 = getParamValue2("pad", node, tensorMap, context);
        const kernelSize = getParamValue2("kernelSize", node, tensorMap, context);
        return [ops.avgPool3d(getParamValue2("x", node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad2)];
      }
      case "MaxPool3D": {
        const stride = getParamValue2("strides", node, tensorMap, context);
        const pad2 = getParamValue2("pad", node, tensorMap, context);
        const kernelSize = getParamValue2("kernelSize", node, tensorMap, context);
        return [ops.maxPool3d(getParamValue2("x", node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad2)];
      }
      case "Dilation2D": {
        const strides = getParamValue2("strides", node, tensorMap, context);
        const pad2 = getParamValue2("pad", node, tensorMap, context);
        const dilations = getParamValue2("dilations", node, tensorMap, context);
        const strideHeight = strides[1];
        const strideWidth = strides[2];
        const dilationHeight = dilations[1];
        const dilationWidth = dilations[2];
        return [ops.dilation2d(
          getParamValue2("x", node, tensorMap, context),
          getParamValue2("filter", node, tensorMap, context),
          [strideHeight, strideWidth],
          pad2,
          [dilationHeight, dilationWidth],
          "NHWC"
          /* dataFormat */
        )];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/creation_executor.js
  var executeOp6 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "Fill": {
        const shape = getParamValue2("shape", node, tensorMap, context);
        const dtype = getParamValue2("dtype", node, tensorMap, context);
        const value = getParamValue2("value", node, tensorMap, context);
        return [ops.fill(shape, value, dtype)];
      }
      case "LinSpace": {
        const start = getParamValue2("start", node, tensorMap, context);
        const stop = getParamValue2("stop", node, tensorMap, context);
        const num = getParamValue2("num", node, tensorMap, context);
        return [ops.linspace(start, stop, num)];
      }
      case "Multinomial": {
        const logits = getParamValue2("logits", node, tensorMap, context);
        const numSamples = getParamValue2("numSamples", node, tensorMap, context);
        const seed = getParamValue2("seed", node, tensorMap, context);
        return [ops.multinomial(logits, numSamples, seed)];
      }
      case "OneHot": {
        const indices = getParamValue2("indices", node, tensorMap, context);
        const depth = getParamValue2("depth", node, tensorMap, context);
        const onValue = getParamValue2("onValue", node, tensorMap, context);
        const offValue = getParamValue2("offValue", node, tensorMap, context);
        const dtype = getParamValue2("dtype", node, tensorMap, context);
        return [ops.oneHot(indices, depth, onValue, offValue, dtype)];
      }
      case "Ones": {
        return [ops.ones(getParamValue2("shape", node, tensorMap, context), getParamValue2("dtype", node, tensorMap, context))];
      }
      case "OnesLike": {
        return [ops.onesLike(getParamValue2("x", node, tensorMap, context))];
      }
      case "RandomStandardNormal": {
        return [ops.randomStandardNormal(getParamValue2("shape", node, tensorMap, context), getParamValue2("dtype", node, tensorMap, context), getParamValue2("seed", node, tensorMap, context))];
      }
      case "RandomUniform": {
        return [ops.randomUniform(
          // tslint:disable-next-line:no-any
          getParamValue2("shape", node, tensorMap, context),
          getParamValue2("minval", node, tensorMap, context),
          getParamValue2("maxval", node, tensorMap, context),
          getParamValue2("dtype", node, tensorMap, context)
        )];
      }
      case "Range": {
        const start = getParamValue2("start", node, tensorMap, context);
        const stop = getParamValue2("stop", node, tensorMap, context);
        const step3 = getParamValue2("step", node, tensorMap, context);
        return [ops.range(start, stop, step3, getParamValue2("dtype", node, tensorMap, context))];
      }
      case "TruncatedNormal": {
        const shape = getParamValue2("shape", node, tensorMap, context);
        const mean2 = getParamValue2("mean", node, tensorMap, context);
        const stdDev = getParamValue2("stdDev", node, tensorMap, context);
        const seed = getParamValue2("seed", node, tensorMap, context);
        return [ops.truncatedNormal(shape, mean2, stdDev, getParamValue2("dtype", node, tensorMap, context), seed)];
      }
      case "Zeros": {
        return [ops.zeros(getParamValue2("shape", node, tensorMap, context), getParamValue2("dtype", node, tensorMap, context))];
      }
      case "ZerosLike": {
        return [ops.zerosLike(getParamValue2("x", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/dynamic_executor.js
  function nmsParams(node, tensorMap, context) {
    const boxes = getParamValue2("boxes", node, tensorMap, context);
    const scores = getParamValue2("scores", node, tensorMap, context);
    const maxOutputSize = getParamValue2("maxOutputSize", node, tensorMap, context);
    const iouThreshold = getParamValue2("iouThreshold", node, tensorMap, context);
    const scoreThreshold = getParamValue2("scoreThreshold", node, tensorMap, context);
    const softNmsSigma = getParamValue2("softNmsSigma", node, tensorMap, context);
    return {
      boxes,
      scores,
      maxOutputSize,
      iouThreshold,
      scoreThreshold,
      softNmsSigma
    };
  }
  var executeOp7 = async (node, tensorMap, context, resourceManager, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "NonMaxSuppressionV5": {
        const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = nmsParams(node, tensorMap, context);
        const result = await ops.image.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
        return [result.selectedIndices, result.selectedScores];
      }
      case "NonMaxSuppressionV4": {
        const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node, tensorMap, context);
        const padToMaxOutputSize = getParamValue2("padToMaxOutputSize", node, tensorMap, context);
        const result = await ops.image.nonMaxSuppressionPaddedAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
        return [result.selectedIndices, result.validOutputs];
      }
      case "NonMaxSuppressionV3":
      case "NonMaxSuppressionV2": {
        const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node, tensorMap, context);
        return [await ops.image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];
      }
      case "Where": {
        const condition = ops.cast(getParamValue2("condition", node, tensorMap, context), "bool");
        const result = [await ops.whereAsync(condition)];
        condition.dispose();
        return result;
      }
      case "ListDiff": {
        return ops.setdiff1dAsync(getParamValue2("x", node, tensorMap, context), getParamValue2("y", node, tensorMap, context));
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/evaluation_executor.js
  var executeOp8 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "LowerBound": {
        const sortedSequence = getParamValue2("sortedSequence", node, tensorMap, context);
        const values = getParamValue2("values", node, tensorMap, context);
        return [ops.lowerBound(sortedSequence, values)];
      }
      case "TopKV2": {
        const x2 = getParamValue2("x", node, tensorMap, context);
        const k4 = getParamValue2("k", node, tensorMap, context);
        const sorted = getParamValue2("sorted", node, tensorMap, context);
        const result = ops.topk(x2, k4, sorted);
        return [result.values, result.indices];
      }
      case "UpperBound": {
        const sortedSequence = getParamValue2("sortedSequence", node, tensorMap, context);
        const values = getParamValue2("values", node, tensorMap, context);
        return [ops.upperBound(sortedSequence, values)];
      }
      case "Unique": {
        const x2 = getParamValue2("x", node, tensorMap, context);
        const result = ops.unique(x2);
        return [result.values, result.indices];
      }
      case "UniqueV2": {
        const x2 = getParamValue2("x", node, tensorMap, context);
        const axis = getParamValue2("axis", node, tensorMap, context);
        const result = ops.unique(x2, axis);
        return [result.values, result.indices];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/graph_executor.js
  var executeOp9 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "Const": {
        return tensorMap[node.name];
      }
      case "PlaceholderWithDefault":
        const def = getParamValue2("default", node, tensorMap, context);
        return [getTensor2(node.name, tensorMap, context) || def];
      case "Placeholder":
        return [getTensor2(node.name, tensorMap, context)];
      case "Identity":
      case "StopGradient":
      case "FakeQuantWithMinMaxVars": {
        const data2 = getParamValue2("x", node, tensorMap, context);
        return [cloneTensor(data2)];
      }
      case "IdentityN":
        return getParamValue2("x", node, tensorMap, context).map((t3) => cloneTensor(t3));
      case "Snapshot":
        const snapshot = getParamValue2("x", node, tensorMap, context);
        return [cloneTensor(snapshot)];
      case "Shape":
        return [ops.tensor1d(getParamValue2("x", node, tensorMap, context).shape, "int32")];
      case "ShapeN":
        return getParamValue2("x", node, tensorMap, context).map((t3) => ops.tensor1d(t3.shape));
      case "Size":
        return [ops.scalar(getParamValue2("x", node, tensorMap, context).size, "int32")];
      case "Rank":
        return [ops.scalar(getParamValue2("x", node, tensorMap, context).rank, "int32")];
      case "NoOp":
        return [ops.scalar(1)];
      case "Print":
        const input2 = getParamValue2("x", node, tensorMap, context);
        const data = getParamValue2("data", node, tensorMap, context);
        const message = getParamValue2("message", node, tensorMap, context);
        const summarize = getParamValue2("summarize", node, tensorMap, context);
        console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance.");
        console.log(message);
        for (let i2 = 0; i2 < data.length; i2++) {
          console.log(Array.prototype.slice.call(data[i2].dataSync()).slice(0, summarize));
        }
        return [input2];
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/executor/hash_table.js
  var HashTable = class {
    /**
     * Constructor of HashTable. Creates a hash table.
     *
     * @param keyDType `dtype` of the table keys.
     * @param valueDType `dtype` of the table values.
     */
    constructor(keyDType, valueDType) {
      this.keyDType = keyDType;
      this.valueDType = valueDType;
      this.handle = scalar(0);
      this.tensorMap = /* @__PURE__ */ new Map();
      keep(this.handle);
    }
    get id() {
      return this.handle.id;
    }
    /**
     * Dispose the tensors and handle and clear the hashtable.
     */
    clearAndClose() {
      this.tensorMap.forEach((value) => value.dispose());
      this.tensorMap.clear();
      this.handle.dispose();
    }
    /**
     * The number of items in the hash table.
     */
    size() {
      return this.tensorMap.size;
    }
    /**
     * The number of items in the hash table as a rank-0 tensor.
     */
    tensorSize() {
      return scalar(this.size(), "int32");
    }
    /**
     * Replaces the contents of the table with the specified keys and values.
     * @param keys Keys to store in the hashtable.
     * @param values Values to store in the hashtable.
     */
    async import(keys, values) {
      this.checkKeyAndValueTensor(keys, values);
      const $keys = await keys.data();
      this.tensorMap.forEach((value) => value.dispose());
      this.tensorMap.clear();
      return tidy(() => {
        const $values = unstack(values);
        const keysLength = $keys.length;
        const valuesLength = $values.length;
        util_exports.assert(keysLength === valuesLength, () => `The number of elements doesn't match, keys has ${keysLength} elements, the values has ${valuesLength} elements.`);
        for (let i2 = 0; i2 < keysLength; i2++) {
          const key = $keys[i2];
          const value = $values[i2];
          keep(value);
          this.tensorMap.set(key, value);
        }
        return this.handle;
      });
    }
    /**
     * Looks up keys in a hash table, outputs the corresponding values.
     *
     * Performs batch lookups, for every element in the key tensor, `find`
     * stacks the corresponding value into the return tensor.
     *
     * If an element is not present in the table, the given `defaultValue` is
     * used.
     *
     * @param keys Keys to look up. Must have the same type as the keys of the
     *     table.
     * @param defaultValue The scalar `defaultValue` is the value output for keys
     *     not present in the table. It must also be of the same type as the
     *     table values.
     */
    async find(keys, defaultValue) {
      this.checkKeyAndValueTensor(keys, defaultValue);
      const $keys = await keys.data();
      return tidy(() => {
        const result = [];
        for (let i2 = 0; i2 < $keys.length; i2++) {
          const key = $keys[i2];
          const value = this.findWithDefault(key, defaultValue);
          result.push(value);
        }
        return stack(result);
      });
    }
    // tslint:disable-next-line: no-any
    findWithDefault(key, defaultValue) {
      const result = this.tensorMap.get(key);
      return result != null ? result : defaultValue;
    }
    checkKeyAndValueTensor(key, value) {
      if (key.dtype !== this.keyDType) {
        throw new Error(`Expect key dtype ${this.keyDType}, but got ${key.dtype}`);
      }
      if (value.dtype !== this.valueDType) {
        throw new Error(`Expect value dtype ${this.valueDType}, but got ${value.dtype}`);
      }
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/hash_table_executor.js
  var executeOp10 = async (node, tensorMap, context, resourceManager) => {
    switch (node.op) {
      case "HashTable":
      case "HashTableV2": {
        const existingTableHandle = resourceManager.getHashTableHandleByName(node.name);
        if (existingTableHandle != null) {
          return [existingTableHandle];
        } else {
          const keyDType = getParamValue2("keyDType", node, tensorMap, context);
          const valueDType = getParamValue2("valueDType", node, tensorMap, context);
          const hashTable = new HashTable(keyDType, valueDType);
          resourceManager.addHashTable(node.name, hashTable);
          return [hashTable.handle];
        }
      }
      case "InitializeTable":
      case "InitializeTableV2":
      case "LookupTableImport":
      case "LookupTableImportV2": {
        const handle = getParamValue2("tableHandle", node, tensorMap, context, resourceManager);
        const keys = getParamValue2("keys", node, tensorMap, context);
        const values = getParamValue2("values", node, tensorMap, context);
        const hashTable = resourceManager.getHashTableById(handle.id);
        return [await hashTable.import(keys, values)];
      }
      case "LookupTableFind":
      case "LookupTableFindV2": {
        const handle = getParamValue2("tableHandle", node, tensorMap, context, resourceManager);
        const keys = getParamValue2("keys", node, tensorMap, context);
        const defaultValue = getParamValue2("defaultValue", node, tensorMap, context);
        const hashTable = resourceManager.getHashTableById(handle.id);
        return [await hashTable.find(keys, defaultValue)];
      }
      case "LookupTableSize":
      case "LookupTableSizeV2": {
        const handle = getParamValue2("tableHandle", node, tensorMap, context, resourceManager);
        const hashTable = resourceManager.getHashTableById(handle.id);
        return [hashTable.tensorSize()];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/image_executor.js
  var executeOp11 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "ResizeBilinear": {
        const images = getParamValue2("images", node, tensorMap, context);
        const size = getParamValue2("size", node, tensorMap, context);
        const alignCorners = getParamValue2("alignCorners", node, tensorMap, context);
        const halfPixelCenters = getParamValue2("halfPixelCenters", node, tensorMap, context);
        return [ops.image.resizeBilinear(images, [size[0], size[1]], alignCorners, halfPixelCenters)];
      }
      case "ResizeNearestNeighbor": {
        const images = getParamValue2("images", node, tensorMap, context);
        const size = getParamValue2("size", node, tensorMap, context);
        const alignCorners = getParamValue2("alignCorners", node, tensorMap, context);
        const halfPixelCenters = getParamValue2("halfPixelCenters", node, tensorMap, context);
        return [ops.image.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners, halfPixelCenters)];
      }
      case "CropAndResize": {
        const image2 = getParamValue2("image", node, tensorMap, context);
        const boxes = getParamValue2("boxes", node, tensorMap, context);
        const boxInd = getParamValue2("boxInd", node, tensorMap, context);
        const cropSize = getParamValue2("cropSize", node, tensorMap, context);
        const method = getParamValue2("method", node, tensorMap, context);
        const extrapolationValue = getParamValue2("extrapolationValue", node, tensorMap, context);
        return [ops.image.cropAndResize(image2, boxes, boxInd, cropSize, method, extrapolationValue)];
      }
      case "ImageProjectiveTransformV3": {
        const images = getParamValue2("images", node, tensorMap, context);
        const transforms = getParamValue2("transforms", node, tensorMap, context);
        const outputShape = getParamValue2("outputShape", node, tensorMap, context);
        const fillValue = getParamValue2("fillValue", node, tensorMap, context);
        const interpolation = getParamValue2("interpolation", node, tensorMap, context);
        const fillMode = getParamValue2("fillMode", node, tensorMap, context);
        return [ops.image.transform(images, transforms, interpolation.toLowerCase(), fillMode.toLowerCase(), fillValue, outputShape)];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/logical_executor.js
  var executeOp12 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "Equal": {
        return [ops.equal(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "NotEqual": {
        return [ops.notEqual(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "Greater": {
        return [ops.greater(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "GreaterEqual": {
        return [ops.greaterEqual(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "Less": {
        return [ops.less(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "LessEqual": {
        return [ops.lessEqual(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "LogicalAnd": {
        return [ops.logicalAnd(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "LogicalNot": {
        return [ops.logicalNot(getParamValue2("a", node, tensorMap, context))];
      }
      case "LogicalOr": {
        return [ops.logicalOr(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      case "Select":
      case "SelectV2": {
        return [ops.where(getParamValue2("condition", node, tensorMap, context), getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/matrices_executor.js
  var executeOp13 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "BatchMatMul":
      case "BatchMatMulV2":
      case "MatMul":
        return [ops.matMul(getParamValue2("a", node, tensorMap, context), getParamValue2("b", node, tensorMap, context), getParamValue2("transposeA", node, tensorMap, context), getParamValue2("transposeB", node, tensorMap, context))];
      case "Einsum":
        return [ops.einsum(getParamValue2("equation", node, tensorMap, context), ...getParamValue2("tensors", node, tensorMap, context))];
      case "Transpose":
        return [ops.transpose(getParamValue2("x", node, tensorMap, context), getParamValue2("perm", node, tensorMap, context))];
      case "_FusedMatMul":
        const [extraOp, activationFunc] = getParamValue2("fusedOps", node, tensorMap, context);
        const isBiasAdd = extraOp === "biasadd";
        const isPrelu = activationFunc === "prelu";
        const numArgs = getParamValue2("numArgs", node, tensorMap, context);
        const leakyreluAlpha = getParamValue2("leakyreluAlpha", node, tensorMap, context);
        if (isBiasAdd) {
          if (isPrelu && numArgs !== 2) {
            throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
          }
          if (!isPrelu && numArgs !== 1) {
            throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
          }
        }
        const [biasArg, preluArg] = getParamValue2("args", node, tensorMap, context);
        return [ops.fused.matMul({
          a: getParamValue2("a", node, tensorMap, context),
          b: getParamValue2("b", node, tensorMap, context),
          transposeA: getParamValue2("transposeA", node, tensorMap, context),
          transposeB: getParamValue2("transposeB", node, tensorMap, context),
          bias: biasArg,
          activation: activationFunc,
          preluActivationWeights: preluArg,
          leakyreluAlpha
        })];
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/normalization_executor.js
  var executeOp14 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "EuclideanNorm":
        return [ops.euclideanNorm(getParamValue2("x", node, tensorMap, context), getParamValue2("axis", node, tensorMap, context), getParamValue2("keepDims", node, tensorMap, context))];
      case "FusedBatchNorm":
      case "FusedBatchNormV2": {
        return [ops.batchNorm(getParamValue2("x", node, tensorMap, context), getParamValue2("mean", node, tensorMap, context), getParamValue2("variance", node, tensorMap, context), getParamValue2("offset", node, tensorMap, context), getParamValue2("scale", node, tensorMap, context), getParamValue2("epsilon", node, tensorMap, context))];
      }
      case "FusedBatchNormV3": {
        return [ops.batchNorm(getParamValue2("x", node, tensorMap, context), getParamValue2("mean", node, tensorMap, context), getParamValue2("variance", node, tensorMap, context), getParamValue2("offset", node, tensorMap, context), getParamValue2("scale", node, tensorMap, context), getParamValue2("epsilon", node, tensorMap, context))];
      }
      case "LRN": {
        return [ops.localResponseNormalization(getParamValue2("x", node, tensorMap, context), getParamValue2("radius", node, tensorMap, context), getParamValue2("bias", node, tensorMap, context), getParamValue2("alpha", node, tensorMap, context), getParamValue2("beta", node, tensorMap, context))];
      }
      case "Softmax": {
        return [ops.softmax(getParamValue2("x", node, tensorMap, context))];
      }
      case "LogSoftmax": {
        return [ops.logSoftmax(getParamValue2("x", node, tensorMap, context))];
      }
      case "SparseToDense": {
        return [ops.sparseToDense(getParamValue2("sparseIndices", node, tensorMap, context), getParamValue2("outputShape", node, tensorMap, context), getParamValue2("sparseValues", node, tensorMap, context), getParamValue2("defaultValue", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/ragged_executor.js
  var executeOp15 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "RaggedGather": {
        const { outputNestedSplits, outputDenseValues } = ops.raggedGather(getParamValue2("paramsNestedSplits", node, tensorMap, context), getParamValue2("paramsDenseValues", node, tensorMap, context), getParamValue2("indices", node, tensorMap, context), getParamValue2("outputRaggedRank", node, tensorMap, context));
        return outputNestedSplits.concat(outputDenseValues);
      }
      case "RaggedRange": {
        const { rtNestedSplits, rtDenseValues } = ops.raggedRange(getParamValue2("starts", node, tensorMap, context), getParamValue2("limits", node, tensorMap, context), getParamValue2("splits", node, tensorMap, context));
        return [rtNestedSplits, rtDenseValues];
      }
      case "RaggedTensorToTensor": {
        return [ops.raggedTensorToTensor(getParamValue2("shape", node, tensorMap, context), getParamValue2("values", node, tensorMap, context), getParamValue2("defaultValue", node, tensorMap, context), getParamValue2("rowPartitionTensors", node, tensorMap, context), getParamValue2("rowPartitionTypes", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/reduction_executor.js
  var executeOp16 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "Max": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const keepDims = getParamValue2("keepDims", node, tensorMap, context);
        return [ops.max(getParamValue2("x", node, tensorMap, context), axis, keepDims)];
      }
      case "Mean": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const keepDims = getParamValue2("keepDims", node, tensorMap, context);
        return [ops.mean(getParamValue2("x", node, tensorMap, context), axis, keepDims)];
      }
      case "Min": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const keepDims = getParamValue2("keepDims", node, tensorMap, context);
        return [ops.min(getParamValue2("x", node, tensorMap, context), axis, keepDims)];
      }
      case "Sum": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const keepDims = getParamValue2("keepDims", node, tensorMap, context);
        return [ops.sum(getParamValue2("x", node, tensorMap, context), axis, keepDims)];
      }
      case "All": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const keepDims = getParamValue2("keepDims", node, tensorMap, context);
        return [ops.all(getParamValue2("x", node, tensorMap, context), axis, keepDims)];
      }
      case "Any": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const keepDims = getParamValue2("keepDims", node, tensorMap, context);
        return [ops.any(getParamValue2("x", node, tensorMap, context), axis, keepDims)];
      }
      case "ArgMax": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        return [ops.argMax(getParamValue2("x", node, tensorMap, context), axis)];
      }
      case "ArgMin": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        return [ops.argMin(getParamValue2("x", node, tensorMap, context), axis)];
      }
      case "Prod": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const keepDims = getParamValue2("keepDims", node, tensorMap, context);
        return [ops.prod(getParamValue2("x", node, tensorMap, context), axis, keepDims)];
      }
      case "Cumprod": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const exclusive = getParamValue2("exclusive", node, tensorMap, context);
        const reverse3 = getParamValue2("reverse", node, tensorMap, context);
        return [ops.cumprod(getParamValue2("x", node, tensorMap, context), axis, exclusive, reverse3)];
      }
      case "Cumsum": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const exclusive = getParamValue2("exclusive", node, tensorMap, context);
        const reverse3 = getParamValue2("reverse", node, tensorMap, context);
        return [ops.cumsum(getParamValue2("x", node, tensorMap, context), axis, exclusive, reverse3)];
      }
      case "Bincount":
        const x2 = getParamValue2("x", node, tensorMap, context);
        const weights = getParamValue2("weights", node, tensorMap, context);
        const size = getParamValue2("size", node, tensorMap, context);
        return [ops.bincount(x2, weights, size)];
      case "DenseBincount": {
        const x3 = getParamValue2("x", node, tensorMap, context);
        const weights2 = getParamValue2("weights", node, tensorMap, context);
        const size2 = getParamValue2("size", node, tensorMap, context);
        const binaryOutput = getParamValue2("binaryOutput", node, tensorMap, context);
        return [ops.denseBincount(x3, weights2, size2, binaryOutput)];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/slice_join_executor.js
  var executeOp17 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "ConcatV2":
      case "Concat": {
        const n2 = getParamValue2("n", node, tensorMap, context);
        const axis = getParamValue2("axis", node, tensorMap, context);
        let inputs = getParamValue2("tensors", node, tensorMap, context);
        inputs = inputs.slice(0, n2);
        return [ops.concat(inputs, axis)];
      }
      case "Gather": {
        const input2 = getParamValue2("x", node, tensorMap, context);
        const indices = getParamValue2("indices", node, tensorMap, context);
        return [ops.gather(input2, ops.cast(indices, "int32"), 0)];
      }
      case "GatherV2": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const batchDims = getParamValue2("batchDims", node, tensorMap, context);
        const input2 = getParamValue2("x", node, tensorMap, context);
        const indices = getParamValue2("indices", node, tensorMap, context);
        return [ops.gather(input2, ops.cast(indices, "int32"), axis, batchDims)];
      }
      case "Reverse": {
        const dims = getParamValue2("dims", node, tensorMap, context);
        const axis = [];
        for (let i2 = 0; i2 < dims.length; i2++) {
          if (dims[i2]) {
            axis.push(i2);
          }
        }
        const input2 = getParamValue2("x", node, tensorMap, context);
        return [ops.reverse(input2, axis)];
      }
      case "ReverseV2": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const input2 = getParamValue2("x", node, tensorMap, context);
        return [ops.reverse(input2, axis)];
      }
      case "Slice": {
        const begin = getParamValue2("begin", node, tensorMap, context);
        const size = getParamValue2("size", node, tensorMap, context);
        return [ops.slice(getParamValue2("x", node, tensorMap, context), begin, size)];
      }
      case "StridedSlice": {
        const begin = getParamValue2("begin", node, tensorMap, context);
        const end = getParamValue2("end", node, tensorMap, context);
        const strides = getParamValue2("strides", node, tensorMap, context);
        const beginMask = getParamValue2("beginMask", node, tensorMap, context);
        const endMask = getParamValue2("endMask", node, tensorMap, context);
        const ellipsisMask = getParamValue2("ellipsisMask", node, tensorMap, context);
        const newAxisMask = getParamValue2("newAxisMask", node, tensorMap, context);
        const shrinkAxisMask = getParamValue2("shrinkAxisMask", node, tensorMap, context);
        const tensor2 = getParamValue2("x", node, tensorMap, context);
        return [ops.stridedSlice(tensor2, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];
      }
      case "Pack": {
        return tidy(() => {
          const axis = getParamValue2("axis", node, tensorMap, context);
          const tensors = getParamValue2("tensors", node, tensorMap, context);
          const shape = tensors[0].shape;
          const squeezedShape = ops.squeeze(tensors[0]).shape;
          const mapped = tensors.map((tensor2) => {
            const sameShape = util_exports.arraysEqual(tensor2.shape, shape);
            if (!sameShape && !util_exports.arraysEqual(ops.squeeze(tensor2).shape, squeezedShape)) {
              throw new Error("the input tensors shape does not match");
            }
            return sameShape ? tensor2 : ops.reshape(tensor2, shape);
          });
          return [ops.stack(mapped, axis)];
        });
      }
      case "Unpack": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const tensor2 = getParamValue2("tensor", node, tensorMap, context);
        return ops.unstack(tensor2, axis);
      }
      case "Tile": {
        const reps = getParamValue2("reps", node, tensorMap, context);
        return [ops.tile(getParamValue2("x", node, tensorMap, context), reps)];
      }
      case "Split":
      case "SplitV": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        const numOrSizeSplits = getParamValue2("numOrSizeSplits", node, tensorMap, context);
        const tensor2 = getParamValue2("x", node, tensorMap, context);
        return ops.split(tensor2, numOrSizeSplits, axis);
      }
      case "ScatterNd": {
        const indices = getParamValue2("indices", node, tensorMap, context);
        const values = getParamValue2("values", node, tensorMap, context);
        const shape = getParamValue2("shape", node, tensorMap, context);
        return [ops.scatterND(indices, values, shape)];
      }
      case "GatherNd": {
        const x2 = getParamValue2("x", node, tensorMap, context);
        const indices = getParamValue2("indices", node, tensorMap, context);
        return [ops.gatherND(x2, indices)];
      }
      case "SparseToDense": {
        const indices = getParamValue2("sparseIndices", node, tensorMap, context);
        const shape = getParamValue2("outputShape", node, tensorMap, context);
        const sparseValues = getParamValue2("sparseValues", node, tensorMap, context);
        const defaultValue = getParamValue2("defaultValue", node, tensorMap, context);
        return [ops.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops.cast(defaultValue, sparseValues.dtype))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/sparse_executor.js
  var executeOp18 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "SparseFillEmptyRows": {
        const { outputIndices, outputValues, emptyRowIndicator, reverseIndexMap } = ops.sparse.sparseFillEmptyRows(getParamValue2("indices", node, tensorMap, context), getParamValue2("values", node, tensorMap, context), getParamValue2("denseShape", node, tensorMap, context), getParamValue2("defaultValue", node, tensorMap, context));
        return [
          outputIndices,
          outputValues,
          emptyRowIndicator,
          reverseIndexMap
        ];
      }
      case "SparseReshape": {
        const { outputIndices, outputShape } = ops.sparse.sparseReshape(getParamValue2("inputIndices", node, tensorMap, context), getParamValue2("inputShape", node, tensorMap, context), getParamValue2("newShape", node, tensorMap, context));
        return [outputIndices, outputShape];
      }
      case "SparseSegmentMean": {
        const outputData = ops.sparse.sparseSegmentMean(getParamValue2("data", node, tensorMap, context), getParamValue2("indices", node, tensorMap, context), getParamValue2("segmentIds", node, tensorMap, context));
        return [outputData];
      }
      case "SparseSegmentSum": {
        const outputData = ops.sparse.sparseSegmentSum(getParamValue2("data", node, tensorMap, context), getParamValue2("indices", node, tensorMap, context), getParamValue2("segmentIds", node, tensorMap, context));
        return [outputData];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/spectral_executor.js
  var executeOp19 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "FFT": {
        return [ops.fft(getParamValue2("x", node, tensorMap, context))];
      }
      case "IFFT": {
        return [ops.ifft(getParamValue2("x", node, tensorMap, context))];
      }
      case "RFFT": {
        return [ops.rfft(getParamValue2("x", node, tensorMap, context))];
      }
      case "IRFFT": {
        return [ops.irfft(getParamValue2("x", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/string_executor.js
  var executeOp20 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "StringNGrams": {
        const { nGrams, nGramsSplits } = ops.string.stringNGrams(getParamValue2("data", node, tensorMap, context), getParamValue2("dataSplits", node, tensorMap, context), getParamValue2("separator", node, tensorMap, context), getParamValue2("nGramWidths", node, tensorMap, context), getParamValue2("leftPad", node, tensorMap, context), getParamValue2("rightPad", node, tensorMap, context), getParamValue2("padWidth", node, tensorMap, context), getParamValue2("preserveShortSequences", node, tensorMap, context));
        return [nGrams, nGramsSplits];
      }
      case "StringSplit": {
        const { indices, values, shape } = ops.string.stringSplit(getParamValue2("input", node, tensorMap, context), getParamValue2("delimiter", node, tensorMap, context), getParamValue2("skipEmpty", node, tensorMap, context));
        return [indices, values, shape];
      }
      case "StringToHashBucketFast": {
        const output = ops.string.stringToHashBucketFast(getParamValue2("input", node, tensorMap, context), getParamValue2("numBuckets", node, tensorMap, context));
        return [output];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/executors/transformation_executor.js
  var executeOp21 = (node, tensorMap, context, ops = ops_for_converter_exports) => {
    switch (node.op) {
      case "Cast": {
        return [ops.cast(getParamValue2("x", node, tensorMap, context), getParamValue2("dtype", node, tensorMap, context))];
      }
      case "ExpandDims": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        return [ops.expandDims(getParamValue2("x", node, tensorMap, context), axis)];
      }
      case "Squeeze": {
        const axis = getParamValue2("axis", node, tensorMap, context);
        return [ops.squeeze(getParamValue2("x", node, tensorMap, context), axis)];
      }
      case "Reshape": {
        return [ops.reshape(getParamValue2("x", node, tensorMap, context), getParamValue2("shape", node, tensorMap, context))];
      }
      case "MirrorPad": {
        return [ops.mirrorPad(getParamValue2("x", node, tensorMap, context), getParamValue2("padding", node, tensorMap, context), getParamValue2("mode", node, tensorMap, context))];
      }
      case "PadV2":
      case "Pad": {
        return [ops.pad(getParamValue2("x", node, tensorMap, context), getParamValue2("padding", node, tensorMap, context), getParamValue2("constantValue", node, tensorMap, context))];
      }
      case "SpaceToBatchND": {
        const blockShape = getParamValue2("blockShape", node, tensorMap, context);
        const paddings = getParamValue2("paddings", node, tensorMap, context);
        return [ops.spaceToBatchND(getParamValue2("x", node, tensorMap, context), blockShape, paddings)];
      }
      case "BatchToSpaceND": {
        const blockShape = getParamValue2("blockShape", node, tensorMap, context);
        const crops = getParamValue2("crops", node, tensorMap, context);
        return [ops.batchToSpaceND(getParamValue2("x", node, tensorMap, context), blockShape, crops)];
      }
      case "DepthToSpace": {
        const blockSize = getParamValue2("blockSize", node, tensorMap, context);
        const dataFormat = getParamValue2("dataFormat", node, tensorMap, context).toUpperCase();
        return [ops.depthToSpace(getParamValue2("x", node, tensorMap, context), blockSize, dataFormat)];
      }
      case "BroadcastTo": {
        return [ops.broadcastTo(getParamValue2("x", node, tensorMap, context), getParamValue2("shape", node, tensorMap, context))];
      }
      case "BroadcastArgs": {
        return [ops.broadcastArgs(getParamValue2("s0", node, tensorMap, context), getParamValue2("s1", node, tensorMap, context))];
      }
      default:
        throw TypeError(`Node type ${node.op} is not implemented`);
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/operations/operation_executor.js
  function executeOp22(node, tensorMap, context, resourceManager, tidy2 = tidy) {
    const value = ((node2, tensorMap2, context2) => {
      switch (node2.category) {
        case "arithmetic":
          return tidy2(() => executeOp2(node2, tensorMap2, context2));
        case "basic_math":
          return tidy2(() => executeOp3(node2, tensorMap2, context2));
        case "control":
          return executeOp4(node2, tensorMap2, context2);
        case "convolution":
          return tidy2(() => executeOp5(node2, tensorMap2, context2));
        case "creation":
          return tidy2(() => executeOp6(node2, tensorMap2, context2));
        case "dynamic":
          return executeOp7(node2, tensorMap2, context2);
        case "evaluation":
          return tidy2(() => executeOp8(node2, tensorMap2, context2));
        case "image":
          return tidy2(() => executeOp11(node2, tensorMap2, context2));
        case "graph":
          return tidy2(() => executeOp9(node2, tensorMap2, context2));
        case "logical":
          return tidy2(() => executeOp12(node2, tensorMap2, context2));
        case "matrices":
          return tidy2(() => executeOp13(node2, tensorMap2, context2));
        case "normalization":
          return tidy2(() => executeOp14(node2, tensorMap2, context2));
        case "ragged":
          return tidy2(() => executeOp15(node2, tensorMap2, context2));
        case "reduction":
          return tidy2(() => executeOp16(node2, tensorMap2, context2));
        case "slice_join":
          return tidy2(() => executeOp17(node2, tensorMap2, context2));
        case "sparse":
          return tidy2(() => executeOp18(node2, tensorMap2, context2));
        case "spectral":
          return tidy2(() => executeOp19(node2, tensorMap2, context2));
        case "string":
          return tidy2(() => executeOp20(node2, tensorMap2, context2));
        case "transformation":
          return tidy2(() => executeOp21(node2, tensorMap2, context2));
        case "hash_table":
          return executeOp10(node2, tensorMap2, context2, resourceManager);
        case "custom":
          const opMapper = getRegisteredOp2(node2.op);
          if (opMapper && opMapper.customExecutor) {
            return opMapper.customExecutor(new NodeValueImpl2(node2, tensorMap2, context2));
          } else {
            throw TypeError(`Custom op ${node2.op} is not registered.`);
          }
        default:
          throw TypeError(`Unknown op '${node2.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
      }
    })(node, tensorMap, context);
    if (util_exports.isPromise(value)) {
      return value.then((data) => [].concat(data));
    }
    return [].concat(value);
  }

  // node_modules/@tensorflow/tfjs-converter/dist/executor/execution_context.js
  var ExecutionContext2 = class {
    constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {
      this.weightMap = weightMap;
      this.tensorArrayMap = tensorArrayMap;
      this.tensorListMap = tensorListMap;
      this.functionMap = functionMap;
      this.rootContext = { id: 0, frameName: "", iterationId: 0 };
      this.contexts = [this.rootContext];
      this.lastId = 0;
      this.generateCurrentContextIds();
    }
    newFrame(id, frameName) {
      return { id, frameName, iterationId: 0 };
    }
    /**
     * Set the current context
     * @param contexts: ExecutionContextInfo[] the current path of execution
     * frames
     */
    set currentContext(contexts2) {
      if (this.contexts !== contexts2) {
        this.contexts = contexts2;
        this.generateCurrentContextIds();
      }
    }
    get currentContext() {
      return this.contexts;
    }
    /**
     * Returns the current context in string format.
     */
    get currentContextId() {
      return this._currentContextIds[0];
    }
    /**
     * Returns the current context and all parent contexts in string format.
     * This allow access to the nodes in the current and parent frames.
     */
    get currentContextIds() {
      return this._currentContextIds;
    }
    generateCurrentContextIds() {
      const names = [];
      for (let i2 = 0; i2 < this.contexts.length - 1; i2++) {
        const contexts2 = this.contexts.slice(0, this.contexts.length - i2);
        names.push(this.contextIdforContexts(contexts2));
      }
      names.push("");
      this._currentContextIds = names;
    }
    contextIdforContexts(contexts2) {
      return contexts2 ? contexts2.map((context) => context.id === 0 && context.iterationId === 0 ? "" : `${context.frameName}-${context.iterationId}`).join("/") : "";
    }
    /**
     * Enter a new frame, a new context is pushed on the current context list.
     * @param frameId new frame id
     */
    enterFrame(frameId) {
      if (this.contexts) {
        this.lastId++;
        this.contexts = this.contexts.slice();
        this.contexts.push(this.newFrame(this.lastId, frameId));
        this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
      }
    }
    /**
     * Exit the current frame, the last context is removed from the current
     * context list.
     */
    exitFrame() {
      if (this.contexts && this.contexts.length > 1) {
        this.contexts = this.contexts.slice();
        this.contexts.splice(-1);
        this.currentContextIds.shift();
      } else {
        throw new Error("Cannot exit frame, the context is empty");
      }
    }
    /**
     * Enter the next iteration of a loop, the iteration id of last context is
     * increased.
     */
    nextIteration() {
      if (this.contexts && this.contexts.length > 0) {
        this.contexts = this.contexts.slice();
        this.lastId++;
        const context = Object.assign({}, this.contexts[this.contexts.length - 1]);
        context.iterationId += 1;
        context.id = this.lastId;
        this.contexts.splice(-1, 1, context);
        this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
      } else {
        throw new Error("Cannot increase frame iteration, the context is empty");
      }
    }
    getWeight(name) {
      return this.weightMap[name];
    }
    addTensorArray(tensorArray) {
      this.tensorArrayMap[tensorArray.id] = tensorArray;
    }
    getTensorArray(id) {
      return this.tensorArrayMap[id];
    }
    addTensorList(tensorList) {
      this.tensorListMap[tensorList.id] = tensorList;
    }
    getTensorList(id) {
      return this.tensorListMap[id];
    }
    dispose(keepIds) {
      for (const key in this.tensorArrayMap) {
        this.tensorArrayMap[key].clearAndClose(keepIds);
      }
      for (const key in this.tensorListMap) {
        this.tensorListMap[key].clearAndClose(keepIds);
      }
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/executor/model_analysis.js
  function getExecutionSubgraph2(inputs, outputs, weightMap, initNodes) {
    const usedNodes = /* @__PURE__ */ new Set();
    const missingInputs = [];
    let dynamicNode = null;
    let syncInputs = null;
    const seen = /* @__PURE__ */ new Set();
    const inputNodeNames = Object.keys(inputs).map((name) => parseNodeName2(name)[0]);
    let initNodeNames = [];
    if (initNodes != null) {
      initNodeNames = initNodes.map((node) => parseNodeName2(node.name)[0]);
    }
    const frontier = [...outputs];
    while (frontier.length > 0) {
      const node = frontier.pop();
      if (isControlFlow2(node) || isDynamicShape2(node) || isHashTable(node)) {
        if (dynamicNode == null) {
          dynamicNode = node;
          syncInputs = dynamicNode.children.map((child) => child.name).filter((name) => usedNodes.has(name));
        }
      }
      usedNodes.add(node.name);
      if (weightMap[node.name] != null) {
        continue;
      }
      if (inputNodeNames.indexOf(node.name) !== -1) {
        continue;
      }
      if (initNodeNames.indexOf(node.name) !== -1) {
        continue;
      }
      if (node.inputs.length === 0) {
        missingInputs.push(node.name);
        continue;
      }
      node.inputs.forEach((input2) => {
        if (seen.has(input2.name)) {
          return;
        }
        seen.add(input2.name);
        frontier.push(input2);
      });
    }
    return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };
  }
  function getNodesInTopologicalOrder2(graph2, weightMap, executionInfo) {
    const { usedNodes, inputs } = executionInfo;
    const frontier = [];
    const inputNodes = Object.keys(inputs).map((name) => parseNodeName2(name)[0]).map((name) => graph2.nodes[name]);
    const initNodes = graph2.initNodes;
    inputNodes.forEach((input2) => {
      if (usedNodes.has(input2.name)) {
        frontier.push(input2);
      }
    });
    graph2.weights.forEach((weight) => {
      if (usedNodes.has(weight.name)) {
        frontier.push(weight);
      }
    });
    if (initNodes != null) {
      initNodes.forEach((node) => {
        if (usedNodes.has(node.name)) {
          frontier.push(node);
        }
      });
    }
    const seen = /* @__PURE__ */ new Set();
    const orderedNodes = [];
    while (frontier.length > 0) {
      const node = frontier.pop();
      seen.add(node.name);
      if (!weightMap[node.name]) {
        orderedNodes.push(node);
      }
      node.children.forEach((child) => {
        if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every((input2) => seen.has(input2.name))) {
          frontier.push(child);
        }
      });
    }
    return orderedNodes;
  }
  var CONTROL_FLOW_OPS2 = [
    "Switch",
    "Merge",
    "Enter",
    "Exit",
    "NextIteration",
    "StatelessIf",
    "StatelessWhile",
    "if",
    "While"
  ];
  var DYNAMIC_SHAPE_OPS2 = [
    "NonMaxSuppressionV2",
    "NonMaxSuppressionV3",
    "NonMaxSuppressionV5",
    "Where"
  ];
  var HASH_TABLE_OPS = [
    "HashTable",
    "HashTableV2",
    "LookupTableImport",
    "LookupTableImportV2",
    "LookupTableFind",
    "LookupTableFindV2",
    "LookupTableSize",
    "LookupTableSizeV2"
  ];
  function isControlFlow2(node) {
    return CONTROL_FLOW_OPS2.indexOf(node.op) >= 0;
  }
  function isDynamicShape2(node) {
    return DYNAMIC_SHAPE_OPS2.indexOf(node.op) >= 0;
  }
  function isHashTable(node) {
    return HASH_TABLE_OPS.indexOf(node.op) >= 0;
  }

  // node_modules/@tensorflow/tfjs-converter/dist/executor/graph_executor.js
  var GraphExecutor2 = class {
    /**
     *
     * @param graph Graph the model or function graph to be executed.
     * @param parent When building function exector you need to set the parent
     * executor. Since the weights and function executor maps are set at parant
     * level, that function executor can access the function maps and weight maps
     * through the parent.
     */
    constructor(graph2, parent) {
      this.graph = graph2;
      this.parent = parent;
      this.compiledMap = /* @__PURE__ */ new Map();
      this._weightMap = {};
      this.SEPERATOR = ",";
      this._functions = {};
      this._functionExecutorMap = {};
      this.keepIntermediateTensors = false;
      this._outputs = graph2.outputs;
      this._inputs = graph2.inputs;
      this._initNodes = graph2.initNodes;
      this._signature = graph2.signature;
      this._functions = graph2.functions;
      if (graph2.functions != null) {
        Object.keys(graph2.functions).forEach((name) => {
          this._functionExecutorMap[name] = new GraphExecutor2(graph2.functions[name], this);
        });
      }
    }
    get weightIds() {
      return this.parent ? this.parent.weightIds : this._weightIds;
    }
    get functionExecutorMap() {
      return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
    }
    get weightMap() {
      return this.parent ? this.parent.weightMap : this._weightMap;
    }
    set weightMap(weightMap) {
      const weightIds = Object.keys(weightMap).map((key) => weightMap[key].map((tensor2) => tensor2.id));
      this._weightIds = [].concat(...weightIds);
      this._weightMap = weightMap;
    }
    /**
     * Set `ResourceManager` shared by executors of a model.
     * @param resourceManager: `ResourceManager` of the `GraphModel`.
     */
    set resourceManager(resourceManager) {
      this._resourceManager = resourceManager;
    }
    get inputs() {
      return this._inputs.map((node) => {
        return {
          name: node.name,
          shape: node.attrParams["shape"] ? node.attrParams["shape"].value : void 0,
          dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : void 0
        };
      });
    }
    get outputs() {
      return this._outputs.map((node) => {
        return {
          name: node.name,
          shape: node.attrParams["shape"] ? node.attrParams["shape"].value : void 0,
          dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : void 0
        };
      });
    }
    get inputNodes() {
      return this._inputs.map((node) => node.signatureKey || node.name);
    }
    get outputNodes() {
      return this._outputs.map((node) => {
        const name = node.signatureKey || node.name;
        return node.defaultOutput ? `${name}:${node.defaultOutput}` : name;
      });
    }
    get functions() {
      return Object.keys(this._functions).reduce((map, key) => {
        map[key] = this._functions[key].signature;
        return map;
      }, {});
    }
    getCompilationKey(inputs, outputs) {
      const sortedInputs = inputs.map((node) => node.name).sort();
      const sortedOutputs = outputs.map((node) => node.name).sort();
      return sortedInputs.join(this.SEPERATOR) + "--" + sortedOutputs.join(this.SEPERATOR);
    }
    /**
     * Compiles the inference graph and returns the minimal set of nodes that are
     * required for execution, in the correct execution order.
     */
    compile(inputs, outputs) {
      const executionInfo = getExecutionSubgraph2(inputs, outputs, this.weightMap, this._initNodes);
      const { missingInputs, dynamicNode, syncInputs } = executionInfo;
      if (dynamicNode != null) {
        throw new Error(`This execution contains the node '${dynamicNode.name}', which has the dynamic op '${dynamicNode.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${syncInputs}]`);
      }
      if (missingInputs.length > 0) {
        const outNames = outputs.map((n2) => n2.name);
        const inNames = Object.keys(inputs);
        throw new Error(`Cannot compute the outputs [${outNames}] from the provided inputs [${inNames}]. Missing the following inputs: [${missingInputs}]`);
      }
      return getNodesInTopologicalOrder2(this.graph, this.weightMap, executionInfo);
    }
    cloneAndKeepTensor(tensor2) {
      if (tensor2 == null) {
        return null;
      }
      const clone2 = tensor2.clone();
      keep(clone2);
      return clone2;
    }
    cloneTensorList(tensors) {
      if (!tensors) {
        return null;
      }
      const clonedTensor = tensors.map((tensor2) => {
        return this.cloneAndKeepTensor(tensor2);
      });
      return clonedTensor;
    }
    cloneTensorMap(tensorsMap) {
      return Object.fromEntries(Object.entries(tensorsMap).map(([name, tensorsList]) => {
        return [name, this.cloneTensorList(tensorsList)];
      }));
    }
    /**
     * Executes the inference for given input tensors.
     * @param inputs Tensor map for the model inputs, keyed by the input node
     * names.
     * @param outputs Optional. output node name from the Tensorflow model, if
     * no outputs are specified, the default outputs of the model would be used.
     * You can inspect intermediate nodes of the model by adding them to the
     * outputs array.
     */
    execute(inputs, outputs) {
      this.disposeIntermediateTensors();
      inputs = this.mapInputs(inputs);
      const names = Object.keys(inputs).sort();
      this.checkInputs(inputs);
      this.checkInputShapeAndType(inputs);
      outputs = this.mapOutputs(outputs);
      this.checkOutputs(outputs);
      const inputNodes = names.map((name) => this.graph.nodes[parseNodeName2(name)[0]]);
      const outputNodeNames = outputs.map((name) => parseNodeName2(name)[0]);
      let outputNodes = outputNodeNames.map((name) => this.graph.nodes[name]);
      if (outputNodes.length === 0) {
        outputNodes = this._outputs;
      }
      const compilationKey = this.getCompilationKey(inputNodes, outputNodes);
      let orderedNodes = this.compiledMap.get(compilationKey);
      if (orderedNodes == null) {
        orderedNodes = this.compile(inputs, outputNodes);
        this.compiledMap.set(compilationKey, orderedNodes);
      }
      try {
        this.keepIntermediateTensors = env().getBool("KEEP_INTERMEDIATE_TENSORS");
      } catch (e2) {
        this.keepIntermediateTensors = false;
        console.warn(e2.message);
      }
      const tensorArrayMap = {};
      const tensorListMap = {};
      return tidy(() => {
        const context = new ExecutionContext2(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap);
        const tensorsMap = Object.assign({}, this.weightMap);
        if (this.keepIntermediateTensors) {
          this.clonedTensorsMap = this.cloneTensorMap(this.weightMap);
        }
        Object.keys(inputs).forEach((name) => {
          const [nodeName, index] = parseNodeName2(name);
          const tensors = [];
          tensors[index] = inputs[name];
          tensorsMap[nodeName] = tensors;
          if (this.keepIntermediateTensors) {
            this.clonedTensorsMap[nodeName] = this.cloneTensorList(tensors);
          }
        });
        const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
        const intermediateTensorConsumerCount = {};
        for (let i2 = 0; i2 < orderedNodes.length; i2++) {
          const node = orderedNodes[i2];
          if (!tensorsMap[node.name]) {
            const tensors = executeOp22(node, tensorsMap, context, this._resourceManager);
            if (util_exports.isPromise(tensors)) {
              throw new Error(`The execution of the op '${node.op}' returned a promise. Please use model.executeAsync() instead.`);
            }
            tensorsMap[node.name] = tensors;
            if (this.keepIntermediateTensors) {
              this.clonedTensorsMap[node.name] = this.cloneTensorList(tensors);
            }
            this.checkTensorForDisposal(node.name, node, tensorsMap, context, tensorsToKeep, outputNodeNames, intermediateTensorConsumerCount);
          }
        }
        if (this.parent == null) {
          context.dispose(tensorsToKeep);
        }
        return outputs.map((name) => getTensor2(name, tensorsMap, context));
      });
    }
    getFrozenTensorIds(tensorMap) {
      const ids = [].concat.apply([], Object.keys(tensorMap).map((key) => tensorMap[key]).map((tensors) => tensors.map((tensor2) => tensor2.id)));
      return new Set(ids);
    }
    checkTensorForDisposal(nodeName, node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount) {
      if (node.category === "control" || outputNames.indexOf(nodeName) !== -1) {
        return;
      }
      tensorMap[nodeName].forEach((tensor2) => {
        if (tensor2 != null) {
          intermediateTensorConsumerCount[tensor2.id] = (intermediateTensorConsumerCount[tensor2.id] || 0) + node.children.length;
        }
      });
      node.inputs.forEach((input2) => {
        if (input2.category !== "control") {
          const tensors = getTensorsForCurrentContenxt2(input2.name, tensorMap, context);
          if (tensors != null) {
            tensors.forEach((tensor2) => {
              if (tensor2 && !tensor2.kept && !tensorsToKeep.has(tensor2.id)) {
                const count2 = intermediateTensorConsumerCount[tensor2.id];
                if (count2 === 1) {
                  tensor2.dispose();
                  delete intermediateTensorConsumerCount[tensor2.id];
                } else if (count2 != null) {
                  intermediateTensorConsumerCount[tensor2.id]--;
                }
              }
            });
          }
        }
      });
    }
    /**
     * Executes the inference for given input tensors in Async fashion.
     * @param inputs Tensor map for the model inputs, keyed by the input node
     * names.
     * @param outputs output node name from the Tensorflow model, if no outputs
     * are specified, the default outputs of the model would be used. You can
     * inspect intermediate nodes of the model by adding them to the outputs
     * array.
     */
    async executeAsync(inputs, outputs) {
      return this._executeAsync(inputs, outputs);
    }
    disposeIntermediateTensors() {
      if (!this.clonedTensorsMap) {
        return;
      }
      Object.values(this.clonedTensorsMap).forEach((tensorsList) => {
        for (const tensor2 of tensorsList) {
          if (tensor2 && !tensor2.isDisposed) {
            tensor2.dispose();
          }
        }
      });
      this.clonedTensorsMap = null;
    }
    getIntermediateTensors() {
      return this.clonedTensorsMap;
    }
    /**
     * Executes the inference for given input tensors in Async fashion.
     * @param inputs Tensor map for the model inputs, keyed by the input node
     * names.
     * @param outputs Optional. output node name from the Tensorflow model,
     * if no outputs are specified, the default outputs of the model would be
     * used. You can inspect intermediate nodes of the model by adding them to
     * the outputs array.
     * @param isFunctionExecution Optional. Flag for executing a function.
     * @param tensorArrayMap Optional, global TensorArray map by id. Used for
     * function execution.
     * @param tensorArrayMap Optinal global TensorList map by id. Used for
     * function execution.
     */
    async _executeAsync(inputs, outputs, isFunctionExecution = false, tensorArrayMap = {}, tensorListMap = {}) {
      this.disposeIntermediateTensors();
      if (!isFunctionExecution) {
        inputs = this.mapInputs(inputs);
        this.checkInputs(inputs);
        this.checkInputShapeAndType(inputs);
        outputs = this.mapOutputs(outputs);
        this.checkOutputs(outputs);
      }
      try {
        this.keepIntermediateTensors = env().getBool("KEEP_INTERMEDIATE_TENSORS");
      } catch (e2) {
        this.keepIntermediateTensors = false;
        console.warn(e2.message);
      }
      const context = new ExecutionContext2(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap);
      if (this.keepIntermediateTensors) {
        this.clonedTensorsMap = this.cloneTensorMap(this.weightMap);
      }
      const tensorsMap = await this.executeWithControlFlow(inputs, context, outputs, isFunctionExecution);
      const results = outputs.map((name) => getTensor2(name, tensorsMap, context));
      const outputIds = results.map((t3) => t3.id);
      const inputIds = Object.keys(inputs).map((name) => inputs[name].id);
      const keepIds = /* @__PURE__ */ new Set([...outputIds, ...inputIds, ...this.weightIds]);
      Object.values(tensorsMap).forEach((tensorsList) => {
        tensorsList.forEach((tensor2) => {
          if (tensor2 && !tensor2.isDisposed && !keepIds.has(tensor2.id)) {
            tensor2.dispose();
          }
        });
      });
      if (this.parent == null) {
        context.dispose(keepIds);
      }
      return results;
    }
    async executeFunctionAsync(inputs, tensorArrayMap, tensorListMap) {
      const mappedInputs = inputs.reduce((map, tensor2, index) => {
        map[this.inputs[index].name] = tensor2;
        return map;
      }, {});
      return this._executeAsync(mappedInputs, this.outputNodes, true, tensorArrayMap, tensorListMap);
    }
    /**
     * When there are control flow nodes in the graph, the graph execution use
     * ExecutionContext to keep track of the frames and loop iterators.
     * @param inputs placeholder tensors for the graph.
     * @param context the execution context object for current execution.
     * @param outputNames Optional. output node name from the Tensorflow model,
     * if no outputs are specified, the default outputs of the model would be
     * used. You can inspect intermediate nodes of the model by adding them to
     * the outputs array.
     * @param isFunctionExecution Flag for executing a function.
     */
    async executeWithControlFlow(inputs, context, outputNames, isFunctionExecution) {
      const names = Object.keys(inputs);
      const inputNodes = names.map((name) => this.graph.nodes[parseNodeName2(name)[0]]);
      const outputNodeNames = outputNames.map((name) => parseNodeName2(name)[0]);
      let outputNodes = outputNodeNames.map((name) => this.graph.nodes[name]);
      if (outputNodes.length === 0) {
        outputNodes = this._outputs;
      }
      const { usedNodes, missingInputs, dynamicNode, syncInputs } = getExecutionSubgraph2(inputs, outputNodes, this.weightMap, this._initNodes);
      const stack2 = [
        ...inputNodes,
        ...this.graph.weights,
        ...this._initNodes || []
      ].map((node) => {
        return { node, contexts: context.currentContext };
      });
      const tensorsMap = Object.assign({}, this.weightMap);
      Object.keys(inputs).forEach((name) => {
        const [nodeName, index] = parseNodeName2(name);
        const tensors = [];
        tensors[index] = inputs[name];
        tensorsMap[nodeName] = tensors;
      });
      const intermediateTensorConsumerCount = {};
      const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
      const added = {};
      while (stack2.length > 0) {
        const promises = this.processStack(inputNodes, stack2, context, tensorsMap, added, tensorsToKeep, outputNodeNames, intermediateTensorConsumerCount, usedNodes);
        await Promise.all(promises);
      }
      if (dynamicNode == null && !isFunctionExecution) {
        console.warn(`This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.`);
      }
      const missingOutputs = outputNodes.filter((node) => !isControlFlow2(node) && !getTensor2(node.name, tensorsMap, context)).map((node) => node.name);
      if (missingOutputs.length > 0) {
        let alternativeMsg = "";
        if (dynamicNode != null) {
          alternativeMsg = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${syncInputs}]`;
        }
        throw new Error(`Cannot compute the outputs [${missingOutputs}] from the provided inputs [${names}]. Consider providing the following inputs: [${missingInputs}]. ${alternativeMsg}`);
      }
      return tensorsMap;
    }
    processStack(inputNodes, stack2, context, tensorMap, added, tensorsToKeep, outputNames, intermediateTensorConsumerCount, usedNodes) {
      const promises = [];
      while (stack2.length > 0) {
        const item = stack2.pop();
        context.currentContext = item.contexts;
        let nodeName = "";
        if (item.node.op === "Enter" && getParamValue2("isConstant", item.node, tensorMap, context)) {
          [nodeName] = getNodeNameAndIndex2(item.node.name, context);
        }
        if (tensorMap[item.node.name] == null) {
          const tensors = executeOp22(item.node, tensorMap, context, this._resourceManager);
          if (!nodeName) {
            [nodeName] = getNodeNameAndIndex2(item.node.name, context);
          }
          const currentContext = context.currentContext;
          if (util_exports.isPromise(tensors)) {
            promises.push(tensors.then((t3) => {
              tensorMap[nodeName] = t3;
              if (this.keepIntermediateTensors) {
                this.clonedTensorsMap[nodeName] = this.cloneTensorList(t3);
              }
              context.currentContext = currentContext;
              this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);
              this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
              return t3;
            }));
          } else {
            tensorMap[nodeName] = tensors;
            if (this.keepIntermediateTensors) {
              this.clonedTensorsMap[nodeName] = this.cloneTensorList(tensors);
            }
            this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);
            this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
          }
        } else {
          this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
        }
      }
      return promises;
    }
    processChildNodes(node, stack2, context, tensorMap, added, usedNodes) {
      node.children.forEach((childNode) => {
        const [nodeName] = getNodeNameAndIndex2(childNode.name, context);
        if (added[nodeName] || !usedNodes.has(childNode.name)) {
          return;
        }
        if (childNode.op === "Merge") {
          if (childNode.inputNames.some((name) => {
            return !!getTensor2(name, tensorMap, context);
          })) {
            added[nodeName] = true;
            stack2.push({ contexts: context.currentContext, node: childNode });
          }
        } else if (childNode.inputNames.every((name) => {
          return !!getTensor2(name, tensorMap, context);
        })) {
          added[nodeName] = true;
          stack2.push({ contexts: context.currentContext, node: childNode });
        }
      });
    }
    /**
     * Releases the memory used by the weight tensors.
     */
    dispose() {
      Object.keys(this.weightMap).forEach((key) => this.weightMap[key].forEach((tensor2) => tensor2.dispose()));
    }
    checkInputShapeAndType(inputs) {
      Object.keys(inputs).forEach((name) => {
        const input2 = inputs[name];
        const [nodeName] = parseNodeName2(name);
        const node = this.graph.nodes[nodeName];
        if (node.attrParams["shape"] && node.attrParams["shape"].value) {
          const shape = node.attrParams["shape"].value;
          const match = shape.length === input2.shape.length && input2.shape.every((dim, index) => shape[index] === -1 || shape[index] === dim);
          util_exports.assert(match, () => `The shape of dict['${node.name}'] provided in model.execute(dict) must be [${shape}], but was [${input2.shape}]`);
        }
        if (node.attrParams["dtype"] && node.attrParams["dtype"].value) {
          util_exports.assert(input2.dtype === node.attrParams["dtype"].value, () => `The dtype of dict['${node.name}'] provided in model.execute(dict) must be ${node.attrParams["dtype"].value}, but was ${input2.dtype}`);
        }
      });
    }
    mapInputs(inputs) {
      var _a2, _b;
      const result = {};
      for (const inputName in inputs) {
        const tensor2 = (_b = (_a2 = this._signature) === null || _a2 === void 0 ? void 0 : _a2.inputs) === null || _b === void 0 ? void 0 : _b[inputName];
        if (tensor2 != null) {
          result[tensor2.name] = inputs[inputName];
        } else {
          result[inputName] = inputs[inputName];
        }
      }
      return result;
    }
    checkInputs(inputs) {
      const notInGraph = Object.keys(inputs).filter((name) => {
        const [nodeName] = parseNodeName2(name);
        return this.graph.nodes[nodeName] == null;
      });
      if (notInGraph.length > 0) {
        throw new Error(`The dict provided in model.execute(dict) has keys: [${notInGraph}] that are not part of graph`);
      }
    }
    mapOutputs(outputs) {
      return outputs.map((name) => {
        var _a2, _b;
        const tensor2 = (_b = (_a2 = this._signature) === null || _a2 === void 0 ? void 0 : _a2.outputs) === null || _b === void 0 ? void 0 : _b[name];
        if (tensor2 != null) {
          return tensor2.name;
        }
        return name;
      }, {});
    }
    checkOutputs(outputs) {
      outputs.forEach((name) => {
        const [normalizedName] = parseNodeName2(name);
        if (!this.graph.nodes[normalizedName]) {
          throw new Error(`The output '${name}' is not found in the graph`);
        }
      });
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/executor/resource_manager.js
  var ResourceManager = class {
    constructor(hashTableNameToHandle = {}, hashTableMap = {}) {
      this.hashTableNameToHandle = hashTableNameToHandle;
      this.hashTableMap = hashTableMap;
    }
    /**
     * Register a `HashTable` in the resource manager.
     *
     * The `HashTable` can be retrieved by `resourceManager.getHashTableById`,
     * where id is the table handle tensor's id.
     *
     * @param name Op node name that creates the `HashTable`.
     * @param hashTable The `HashTable` to be added to resource manager.
     */
    addHashTable(name, hashTable) {
      this.hashTableNameToHandle[name] = hashTable.handle;
      this.hashTableMap[hashTable.id] = hashTable;
    }
    /**
     * Get the table handle by node name.
     * @param name Op node name that creates the `HashTable`. This name is also
     *     used in the inputs list of lookup and import `HashTable` ops.
     */
    getHashTableHandleByName(name) {
      return this.hashTableNameToHandle[name];
    }
    /**
     * Get the actual `HashTable` by its handle tensor's id.
     * @param id The id of the handle tensor.
     */
    getHashTableById(id) {
      return this.hashTableMap[id];
    }
    /**
     * Dispose `ResourceManager`, including its hashTables and tensors in them.
     */
    dispose() {
      for (const key in this.hashTableMap) {
        this.hashTableMap[key].clearAndClose();
        delete this.hashTableMap[key];
      }
      for (const name in this.hashTableNameToHandle) {
        this.hashTableNameToHandle[name].dispose();
        delete this.hashTableNameToHandle[name];
      }
    }
  };

  // node_modules/@tensorflow/tfjs-converter/dist/executor/graph_model.js
  var TFHUB_SEARCH_PARAM = "?tfjs-format=file";
  var DEFAULT_MODEL_NAME = "model.json";
  var GraphModel2 = class {
    /**
     * @param modelUrl url for the model, or an `io.IOHandler`.
     * @param weightManifestUrl url for the weight file generated by
     * scripts/convert.py script.
     * @param requestOption options for Request, which allows to send credentials
     * and custom headers.
     * @param onProgress Optional, progress callback function, fired periodically
     * before the load is completed.
     */
    constructor(modelUrl, loadOptions = {}, tfio = io_exports) {
      this.modelUrl = modelUrl;
      this.loadOptions = loadOptions;
      this.version = "n/a";
      this.io = tfio;
      if (loadOptions == null) {
        this.loadOptions = {};
      }
      this.resourceManager = new ResourceManager();
    }
    // Returns the version information for the tensorflow model GraphDef.
    get modelVersion() {
      return this.version;
    }
    get inputNodes() {
      return this.executor.inputNodes;
    }
    get outputNodes() {
      return this.executor.outputNodes;
    }
    get inputs() {
      return this.executor.inputs;
    }
    get outputs() {
      return this.executor.outputs;
    }
    get weights() {
      return this.executor.weightMap;
    }
    get metadata() {
      return this.artifacts.userDefinedMetadata;
    }
    get modelSignature() {
      return this.signature;
    }
    get modelStructuredOutputKeys() {
      return this.structuredOutputKeys;
    }
    findIOHandler() {
      const path = this.modelUrl;
      if (path.load != null) {
        this.handler = path;
      } else if (this.loadOptions.requestInit != null) {
        this.handler = this.io.browserHTTPRequest(path, this.loadOptions);
      } else {
        const handlers = this.io.getLoadHandlers(path, this.loadOptions);
        if (handlers.length === 0) {
          handlers.push(this.io.browserHTTPRequest(path, this.loadOptions));
        } else if (handlers.length > 1) {
          throw new Error(`Found more than one (${handlers.length}) load handlers for URL '${[path]}'`);
        }
        this.handler = handlers[0];
      }
    }
    /**
     * Loads the model and weight files, construct the in memory weight map and
     * compile the inference graph.
     */
    load() {
      this.findIOHandler();
      if (this.handler.load == null) {
        throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
      }
      const loadResult = this.handler.load();
      if (util_exports.isPromise(loadResult)) {
        return loadResult.then((artifacts) => this.loadSync(artifacts));
      }
      return this.loadSync(loadResult);
    }
    /**
     * Synchronously construct the in memory weight map and
     * compile the inference graph.
     *
     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
     */
    loadSync(artifacts) {
      this.artifacts = artifacts;
      const graph2 = this.artifacts.modelTopology;
      let signature = this.artifacts.signature;
      if (this.artifacts.userDefinedMetadata != null) {
        const metadata = this.artifacts.userDefinedMetadata;
        if (metadata.signature != null) {
          signature = metadata.signature;
        }
        if (metadata.structuredOutputKeys != null) {
          this.structuredOutputKeys = metadata.structuredOutputKeys;
        }
      }
      this.signature = signature;
      this.version = `${graph2.versions.producer}.${graph2.versions.minConsumer}`;
      const weightMap = this.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
      this.executor = new GraphExecutor2(OperationMapper2.Instance.transformGraph(graph2, this.signature));
      this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
      this.executor.resourceManager = this.resourceManager;
      if (artifacts.modelInitializer != null && artifacts.modelInitializer.node != null) {
        const initializer = OperationMapper2.Instance.transformGraph(artifacts.modelInitializer);
        this.initializer = new GraphExecutor2(initializer);
        this.initializer.weightMap = this.executor.weightMap;
        this.initializer.resourceManager = this.resourceManager;
        this.initializerSignature = artifacts.initializerSignature;
      }
      return true;
    }
    /**
     * Save the configuration and/or weights of the GraphModel.
     *
     * An `IOHandler` is an object that has a `save` method of the proper
     * signature defined. The `save` method manages the storing or
     * transmission of serialized data ("artifacts") that represent the
     * model's topology and weights onto or via a specific medium, such as
     * file downloads, local storage, IndexedDB in the web browser and HTTP
     * requests to a server. TensorFlow.js provides `IOHandler`
     * implementations for a number of frequently used saving mediums, such as
     * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`
     * for more details.
     *
     * This method also allows you to refer to certain types of `IOHandler`s
     * as URL-like string shortcuts, such as 'localstorage://' and
     * 'indexeddb://'.
     *
     * Example 1: Save `model`'s topology and weights to browser [local
     * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);
     * then load it back.
     *
     * ```js
     * const modelUrl =
     *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
     * const model = await tf.loadGraphModel(modelUrl);
     * const zeros = tf.zeros([1, 224, 224, 3]);
     * model.predict(zeros).print();
     *
     * const saveResults = await model.save('localstorage://my-model-1');
     *
     * const loadedModel = await tf.loadGraphModel('localstorage://my-model-1');
     * console.log('Prediction from loaded model:');
     * model.predict(zeros).print();
     * ```
     *
     * @param handlerOrURL An instance of `IOHandler` or a URL-like,
     * scheme-based string shortcut for `IOHandler`.
     * @param config Options for saving the model.
     * @returns A `Promise` of `SaveResult`, which summarizes the result of
     * the saving, such as byte sizes of the saved artifacts for the model's
     *   topology and weight values.
     *
     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
     */
    async save(handlerOrURL, config) {
      if (typeof handlerOrURL === "string") {
        const handlers = this.io.getSaveHandlers(handlerOrURL);
        if (handlers.length === 0) {
          throw new Error(`Cannot find any save handlers for URL '${handlerOrURL}'`);
        } else if (handlers.length > 1) {
          throw new Error(`Found more than one (${handlers.length}) save handlers for URL '${handlerOrURL}'`);
        }
        handlerOrURL = handlers[0];
      }
      if (handlerOrURL.save == null) {
        throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
      }
      return handlerOrURL.save(this.artifacts);
    }
    addStructuredOutputNames(outputTensors) {
      if (this.structuredOutputKeys) {
        const outputTensorsArray = outputTensors instanceof Tensor ? [outputTensors] : outputTensors;
        const outputTensorMap = {};
        outputTensorsArray.forEach((outputTensor, i2) => outputTensorMap[this.structuredOutputKeys[i2]] = outputTensor);
        return outputTensorMap;
      }
      return outputTensors;
    }
    /**
     * Execute the inference for the input tensors.
     *
     * @param input The input tensors, when there is single input for the model,
     * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
     * inputs params should be in either `tf.Tensor`[] if the input order is
     * fixed, or otherwise NamedTensorMap format.
     *
     * For model with multiple inputs, we recommend you use NamedTensorMap as the
     * input type, if you use `tf.Tensor`[], the order of the array needs to
     * follow the
     * order of inputNodes array. @see {@link GraphModel.inputNodes}
     *
     * You can also feed any intermediate nodes using the NamedTensorMap as the
     * input type. For example, given the graph
     *    InputNode => Intermediate => OutputNode,
     * you can execute the subgraph Intermediate => OutputNode by calling
     *    model.execute('IntermediateNode' : tf.tensor(...));
     *
     * This is useful for models that uses tf.dynamic_rnn, where the intermediate
     * state needs to be fed manually.
     *
     * For batch inference execution, the tensors for each input need to be
     * concatenated together. For example with mobilenet, the required input shape
     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
     * If we are provide a batched data of 100 images, the input tensor should be
     * in the shape of [100, 244, 244, 3].
     *
     * @param config Prediction configuration for specifying the batch size.
     * Currently the batch size option is ignored for graph model.
     *
     * @returns Inference result tensors. If the model is converted and it
     * originally had structured_outputs in tensorflow, then a NamedTensorMap
     * will be returned matching the structured_outputs. If no structured_outputs
     * are present, the output will be single `tf.Tensor` if the model has single
     * output node, otherwise Tensor[].
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    predict(inputs, config) {
      const outputTensors = this.execute(inputs, this.outputNodes);
      return this.addStructuredOutputNames(outputTensors);
    }
    /**
     * Execute the inference for the input tensors in async fashion, use this
     * method when your model contains control flow ops.
     *
     * @param input The input tensors, when there is single input for the model,
     * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
     * inputs params should be in either `tf.Tensor`[] if the input order is
     * fixed, or otherwise NamedTensorMap format.
     *
     * For model with multiple inputs, we recommend you use NamedTensorMap as the
     * input type, if you use `tf.Tensor`[], the order of the array needs to
     * follow the
     * order of inputNodes array. @see {@link GraphModel.inputNodes}
     *
     * You can also feed any intermediate nodes using the NamedTensorMap as the
     * input type. For example, given the graph
     *    InputNode => Intermediate => OutputNode,
     * you can execute the subgraph Intermediate => OutputNode by calling
     *    model.execute('IntermediateNode' : tf.tensor(...));
     *
     * This is useful for models that uses tf.dynamic_rnn, where the intermediate
     * state needs to be fed manually.
     *
     * For batch inference execution, the tensors for each input need to be
     * concatenated together. For example with mobilenet, the required input shape
     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
     * If we are provide a batched data of 100 images, the input tensor should be
     * in the shape of [100, 244, 244, 3].
     *
     * @param config Prediction configuration for specifying the batch size.
     * Currently the batch size option is ignored for graph model.
     *
     * @returns A Promise of inference result tensors. If the model is converted
     * and it originally had structured_outputs in tensorflow, then a
     * NamedTensorMap will be returned matching the structured_outputs. If no
     * structured_outputs are present, the output will be single `tf.Tensor` if
     * the model has single output node, otherwise Tensor[].
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    async predictAsync(inputs, config) {
      const outputTensors = await this.executeAsync(inputs, this.outputNodes);
      return this.addStructuredOutputNames(outputTensors);
    }
    normalizeInputs(inputs) {
      var _a2;
      if (!(inputs instanceof Tensor) && !Array.isArray(inputs)) {
        const signatureInputs = (_a2 = this.signature) === null || _a2 === void 0 ? void 0 : _a2.inputs;
        if (signatureInputs != null) {
          for (const input2 in signatureInputs) {
            const tensor2 = signatureInputs[input2];
            if (tensor2.resourceId != null) {
              inputs[input2] = this.resourceIdToCapturedInput[tensor2.resourceId];
            }
          }
        }
        return inputs;
      }
      inputs = Array.isArray(inputs) ? inputs : [inputs];
      const numCapturedInputs = Object.keys(this.resourceIdToCapturedInput).length;
      if (inputs.length + numCapturedInputs !== this.inputNodes.length) {
        throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - numCapturedInputs} non-resource placeholders, while there are ${inputs.length} input tensors provided.`);
      }
      let inputIndex = 0;
      return this.inputNodes.reduce((map, inputName) => {
        var _a3, _b, _c2;
        const resourceId = (_c2 = (_b = (_a3 = this.signature) === null || _a3 === void 0 ? void 0 : _a3.inputs) === null || _b === void 0 ? void 0 : _b[inputName]) === null || _c2 === void 0 ? void 0 : _c2.resourceId;
        if (resourceId != null) {
          map[inputName] = this.resourceIdToCapturedInput[resourceId];
        } else {
          map[inputName] = inputs[inputIndex++];
        }
        return map;
      }, {});
    }
    normalizeOutputs(outputs) {
      outputs = outputs || this.outputNodes;
      return !Array.isArray(outputs) ? [outputs] : outputs;
    }
    executeInitializerGraph() {
      if (this.initializer == null) {
        return [];
      }
      if (this.initializerSignature == null) {
        return this.initializer.execute({}, []);
      } else {
        return this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
      }
    }
    async executeInitializerGraphAsync() {
      if (this.initializer == null) {
        return [];
      }
      if (this.initializerSignature == null) {
        return this.initializer.executeAsync({}, []);
      } else {
        return this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs));
      }
    }
    setResourceIdToCapturedInput(outputs) {
      this.resourceIdToCapturedInput = {};
      if (this.initializerSignature) {
        const signatureOutputs = this.initializerSignature.outputs;
        const outputNames = Object.keys(signatureOutputs);
        for (let i2 = 0; i2 < outputNames.length; i2++) {
          const outputName = outputNames[i2];
          const tensorInfo = signatureOutputs[outputName];
          this.resourceIdToCapturedInput[tensorInfo.resourceId] = outputs[i2];
        }
      }
    }
    /**
     * Executes inference for the model for given input tensors.
     * @param inputs tensor, tensor array or tensor map of the inputs for the
     * model, keyed by the input node names.
     * @param outputs output node name from the TensorFlow model, if no
     * outputs are specified, the default outputs of the model would be used.
     * You can inspect intermediate nodes of the model by adding them to the
     * outputs array.
     *
     * @returns A single tensor if provided with a single output or no outputs
     * are provided and there is only one default output, otherwise return a
     * tensor array. The order of the tensor array is the same as the outputs
     * if provided, otherwise the order of outputNodes attribute of the model.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    execute(inputs, outputs) {
      if (this.resourceIdToCapturedInput == null) {
        this.setResourceIdToCapturedInput(this.executeInitializerGraph());
      }
      inputs = this.normalizeInputs(inputs);
      outputs = this.normalizeOutputs(outputs);
      const result = this.executor.execute(inputs, outputs);
      return result.length > 1 ? result : result[0];
    }
    /**
     * Executes inference for the model for given input tensors in async
     * fashion, use this method when your model contains control flow ops.
     * @param inputs tensor, tensor array or tensor map of the inputs for the
     * model, keyed by the input node names.
     * @param outputs output node name from the TensorFlow model, if no outputs
     * are specified, the default outputs of the model would be used. You can
     * inspect intermediate nodes of the model by adding them to the outputs
     * array.
     *
     * @returns A Promise of single tensor if provided with a single output or
     * no outputs are provided and there is only one default output, otherwise
     * return a tensor map.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    async executeAsync(inputs, outputs) {
      if (this.resourceIdToCapturedInput == null) {
        this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync());
      }
      inputs = this.normalizeInputs(inputs);
      outputs = this.normalizeOutputs(outputs);
      const result = await this.executor.executeAsync(inputs, outputs);
      return result.length > 1 ? result : result[0];
    }
    /**
     * Get intermediate tensors for model debugging mode (flag
     * KEEP_INTERMEDIATE_TENSORS is true).
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    getIntermediateTensors() {
      return this.executor.getIntermediateTensors();
    }
    /**
     * Dispose intermediate tensors for model debugging mode (flag
     * KEEP_INTERMEDIATE_TENSORS is true).
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    disposeIntermediateTensors() {
      this.executor.disposeIntermediateTensors();
    }
    convertTensorMapToTensorsMap(map) {
      return Object.keys(map).reduce((newMap, key) => {
        newMap[key] = [map[key]];
        return newMap;
      }, {});
    }
    /**
     * Releases the memory used by the weight tensors and resourceManager.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    dispose() {
      this.executor.dispose();
      if (this.initializer) {
        this.initializer.dispose();
        if (this.resourceIdToCapturedInput) {
          dispose(this.resourceIdToCapturedInput);
        }
      }
      this.resourceManager.dispose();
    }
  };
  async function loadGraphModel(modelUrl, options = {}, tfio = io_exports) {
    if (modelUrl == null) {
      throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
    }
    if (options == null) {
      options = {};
    }
    if (options.fromTFHub && typeof modelUrl === "string") {
      modelUrl = getTFHubUrl(modelUrl);
    }
    const model = new GraphModel2(modelUrl, options, tfio);
    await model.load();
    return model;
  }
  function getTFHubUrl(modelUrl) {
    if (!modelUrl.endsWith("/")) {
      modelUrl = modelUrl + "/";
    }
    return `${modelUrl}${DEFAULT_MODEL_NAME}${TFHUB_SEARCH_PARAM}`;
  }

  // node_modules/@tensorflow-models/face-landmarks-detection/dist/face-landmarks-detection.esm.js
  var E2 = function() {
    return E2 = Object.assign || function(t3) {
      for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
        for (var i2 in e2 = arguments[n2])
          Object.prototype.hasOwnProperty.call(e2, i2) && (t3[i2] = e2[i2]);
      return t3;
    }, E2.apply(this, arguments);
  };
  function S2(t3, e2, n2, r2) {
    return new (n2 || (n2 = Promise))(function(i2, o2) {
      function a2(t4) {
        try {
          s2(r2.next(t4));
        } catch (t5) {
          o2(t5);
        }
      }
      function u2(t4) {
        try {
          s2(r2.throw(t4));
        } catch (t5) {
          o2(t5);
        }
      }
      function s2(t4) {
        var e3;
        t4.done ? i2(t4.value) : (e3 = t4.value, e3 instanceof n2 ? e3 : new n2(function(t5) {
          t5(e3);
        })).then(a2, u2);
      }
      s2((r2 = r2.apply(t3, e2 || [])).next());
    });
  }
  function F2(t3, e2) {
    var n2, r2, i2, o2, a2 = { label: 0, sent: function() {
      if (1 & i2[0])
        throw i2[1];
      return i2[1];
    }, trys: [], ops: [] };
    return o2 = { next: u2(0), throw: u2(1), return: u2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
      return this;
    }), o2;
    function u2(o3) {
      return function(u3) {
        return function(o4) {
          if (n2)
            throw new TypeError("Generator is already executing.");
          for (; a2; )
            try {
              if (n2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                return i2;
              switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                case 0:
                case 1:
                  i2 = o4;
                  break;
                case 4:
                  return a2.label++, { value: o4[1], done: false };
                case 5:
                  a2.label++, r2 = o4[1], o4 = [0];
                  continue;
                case 7:
                  o4 = a2.ops.pop(), a2.trys.pop();
                  continue;
                default:
                  if (!(i2 = a2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                    a2 = 0;
                    continue;
                  }
                  if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                    a2.label = o4[1];
                    break;
                  }
                  if (6 === o4[0] && a2.label < i2[1]) {
                    a2.label = i2[1], i2 = o4;
                    break;
                  }
                  if (i2 && a2.label < i2[2]) {
                    a2.label = i2[2], a2.ops.push(o4);
                    break;
                  }
                  i2[2] && a2.ops.pop(), a2.trys.pop();
                  continue;
              }
              o4 = e2.call(t3, a2);
            } catch (t4) {
              o4 = [6, t4], r2 = 0;
            } finally {
              n2 = i2 = 0;
            }
          if (5 & o4[0])
            throw o4[1];
          return { value: o4[0] ? o4[1] : void 0, done: true };
        }([o3, u3]);
      };
    }
  }
  function C2(t3) {
    var e2 = t3.map(function(t4) {
      return t4[0];
    });
    return e2.push(t3[t3.length - 1][1]), e2;
  }
  var O2 = { lips: C2([[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]]), leftEye: C2([[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]]), leftEyebrow: C2([[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]]), leftIris: C2([[474, 475], [475, 476], [476, 477], [477, 474]]), rightEye: C2([[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]]), rightEyebrow: C2([[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]]), rightIris: C2([[469, 470], [470, 471], [471, 472], [472, 469]]), faceOval: C2([[10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]]) };
  var _2 = [[127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]];
  var j2 = Object.entries(O2).map(function(t3) {
    var e2 = t3[0];
    return t3[1].map(function(t4) {
      return [t4, e2];
    });
  }).flat();
  var k3 = new Map(j2);
  function R2(t3) {
    for (var e2 = { locationData: { relativeKeypoints: [] } }, n2 = Number.MAX_SAFE_INTEGER, r2 = Number.MIN_SAFE_INTEGER, i2 = Number.MAX_SAFE_INTEGER, o2 = Number.MIN_SAFE_INTEGER, a2 = 0; a2 < t3.length; ++a2) {
      var u2 = t3[a2];
      n2 = Math.min(n2, u2.x), r2 = Math.max(r2, u2.x), i2 = Math.min(i2, u2.y), o2 = Math.max(o2, u2.y), e2.locationData.relativeKeypoints.push({ x: u2.x, y: u2.y });
    }
    return e2.locationData.relativeBoundingBox = { xMin: n2, yMin: i2, xMax: r2, yMax: o2, width: r2 - n2, height: o2 - i2 }, e2;
  }
  var I2 = { runtime: "mediapipe", maxFaces: 1, refineLandmarks: false };
  var L2 = function() {
    function n2(e2) {
      var n3 = this;
      this.width = 0, this.height = 0, this.selfieMode = false, this.faceMeshSolution = new t2.FaceMesh({ locateFile: function(t3, n4) {
        return e2.solutionPath ? e2.solutionPath.replace(/\/+$/, "") + "/" + t3 : n4 + "/" + t3;
      } }), this.faceMeshSolution.setOptions({ refineLandmarks: e2.refineLandmarks, selfieMode: this.selfieMode, maxNumFaces: e2.maxFaces }), this.faceMeshSolution.onResults(function(t3) {
        if (n3.height = t3.image.height, n3.width = t3.image.width, n3.faces = [], null !== t3.multiFaceLandmarks)
          for (var e3 = t3.multiFaceLandmarks, r2 = 0; r2 < e3.length; r2++) {
            var i2 = n3.translateOutput(e3[r2]);
            n3.faces.push({ keypoints: i2, box: R2(i2).locationData.relativeBoundingBox });
          }
      });
    }
    return n2.prototype.translateOutput = function(t3) {
      var e2 = this;
      return t3.map(function(t4, n3) {
        var r2 = { x: t4.x * e2.width, y: t4.y * e2.height, z: t4.z * e2.width }, i2 = k3.get(n3);
        return null != i2 && (r2.name = i2), r2;
      });
    }, n2.prototype.estimateFaces = function(t3, n3) {
      return S2(this, void 0, void 0, function() {
        var r2, i2;
        return F2(this, function(o2) {
          switch (o2.label) {
            case 0:
              return n3 && n3.flipHorizontal && n3.flipHorizontal !== this.selfieMode && (this.selfieMode = n3.flipHorizontal, this.faceMeshSolution.setOptions({ selfieMode: this.selfieMode })), t3 instanceof Tensor ? (i2 = ImageData.bind, [4, browser_exports.toPixels(t3)]) : [3, 2];
            case 1:
              return r2 = new (i2.apply(ImageData, [void 0, o2.sent(), t3.shape[1], t3.shape[0]]))(), [3, 3];
            case 2:
              r2 = t3, o2.label = 3;
            case 3:
              return t3 = r2, [4, this.faceMeshSolution.send({ image: t3 })];
            case 4:
              return o2.sent(), [2, this.faces];
          }
        });
      });
    }, n2.prototype.dispose = function() {
      this.faceMeshSolution.close();
    }, n2.prototype.reset = function() {
      this.faceMeshSolution.reset(), this.width = 0, this.height = 0, this.faces = null, this.selfieMode = false;
    }, n2.prototype.initialize = function() {
      return this.faceMeshSolution.initialize();
    }, n2;
  }();
  function B2(t3) {
    return S2(this, void 0, void 0, function() {
      var e2, n2;
      return F2(this, function(r2) {
        switch (r2.label) {
          case 0:
            return e2 = function(t4) {
              if (null == t4)
                return E2({}, I2);
              var e3 = E2({}, t4);
              return e3.runtime = "mediapipe", null == e3.maxFaces && (e3.maxFaces = I2.maxFaces), null == e3.refineLandmarks && (e3.refineLandmarks = I2.refineLandmarks), e3;
            }(t3), [4, (n2 = new L2(e2)).initialize()];
          case 1:
            return r2.sent(), [2, n2];
        }
      });
    });
  }
  var D2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
  var P2 = {};
  (function() {
    var t3;
    function e2(t4) {
      var e3 = 0;
      return function() {
        return e3 < t4.length ? { done: false, value: t4[e3++] } : { done: true };
      };
    }
    var n2 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(t4, e3, n3) {
      return t4 == Array.prototype || t4 == Object.prototype || (t4[e3] = n3.value), t4;
    };
    var r2 = function(t4) {
      t4 = ["object" == typeof globalThis && globalThis, t4, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof D2 && D2];
      for (var e3 = 0; e3 < t4.length; ++e3) {
        var n3 = t4[e3];
        if (n3 && n3.Math == Math)
          return n3;
      }
      throw Error("Cannot find global object");
    }(this);
    function i2(t4, e3) {
      if (e3)
        t: {
          var i3 = r2;
          t4 = t4.split(".");
          for (var o3 = 0; o3 < t4.length - 1; o3++) {
            var a3 = t4[o3];
            if (!(a3 in i3))
              break t;
            i3 = i3[a3];
          }
          (e3 = e3(o3 = i3[t4 = t4[t4.length - 1]])) != o3 && null != e3 && n2(i3, t4, { configurable: true, writable: true, value: e3 });
        }
    }
    function o2(t4) {
      return (t4 = { next: t4 })[Symbol.iterator] = function() {
        return this;
      }, t4;
    }
    function a2(t4) {
      var n3 = "undefined" != typeof Symbol && Symbol.iterator && t4[Symbol.iterator];
      return n3 ? n3.call(t4) : { next: e2(t4) };
    }
    function u2(t4) {
      if (!(t4 instanceof Array)) {
        t4 = a2(t4);
        for (var e3, n3 = []; !(e3 = t4.next()).done; )
          n3.push(e3.value);
        t4 = n3;
      }
      return t4;
    }
    i2("Symbol", function(t4) {
      function e3(t5, e4) {
        this.g = t5, n2(this, "description", { configurable: true, writable: true, value: e4 });
      }
      if (t4)
        return t4;
      e3.prototype.toString = function() {
        return this.g;
      };
      var r3 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", i3 = 0;
      return function t5(n3) {
        if (this instanceof t5)
          throw new TypeError("Symbol is not a constructor");
        return new e3(r3 + (n3 || "") + "_" + i3++, n3);
      };
    }), i2("Symbol.iterator", function(t4) {
      if (t4)
        return t4;
      t4 = Symbol("Symbol.iterator");
      for (var i3 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), a3 = 0; a3 < i3.length; a3++) {
        var u3 = r2[i3[a3]];
        "function" == typeof u3 && "function" != typeof u3.prototype[t4] && n2(u3.prototype, t4, { configurable: true, writable: true, value: function() {
          return o2(e2(this));
        } });
      }
      return t4;
    });
    var s2, c2 = "function" == typeof Object.create ? Object.create : function(t4) {
      function e3() {
      }
      return e3.prototype = t4, new e3();
    };
    if ("function" == typeof Object.setPrototypeOf)
      s2 = Object.setPrototypeOf;
    else {
      var h;
      t: {
        var l3 = {};
        try {
          l3.__proto__ = { a: true }, h = l3.a;
          break t;
        } catch (t4) {
        }
        h = false;
      }
      s2 = h ? function(t4, e3) {
        if (t4.__proto__ = e3, t4.__proto__ !== e3)
          throw new TypeError(t4 + " is not extensible");
        return t4;
      } : null;
    }
    var f2 = s2;
    function d2(t4, e3) {
      if (t4.prototype = c2(e3.prototype), t4.prototype.constructor = t4, f2)
        f2(t4, e3);
      else
        for (var n3 in e3)
          if ("prototype" != n3)
            if (Object.defineProperties) {
              var r3 = Object.getOwnPropertyDescriptor(e3, n3);
              r3 && Object.defineProperty(t4, n3, r3);
            } else
              t4[n3] = e3[n3];
      t4.na = e3.prototype;
    }
    function p2() {
      this.l = false, this.i = null, this.h = void 0, this.g = 1, this.u = this.o = 0, this.j = null;
    }
    function g2(t4) {
      if (t4.l)
        throw new TypeError("Generator is already running");
      t4.l = true;
    }
    function v2(t4, e3) {
      t4.j = { da: e3, ea: true }, t4.g = t4.o || t4.u;
    }
    function m2(t4, e3, n3) {
      return t4.g = n3, { value: e3 };
    }
    function y2(t4) {
      this.g = new p2(), this.h = t4;
    }
    function w2(t4, e3, n3, r3) {
      try {
        var i3 = e3.call(t4.g.i, n3);
        if (!(i3 instanceof Object))
          throw new TypeError("Iterator result " + i3 + " is not an object");
        if (!i3.done)
          return t4.g.l = false, i3;
        var o3 = i3.value;
      } catch (e4) {
        return t4.g.i = null, v2(t4.g, e4), b2(t4);
      }
      return t4.g.i = null, r3.call(t4.g, o3), b2(t4);
    }
    function b2(t4) {
      for (; t4.g.g; )
        try {
          var e3 = t4.h(t4.g);
          if (e3)
            return t4.g.l = false, { value: e3.value, done: false };
        } catch (e4) {
          t4.g.h = void 0, v2(t4.g, e4);
        }
      if (t4.g.l = false, t4.g.j) {
        if (e3 = t4.g.j, t4.g.j = null, e3.ea)
          throw e3.da;
        return { value: e3.return, done: true };
      }
      return { value: void 0, done: true };
    }
    function x2(t4) {
      this.next = function(e3) {
        return g2(t4.g), t4.g.i ? e3 = w2(t4, t4.g.i.next, e3, t4.g.s) : (t4.g.s(e3), e3 = b2(t4)), e3;
      }, this.throw = function(e3) {
        return g2(t4.g), t4.g.i ? e3 = w2(t4, t4.g.i.throw, e3, t4.g.s) : (v2(t4.g, e3), e3 = b2(t4)), e3;
      }, this.return = function(e3) {
        return function(t5, e4) {
          g2(t5.g);
          var n3 = t5.g.i;
          return n3 ? w2(t5, "return" in n3 ? n3.return : function(t6) {
            return { value: t6, done: true };
          }, e4, t5.g.return) : (t5.g.return(e4), b2(t5));
        }(t4, e3);
      }, this[Symbol.iterator] = function() {
        return this;
      };
    }
    function M2(t4) {
      return function(t5) {
        function e3(e4) {
          return t5.next(e4);
        }
        function n3(e4) {
          return t5.throw(e4);
        }
        return new Promise(function(r3, i3) {
          !function t6(o3) {
            o3.done ? r3(o3.value) : Promise.resolve(o3.value).then(e3, n3).then(t6, i3);
          }(t5.next());
        });
      }(new x2(new y2(t4)));
    }
    p2.prototype.s = function(t4) {
      this.h = t4;
    }, p2.prototype.return = function(t4) {
      this.j = { return: t4 }, this.g = this.u;
    }, i2("Promise", function(t4) {
      function e3(t5) {
        this.h = 0, this.i = void 0, this.g = [], this.s = false;
        var e4 = this.j();
        try {
          t5(e4.resolve, e4.reject);
        } catch (t6) {
          e4.reject(t6);
        }
      }
      function n3() {
        this.g = null;
      }
      function i3(t5) {
        return t5 instanceof e3 ? t5 : new e3(function(e4) {
          e4(t5);
        });
      }
      if (t4)
        return t4;
      n3.prototype.h = function(t5) {
        if (null == this.g) {
          this.g = [];
          var e4 = this;
          this.i(function() {
            e4.l();
          });
        }
        this.g.push(t5);
      };
      var o3 = r2.setTimeout;
      n3.prototype.i = function(t5) {
        o3(t5, 0);
      }, n3.prototype.l = function() {
        for (; this.g && this.g.length; ) {
          var t5 = this.g;
          this.g = [];
          for (var e4 = 0; e4 < t5.length; ++e4) {
            var n4 = t5[e4];
            t5[e4] = null;
            try {
              n4();
            } catch (t6) {
              this.j(t6);
            }
          }
        }
        this.g = null;
      }, n3.prototype.j = function(t5) {
        this.i(function() {
          throw t5;
        });
      }, e3.prototype.j = function() {
        function t5(t6) {
          return function(r3) {
            n4 || (n4 = true, t6.call(e4, r3));
          };
        }
        var e4 = this, n4 = false;
        return { resolve: t5(this.D), reject: t5(this.l) };
      }, e3.prototype.D = function(t5) {
        if (t5 === this)
          this.l(new TypeError("A Promise cannot resolve to itself"));
        else if (t5 instanceof e3)
          this.H(t5);
        else {
          t:
            switch (typeof t5) {
              case "object":
                var n4 = null != t5;
                break t;
              case "function":
                n4 = true;
                break t;
              default:
                n4 = false;
            }
          n4 ? this.A(t5) : this.o(t5);
        }
      }, e3.prototype.A = function(t5) {
        var e4 = void 0;
        try {
          e4 = t5.then;
        } catch (t6) {
          return void this.l(t6);
        }
        "function" == typeof e4 ? this.I(e4, t5) : this.o(t5);
      }, e3.prototype.l = function(t5) {
        this.u(2, t5);
      }, e3.prototype.o = function(t5) {
        this.u(1, t5);
      }, e3.prototype.u = function(t5, e4) {
        if (0 != this.h)
          throw Error("Cannot settle(" + t5 + ", " + e4 + "): Promise already settled in state" + this.h);
        this.h = t5, this.i = e4, 2 === this.h && this.G(), this.B();
      }, e3.prototype.G = function() {
        var t5 = this;
        o3(function() {
          if (t5.C()) {
            var e4 = r2.console;
            void 0 !== e4 && e4.error(t5.i);
          }
        }, 1);
      }, e3.prototype.C = function() {
        if (this.s)
          return false;
        var t5 = r2.CustomEvent, e4 = r2.Event, n4 = r2.dispatchEvent;
        return void 0 === n4 || ("function" == typeof t5 ? t5 = new t5("unhandledrejection", { cancelable: true }) : "function" == typeof e4 ? t5 = new e4("unhandledrejection", { cancelable: true }) : (t5 = r2.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection", false, true, t5), t5.promise = this, t5.reason = this.i, n4(t5));
      }, e3.prototype.B = function() {
        if (null != this.g) {
          for (var t5 = 0; t5 < this.g.length; ++t5)
            u3.h(this.g[t5]);
          this.g = null;
        }
      };
      var u3 = new n3();
      return e3.prototype.H = function(t5) {
        var e4 = this.j();
        t5.M(e4.resolve, e4.reject);
      }, e3.prototype.I = function(t5, e4) {
        var n4 = this.j();
        try {
          t5.call(e4, n4.resolve, n4.reject);
        } catch (t6) {
          n4.reject(t6);
        }
      }, e3.prototype.then = function(t5, n4) {
        function r3(t6, e4) {
          return "function" == typeof t6 ? function(e5) {
            try {
              i4(t6(e5));
            } catch (t7) {
              o4(t7);
            }
          } : e4;
        }
        var i4, o4, a3 = new e3(function(t6, e4) {
          i4 = t6, o4 = e4;
        });
        return this.M(r3(t5, i4), r3(n4, o4)), a3;
      }, e3.prototype.catch = function(t5) {
        return this.then(void 0, t5);
      }, e3.prototype.M = function(t5, e4) {
        function n4() {
          switch (r3.h) {
            case 1:
              t5(r3.i);
              break;
            case 2:
              e4(r3.i);
              break;
            default:
              throw Error("Unexpected state: " + r3.h);
          }
        }
        var r3 = this;
        null == this.g ? u3.h(n4) : this.g.push(n4), this.s = true;
      }, e3.resolve = i3, e3.reject = function(t5) {
        return new e3(function(e4, n4) {
          n4(t5);
        });
      }, e3.race = function(t5) {
        return new e3(function(e4, n4) {
          for (var r3 = a2(t5), o4 = r3.next(); !o4.done; o4 = r3.next())
            i3(o4.value).M(e4, n4);
        });
      }, e3.all = function(t5) {
        var n4 = a2(t5), r3 = n4.next();
        return r3.done ? i3([]) : new e3(function(t6, e4) {
          function o4(e5) {
            return function(n5) {
              a3[e5] = n5, 0 == --u4 && t6(a3);
            };
          }
          var a3 = [], u4 = 0;
          do {
            a3.push(void 0), u4++, i3(r3.value).M(o4(a3.length - 1), e4), r3 = n4.next();
          } while (!r3.done);
        });
      }, e3;
    });
    var A2 = "function" == typeof Object.assign ? Object.assign : function(t4, e3) {
      for (var n3 = 1; n3 < arguments.length; n3++) {
        var r3 = arguments[n3];
        if (r3)
          for (var i3 in r3)
            Object.prototype.hasOwnProperty.call(r3, i3) && (t4[i3] = r3[i3]);
      }
      return t4;
    };
    i2("Object.assign", function(t4) {
      return t4 || A2;
    }), i2("Object.is", function(t4) {
      return t4 || function(t5, e3) {
        return t5 === e3 ? 0 !== t5 || 1 / t5 == 1 / e3 : t5 != t5 && e3 != e3;
      };
    }), i2("Array.prototype.includes", function(t4) {
      return t4 || function(t5, e3) {
        var n3 = this;
        n3 instanceof String && (n3 = String(n3));
        var r3 = n3.length;
        for (0 > (e3 = e3 || 0) && (e3 = Math.max(e3 + r3, 0)); e3 < r3; e3++) {
          var i3 = n3[e3];
          if (i3 === t5 || Object.is(i3, t5))
            return true;
        }
        return false;
      };
    }), i2("String.prototype.includes", function(t4) {
      return t4 || function(t5, e3) {
        if (null == this)
          throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");
        if (t5 instanceof RegExp)
          throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
        return -1 !== this.indexOf(t5, e3 || 0);
      };
    }), i2("Array.prototype.keys", function(t4) {
      return t4 || function() {
        return function(t5, e3) {
          t5 instanceof String && (t5 += "");
          var n3 = 0, r3 = false, i3 = { next: function() {
            if (!r3 && n3 < t5.length) {
              var i4 = n3++;
              return { value: e3(i4, t5[i4]), done: false };
            }
            return r3 = true, { done: true, value: void 0 };
          } };
          return i3[Symbol.iterator] = function() {
            return i3;
          }, i3;
        }(this, function(t5) {
          return t5;
        });
      };
    });
    var T2 = this || self;
    function E3(t4, e3) {
      t4 = t4.split(".");
      var n3, r3 = T2;
      t4[0] in r3 || void 0 === r3.execScript || r3.execScript("var " + t4[0]);
      for (; t4.length && (n3 = t4.shift()); )
        t4.length || void 0 === e3 ? r3 = r3[n3] && r3[n3] !== Object.prototype[n3] ? r3[n3] : r3[n3] = {} : r3[n3] = e3;
    }
    function S3() {
      throw Error("Invalid UTF8");
    }
    function F3(t4, e3) {
      return e3 = String.fromCharCode.apply(null, e3), null == t4 ? e3 : t4 + e3;
    }
    var C3, O3, _3 = "undefined" != typeof TextDecoder, j3 = "undefined" != typeof TextEncoder, k4 = {}, R3 = null;
    function I3(t4) {
      var e3;
      void 0 === e3 && (e3 = 0), B3(), e3 = k4[e3];
      for (var n3 = Array(Math.floor(t4.length / 3)), r3 = e3[64] || "", i3 = 0, o3 = 0; i3 < t4.length - 2; i3 += 3) {
        var a3 = t4[i3], u3 = t4[i3 + 1], s3 = t4[i3 + 2], c3 = e3[a3 >> 2];
        a3 = e3[(3 & a3) << 4 | u3 >> 4], u3 = e3[(15 & u3) << 2 | s3 >> 6], s3 = e3[63 & s3], n3[o3++] = c3 + a3 + u3 + s3;
      }
      switch (c3 = 0, s3 = r3, t4.length - i3) {
        case 2:
          s3 = e3[(15 & (c3 = t4[i3 + 1])) << 2] || r3;
        case 1:
          t4 = t4[i3], n3[o3] = e3[t4 >> 2] + e3[(3 & t4) << 4 | c3 >> 4] + s3 + r3;
      }
      return n3.join("");
    }
    function L3(t4) {
      var e3 = t4.length, n3 = 3 * e3 / 4;
      n3 % 3 ? n3 = Math.floor(n3) : -1 != "=.".indexOf(t4[e3 - 1]) && (n3 = -1 != "=.".indexOf(t4[e3 - 2]) ? n3 - 2 : n3 - 1);
      var r3 = new Uint8Array(n3), i3 = 0;
      return function(t5, e4) {
        function n4(e5) {
          for (; r4 < t5.length; ) {
            var n5 = t5.charAt(r4++), i5 = R3[n5];
            if (null != i5)
              return i5;
            if (!/^[\s\xa0]*$/.test(n5))
              throw Error("Unknown base64 encoding at char: " + n5);
          }
          return e5;
        }
        B3();
        for (var r4 = 0; ; ) {
          var i4 = n4(-1), o3 = n4(0), a3 = n4(64), u3 = n4(64);
          if (64 === u3 && -1 === i4)
            break;
          e4(i4 << 2 | o3 >> 4), 64 != a3 && (e4(o3 << 4 & 240 | a3 >> 2), 64 != u3 && e4(a3 << 6 & 192 | u3));
        }
      }(t4, function(t5) {
        r3[i3++] = t5;
      }), i3 !== n3 ? r3.subarray(0, i3) : r3;
    }
    function B3() {
      if (!R3) {
        R3 = {};
        for (var t4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e3 = ["+/=", "+/", "-_=", "-_.", "-_"], n3 = 0; 5 > n3; n3++) {
          var r3 = t4.concat(e3[n3].split(""));
          k4[n3] = r3;
          for (var i3 = 0; i3 < r3.length; i3++) {
            var o3 = r3[i3];
            void 0 === R3[o3] && (R3[o3] = i3);
          }
        }
      }
    }
    var P3, z3 = "function" == typeof Uint8Array;
    function U3(t4) {
      return z3 && null != t4 && t4 instanceof Uint8Array;
    }
    function N3(t4) {
      if (this.L = t4, null !== t4 && 0 === t4.length)
        throw Error("ByteString should be constructed with non-empty values");
    }
    var V3 = "function" == typeof Uint8Array.prototype.slice, H3 = 0;
    function K3(t4, e3) {
      return Error("Invalid wire type: " + t4 + " (at position " + e3 + ")");
    }
    function W3() {
      return Error("Failed to read varint, encoding is invalid.");
    }
    function G3(t4, e3) {
      e3 = void 0 !== (e3 = void 0 === e3 ? {} : e3).v && e3.v, this.h = null, this.g = this.i = this.j = 0, this.v = e3, t4 && X3(this, t4);
    }
    function X3(t4, e3) {
      t4.h = function(t5, e4) {
        if (t5.constructor === Uint8Array)
          return t5;
        if (t5.constructor === ArrayBuffer)
          return new Uint8Array(t5);
        if (t5.constructor === Array)
          return new Uint8Array(t5);
        if (t5.constructor === String)
          return L3(t5);
        if (t5.constructor === N3)
          return !e4 && (e4 = t5.L) && e4.constructor === Uint8Array ? e4 : (e4 = null == (e4 = t5.L) || U3(e4) ? e4 : "string" == typeof e4 ? L3(e4) : null, (t5 = t5.L = e4) ? new Uint8Array(t5) : P3 || (P3 = new Uint8Array(0)));
        if (t5 instanceof Uint8Array)
          return new Uint8Array(t5.buffer, t5.byteOffset, t5.byteLength);
        throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers");
      }(e3, t4.v), t4.j = 0, t4.i = t4.h.length, t4.g = t4.j;
    }
    function Y3(t4) {
      if (t4.g > t4.i)
        throw Error("Tried to read past the end of the data " + t4.g + " > " + t4.i);
    }
    function J3(t4) {
      var e3 = t4.h, n3 = e3[t4.g], r3 = 127 & n3;
      if (128 > n3)
        return t4.g += 1, Y3(t4), r3;
      if (r3 |= (127 & (n3 = e3[t4.g + 1])) << 7, 128 > n3)
        return t4.g += 2, Y3(t4), r3;
      if (r3 |= (127 & (n3 = e3[t4.g + 2])) << 14, 128 > n3)
        return t4.g += 3, Y3(t4), r3;
      if (r3 |= (127 & (n3 = e3[t4.g + 3])) << 21, 128 > n3)
        return t4.g += 4, Y3(t4), r3;
      if (n3 = e3[t4.g + 4], t4.g += 5, r3 |= (15 & n3) << 28, 128 > n3)
        return Y3(t4), r3;
      if (128 <= e3[t4.g++] && 128 <= e3[t4.g++] && 128 <= e3[t4.g++] && 128 <= e3[t4.g++] && 128 <= e3[t4.g++])
        throw W3();
      return Y3(t4), r3;
    }
    G3.prototype.reset = function() {
      this.g = this.j;
    };
    var q3 = [];
    function $3() {
      this.g = [];
    }
    function Z3(t4, e3) {
      for (; 127 < e3; )
        t4.g.push(127 & e3 | 128), e3 >>>= 7;
      t4.g.push(e3);
    }
    function Q3(t4) {
      var e3 = {}, n3 = void 0 !== e3.W && e3.W;
      this.l = { v: void 0 !== e3.v && e3.v }, this.W = n3, e3 = this.l, q3.length ? (n3 = q3.pop(), e3 && (n3.v = e3.v), t4 && X3(n3, t4), t4 = n3) : t4 = new G3(t4, e3), this.g = t4, this.j = this.g.g, this.h = this.i = -1;
    }
    function tt3(t4) {
      var e3 = t4.g;
      if (e3.g == e3.i)
        return false;
      t4.j = t4.g.g;
      var n3 = J3(t4.g) >>> 0;
      if (e3 = n3 >>> 3, !(0 <= (n3 &= 7) && 5 >= n3))
        throw K3(n3, t4.j);
      if (1 > e3)
        throw Error("Invalid field number: " + e3 + " (at position " + t4.j + ")");
      return t4.i = e3, t4.h = n3, true;
    }
    function et3(t4) {
      switch (t4.h) {
        case 0:
          if (0 != t4.h)
            et3(t4);
          else
            t: {
              for (var e3 = (t4 = t4.g).g, n3 = e3 + 10; e3 < n3; )
                if (0 == (128 & t4.h[e3++])) {
                  t4.g = e3, Y3(t4);
                  break t;
                }
              throw W3();
            }
          break;
        case 1:
          (t4 = t4.g).g += 8, Y3(t4);
          break;
        case 2:
          2 != t4.h ? et3(t4) : (e3 = J3(t4.g) >>> 0, (t4 = t4.g).g += e3, Y3(t4));
          break;
        case 5:
          (t4 = t4.g).g += 4, Y3(t4);
          break;
        case 3:
          for (e3 = t4.i; ; ) {
            if (!tt3(t4))
              throw Error("Unmatched start-group tag: stream EOF");
            if (4 == t4.h) {
              if (t4.i != e3)
                throw Error("Unmatched end-group tag");
              break;
            }
            et3(t4);
          }
          break;
        default:
          throw K3(t4.h, t4.j);
      }
    }
    $3.prototype.length = function() {
      return this.g.length;
    }, $3.prototype.end = function() {
      var t4 = this.g;
      return this.g = [], t4;
    }, Q3.prototype.reset = function() {
      this.g.reset(), this.j = this.g.g, this.h = this.i = -1;
    };
    var nt3 = [];
    function rt3() {
      this.i = [], this.h = 0, this.g = new $3();
    }
    function it3(t4, e3) {
      0 !== e3.length && (t4.i.push(e3), t4.h += e3.length);
    }
    var ot3 = "function" == typeof Symbol && "symbol" == typeof Symbol() ? Symbol(void 0) : void 0;
    function at3(t4, e3) {
      Object.isFrozen(t4) || (ot3 ? t4[ot3] |= e3 : void 0 !== t4.N ? t4.N |= e3 : Object.defineProperties(t4, { N: { value: e3, configurable: true, writable: true, enumerable: false } }));
    }
    function ut3(t4) {
      var e3;
      return null == (e3 = ot3 ? t4[ot3] : t4.N) ? 0 : e3;
    }
    function st3(t4) {
      return at3(t4, 1), t4;
    }
    function ct3(t4) {
      return !!Array.isArray(t4) && !!(2 & ut3(t4));
    }
    function ht3(t4) {
      if (!Array.isArray(t4))
        throw Error("cannot mark non-array as immutable");
      at3(t4, 2);
    }
    function lt3(t4) {
      return null !== t4 && "object" == typeof t4 && !Array.isArray(t4) && t4.constructor === Object;
    }
    var ft3 = Object.freeze(st3([]));
    function dt3(t4) {
      if (ct3(t4.m))
        throw Error("Cannot mutate an immutable Message");
    }
    var pt3, gt3 = "undefined" != typeof Symbol && void 0 !== Symbol.hasInstance;
    function vt3(t4) {
      return { value: t4, configurable: false, writable: false, enumerable: false };
    }
    function mt3(t4, e3, n3) {
      return -1 === e3 ? null : e3 >= t4.i ? t4.g ? t4.g[e3] : void 0 : void 0 !== n3 && n3 && t4.g && null != (n3 = t4.g[e3]) ? n3 : t4.m[e3 + t4.h];
    }
    function yt3(t4, e3, n3, r3) {
      r3 = void 0 !== r3 && r3, dt3(t4), e3 < t4.i && !r3 ? t4.m[e3 + t4.h] = n3 : (t4.g || (t4.g = t4.m[t4.i + t4.h] = {}))[e3] = n3;
    }
    function wt3(t4, e3, n3, r3) {
      n3 = void 0 === n3 || n3;
      var i3 = mt3(t4, e3, r3 = void 0 !== r3 && r3);
      return null == i3 && (i3 = ft3), ct3(t4.m) ? n3 && (ht3(i3), Object.freeze(i3)) : (i3 === ft3 || ct3(i3)) && yt3(t4, e3, i3 = st3(i3.slice()), r3), i3;
    }
    function bt3(t4, e3, n3) {
      return null == (t4 = null == (t4 = mt3(t4, e3)) ? t4 : +t4) ? void 0 === n3 ? 0 : n3 : t4;
    }
    function xt3(t4, e3, n3, r3) {
      t4.j || (t4.j = {});
      var i3 = ct3(t4.m), o3 = t4.j[n3];
      if (!o3) {
        r3 = wt3(t4, n3, true, void 0 !== r3 && r3), o3 = [], i3 = i3 || ct3(r3);
        for (var a3 = 0; a3 < r3.length; a3++)
          o3[a3] = new e3(r3[a3]), i3 && ht3(o3[a3].m);
        i3 && (ht3(o3), Object.freeze(o3)), t4.j[n3] = o3;
      }
      return o3;
    }
    function Mt3(t4, e3, n3, r3, i3) {
      var o3 = void 0 !== o3 && o3;
      return dt3(t4), o3 = xt3(t4, n3, e3, o3), n3 = r3 || new n3(), t4 = wt3(t4, e3), null != i3 ? (o3.splice(i3, 0, n3), t4.splice(i3, 0, n3.m)) : (o3.push(n3), t4.push(n3.m)), n3;
    }
    function At3(t4, e3) {
      return null == (t4 = mt3(t4, e3)) ? 0 : t4;
    }
    function Tt3(t4, e3) {
      return null == (t4 = mt3(t4, e3)) ? "" : t4;
    }
    function Et3(t4) {
      var e3 = Ct3;
      return Ft3(t4, e3 = void 0 === e3 ? Ot3 : e3);
    }
    function St3(t4, e3) {
      if (null != t4) {
        if (Array.isArray(t4))
          t4 = Ft3(t4, e3);
        else if (lt3(t4)) {
          var n3, r3 = {};
          for (n3 in t4)
            r3[n3] = St3(t4[n3], e3);
          t4 = r3;
        } else
          t4 = e3(t4);
        return t4;
      }
    }
    function Ft3(t4, e3) {
      for (var n3 = t4.slice(), r3 = 0; r3 < n3.length; r3++)
        n3[r3] = St3(n3[r3], e3);
      return Array.isArray(t4) && 1 & ut3(t4) && st3(n3), n3;
    }
    function Ct3(t4) {
      return t4 && "object" == typeof t4 && t4.toJSON ? t4.toJSON() : (t4 = function(t5) {
        switch (typeof t5) {
          case "number":
            return isFinite(t5) ? t5 : String(t5);
          case "object":
            if (t5 && !Array.isArray(t5)) {
              if (U3(t5))
                return I3(t5);
              if (t5 instanceof N3) {
                var e3 = t5.L;
                return e3 = null == e3 || "string" == typeof e3 ? e3 : z3 && e3 instanceof Uint8Array ? I3(e3) : null, (t5.L = e3) || "";
              }
            }
        }
        return t5;
      }(t4), Array.isArray(t4) ? Et3(t4) : t4);
    }
    function Ot3(t4) {
      return U3(t4) ? new Uint8Array(t4) : t4;
    }
    function _t3(t4, e3, n3) {
      t4 || (t4 = pt3), pt3 = null;
      var r3 = this.constructor.h;
      if (t4 || (t4 = r3 ? [r3] : []), this.h = (r3 ? 0 : -1) - (this.constructor.g || 0), this.j = void 0, this.m = t4, t4 = (r3 = this.m.length) - 1, r3 && lt3(r3 = this.m[t4]) ? (this.i = t4 - this.h, this.g = r3) : void 0 !== e3 && -1 < e3 ? (this.i = Math.max(e3, t4 + 1 - this.h), this.g = void 0) : this.i = Number.MAX_VALUE, n3)
        for (e3 = 0; e3 < n3.length; e3++)
          if ((t4 = n3[e3]) < this.i)
            t4 += this.h, (r3 = this.m[t4]) ? Array.isArray(r3) && st3(r3) : this.m[t4] = ft3;
          else {
            var i3 = (r3 = this.g || (this.g = this.m[this.i + this.h] = {}))[t4];
            i3 ? Array.isArray(i3) && st3(i3) : r3[t4] = ft3;
          }
    }
    function jt3() {
      _t3.apply(this, arguments);
    }
    if (_t3.prototype.toJSON = function() {
      return Et3(this.m);
    }, _t3.prototype.toString = function() {
      return this.m.toString();
    }, d2(jt3, _t3), gt3) {
      var kt3 = {};
      Object.defineProperties(jt3, (kt3[Symbol.hasInstance] = vt3(function() {
        throw Error("Cannot perform instanceof checks for MutableMessage");
      }), kt3));
    }
    function Rt3(t4, e3, n3) {
      if (n3) {
        var r3, i3 = {};
        for (r3 in n3) {
          var o3 = n3[r3], a3 = o3.ha;
          a3 || (i3.F = o3.la || o3.fa.P, o3.aa ? (i3.U = Ut3(o3.aa), a3 = function(t5) {
            return function(e4, n4, r4) {
              return t5.F(e4, n4, r4, t5.U);
            };
          }(i3)) : o3.ca ? (i3.T = Nt3(o3.X.g, o3.ca), a3 = function(t5) {
            return function(e4, n4, r4) {
              return t5.F(e4, n4, r4, t5.T);
            };
          }(i3)) : a3 = i3.F, o3.ha = a3), a3(e3, t4, o3.X), i3 = { F: i3.F, U: i3.U, T: i3.T };
        }
      }
      !function(t5, e4) {
        if (e4 = e4.ba) {
          it3(t5, t5.g.end());
          for (var n4 = 0; n4 < e4.length; n4++)
            it3(t5, e4[n4]);
        }
      }(e3, t4);
    }
    var It3 = Symbol();
    function Lt3(t4, e3, n3) {
      return t4[It3] || (t4[It3] = function(t5, r3) {
        return e3(t5, r3, n3);
      });
    }
    function Bt3(t4) {
      var e3 = t4[It3];
      if (!e3) {
        var n3 = Qt2(t4);
        e3 = function(t5, e4) {
          return te2(t5, e4, n3);
        }, t4[It3] = e3;
      }
      return e3;
    }
    function Dt3(t4) {
      var e3 = function(t5) {
        var e4 = t5.aa;
        return e4 ? Bt3(e4) : (e4 = t5.ka) ? Lt3(t5.X.g, e4, t5.ca) : void 0;
      }(t4), n3 = t4.X, r3 = t4.fa.O;
      return e3 ? function(t5, i3) {
        return r3(t5, i3, n3, e3);
      } : function(t5, e4) {
        return r3(t5, e4, n3);
      };
    }
    function Pt3(t4, e3, n3, r3, i3, o3) {
      var a3 = 0;
      for ((t4 = t4()).length && "number" != typeof t4[0] && (n3(e3, t4[0]), a3++); a3 < t4.length; ) {
        n3 = t4[a3++];
        for (var u3 = a3 + 1; u3 < t4.length && "number" != typeof t4[u3]; )
          u3++;
        var s3 = t4[a3++];
        switch (u3 -= a3) {
          case 0:
            r3(e3, n3, s3);
            break;
          case 1:
            r3(e3, n3, s3, t4[a3++]);
            break;
          case 2:
            i3(e3, n3, s3, t4[a3++], t4[a3++]);
            break;
          case 3:
            u3 = t4[a3++];
            var c3 = t4[a3++], h2 = t4[a3++];
            Array.isArray(h2) ? i3(e3, n3, s3, u3, c3, h2) : o3(e3, n3, s3, u3, c3, h2);
            break;
          case 4:
            o3(e3, n3, s3, t4[a3++], t4[a3++], t4[a3++], t4[a3++]);
            break;
          default:
            throw Error("unexpected number of binary field arguments: " + u3);
        }
      }
      return e3;
    }
    var zt3 = Symbol();
    function Ut3(t4) {
      var e3 = t4[zt3];
      if (!e3) {
        var n3 = Xt3(t4);
        e3 = function(t5, e4) {
          return ne2(t5, e4, n3);
        }, t4[zt3] = e3;
      }
      return e3;
    }
    function Nt3(t4, e3) {
      var n3 = t4[zt3];
      return n3 || (n3 = function(t5, n4) {
        return Rt3(t5, n4, e3);
      }, t4[zt3] = n3), n3;
    }
    var Vt3 = Symbol();
    function Ht3(t4, e3) {
      t4.push(e3);
    }
    function Kt3(t4, e3, n3) {
      t4.push(e3, n3.P);
    }
    function Wt3(t4, e3, n3, r3, i3) {
      var o3 = Ut3(i3), a3 = n3.P;
      t4.push(e3, function(t5, e4, n4) {
        return a3(t5, e4, n4, r3, o3);
      });
    }
    function Gt3(t4, e3, n3, r3, i3, o3) {
      var a3 = Nt3(r3, o3), u3 = n3.P;
      t4.push(e3, function(t5, e4, n4) {
        return u3(t5, e4, n4, r3, a3);
      });
    }
    function Xt3(t4) {
      var e3 = t4[Vt3];
      return e3 || Pt3(t4, t4[Vt3] = [], Ht3, Kt3, Wt3, Gt3);
    }
    var Yt3 = Symbol();
    function Jt3(t4, e3) {
      t4[0] = e3;
    }
    function qt3(t4, e3, n3, r3) {
      var i3 = n3.O;
      t4[e3] = r3 ? function(t5, e4, n4) {
        return i3(t5, e4, n4, r3);
      } : i3;
    }
    function $t3(t4, e3, n3, r3, i3, o3) {
      var a3 = n3.O, u3 = Bt3(i3);
      t4[e3] = function(t5, e4, n4) {
        return a3(t5, e4, n4, r3, u3, o3);
      };
    }
    function Zt3(t4, e3, n3, r3, i3, o3, a3) {
      var u3 = n3.O, s3 = Lt3(r3, i3, o3);
      t4[e3] = function(t5, e4, n4) {
        return u3(t5, e4, n4, r3, s3, a3);
      };
    }
    function Qt2(t4) {
      var e3 = t4[Yt3];
      return e3 || Pt3(t4, t4[Yt3] = {}, Jt3, qt3, $t3, Zt3);
    }
    function te2(t4, e3, n3) {
      for (; tt3(e3) && 4 != e3.h; ) {
        var r3 = e3.i, i3 = n3[r3];
        if (!i3) {
          var o3 = n3[0];
          o3 && (o3 = o3[r3]) && (i3 = n3[r3] = Dt3(o3));
        }
        if (!(i3 && i3(e3, t4, r3) || (i3 = e3, r3 = t4, o3 = i3.j, et3(i3), i3.W))) {
          var a3 = i3.g.h;
          i3 = o3 === (i3 = i3.g.g) ? P3 || (P3 = new Uint8Array(0)) : V3 ? a3.slice(o3, i3) : new Uint8Array(a3.subarray(o3, i3)), (o3 = r3.ba) ? o3.push(i3) : r3.ba = [i3];
        }
      }
      return t4;
    }
    function ee2(t4, e3, n3) {
      if (nt3.length) {
        var r3 = nt3.pop();
        t4 && (X3(r3.g, t4), r3.i = -1, r3.h = -1), t4 = r3;
      } else
        t4 = new Q3(t4);
      try {
        return te2(new e3(), t4, Qt2(n3));
      } finally {
        (e3 = t4.g).h = null, e3.j = 0, e3.i = 0, e3.g = 0, e3.v = false, t4.i = -1, t4.h = -1, 100 > nt3.length && nt3.push(t4);
      }
    }
    function ne2(t4, e3, n3) {
      for (var r3 = n3.length, i3 = 1 == r3 % 2, o3 = i3 ? 1 : 0; o3 < r3; o3 += 2)
        (0, n3[o3 + 1])(e3, t4, n3[o3]);
      Rt3(t4, e3, i3 ? n3[0] : void 0);
    }
    function re2(t4, e3) {
      var n3 = new rt3();
      ne2(t4, n3, Xt3(e3)), it3(n3, n3.g.end()), t4 = new Uint8Array(n3.h);
      for (var r3 = (e3 = n3.i).length, i3 = 0, o3 = 0; o3 < r3; o3++) {
        var a3 = e3[o3];
        t4.set(a3, i3), i3 += a3.length;
      }
      return n3.i = [t4], t4;
    }
    function ie2(t4, e3) {
      return { O: t4, P: e3 };
    }
    var oe2 = ie2(function(t4, e3, n3) {
      if (5 !== t4.h)
        return false;
      var r3 = (t4 = t4.g).h[t4.g], i3 = t4.h[t4.g + 1], o3 = t4.h[t4.g + 2], a3 = t4.h[t4.g + 3];
      return t4.g += 4, Y3(t4), t4 = 2 * ((i3 = (r3 << 0 | i3 << 8 | o3 << 16 | a3 << 24) >>> 0) >> 31) + 1, r3 = i3 >>> 23 & 255, i3 &= 8388607, yt3(e3, n3, 255 == r3 ? i3 ? NaN : 1 / 0 * t4 : 0 == r3 ? t4 * Math.pow(2, -149) * i3 : t4 * Math.pow(2, r3 - 150) * (i3 + Math.pow(2, 23))), true;
    }, function(t4, e3, n3) {
      if (null != (e3 = mt3(e3, n3))) {
        Z3(t4.g, 8 * n3 + 5), t4 = t4.g;
        var r3 = e3;
        0 === (r3 = (n3 = 0 > r3 ? 1 : 0) ? -r3 : r3) ? 0 < 1 / r3 ? H3 = 0 : (0, H3 = 2147483648) : isNaN(r3) ? (0, H3 = 2147483647) : 34028234663852886e22 < r3 ? (0, H3 = (n3 << 31 | 2139095040) >>> 0) : 11754943508222875e-54 > r3 ? (r3 = Math.round(r3 / Math.pow(2, -149)), 0, H3 = (n3 << 31 | r3) >>> 0) : (e3 = Math.floor(Math.log(r3) / Math.LN2), r3 *= Math.pow(2, -e3), 16777216 <= (r3 = Math.round(8388608 * r3)) && ++e3, 0, H3 = (n3 << 31 | e3 + 127 << 23 | 8388607 & r3) >>> 0), n3 = H3, t4.g.push(n3 >>> 0 & 255), t4.g.push(n3 >>> 8 & 255), t4.g.push(n3 >>> 16 & 255), t4.g.push(n3 >>> 24 & 255);
      }
    }), ae2 = ie2(function(t4, e3, n3) {
      if (0 !== t4.h)
        return false;
      for (var r3 = t4.g, i3 = 128, o3 = 0, a3 = t4 = 0; 4 > a3 && 128 <= i3; a3++)
        i3 = r3.h[r3.g++], Y3(r3), o3 |= (127 & i3) << 7 * a3;
      if (128 <= i3 && (i3 = r3.h[r3.g++], Y3(r3), o3 |= (127 & i3) << 28, t4 |= (127 & i3) >> 4), 128 <= i3)
        for (a3 = 0; 5 > a3 && 128 <= i3; a3++)
          i3 = r3.h[r3.g++], Y3(r3), t4 |= (127 & i3) << 7 * a3 + 3;
      if (!(128 > i3))
        throw W3();
      return r3 = o3 >>> 0, (t4 = 2147483648 & (i3 = t4 >>> 0)) && (i3 = ~i3 >>> 0, 0 == (r3 = 1 + ~r3 >>> 0) && (i3 = i3 + 1 >>> 0)), r3 = 4294967296 * i3 + (r3 >>> 0), yt3(e3, n3, t4 ? -r3 : r3), true;
    }, function(t4, e3, n3) {
      if (null != (e3 = mt3(e3, n3)) && null != e3) {
        Z3(t4.g, 8 * n3), t4 = t4.g;
        var r3 = e3;
        for (n3 = 0 > r3, e3 = (r3 = Math.abs(r3)) >>> 0, r3 = Math.floor((r3 - e3) / 4294967296), r3 >>>= 0, n3 && (r3 = ~r3 >>> 0, 4294967295 < (e3 = 1 + (~e3 >>> 0)) && (e3 = 0, 4294967295 < ++r3 && (r3 = 0))), n3 = H3 = e3, e3 = r3; 0 < e3 || 127 < n3; )
          t4.g.push(127 & n3 | 128), n3 = (n3 >>> 7 | e3 << 25) >>> 0, e3 >>>= 7;
        t4.g.push(n3);
      }
    }), ue2 = ie2(function(t4, e3, n3) {
      return 0 === t4.h && (yt3(e3, n3, J3(t4.g)), true);
    }, function(t4, e3, n3) {
      if (null != (e3 = mt3(e3, n3)) && null != e3)
        if (Z3(t4.g, 8 * n3), t4 = t4.g, 0 <= (n3 = e3))
          Z3(t4, n3);
        else {
          for (e3 = 0; 9 > e3; e3++)
            t4.g.push(127 & n3 | 128), n3 >>= 7;
          t4.g.push(1);
        }
    }), se2 = ie2(function(t4, e3, n3) {
      if (2 !== t4.h)
        return false;
      var r3, i3 = J3(t4.g) >>> 0, o3 = (t4 = t4.g).g;
      if (t4.g += i3, Y3(t4), t4 = t4.h, _3)
        (r3 = C3) || (r3 = C3 = new TextDecoder("utf-8", { fatal: true })), r3 = r3.decode(t4.subarray(o3, o3 + i3));
      else {
        i3 = o3 + i3;
        for (var a3, u3, s3, c3 = [], h2 = null; o3 < i3; )
          128 > (a3 = t4[o3++]) ? c3.push(a3) : 224 > a3 ? o3 >= i3 ? S3() : (u3 = t4[o3++], 194 > a3 || 128 != (192 & u3) ? (o3--, S3()) : c3.push((31 & a3) << 6 | 63 & u3)) : 240 > a3 ? o3 >= i3 - 1 ? S3() : 128 != (192 & (u3 = t4[o3++])) || 224 === a3 && 160 > u3 || 237 === a3 && 160 <= u3 || 128 != (192 & (r3 = t4[o3++])) ? (o3--, S3()) : c3.push((15 & a3) << 12 | (63 & u3) << 6 | 63 & r3) : 244 >= a3 ? o3 >= i3 - 2 ? S3() : 128 != (192 & (u3 = t4[o3++])) || 0 != u3 - 144 + (a3 << 28) >> 30 || 128 != (192 & (r3 = t4[o3++])) || 128 != (192 & (s3 = t4[o3++])) ? (o3--, S3()) : (a3 = (7 & a3) << 18 | (63 & u3) << 12 | (63 & r3) << 6 | 63 & s3, a3 -= 65536, c3.push(55296 + (a3 >> 10 & 1023), 56320 + (1023 & a3))) : S3(), 8192 <= c3.length && (h2 = F3(h2, c3), c3.length = 0);
        r3 = F3(h2, c3);
      }
      return yt3(e3, n3, r3), true;
    }, function(t4, e3, n3) {
      if (null != (e3 = mt3(e3, n3))) {
        var r3 = false;
        if (r3 = void 0 !== r3 && r3, j3) {
          if (r3 && /(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(e3))
            throw Error("Found an unpaired surrogate");
          e3 = (O3 || (O3 = new TextEncoder())).encode(e3);
        } else {
          for (var i3 = 0, o3 = new Uint8Array(3 * e3.length), a3 = 0; a3 < e3.length; a3++) {
            var u3 = e3.charCodeAt(a3);
            if (128 > u3)
              o3[i3++] = u3;
            else {
              if (2048 > u3)
                o3[i3++] = u3 >> 6 | 192;
              else {
                if (55296 <= u3 && 57343 >= u3) {
                  if (56319 >= u3 && a3 < e3.length) {
                    var s3 = e3.charCodeAt(++a3);
                    if (56320 <= s3 && 57343 >= s3) {
                      u3 = 1024 * (u3 - 55296) + s3 - 56320 + 65536, o3[i3++] = u3 >> 18 | 240, o3[i3++] = u3 >> 12 & 63 | 128, o3[i3++] = u3 >> 6 & 63 | 128, o3[i3++] = 63 & u3 | 128;
                      continue;
                    }
                    a3--;
                  }
                  if (r3)
                    throw Error("Found an unpaired surrogate");
                  u3 = 65533;
                }
                o3[i3++] = u3 >> 12 | 224, o3[i3++] = u3 >> 6 & 63 | 128;
              }
              o3[i3++] = 63 & u3 | 128;
            }
          }
          e3 = o3.subarray(0, i3);
        }
        Z3(t4.g, 8 * n3 + 2), Z3(t4.g, e3.length), it3(t4, t4.g.end()), it3(t4, e3);
      }
    }), ce2 = ie2(function(t4, e3, n3, r3, i3) {
      if (2 !== t4.h)
        return false;
      e3 = Mt3(e3, n3, r3), n3 = t4.g.i, r3 = J3(t4.g) >>> 0;
      var o3 = t4.g.g + r3, a3 = o3 - n3;
      if (0 >= a3 && (t4.g.i = o3, i3(e3, t4), a3 = o3 - t4.g.g), a3)
        throw Error("Message parsing ended unexpectedly. Expected to read " + r3 + " bytes, instead read " + (r3 - a3) + " bytes, either the data ended unexpectedly or the message misreported its own length");
      return t4.g.g = o3, t4.g.i = n3, true;
    }, function(t4, e3, n3, r3, i3) {
      if (null != (e3 = xt3(e3, r3, n3)))
        for (r3 = 0; r3 < e3.length; r3++) {
          var o3 = t4;
          Z3(o3.g, 8 * n3 + 2);
          var a3 = o3.g.end();
          it3(o3, a3), a3.push(o3.h), o3 = a3, i3(e3[r3], t4), a3 = t4;
          var u3 = o3.pop();
          for (u3 = a3.h + a3.g.length() - u3; 127 < u3; )
            o3.push(127 & u3 | 128), u3 >>>= 7, a3.h++;
          o3.push(u3), a3.h++;
        }
    });
    function he2() {
      jt3.apply(this, arguments);
    }
    if (d2(he2, jt3), gt3) {
      var le2 = {};
      Object.defineProperties(he2, (le2[Symbol.hasInstance] = vt3(Object[Symbol.hasInstance]), le2));
    }
    function fe2(t4) {
      he2.call(this, t4);
    }
    function de2() {
      return [1, ue2, 2, oe2, 3, se2, 4, se2];
    }
    function pe2(t4) {
      he2.call(this, t4, -1, ve2);
    }
    function ge2() {
      return [1, ce2, fe2, de2];
    }
    d2(fe2, he2), d2(pe2, he2), pe2.prototype.addClassification = function(t4, e3) {
      return Mt3(this, 1, fe2, t4, e3), this;
    };
    var ve2 = [1];
    function me2(t4) {
      he2.call(this, t4);
    }
    function ye2() {
      return [1, oe2, 2, oe2, 3, oe2, 4, oe2, 5, oe2];
    }
    function we2(t4) {
      he2.call(this, t4, -1, xe2);
    }
    function be2() {
      return [1, ce2, me2, ye2];
    }
    d2(me2, he2), d2(we2, he2);
    var xe2 = [1];
    function Me2(t4) {
      he2.call(this, t4);
    }
    function Ae2() {
      return [1, oe2, 2, oe2, 3, oe2, 4, oe2, 5, oe2, 6, ae2];
    }
    d2(Me2, he2);
    var Te2 = [[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]], Ee2 = [[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]], Se2 = [[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]], Fe2 = [[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]], Ce2 = [[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]], Oe2 = [[10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]], _e2 = [].concat(u2(Te2), u2(Ee2), u2(Se2), u2(Fe2), u2(Ce2), u2(Oe2));
    function je2(t4, e3, n3) {
      if (n3 = t4.createShader(0 === n3 ? t4.VERTEX_SHADER : t4.FRAGMENT_SHADER), t4.shaderSource(n3, e3), t4.compileShader(n3), !t4.getShaderParameter(n3, t4.COMPILE_STATUS))
        throw Error("Could not compile WebGL shader.\n\n" + t4.getShaderInfoLog(n3));
      return n3;
    }
    function ke2(t4) {
      return xt3(t4, fe2, 1).map(function(t5) {
        return { index: At3(t5, 1), ga: bt3(t5, 2), label: null != mt3(t5, 3) ? Tt3(t5, 3) : void 0, displayName: null != mt3(t5, 4) ? Tt3(t5, 4) : void 0 };
      });
    }
    function Re2(t4) {
      return { x: bt3(t4, 1), y: bt3(t4, 2), z: bt3(t4, 3), visibility: null != mt3(t4, 4) ? bt3(t4, 4) : void 0 };
    }
    function Ie2(t4, e3) {
      this.h = t4, this.g = e3, this.l = 0;
    }
    function Le2(t4, e3, n3) {
      return function(t5, e4) {
        var n4 = t5.g;
        if (void 0 === t5.o) {
          var r3 = je2(n4, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", 0), i3 = je2(n4, "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }", 1), o3 = n4.createProgram();
          if (n4.attachShader(o3, r3), n4.attachShader(o3, i3), n4.linkProgram(o3), !n4.getProgramParameter(o3, n4.LINK_STATUS))
            throw Error("Could not compile WebGL program.\n\n" + n4.getProgramInfoLog(o3));
          r3 = t5.o = o3, n4.useProgram(r3), i3 = n4.getUniformLocation(r3, "sampler0"), t5.j = { K: n4.getAttribLocation(r3, "aVertex"), J: n4.getAttribLocation(r3, "aTex"), ma: i3 }, t5.u = n4.createBuffer(), n4.bindBuffer(n4.ARRAY_BUFFER, t5.u), n4.enableVertexAttribArray(t5.j.K), n4.vertexAttribPointer(t5.j.K, 2, n4.FLOAT, false, 0, 0), n4.bufferData(n4.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), n4.STATIC_DRAW), n4.bindBuffer(n4.ARRAY_BUFFER, null), t5.s = n4.createBuffer(), n4.bindBuffer(n4.ARRAY_BUFFER, t5.s), n4.enableVertexAttribArray(t5.j.J), n4.vertexAttribPointer(t5.j.J, 2, n4.FLOAT, false, 0, 0), n4.bufferData(n4.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), n4.STATIC_DRAW), n4.bindBuffer(n4.ARRAY_BUFFER, null), n4.uniform1i(i3, 0);
        }
        r3 = t5.j, n4.useProgram(t5.o), n4.canvas.width = e4.width, n4.canvas.height = e4.height, n4.viewport(0, 0, e4.width, e4.height), n4.activeTexture(n4.TEXTURE0), t5.h.bindTexture2d(e4.glName), n4.enableVertexAttribArray(r3.K), n4.bindBuffer(n4.ARRAY_BUFFER, t5.u), n4.vertexAttribPointer(r3.K, 2, n4.FLOAT, false, 0, 0), n4.enableVertexAttribArray(r3.J), n4.bindBuffer(n4.ARRAY_BUFFER, t5.s), n4.vertexAttribPointer(r3.J, 2, n4.FLOAT, false, 0, 0), n4.bindFramebuffer(n4.DRAW_FRAMEBUFFER ? n4.DRAW_FRAMEBUFFER : n4.FRAMEBUFFER, null), n4.clearColor(0, 0, 0, 0), n4.clear(n4.COLOR_BUFFER_BIT), n4.colorMask(true, true, true, true), n4.drawArrays(n4.TRIANGLE_FAN, 0, 4), n4.disableVertexAttribArray(r3.K), n4.disableVertexAttribArray(r3.J), n4.bindBuffer(n4.ARRAY_BUFFER, null), t5.h.bindTexture2d(0);
      }(t4, e3), "function" == typeof t4.g.canvas.transferToImageBitmap ? Promise.resolve(t4.g.canvas.transferToImageBitmap()) : n3 ? Promise.resolve(t4.g.canvas) : "function" == typeof createImageBitmap ? createImageBitmap(t4.g.canvas) : (void 0 === t4.i && (t4.i = document.createElement("canvas")), new Promise(function(e4) {
        t4.i.height = t4.g.canvas.height, t4.i.width = t4.g.canvas.width, t4.i.getContext("2d", {}).drawImage(t4.g.canvas, 0, 0, t4.g.canvas.width, t4.g.canvas.height), e4(t4.i);
      }));
    }
    function Be2(t4) {
      this.g = t4;
    }
    var De2 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]);
    function Pe2(t4, e3) {
      return e3 + t4;
    }
    function ze2(t4, e3) {
      window[t4] = e3;
    }
    function Ue(t4) {
      if (this.g = t4, this.listeners = {}, this.j = {}, this.H = {}, this.o = {}, this.u = {}, this.I = this.s = this.Z = true, this.D = Promise.resolve(), this.Y = "", this.C = {}, this.locateFile = t4 && t4.locateFile || Pe2, "object" == typeof window)
        var e3 = window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/";
      else {
        if ("undefined" == typeof location)
          throw Error("solutions can only be loaded on a web page or in a web worker");
        e3 = location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/";
      }
      if (this.$ = e3, t4.options)
        for (var n3 = (e3 = a2(Object.keys(t4.options))).next(); !n3.done; n3 = e3.next()) {
          n3 = n3.value;
          var r3 = t4.options[n3].default;
          void 0 !== r3 && (this.j[n3] = "function" == typeof r3 ? r3() : r3);
        }
    }
    function Ne2(t4) {
      var e3, n3, r3, i3, o3, a3, s3, c3, h2, l4, f3;
      return M2(function(d3) {
        switch (d3.g) {
          case 1:
            return t4.Z ? (e3 = void 0 === t4.g.files ? [] : "function" == typeof t4.g.files ? t4.g.files(t4.j) : t4.g.files, m2(d3, M2(function(t5) {
              switch (t5.g) {
                case 1:
                  return t5.o = 2, m2(t5, WebAssembly.instantiate(De2), 4);
                case 4:
                  t5.g = 3, t5.o = 0;
                  break;
                case 2:
                  return t5.o = 0, t5.j = null, t5.return(false);
                case 3:
                  return t5.return(true);
              }
            }), 2)) : d3.return();
          case 2:
            if (n3 = d3.h, "object" == typeof window)
              return ze2("createMediapipeSolutionsWasm", { locateFile: t4.locateFile }), ze2("createMediapipeSolutionsPackedAssets", { locateFile: t4.locateFile }), a3 = e3.filter(function(t5) {
                return void 0 !== t5.data;
              }), s3 = e3.filter(function(t5) {
                return void 0 === t5.data;
              }), c3 = Promise.all(a3.map(function(e4) {
                var n4 = Ve(t4, e4.url);
                if (void 0 !== e4.path) {
                  var r4 = e4.path;
                  n4 = n4.then(function(e5) {
                    return t4.overrideFile(r4, e5), Promise.resolve(e5);
                  });
                }
                return n4;
              })), h2 = Promise.all(s3.map(function(e4) {
                return void 0 === e4.simd || e4.simd && n3 || !e4.simd && !n3 ? function(t5) {
                  var e5 = document.createElement("script");
                  return e5.setAttribute("src", t5), e5.setAttribute("crossorigin", "anonymous"), new Promise(function(t6) {
                    e5.addEventListener("load", function() {
                      t6();
                    }, false), e5.addEventListener("error", function() {
                      t6();
                    }, false), document.body.appendChild(e5);
                  });
                }(t4.locateFile(e4.url, t4.$)) : Promise.resolve();
              })).then(function() {
                var e4, n4, r4;
                return M2(function(i4) {
                  if (1 == i4.g)
                    return e4 = window.createMediapipeSolutionsWasm, n4 = window.createMediapipeSolutionsPackedAssets, r4 = t4, m2(i4, e4(n4), 2);
                  r4.h = i4.h, i4.g = 0;
                });
              }), l4 = M2(function(e4) {
                return t4.g.graph && t4.g.graph.url ? e4 = m2(e4, Ve(t4, t4.g.graph.url), 0) : (e4.g = 0, e4 = void 0), e4;
              }), m2(d3, Promise.all([h2, c3, l4]), 7);
            if ("function" != typeof importScripts)
              throw Error("solutions can only be loaded on a web page or in a web worker");
            return r3 = e3.filter(function(t5) {
              return void 0 === t5.simd || t5.simd && n3 || !t5.simd && !n3;
            }).map(function(e4) {
              return t4.locateFile(e4.url, t4.$);
            }), importScripts.apply(null, u2(r3)), i3 = t4, m2(d3, createMediapipeSolutionsWasm(Module), 6);
          case 6:
            i3.h = d3.h, t4.l = new OffscreenCanvas(1, 1), t4.h.canvas = t4.l, o3 = t4.h.GL.createContext(t4.l, { antialias: false, alpha: false, ja: "undefined" != typeof WebGL2RenderingContext ? 2 : 1 }), t4.h.GL.makeContextCurrent(o3), d3.g = 4;
            break;
          case 7:
            if (t4.l = document.createElement("canvas"), !(f3 = t4.l.getContext("webgl2", {})) && !(f3 = t4.l.getContext("webgl", {})))
              return alert("Failed to create WebGL canvas context when passing video frame."), d3.return();
            t4.G = f3, t4.h.canvas = t4.l, t4.h.createContext(t4.l, true, true, {});
          case 4:
            t4.i = new t4.h.SolutionWasm(), t4.Z = false, d3.g = 0;
        }
      });
    }
    function Ve(t4, e3) {
      var n3, r3;
      return M2(function(i3) {
        return e3 in t4.H ? i3.return(t4.H[e3]) : (n3 = t4.locateFile(e3, ""), r3 = fetch(n3).then(function(t5) {
          return t5.arrayBuffer();
        }), t4.H[e3] = r3, i3.return(r3));
      });
    }
    function He(t4, e3, n3) {
      var r3, i3, o3, u3, s3, c3, h2, l4, f3, d3, p3, g3, v3, y3;
      return M2(function(w3) {
        switch (w3.g) {
          case 1:
            if (!n3)
              return w3.return(e3);
            for (r3 = {}, i3 = 0, o3 = a2(Object.keys(n3)), u3 = o3.next(); !u3.done; u3 = o3.next())
              s3 = u3.value, "string" != typeof (c3 = n3[s3]) && "texture" === c3.type && void 0 !== e3[c3.stream] && ++i3;
            1 < i3 && (t4.I = false), h2 = a2(Object.keys(n3)), u3 = h2.next();
          case 2:
            if (u3.done) {
              w3.g = 4;
              break;
            }
            if (l4 = u3.value, "string" == typeof (f3 = n3[l4]))
              return v3 = r3, y3 = l4, m2(w3, function(t5, e4, n4) {
                var r4;
                return M2(function(i4) {
                  return "number" == typeof n4 || n4 instanceof Uint8Array || n4 instanceof t5.h.Uint8BlobList ? i4.return(n4) : n4 instanceof t5.h.Texture2dDataOut ? ((r4 = t5.u[e4]) || (r4 = new Ie2(t5.h, t5.G), t5.u[e4] = r4), i4.return(Le2(r4, n4, t5.I))) : i4.return(void 0);
                });
              }(t4, l4, e3[f3]), 14);
            if (d3 = e3[f3.stream], "detection_list" === f3.type) {
              if (d3) {
                for (var b3 = d3.getRectList(), x3 = d3.getLandmarksList(), A3 = d3.getClassificationsList(), T3 = [], E4 = 0; E4 < b3.size(); ++E4) {
                  var S4 = ee2(b3.get(E4), Me2, Ae2);
                  S4 = { boundingBox: { xCenter: bt3(S4, 1), yCenter: bt3(S4, 2), height: bt3(S4, 3), width: bt3(S4, 4), rotation: bt3(S4, 5, 0), rectId: At3(S4, 6) }, landmarks: xt3(ee2(x3.get(E4), we2, be2), me2, 1).map(Re2), V: ke2(ee2(A3.get(E4), pe2, ge2)) }, T3.push(S4);
                }
                b3 = T3;
              } else
                b3 = [];
              r3[l4] = b3, w3.g = 7;
              break;
            }
            if ("proto_list" === f3.type) {
              if (d3) {
                for (b3 = Array(d3.size()), x3 = 0; x3 < d3.size(); x3++)
                  b3[x3] = d3.get(x3);
                d3.delete();
              } else
                b3 = [];
              r3[l4] = b3, w3.g = 7;
              break;
            }
            if (void 0 === d3) {
              w3.g = 3;
              break;
            }
            if ("float_list" === f3.type) {
              r3[l4] = d3, w3.g = 7;
              break;
            }
            if ("proto" === f3.type) {
              r3[l4] = d3, w3.g = 7;
              break;
            }
            if ("texture" !== f3.type)
              throw Error("Unknown output config type: '" + f3.type + "'");
            return (p3 = t4.u[l4]) || (p3 = new Ie2(t4.h, t4.G), t4.u[l4] = p3), m2(w3, Le2(p3, d3, t4.I), 13);
          case 13:
            g3 = w3.h, r3[l4] = g3;
          case 7:
            f3.transform && r3[l4] && (r3[l4] = f3.transform(r3[l4])), w3.g = 3;
            break;
          case 14:
            v3[y3] = w3.h;
          case 3:
            u3 = h2.next(), w3.g = 2;
            break;
          case 4:
            return w3.return(r3);
        }
      });
    }
    function Ke(t4, e3) {
      for (var n3 = e3.name || "$", r3 = [].concat(u2(e3.wants)), i3 = new t4.h.StringList(), o3 = a2(e3.wants), s3 = o3.next(); !s3.done; s3 = o3.next())
        i3.push_back(s3.value);
      o3 = t4.h.PacketListener.implement({ onResults: function(i4) {
        for (var o4 = {}, a3 = 0; a3 < e3.wants.length; ++a3)
          o4[r3[a3]] = i4.get(a3);
        var u3 = t4.listeners[n3];
        u3 && (t4.D = He(t4, o4, e3.outs).then(function(n4) {
          n4 = u3(n4);
          for (var i5 = 0; i5 < e3.wants.length; ++i5) {
            var a4 = o4[r3[i5]];
            "object" == typeof a4 && a4.hasOwnProperty && a4.hasOwnProperty("delete") && a4.delete();
          }
          n4 && (t4.D = n4);
        }));
      } }), t4.i.attachMultiListener(i3, o3), i3.delete();
    }
    function We(t4) {
      var e3 = this;
      t4 = t4 || {};
      var n3 = { url: "face_detection_short.binarypb" }, r3 = { type: 1, graphOptionXref: { calculatorType: "TensorsToDetectionsCalculator", calculatorName: "facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator", fieldName: "min_score_thresh" } };
      this.g = new Ue({ locateFile: t4.locateFile, files: [{ data: true, url: "face_detection_short.binarypb" }, { data: true, url: "face_detection_short_range.tflite" }, { simd: true, url: "face_detection_solution_simd_wasm_bin.js" }, { simd: false, url: "face_detection_solution_wasm_bin.js" }], graph: n3, listeners: [{ wants: ["detections", "image_transformed"], outs: { image: "image_transformed", detections: { type: "detection_list", stream: "detections" } } }], inputs: { image: { type: "video", stream: "input_frames_gpu" } }, options: { useCpuInference: { type: 0, graphOptionXref: { calculatorType: "InferenceCalculator", fieldName: "use_cpu_inference" }, default: "object" == typeof window && void 0 !== window.navigator && ("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document) }, selfieMode: { type: 0, graphOptionXref: { calculatorType: "GlScalerCalculator", calculatorIndex: 1, fieldName: "flip_horizontal" } }, model: { type: 0, onChange: function(t5) {
        var i3, o3, u3, s3, c3;
        return M2(function(h2) {
          switch (h2.g) {
            case 1:
              i3 = a2("short" === t5 ? ["face_detection_short_range.tflite"] : ["face_detection_full_range_sparse.tflite"]), o3 = i3.next();
            case 2:
              if (o3.done) {
                h2.g = 4;
                break;
              }
              return u3 = o3.value, s3 = "third_party/mediapipe/modules/face_detection/" + u3, m2(h2, Ve(e3.g, u3), 5);
            case 5:
              c3 = h2.h, e3.g.overrideFile(s3, c3), o3 = i3.next(), h2.g = 2;
              break;
            case 4:
              return n3.url = "short" === t5 ? "face_detection_short.binarypb" : "face_detection_full.binarypb", r3.graphOptionXref.calculatorName = "short" === t5 ? "facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator" : "facedetectionfullrangegpu__facedetectionfullrangecommon__TensorsToDetectionsCalculator", h2.return(true);
          }
        });
      } }, minDetectionConfidence: r3 } });
    }
    (t3 = Ue.prototype).close = function() {
      return this.i && this.i.delete(), Promise.resolve();
    }, t3.reset = function() {
      var t4 = this;
      return M2(function(e3) {
        t4.i && (t4.i.reset(), t4.o = {}, t4.u = {}), e3.g = 0;
      });
    }, t3.setOptions = function(t4, e3) {
      var n3 = this;
      if (e3 = e3 || this.g.options) {
        for (var r3 = [], i3 = [], o3 = {}, u3 = a2(Object.keys(t4)), s3 = u3.next(); !s3.done; o3 = { R: o3.R, S: o3.S }, s3 = u3.next()) {
          var c3 = s3.value;
          c3 in this.j && this.j[c3] === t4[c3] || (this.j[c3] = t4[c3], void 0 !== (s3 = e3[c3]) && (s3.onChange && (o3.R = s3.onChange, o3.S = t4[c3], r3.push(function(t5) {
            return function() {
              return M2(function(e4) {
                if (1 == e4.g)
                  return m2(e4, t5.R(t5.S), 2);
                true === e4.h && (n3.s = true), e4.g = 0;
              });
            };
          }(o3))), s3.graphOptionXref && (c3 = { valueNumber: 1 === s3.type ? t4[c3] : 0, valueBoolean: 0 === s3.type && t4[c3], valueString: 2 === s3.type ? t4[c3] : "" }, s3 = Object.assign(Object.assign(Object.assign({}, { calculatorName: "", calculatorIndex: 0 }), s3.graphOptionXref), c3), i3.push(s3))));
        }
        0 === r3.length && 0 === i3.length || (this.s = true, this.B = (void 0 === this.B ? [] : this.B).concat(i3), this.A = (void 0 === this.A ? [] : this.A).concat(r3));
      }
    }, t3.initialize = function() {
      var t4 = this;
      return M2(function(e3) {
        return 1 == e3.g ? m2(e3, Ne2(t4), 2) : 3 != e3.g ? m2(e3, function(t5) {
          var e4, n3, r3, i3, o3, u3, s3, c3;
          return M2(function(h2) {
            if (1 == h2.g)
              return t5.g.graph && t5.g.graph.url && t5.Y === t5.g.graph.url ? h2.return() : (t5.s = true, t5.g.graph && t5.g.graph.url ? (t5.Y = t5.g.graph.url, m2(h2, Ve(t5, t5.g.graph.url), 3)) : void (h2.g = 2));
            for (2 != h2.g && (e4 = h2.h, t5.i.loadGraph(e4)), n3 = a2(Object.keys(t5.C)), r3 = n3.next(); !r3.done; r3 = n3.next())
              i3 = r3.value, t5.i.overrideFile(i3, t5.C[i3]);
            if (t5.C = {}, t5.g.listeners)
              for (o3 = a2(t5.g.listeners), u3 = o3.next(); !u3.done; u3 = o3.next())
                s3 = u3.value, Ke(t5, s3);
            c3 = t5.j, t5.j = {}, t5.setOptions(c3), h2.g = 0;
          });
        }(t4), 3) : m2(e3, function(t5) {
          var e4, n3, r3, i3, o3, u3;
          return M2(function(s3) {
            switch (s3.g) {
              case 1:
                if (!t5.s)
                  return s3.return();
                if (!t5.A) {
                  s3.g = 2;
                  break;
                }
                e4 = a2(t5.A), n3 = e4.next();
              case 3:
                if (n3.done) {
                  s3.g = 5;
                  break;
                }
                return m2(s3, (0, n3.value)(), 4);
              case 4:
                n3 = e4.next(), s3.g = 3;
                break;
              case 5:
                t5.A = void 0;
              case 2:
                if (t5.B) {
                  for (r3 = new t5.h.GraphOptionChangeRequestList(), i3 = a2(t5.B), o3 = i3.next(); !o3.done; o3 = i3.next())
                    u3 = o3.value, r3.push_back(u3);
                  t5.i.changeOptions(r3), r3.delete(), t5.B = void 0;
                }
                t5.s = false, s3.g = 0;
            }
          });
        }(t4), 0);
      });
    }, t3.overrideFile = function(t4, e3) {
      this.i ? this.i.overrideFile(t4, e3) : this.C[t4] = e3;
    }, t3.clearOverriddenFiles = function() {
      this.C = {}, this.i && this.i.clearOverriddenFiles();
    }, t3.send = function(t4, e3) {
      var n3, r3, i3, o3, u3, s3, c3, h2, l4, f3 = this;
      return M2(function(d3) {
        switch (d3.g) {
          case 1:
            return f3.g.inputs ? (n3 = 1e3 * (null == e3 ? performance.now() : e3), m2(d3, f3.D, 2)) : d3.return();
          case 2:
            return m2(d3, f3.initialize(), 3);
          case 3:
            for (r3 = new f3.h.PacketDataList(), i3 = a2(Object.keys(t4)), o3 = i3.next(); !o3.done; o3 = i3.next())
              if (u3 = o3.value, s3 = f3.g.inputs[u3]) {
                t: {
                  var p3 = t4[u3];
                  switch (s3.type) {
                    case "video":
                      var g3 = f3.o[s3.stream];
                      if (g3 || (g3 = new Ie2(f3.h, f3.G), f3.o[s3.stream] = g3), 0 === g3.l && (g3.l = g3.h.createTexture()), "undefined" != typeof HTMLVideoElement && p3 instanceof HTMLVideoElement)
                        var v3 = p3.videoWidth, y3 = p3.videoHeight;
                      else
                        "undefined" != typeof HTMLImageElement && p3 instanceof HTMLImageElement ? (v3 = p3.naturalWidth, y3 = p3.naturalHeight) : (v3 = p3.width, y3 = p3.height);
                      y3 = { glName: g3.l, width: v3, height: y3 }, (v3 = g3.g).canvas.width = y3.width, v3.canvas.height = y3.height, v3.activeTexture(v3.TEXTURE0), g3.h.bindTexture2d(g3.l), v3.texImage2D(v3.TEXTURE_2D, 0, v3.RGBA, v3.RGBA, v3.UNSIGNED_BYTE, p3), g3.h.bindTexture2d(0), g3 = y3;
                      break t;
                    case "detections":
                      for ((g3 = f3.o[s3.stream]) || (g3 = new Be2(f3.h), f3.o[s3.stream] = g3), g3.data || (g3.data = new g3.g.DetectionListData()), g3.data.reset(p3.length), y3 = 0; y3 < p3.length; ++y3) {
                        v3 = p3[y3];
                        var w3 = g3.data, b3 = w3.setBoundingBox, x3 = y3, M3 = v3.boundingBox, A3 = new Me2();
                        if (yt3(A3, 1, M3.xCenter), yt3(A3, 2, M3.yCenter), yt3(A3, 3, M3.height), yt3(A3, 4, M3.width), yt3(A3, 5, M3.rotation), yt3(A3, 6, M3.rectId), M3 = re2(A3, Ae2), b3.call(w3, x3, M3), v3.landmarks)
                          for (w3 = 0; w3 < v3.landmarks.length; ++w3) {
                            var T3 = !!(A3 = v3.landmarks[w3]).visibility;
                            x3 = (b3 = g3.data).addNormalizedLandmark, M3 = y3, A3 = Object.assign(Object.assign({}, A3), { visibility: T3 ? A3.visibility : 0 }), yt3(T3 = new me2(), 1, A3.x), yt3(T3, 2, A3.y), yt3(T3, 3, A3.z), A3.visibility && yt3(T3, 4, A3.visibility), A3 = re2(T3, ye2), x3.call(b3, M3, A3);
                          }
                        if (v3.V)
                          for (w3 = 0; w3 < v3.V.length; ++w3)
                            x3 = (b3 = g3.data).addClassification, M3 = y3, A3 = v3.V[w3], yt3(T3 = new fe2(), 2, A3.ga), A3.index && yt3(T3, 1, A3.index), A3.label && yt3(T3, 3, A3.label), A3.displayName && yt3(T3, 4, A3.displayName), A3 = re2(T3, de2), x3.call(b3, M3, A3);
                      }
                      g3 = g3.data;
                      break t;
                    default:
                      g3 = {};
                  }
                }
                switch (c3 = g3, h2 = s3.stream, s3.type) {
                  case "video":
                    r3.pushTexture2d(Object.assign(Object.assign({}, c3), { stream: h2, timestamp: n3 }));
                    break;
                  case "detections":
                    (l4 = c3).stream = h2, l4.timestamp = n3, r3.pushDetectionList(l4);
                    break;
                  default:
                    throw Error("Unknown input config type: '" + s3.type + "'");
                }
              }
            return f3.i.send(r3), m2(d3, f3.D, 4);
          case 4:
            r3.delete(), d3.g = 0;
        }
      });
    }, t3.onResults = function(t4, e3) {
      this.listeners[e3 || "$"] = t4;
    }, E3("Solution", Ue), E3("OptionType", { BOOL: 0, NUMBER: 1, ia: 2, 0: "BOOL", 1: "NUMBER", 2: "STRING" }), (t3 = We.prototype).close = function() {
      return this.g.close(), Promise.resolve();
    }, t3.onResults = function(t4) {
      this.g.onResults(t4);
    }, t3.initialize = function() {
      var t4 = this;
      return M2(function(e3) {
        return m2(e3, t4.g.initialize(), 0);
      });
    }, t3.reset = function() {
      this.g.reset();
    }, t3.send = function(t4) {
      var e3 = this;
      return M2(function(n3) {
        return m2(n3, e3.g.send(t4), 0);
      });
    }, t3.setOptions = function(t4) {
      this.g.setOptions(t4);
    }, E3("FaceDetection", We), E3("FACEDETECTION_LIPS", Te2), E3("FACEDETECTION_LEFT_EYE", Ee2), E3("FACEDETECTION_LEFT_EYEBROW", Se2), E3("FACEDETECTION_RIGHT_EYE", Fe2), E3("FACEDETECTION_RIGHT_EYEBROW", Ce2), E3("FACEDETECTION_FACE_OVAL", Oe2), E3("FACEDETECTION_CONTOURS", _e2), E3("FACEDETECTION_TESSELATION", [[127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]]), E3("VERSION", "0.4.1646425229");
  }).call(D2);
  var z2 = function() {
    return z2 = Object.assign || function(t3) {
      for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
        for (var i2 in e2 = arguments[n2])
          Object.prototype.hasOwnProperty.call(e2, i2) && (t3[i2] = e2[i2]);
      return t3;
    }, z2.apply(this, arguments);
  };
  function U2(t3, e2, n2, r2) {
    return new (n2 || (n2 = Promise))(function(i2, o2) {
      function a2(t4) {
        try {
          s2(r2.next(t4));
        } catch (t5) {
          o2(t5);
        }
      }
      function u2(t4) {
        try {
          s2(r2.throw(t4));
        } catch (t5) {
          o2(t5);
        }
      }
      function s2(t4) {
        var e3;
        t4.done ? i2(t4.value) : (e3 = t4.value, e3 instanceof n2 ? e3 : new n2(function(t5) {
          t5(e3);
        })).then(a2, u2);
      }
      s2((r2 = r2.apply(t3, e2 || [])).next());
    });
  }
  function N2(t3, e2) {
    var n2, r2, i2, o2, a2 = { label: 0, sent: function() {
      if (1 & i2[0])
        throw i2[1];
      return i2[1];
    }, trys: [], ops: [] };
    return o2 = { next: u2(0), throw: u2(1), return: u2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
      return this;
    }), o2;
    function u2(o3) {
      return function(u3) {
        return function(o4) {
          if (n2)
            throw new TypeError("Generator is already executing.");
          for (; a2; )
            try {
              if (n2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                return i2;
              switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                case 0:
                case 1:
                  i2 = o4;
                  break;
                case 4:
                  return a2.label++, { value: o4[1], done: false };
                case 5:
                  a2.label++, r2 = o4[1], o4 = [0];
                  continue;
                case 7:
                  o4 = a2.ops.pop(), a2.trys.pop();
                  continue;
                default:
                  if (!((i2 = (i2 = a2.trys).length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                    a2 = 0;
                    continue;
                  }
                  if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                    a2.label = o4[1];
                    break;
                  }
                  if (6 === o4[0] && a2.label < i2[1]) {
                    a2.label = i2[1], i2 = o4;
                    break;
                  }
                  if (i2 && a2.label < i2[2]) {
                    a2.label = i2[2], a2.ops.push(o4);
                    break;
                  }
                  i2[2] && a2.ops.pop(), a2.trys.pop();
                  continue;
              }
              o4 = e2.call(t3, a2);
            } catch (t4) {
              o4 = [6, t4], r2 = 0;
            } finally {
              n2 = i2 = 0;
            }
          if (5 & o4[0])
            throw o4[1];
          return { value: o4[0] ? o4[1] : void 0, done: true };
        }([o3, u3]);
      };
    }
  }
  var V2 = ["rightEye", "leftEye", "noseTip", "mouthCenter", "rightEarTragion", "leftEarTragion"];
  var H2 = { modelType: "short", runtime: "mediapipe", maxFaces: 1 };
  var K2 = function() {
    function t3(t4) {
      var e2 = this;
      this.width = 0, this.height = 0, this.selfieMode = false, this.faceDetectorSolution = new P2.FaceDetection({ locateFile: function(e3, n2) {
        return t4.solutionPath ? t4.solutionPath.replace(/\/+$/, "") + "/" + e3 : n2 + "/" + e3;
      } }), this.faceDetectorSolution.setOptions({ selfieMode: this.selfieMode, model: t4.modelType }), this.faceDetectorSolution.onResults(function(t5) {
        if (e2.height = t5.image.height, e2.width = t5.image.width, e2.faces = [], null !== t5.detections)
          for (var n2 = 0, r2 = t5.detections; n2 < r2.length; n2++) {
            var i2 = r2[n2];
            e2.faces.push(e2.normalizedToAbsolute(i2.landmarks, (void 0, void 0, void 0, { xMin: a2 = (o2 = i2.boundingBox).xCenter - o2.width / 2, xMax: a2 + o2.width, yMin: u2 = o2.yCenter - o2.height / 2, yMax: u2 + o2.height, width: o2.width, height: o2.height })));
          }
        var o2, a2, u2;
      });
    }
    return t3.prototype.normalizedToAbsolute = function(t4, e2) {
      var n2 = this;
      return { keypoints: t4.map(function(t5, e3) {
        return { x: t5.x * n2.width, y: t5.y * n2.height, name: V2[e3] };
      }), box: { xMin: e2.xMin * this.width, yMin: e2.yMin * this.height, xMax: e2.xMax * this.width, yMax: e2.yMax * this.height, width: e2.width * this.width, height: e2.height * this.height } };
    }, t3.prototype.estimateFaces = function(t4, e2) {
      return U2(this, void 0, void 0, function() {
        var i2, o2;
        return N2(this, function(a2) {
          switch (a2.label) {
            case 0:
              return e2 && e2.flipHorizontal && e2.flipHorizontal !== this.selfieMode && (this.selfieMode = e2.flipHorizontal, this.faceDetectorSolution.setOptions({ selfieMode: this.selfieMode })), t4 instanceof Tensor ? (o2 = ImageData.bind, [4, browser_exports.toPixels(t4)]) : [3, 2];
            case 1:
              return i2 = new (o2.apply(ImageData, [void 0, a2.sent(), t4.shape[1], t4.shape[0]]))(), [3, 3];
            case 2:
              i2 = t4, a2.label = 3;
            case 3:
              return t4 = i2, [4, this.faceDetectorSolution.send({ image: t4 })];
            case 4:
              return a2.sent(), [2, this.faces];
          }
        });
      });
    }, t3.prototype.dispose = function() {
      this.faceDetectorSolution.close();
    }, t3.prototype.reset = function() {
      this.faceDetectorSolution.reset(), this.width = 0, this.height = 0, this.faces = null, this.selfieMode = false;
    }, t3.prototype.initialize = function() {
      return this.faceDetectorSolution.initialize();
    }, t3;
  }();
  function W2(t3) {
    return U2(this, void 0, void 0, function() {
      var e2, n2;
      return N2(this, function(r2) {
        switch (r2.label) {
          case 0:
            return e2 = function(t4) {
              if (null == t4)
                return z2({}, H2);
              var e3 = z2({}, t4);
              return e3.runtime = "mediapipe", null == e3.modelType && (e3.modelType = H2.modelType), null == e3.maxFaces && (e3.maxFaces = H2.maxFaces), e3;
            }(t3), [4, (n2 = new K2(e2)).initialize()];
          case 1:
            return r2.sent(), [2, n2];
        }
      });
    });
  }
  function G2(t3) {
    return t3 instanceof Tensor ? { height: t3.shape[0], width: t3.shape[1] } : { height: t3.height, width: t3.width };
  }
  function X2(t3) {
    return t3 instanceof Tensor ? t3 : browser_exports.fromPixels(t3);
  }
  function Y2(t3, e2) {
    util_exports.assert(0 !== t3.width, function() {
      return e2 + " width cannot be 0.";
    }), util_exports.assert(0 !== t3.height, function() {
      return e2 + " height cannot be 0.";
    });
  }
  function J2(t3, e2, n2) {
    var r2 = e2.outputTensorSize, i2 = e2.keepAspectRatio, o2 = e2.borderMode, h = e2.outputTensorFloatRange, f2 = G2(t3), g2 = function(t4, e3) {
      return e3 ? { xCenter: e3.xCenter * t4.width, yCenter: e3.yCenter * t4.height, width: e3.width * t4.width, height: e3.height * t4.height, rotation: e3.rotation } : { xCenter: 0.5 * t4.width, yCenter: 0.5 * t4.height, width: t4.width, height: t4.height, rotation: 0 };
    }(f2, n2), v2 = function(t4, e3, n3) {
      if (void 0 === n3 && (n3 = false), !n3)
        return { top: 0, left: 0, right: 0, bottom: 0 };
      var r3 = e3.height, i3 = e3.width;
      Y2(e3, "targetSize"), Y2(t4, "roi");
      var o3, a2, u2 = r3 / i3, s2 = t4.height / t4.width, c2 = 0, h2 = 0;
      return u2 > s2 ? (o3 = t4.width, a2 = t4.width * u2, h2 = (1 - s2 / u2) / 2) : (o3 = t4.height / u2, a2 = t4.height, c2 = (1 - u2 / s2) / 2), t4.width = o3, t4.height = a2, { top: h2, left: c2, right: c2, bottom: h2 };
    }(g2, r2, i2), m2 = function(t4, e3, n3, r3) {
      var i3 = t4.width, o3 = t4.height, a2 = r3 ? -1 : 1, u2 = Math.cos(t4.rotation), s2 = Math.sin(t4.rotation), c2 = t4.xCenter, h2 = t4.yCenter, l3 = 1 / e3, f3 = 1 / n3, d2 = new Array(16);
      return d2[0] = i3 * u2 * a2 * l3, d2[1] = -o3 * s2 * l3, d2[2] = 0, d2[3] = (-0.5 * i3 * u2 * a2 + 0.5 * o3 * s2 + c2) * l3, d2[4] = i3 * s2 * a2 * f3, d2[5] = o3 * u2 * f3, d2[6] = 0, d2[7] = (-0.5 * o3 * u2 - 0.5 * i3 * s2 * a2 + h2) * f3, d2[8] = 0, d2[9] = 0, d2[10] = i3 * l3, d2[11] = 0, d2[12] = 0, d2[13] = 0, d2[14] = 0, d2[15] = 1, function(t5) {
        if (16 !== t5.length)
          throw new Error("Array length must be 16 but got " + t5.length);
        return [[t5[0], t5[1], t5[2], t5[3]], [t5[4], t5[5], t5[6], t5[7]], [t5[8], t5[9], t5[10], t5[11]], [t5[12], t5[13], t5[14], t5[15]]];
      }(d2);
    }(g2, f2.width, f2.height, false), y2 = tidy(function() {
      var e3 = X2(t3), n3 = tensor2d(function(t4, e4, n4) {
        return Y2(n4, "inputResolution"), [1 / n4.width * t4[0][0] * e4.width, 1 / n4.height * t4[0][1] * e4.width, t4[0][3] * e4.width, 1 / n4.width * t4[1][0] * e4.height, 1 / n4.height * t4[1][1] * e4.height, t4[1][3] * e4.height, 0, 0];
      }(m2, f2, r2), [1, 8]), i3 = "zero" === o2 ? "constant" : "nearest", g3 = image.transform(expandDims(cast(e3, "float32")), n3, "bilinear", i3, 0, [r2.height, r2.width]);
      return null != h ? function(t4, e4) {
        var n4 = function(t5, e5, n5, r3) {
          var i4 = (r3 - n5) / 255;
          return { scale: i4, offset: n5 - 0 * i4 };
        }(0, 0, e4[0], e4[1]);
        return tidy(function() {
          return add2(mul(t4, n4.scale), n4.offset);
        });
      }(g3, h) : g3;
    });
    return { imageTensor: y2, padding: v2, transformationMatrix: m2 };
  }
  function q2(t3) {
    null == t3.reduceBoxesInLowestLayer && (t3.reduceBoxesInLowestLayer = false), null == t3.interpolatedScaleAspectRatio && (t3.interpolatedScaleAspectRatio = 1), null == t3.fixedAnchorSize && (t3.fixedAnchorSize = false);
    for (var e2 = [], n2 = 0; n2 < t3.numLayers; ) {
      for (var r2 = [], i2 = [], o2 = [], a2 = [], u2 = n2; u2 < t3.strides.length && t3.strides[u2] === t3.strides[n2]; ) {
        var s2 = $2(t3.minScale, t3.maxScale, u2, t3.strides.length);
        if (0 === u2 && t3.reduceBoxesInLowestLayer)
          o2.push(1), o2.push(2), o2.push(0.5), a2.push(0.1), a2.push(s2), a2.push(s2);
        else {
          for (var c2 = 0; c2 < t3.aspectRatios.length; ++c2)
            o2.push(t3.aspectRatios[c2]), a2.push(s2);
          if (t3.interpolatedScaleAspectRatio > 0) {
            var h = u2 === t3.strides.length - 1 ? 1 : $2(t3.minScale, t3.maxScale, u2 + 1, t3.strides.length);
            a2.push(Math.sqrt(s2 * h)), o2.push(t3.interpolatedScaleAspectRatio);
          }
        }
        u2++;
      }
      for (var l3 = 0; l3 < o2.length; ++l3) {
        var f2 = Math.sqrt(o2[l3]);
        r2.push(a2[l3] / f2), i2.push(a2[l3] * f2);
      }
      var d2 = 0, p2 = 0;
      if (t3.featureMapHeight.length > 0)
        d2 = t3.featureMapHeight[n2], p2 = t3.featureMapWidth[n2];
      else {
        var g2 = t3.strides[n2];
        d2 = Math.ceil(t3.inputSizeHeight / g2), p2 = Math.ceil(t3.inputSizeWidth / g2);
      }
      for (var v2 = 0; v2 < d2; ++v2)
        for (var m2 = 0; m2 < p2; ++m2)
          for (var y2 = 0; y2 < r2.length; ++y2) {
            var w2 = { xCenter: (m2 + t3.anchorOffsetX) / p2, yCenter: (v2 + t3.anchorOffsetY) / d2, width: 0, height: 0 };
            t3.fixedAnchorSize ? (w2.width = 1, w2.height = 1) : (w2.width = i2[y2], w2.height = r2[y2]), e2.push(w2);
          }
      n2 = u2;
    }
    return e2;
  }
  function $2(t3, e2, n2, r2) {
    return 1 === r2 ? 0.5 * (t3 + e2) : t3 + (e2 - t3) * n2 / (r2 - 1);
  }
  function Z2(t3, e2) {
    var n2 = e2[0], r2 = e2[1];
    return [n2 * t3[0] + r2 * t3[1] + t3[3], n2 * t3[4] + r2 * t3[5] + t3[7]];
  }
  function Q2(t3, e2, n2, r2) {
    return U2(this, void 0, void 0, function() {
      var r3, s2, c2, h, l3;
      return N2(this, function(f2) {
        switch (f2.label) {
          case 0:
            return t3.sort(function(t4, e3) {
              return Math.max.apply(Math, e3.score) - Math.max.apply(Math, t4.score);
            }), r3 = tensor2d(t3.map(function(t4) {
              return [t4.locationData.relativeBoundingBox.yMin, t4.locationData.relativeBoundingBox.xMin, t4.locationData.relativeBoundingBox.yMax, t4.locationData.relativeBoundingBox.xMax];
            })), s2 = tensor1d(t3.map(function(t4) {
              return t4.score[0];
            })), [4, image.nonMaxSuppressionAsync(r3, s2, e2, n2)];
          case 1:
            return [4, (c2 = f2.sent()).array()];
          case 2:
            return h = f2.sent(), l3 = t3.filter(function(t4, e3) {
              return h.indexOf(e3) > -1;
            }), dispose([r3, s2, c2]), [2, l3];
        }
      });
    });
  }
  function tt2(t3, e2, n2) {
    return U2(this, void 0, void 0, function() {
      var r2, i2, a2, u2, c2;
      return N2(this, function(l3) {
        switch (l3.label) {
          case 0:
            return r2 = t3[0], i2 = t3[1], a2 = function(t4, e3, n3) {
              return tidy(function() {
                var r3, i3, o2, a3;
                n3.reverseOutputOrder ? (i3 = squeeze(slice(t4, [0, n3.boxCoordOffset + 0], [-1, 1])), r3 = squeeze(slice(t4, [0, n3.boxCoordOffset + 1], [-1, 1])), a3 = squeeze(slice(t4, [0, n3.boxCoordOffset + 2], [-1, 1])), o2 = squeeze(slice(t4, [0, n3.boxCoordOffset + 3], [-1, 1]))) : (r3 = squeeze(slice(t4, [0, n3.boxCoordOffset + 0], [-1, 1])), i3 = squeeze(slice(t4, [0, n3.boxCoordOffset + 1], [-1, 1])), o2 = squeeze(slice(t4, [0, n3.boxCoordOffset + 2], [-1, 1])), a3 = squeeze(slice(t4, [0, n3.boxCoordOffset + 3], [-1, 1]))), i3 = add2(mul(div(i3, n3.xScale), e3.w), e3.x), r3 = add2(mul(div(r3, n3.yScale), e3.h), e3.y), n3.applyExponentialOnBoxSize ? (o2 = mul(exp(div(o2, n3.hScale)), e3.h), a3 = mul(exp(div(a3, n3.wScale)), e3.w)) : (o2 = mul(div(o2, n3.hScale), e3.h), a3 = mul(div(a3, n3.wScale), e3.h));
                var u3 = sub(r3, div(o2, 2)), s2 = sub(i3, div(a3, 2)), c3 = add2(r3, div(o2, 2)), l4 = add2(i3, div(a3, 2)), b2 = concat([reshape2(u3, [n3.numBoxes, 1]), reshape2(s2, [n3.numBoxes, 1]), reshape2(c3, [n3.numBoxes, 1]), reshape2(l4, [n3.numBoxes, 1])], 1);
                if (n3.numKeypoints)
                  for (var x2 = 0; x2 < n3.numKeypoints; ++x2) {
                    var M2 = n3.keypointCoordOffset + x2 * n3.numValuesPerKeypoint, A2 = void 0, T2 = void 0;
                    n3.reverseOutputOrder ? (A2 = squeeze(slice(t4, [0, M2], [-1, 1])), T2 = squeeze(slice(t4, [0, M2 + 1], [-1, 1]))) : (T2 = squeeze(slice(t4, [0, M2], [-1, 1])), A2 = squeeze(slice(t4, [0, M2 + 1], [-1, 1])));
                    var E3 = add2(mul(div(A2, n3.xScale), e3.w), e3.x), S3 = add2(mul(div(T2, n3.yScale), e3.h), e3.y);
                    b2 = concat([b2, reshape2(E3, [n3.numBoxes, 1]), reshape2(S3, [n3.numBoxes, 1])], 1);
                  }
                return b2;
              });
            }(i2, e2, n2), u2 = tidy(function() {
              var t4 = r2;
              return n2.sigmoidScore ? (null != n2.scoreClippingThresh && (t4 = clipByValue(r2, -n2.scoreClippingThresh, n2.scoreClippingThresh)), t4 = sigmoid(t4)) : t4;
            }), [4, et2(a2, u2, n2)];
          case 1:
            return c2 = l3.sent(), dispose([a2, u2]), [2, c2];
        }
      });
    });
  }
  function et2(t3, e2, n2) {
    return U2(this, void 0, void 0, function() {
      var r2, i2, o2, a2, u2, s2, c2, h, l3, f2, d2, p2;
      return N2(this, function(g2) {
        switch (g2.label) {
          case 0:
            return r2 = [], [4, t3.data()];
          case 1:
            return i2 = g2.sent(), [4, e2.data()];
          case 2:
            for (o2 = g2.sent(), a2 = 0; a2 < n2.numBoxes; ++a2)
              if (!(null != n2.minScoreThresh && o2[a2] < n2.minScoreThresh || (u2 = a2 * n2.numCoords, s2 = nt2(i2[u2 + 0], i2[u2 + 1], i2[u2 + 2], i2[u2 + 3], o2[a2], n2.flipVertically, a2), (c2 = s2.locationData.relativeBoundingBox).width < 0 || c2.height < 0))) {
                if (n2.numKeypoints > 0)
                  for ((h = s2.locationData).relativeKeypoints = [], l3 = n2.numKeypoints * n2.numValuesPerKeypoint, f2 = 0; f2 < l3; f2 += n2.numValuesPerKeypoint)
                    d2 = u2 + n2.keypointCoordOffset + f2, p2 = { x: i2[d2 + 0], y: n2.flipVertically ? 1 - i2[d2 + 1] : i2[d2 + 1] }, h.relativeKeypoints.push(p2);
                r2.push(s2);
              }
            return [2, r2];
        }
      });
    });
  }
  function nt2(t3, e2, n2, r2, i2, o2, a2) {
    return { score: [i2], ind: a2, locationData: { relativeBoundingBox: { xMin: e2, yMin: o2 ? 1 - n2 : t3, xMax: r2, yMax: o2 ? 1 - t3 : n2, width: r2 - e2, height: n2 - t3 } } };
  }
  var rt2;
  var it2 = { reduceBoxesInLowestLayer: false, interpolatedScaleAspectRatio: 1, featureMapHeight: [], featureMapWidth: [], numLayers: 4, minScale: 0.1484375, maxScale: 0.75, inputSizeHeight: 128, inputSizeWidth: 128, anchorOffsetX: 0.5, anchorOffsetY: 0.5, strides: [8, 16, 16, 16], aspectRatios: [1], fixedAnchorSize: true };
  var ot2 = { reduceBoxesInLowestLayer: false, interpolatedScaleAspectRatio: 0, featureMapHeight: [], featureMapWidth: [], numLayers: 1, minScale: 0.1484375, maxScale: 0.75, inputSizeHeight: 192, inputSizeWidth: 192, anchorOffsetX: 0.5, anchorOffsetY: 0.5, strides: [4], aspectRatios: [1], fixedAnchorSize: true };
  var at2 = { runtime: "tfjs", modelType: "short", maxFaces: 1, detectorModelUrl: "https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1" };
  var ut2 = { applyExponentialOnBoxSize: false, flipVertically: false, ignoreClasses: [], numClasses: 1, numBoxes: 896, numCoords: 16, boxCoordOffset: 0, keypointCoordOffset: 4, numKeypoints: 6, numValuesPerKeypoint: 2, sigmoidScore: true, scoreClippingThresh: 100, reverseOutputOrder: true, xScale: 128, yScale: 128, hScale: 128, wScale: 128, minScoreThresh: 0.5 };
  var st2 = { applyExponentialOnBoxSize: false, flipVertically: false, ignoreClasses: [], numClasses: 1, numBoxes: 2304, numCoords: 16, boxCoordOffset: 0, keypointCoordOffset: 4, numKeypoints: 6, numValuesPerKeypoint: 2, sigmoidScore: true, scoreClippingThresh: 100, reverseOutputOrder: true, xScale: 192, yScale: 192, hScale: 192, wScale: 192, minScoreThresh: 0.6 };
  var ct2 = { outputTensorSize: { width: 128, height: 128 }, keepAspectRatio: true, outputTensorFloatRange: [-1, 1], borderMode: "zero" };
  var ht2 = { outputTensorSize: { width: 192, height: 192 }, keepAspectRatio: true, outputTensorFloatRange: [-1, 1], borderMode: "zero" };
  var lt2 = function() {
    function t3(t4, e2, n2) {
      this.detectorModel = e2, this.maxFaces = n2, "full" === t4 ? (this.imageToTensorConfig = ht2, this.tensorsToDetectionConfig = st2, this.anchors = q2(ot2)) : (this.imageToTensorConfig = ct2, this.tensorsToDetectionConfig = ut2, this.anchors = q2(it2));
      var r2 = tensor1d(this.anchors.map(function(t5) {
        return t5.width;
      })), o2 = tensor1d(this.anchors.map(function(t5) {
        return t5.height;
      })), a2 = tensor1d(this.anchors.map(function(t5) {
        return t5.xCenter;
      })), u2 = tensor1d(this.anchors.map(function(t5) {
        return t5.yCenter;
      }));
      this.anchorTensor = { x: a2, y: u2, w: r2, h: o2 };
    }
    return t3.prototype.dispose = function() {
      this.detectorModel.dispose(), dispose([this.anchorTensor.x, this.anchorTensor.y, this.anchorTensor.w, this.anchorTensor.h]);
    }, t3.prototype.reset = function() {
    }, t3.prototype.detectFaces = function(t4, e2) {
      return void 0 === e2 && (e2 = false), U2(this, void 0, void 0, function() {
        var n2, r2, i2, a2, d2, p2, g2, v2, m2, y2, w2;
        return N2(this, function(b2) {
          switch (b2.label) {
            case 0:
              return null == t4 ? (this.reset(), [2, []]) : (n2 = tidy(function() {
                var n3 = cast(X2(t4), "float32");
                return e2 && (n3 = squeeze(image.flipLeftRight(expandDims(n3, 0)), [0])), n3;
              }), r2 = J2(n2, this.imageToTensorConfig), i2 = r2.imageTensor, a2 = r2.transformationMatrix, d2 = this.detectorModel.execute(i2, "Identity:0"), p2 = function(t5) {
                return tidy(function() {
                  var e3 = function(t6) {
                    return tidy(function() {
                      return [slice(t6, [0, 0, 0], [1, -1, 1]), slice(t6, [0, 0, 1], [1, -1, -1])];
                    });
                  }(t5), n3 = e3[0], r3 = e3[1];
                  return { boxes: squeeze(r3), logits: squeeze(n3) };
                });
              }(d2), g2 = p2.boxes, [4, tt2([v2 = p2.logits, g2], this.anchorTensor, this.tensorsToDetectionConfig)]);
            case 1:
              return 0 === (m2 = b2.sent()).length ? (dispose([n2, i2, d2, v2, g2]), [2, m2]) : [4, Q2(m2, this.maxFaces, 0.3)];
            case 2:
              return y2 = b2.sent(), w2 = function(t5, e3) {
                void 0 === t5 && (t5 = []);
                var n3, r3 = (n3 = e3, [].concat.apply([], n3));
                return t5.forEach(function(t6) {
                  var e4 = t6.locationData;
                  e4.relativeKeypoints.forEach(function(t7) {
                    var e5 = Z2(r3, [t7.x, t7.y]), n5 = e5[0], i4 = e5[1];
                    t7.x = n5, t7.y = i4;
                  });
                  var n4 = e4.relativeBoundingBox, i3 = Number.MAX_VALUE, o2 = Number.MAX_VALUE, a3 = Number.MIN_VALUE, u2 = Number.MIN_VALUE;
                  [[n4.xMin, n4.yMin], [n4.xMin + n4.width, n4.yMin], [n4.xMin + n4.width, n4.yMin + n4.height], [n4.xMin, n4.yMin + n4.height]].forEach(function(t7) {
                    var e5 = Z2(r3, t7), n5 = e5[0], s2 = e5[1];
                    i3 = Math.min(i3, n5), a3 = Math.max(a3, n5), o2 = Math.min(o2, s2), u2 = Math.max(u2, s2);
                  }), e4.relativeBoundingBox = { xMin: i3, xMax: a3, yMin: o2, yMax: u2, width: a3 - i3, height: u2 - o2 };
                }), t5;
              }(y2, a2), dispose([n2, i2, d2, v2, g2]), [2, w2];
          }
        });
      });
    }, t3.prototype.estimateFaces = function(t4, e2) {
      return U2(this, void 0, void 0, function() {
        var n2, r2;
        return N2(this, function(i2) {
          return n2 = G2(t4), r2 = !!e2 && e2.flipHorizontal, [2, this.detectFaces(t4, r2).then(function(t5) {
            return t5.map(function(t6) {
              for (var e3 = t6.locationData.relativeKeypoints.map(function(t7, e4) {
                return z2(z2({}, t7), { x: t7.x * n2.width, y: t7.y * n2.height, name: V2[e4] });
              }), r3 = t6.locationData.relativeBoundingBox, i3 = 0, o2 = ["width", "xMax", "xMin"]; i3 < o2.length; i3++)
                r3[o2[i3]] *= n2.width;
              for (var a2 = 0, u2 = ["height", "yMax", "yMin"]; a2 < u2.length; a2++)
                r3[u2[a2]] *= n2.height;
              return { keypoints: e3, box: r3 };
            });
          })];
        });
      });
    }, t3;
  }();
  function ft2(t3) {
    return U2(this, void 0, void 0, function() {
      var e2, n2, r2;
      return N2(this, function(i2) {
        switch (i2.label) {
          case 0:
            return e2 = function(t4) {
              if (null == t4)
                return z2({}, at2);
              var e3 = z2({}, t4);
              return null == e3.modelType && (e3.modelType = at2.modelType), null == e3.maxFaces && (e3.maxFaces = at2.maxFaces), null == e3.detectorModelUrl && ("full" === e3.modelType ? e3.detectorModelUrl = "https://tfhub.dev/mediapipe/tfjs-model/face_detection/full/1" : e3.detectorModelUrl = "https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"), e3;
            }(t3), n2 = "string" == typeof e2.detectorModelUrl && e2.detectorModelUrl.indexOf("https://tfhub.dev") > -1, [4, loadGraphModel(e2.detectorModelUrl, { fromTFHub: n2 })];
          case 1:
            return r2 = i2.sent(), [2, new lt2(e2.modelType, r2, e2.maxFaces)];
        }
      });
    });
  }
  function dt2(t3, e2) {
    return U2(this, void 0, void 0, function() {
      var n2, r2;
      return N2(this, function(i2) {
        if (t3 === rt2.MediaPipeFaceDetector) {
          if (r2 = void 0, null != (n2 = e2)) {
            if ("tfjs" === n2.runtime)
              return [2, ft2(n2)];
            if ("mediapipe" === n2.runtime)
              return [2, W2(n2)];
            r2 = n2.runtime;
          }
          throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got " + r2);
        }
        throw new Error(t3 + " is not a supported model name.");
      });
    });
  }
  function pt2(t3) {
    return t3.width * t3.height;
  }
  function gt2(t3) {
    var e2 = t3.xCenter - t3.width / 2, n2 = e2 + t3.width, r2 = t3.yCenter - t3.height / 2;
    return { xMin: e2, xMax: n2, yMin: r2, yMax: r2 + t3.height, width: t3.width, height: t3.height };
  }
  function vt2(t3, e2) {
    var n2 = gt2(t3), r2 = gt2(e2);
    if (!function(t4, e3) {
      return !(t4.xMax < e3.xMin || e3.xMax < t4.xMin || t4.yMax < e3.yMin || e3.yMax < t4.yMin);
    }(n2, r2))
      return 0;
    var i2 = pt2(function(t4, e3) {
      var n3 = Math.max(t4.xMin, e3.xMin), r3 = Math.min(t4.xMax, e3.xMax), i3 = Math.max(t4.yMin, e3.yMin), o3 = Math.min(t4.yMax, e3.yMax);
      return { xMin: n3, xMax: r3, yMin: i3, yMax: o3, width: Math.max(r3 - n3, 0), height: Math.max(o3 - i3, 0) };
    }(n2, r2)), o2 = pt2(n2) + pt2(r2) - i2;
    return o2 > 0 ? i2 / o2 : 0;
  }
  function mt2(t3, e2, n2, r2) {
    var i2 = t3.width, o2 = t3.height, a2 = r2 ? -1 : 1, u2 = Math.cos(t3.rotation), s2 = Math.sin(t3.rotation), c2 = t3.xCenter, h = t3.yCenter, l3 = 1 / e2, f2 = 1 / n2, d2 = new Array(16);
    return d2[0] = i2 * u2 * a2 * l3, d2[1] = -o2 * s2 * l3, d2[2] = 0, d2[3] = (-0.5 * i2 * u2 * a2 + 0.5 * o2 * s2 + c2) * l3, d2[4] = i2 * s2 * a2 * f2, d2[5] = o2 * u2 * f2, d2[6] = 0, d2[7] = (-0.5 * o2 * u2 - 0.5 * i2 * s2 * a2 + h) * f2, d2[8] = 0, d2[9] = 0, d2[10] = i2 * l3, d2[11] = 0, d2[12] = 0, d2[13] = 0, d2[14] = 0, d2[15] = 1, function(t4) {
      if (16 !== t4.length)
        throw new Error("Array length must be 16 but got " + t4.length);
      return [[t4[0], t4[1], t4[2], t4[3]], [t4[4], t4[5], t4[6], t4[7]], [t4[8], t4[9], t4[10], t4[11]], [t4[12], t4[13], t4[14], t4[15]]];
    }(d2);
  }
  function yt2(t3) {
    return t3 instanceof Tensor ? { height: t3.shape[0], width: t3.shape[1] } : { height: t3.height, width: t3.width };
  }
  function wt2(t3) {
    return t3 - 2 * Math.PI * Math.floor((t3 + Math.PI) / (2 * Math.PI));
  }
  function bt2(t3) {
    return t3 instanceof Tensor ? t3 : browser_exports.fromPixels(t3);
  }
  function xt2(t3, n2) {
    util_exports.assert(0 !== t3.width, function() {
      return n2 + " width cannot be 0.";
    }), util_exports.assert(0 !== t3.height, function() {
      return n2 + " height cannot be 0.";
    });
  }
  function Mt2(t3, n2) {
    var r2 = function(t4, e2, n3, r3) {
      var i2 = e2 - t4, o2 = r3 - n3;
      if (0 === i2)
        throw new Error("Original min and max are both " + t4 + ", range cannot be 0.");
      var a2 = o2 / i2;
      return { scale: a2, offset: n3 - t4 * a2 };
    }(0, 255, n2[0], n2[1]);
    return tidy(function() {
      return add2(mul(t3, r2.scale), r2.offset);
    });
  }
  function At2(t3, n2, r2) {
    var i2 = n2.outputTensorSize, o2 = n2.keepAspectRatio, a2 = n2.borderMode, u2 = n2.outputTensorFloatRange, s2 = yt2(t3), c2 = function(t4, e2) {
      return e2 ? { xCenter: e2.xCenter * t4.width, yCenter: e2.yCenter * t4.height, width: e2.width * t4.width, height: e2.height * t4.height, rotation: e2.rotation } : { xCenter: 0.5 * t4.width, yCenter: 0.5 * t4.height, width: t4.width, height: t4.height, rotation: 0 };
    }(s2, r2), h = function(t4, e2, n3) {
      if (void 0 === n3 && (n3 = false), !n3)
        return { top: 0, left: 0, right: 0, bottom: 0 };
      var r3 = e2.height, i3 = e2.width;
      xt2(e2, "targetSize"), xt2(t4, "roi");
      var o3, a3, u3 = r3 / i3, s3 = t4.height / t4.width, c3 = 0, h2 = 0;
      return u3 > s3 ? (o3 = t4.width, a3 = t4.width * u3, h2 = (1 - s3 / u3) / 2) : (o3 = t4.height / u3, a3 = t4.height, c3 = (1 - u3 / s3) / 2), t4.width = o3, t4.height = a3, { top: h2, left: c3, right: c3, bottom: h2 };
    }(c2, i2, o2), l3 = mt2(c2, s2.width, s2.height, false), f2 = tidy(function() {
      var n3 = bt2(t3), r3 = tensor2d(function(t4, e2, n4) {
        return xt2(n4, "inputResolution"), [1 / n4.width * t4[0][0] * e2.width, 1 / n4.height * t4[0][1] * e2.width, t4[0][3] * e2.width, 1 / n4.width * t4[1][0] * e2.height, 1 / n4.height * t4[1][1] * e2.height, t4[1][3] * e2.height, 0, 0];
      }(l3, s2, i2), [1, 8]), o3 = "zero" === a2 ? "constant" : "nearest", c3 = image.transform(expandDims(cast(n3, "float32")), r3, "bilinear", o3, 0, [i2.height, i2.width]);
      return null != u2 ? Mt2(c3, u2) : c3;
    });
    return { imageTensor: f2, padding: h, transformationMatrix: l3 };
  }
  function Tt2(t3) {
    return { xCenter: t3.xMin + t3.width / 2, yCenter: t3.yMin + t3.height / 2, width: t3.width, height: t3.height };
  }
  function Et2(t3) {
    var e2 = t3.relativeKeypoints;
    if (e2.length <= 1)
      throw new Error("2 or more keypoints required to calculate a rect.");
    var n2 = Number.MAX_VALUE, r2 = Number.MAX_VALUE, i2 = Number.MIN_VALUE, o2 = Number.MIN_VALUE;
    return e2.forEach(function(t4) {
      n2 = Math.min(n2, t4.x), i2 = Math.max(i2, t4.x), r2 = Math.min(r2, t4.y), o2 = Math.max(o2, t4.y);
    }), { xCenter: (n2 + i2) / 2, yCenter: (r2 + o2) / 2, width: i2 - n2, height: o2 - r2 };
  }
  function St2(t3, e2, n2, r2, i2) {
    var o2 = "rect" === n2 ? function(t4, e3, n3) {
      var r3, i3 = t4.locationData;
      if ("boundingbox" === e3)
        r3 = Tt2(i3.boundingBox);
      else {
        r3 = Et2(i3);
        var o3 = n3.width, a2 = n3.height;
        r3.xCenter = Math.round(r3.xCenter * o3), r3.yCenter = Math.round(r3.yCenter * a2), r3.width = Math.round(r3.width * o3), r3.height = Math.round(r3.height * a2);
      }
      return r3;
    }(t3, e2, r2) : function(t4, e3) {
      var n3 = t4.locationData;
      return "boundingbox" === e3 ? Tt2(n3.relativeBoundingBox) : Et2(n3);
    }(t3, e2);
    return i2 && (o2.rotation = function(t4, e3, n3) {
      var r3, i3 = t4.locationData, o3 = n3.rotationVectorStartKeypointIndex, a2 = n3.rotationVectorEndKeypointIndex;
      r3 = n3.rotationVectorTargetAngle ? n3.rotationVectorTargetAngle : Math.PI * n3.rotationVectorTargetAngleDegree / 180;
      var u2 = i3.relativeKeypoints[o3].x * e3.width, s2 = i3.relativeKeypoints[o3].y * e3.height, c2 = i3.relativeKeypoints[a2].x * e3.width, h = i3.relativeKeypoints[a2].y * e3.height;
      return wt2(r3 - Math.atan2(-(h - s2), c2 - u2));
    }(t3, r2, i2)), o2;
  }
  function Ft2(t3, e2, n2) {
    for (var r2 = 0; r2 < e2.length; ++r2) {
      var i2 = e2[r2], o2 = n2[t3[r2]];
      o2.x = i2.x, o2.y = i2.y;
    }
  }
  function Ct2(t3, e2, n2, r2) {
    if ("string" == typeof e2) {
      if ("copy" === e2)
        for (var i2 = 0; i2 < n2.length; ++i2)
          r2[t3[i2]].z = n2[i2].z;
    } else {
      var o2 = function(t4, e3) {
        for (var n3 = 0, r3 = 0; r3 < e3.length; ++r3)
          n3 += t4[e3[r3]].z;
        return n3 / e3.length;
      }(r2, e2);
      for (i2 = 0; i2 < t3.length; ++i2)
        r2[t3[i2]].z = o2;
    }
  }
  function Ot2(t3, e2) {
    for (var n2 = function(t4) {
      var e3 = [].concat.apply([], t4.map(function(t5) {
        return t5.indexesMapping;
      }));
      if (0 === e3.length)
        throw new Error("There should be at least one landmark in indexes mapping");
      var n3 = e3[0], r3 = e3[0], i3 = new Set(e3);
      i3.forEach(function(t5) {
        n3 = Math.min(n3, t5), r3 = Math.max(r3, t5);
      });
      var o3 = i3.size;
      if (0 !== n3)
        throw new Error("Indexes are expected to start with 0 instead of " + n3);
      if (r3 + 1 !== o3)
        throw new Error("Indexes should have no gaps but " + (r3 - o3 + 1) + " indexes are missing");
      return o3;
    }(e2), r2 = new Array(n2).fill(null).map(Object), i2 = 0; i2 < t3.length; ++i2) {
      var o2 = t3[i2], a2 = e2[i2];
      if (o2.length !== a2.indexesMapping.length)
        throw new Error("There are " + o2.length + " refinement landmarks while mapping has " + a2.indexesMapping.length);
      Ft2(a2.indexesMapping, o2, r2), Ct2(a2.indexesMapping, a2.zRefinement, o2, r2);
    }
    return r2;
  }
  function _t2(t3, e2) {
    return t3.map(function(t4) {
      var n2 = E2(E2({}, t4), { x: t4.x * e2.width, y: t4.y * e2.height });
      return null != t4.z && (n2.z = t4.z * e2.width), n2;
    });
  }
  function jt2(t3, e2) {
    return "none" === t3 ? e2 : function(t4) {
      return 1 / (1 + Math.exp(-t4));
    }(e2);
  }
  function kt2(t3, e2, n2, r2) {
    return S2(this, void 0, void 0, function() {
      var i2, o2, a2, u2, s2, c2, h, l3;
      return F2(this, function(f2) {
        switch (f2.label) {
          case 0:
            return n2 = n2 || e2.flipHorizontally || false, r2 = r2 || e2.flipVertically || false, i2 = t3.size, o2 = i2 / e2.numLandmarks, [4, t3.data()];
          case 1:
            for (a2 = f2.sent(), u2 = [], s2 = 0; s2 < e2.numLandmarks; ++s2)
              c2 = s2 * o2, (l3 = { x: 0, y: 0 }).x = n2 ? e2.inputImageWidth - a2[c2] : a2[c2], o2 > 1 && (l3.y = r2 ? e2.inputImageHeight - a2[c2 + 1] : a2[c2 + 1]), o2 > 2 && (l3.z = a2[c2 + 2]), o2 > 3 && (l3.score = jt2(e2.visibilityActivation, a2[c2 + 3])), u2.push(l3);
            for (h = 0; h < u2.length; ++h)
              (l3 = u2[h]).x = l3.x / e2.inputImageWidth, l3.y = l3.y / e2.inputImageHeight, l3.z = l3.z / e2.inputImageWidth / (e2.normalizeZ || 1);
            return [2, u2];
        }
      });
    });
  }
  function Rt2(t3, e2, n2) {
    var r2 = t3.width, i2 = t3.height, o2 = t3.rotation;
    if (null == n2.rotation && null == n2.rotationDegree || (o2 = function(t4, e3) {
      null != e3.rotation ? t4 += e3.rotation : null != e3.rotationDegree && (t4 += Math.PI * e3.rotationDegree / 180);
      return wt2(t4);
    }(o2, n2)), 0 === o2)
      t3.xCenter = t3.xCenter + r2 * n2.shiftX, t3.yCenter = t3.yCenter + i2 * n2.shiftY;
    else {
      var a2 = (e2.width * r2 * n2.shiftX * Math.cos(o2) - e2.height * i2 * n2.shiftY * Math.sin(o2)) / e2.width, u2 = (e2.width * r2 * n2.shiftX * Math.sin(o2) + e2.height * i2 * n2.shiftY * Math.cos(o2)) / e2.height;
      t3.xCenter = t3.xCenter + a2, t3.yCenter = t3.yCenter + u2;
    }
    if (n2.squareLong) {
      var s2 = Math.max(r2 * e2.width, i2 * e2.height);
      r2 = s2 / e2.width, i2 = s2 / e2.height;
    } else if (n2.squareShort) {
      var c2 = Math.min(r2 * e2.width, i2 * e2.height);
      r2 = c2 / e2.width, i2 = c2 / e2.height;
    }
    return t3.width = r2 * n2.scaleX, t3.height = i2 * n2.scaleY, t3;
  }
  (rt2 || (rt2 = {})).MediaPipeFaceDetector = "MediaPipeFaceDetector";
  var It2 = { runtime: "tfjs", maxFaces: 1, refineLandmarks: false, landmarkModelUrl: "https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/face_mesh/1" };
  var Lt2 = { flipHorizontal: false, staticImageMode: false };
  var Bt2 = { shiftX: 0, shiftY: 0, scaleX: 1.5, scaleY: 1.5, squareLong: true };
  var Dt2 = { outputTensorSize: { width: 192, height: 192 }, outputTensorFloatRange: [0, 1], borderMode: "replicate" };
  var Pt2 = { numLandmarks: 468, inputImageWidth: 192, inputImageHeight: 192, visibilityActivation: "none", flipHorizontally: false, flipVertically: false };
  var zt2 = { numLandmarks: 80, inputImageWidth: 192, inputImageHeight: 192, visibilityActivation: "none", flipHorizontally: false, flipVertically: false };
  var Ut2 = { numLandmarks: 71, inputImageWidth: 192, inputImageHeight: 192, visibilityActivation: "none", flipHorizontally: false, flipVertically: false };
  var Nt2 = { numLandmarks: 5, inputImageWidth: 192, inputImageHeight: 192, visibilityActivation: "none", flipHorizontally: false, flipVertically: false };
  var Vt2 = { indexesMapping: Array.from(Array(468).keys()), zRefinement: "copy" };
  var Ht2 = { indexesMapping: [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 185, 40, 39, 37, 0, 267, 269, 270, 409, 78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308, 191, 80, 81, 82, 13, 312, 311, 310, 415, 76, 77, 90, 180, 85, 16, 315, 404, 320, 307, 306, 184, 74, 73, 72, 11, 302, 303, 304, 408, 62, 96, 89, 179, 86, 15, 316, 403, 319, 325, 292, 183, 42, 41, 38, 12, 268, 271, 272, 407], zRefinement: "none" };
  var Kt2 = { indexesMapping: [33, 7, 163, 144, 145, 153, 154, 155, 133, 246, 161, 160, 159, 158, 157, 173, 130, 25, 110, 24, 23, 22, 26, 112, 243, 247, 30, 29, 27, 28, 56, 190, 226, 31, 228, 229, 230, 231, 232, 233, 244, 113, 225, 224, 223, 222, 221, 189, 35, 124, 46, 53, 52, 65, 143, 111, 117, 118, 119, 120, 121, 128, 245, 156, 70, 63, 105, 66, 107, 55, 193], zRefinement: "none" };
  var Wt2 = { indexesMapping: [263, 249, 390, 373, 374, 380, 381, 382, 362, 466, 388, 387, 386, 385, 384, 398, 359, 255, 339, 254, 253, 252, 256, 341, 463, 467, 260, 259, 257, 258, 286, 414, 446, 261, 448, 449, 450, 451, 452, 453, 464, 342, 445, 444, 443, 442, 441, 413, 265, 353, 276, 283, 282, 295, 372, 340, 346, 347, 348, 349, 350, 357, 465, 383, 300, 293, 334, 296, 336, 285, 417], zRefinement: "none" };
  var Gt2 = { indexesMapping: [468, 469, 470, 471, 472], zRefinement: [33, 7, 163, 144, 145, 153, 154, 155, 133, 246, 161, 160, 159, 158, 157, 173] };
  var Xt2 = { indexesMapping: [473, 474, 475, 476, 477], zRefinement: [263, 249, 390, 373, 374, 380, 381, 382, 362, 466, 388, 387, 386, 385, 384, 398] };
  var Yt2;
  var Jt2 = function() {
    function t3(t4, e2, n2, r2) {
      this.detector = t4, this.landmarkModel = e2, this.maxFaces = n2, this.withAttention = r2, this.prevFaceRectsFromLandmarks = null;
    }
    return t3.prototype.estimateFaces = function(t4, n2) {
      return S2(this, void 0, void 0, function() {
        var r2, i2, o2, a2, u2, s2, c2, h, l3, f2, d2, p2, g2, v2 = this;
        return F2(this, function(m2) {
          switch (m2.label) {
            case 0:
              return r2 = function(t5) {
                if (null == t5)
                  return E2({}, Lt2);
                var e2 = E2({}, t5);
                return null == e2.flipHorizontal && (e2.flipHorizontal = Lt2.flipHorizontal), null == e2.staticImageMode && (e2.staticImageMode = Lt2.staticImageMode), e2;
              }(n2), null == t4 ? (this.reset(), [2, []]) : (i2 = yt2(t4), o2 = tidy(function() {
                var n3 = cast(bt2(t4), "float32");
                if (r2.flipHorizontal) {
                  n3 = squeeze(image.flipLeftRight(expandDims(n3, 0)), [0]);
                }
                return n3;
              }), a2 = this.prevFaceRectsFromLandmarks, r2.staticImageMode || null == a2 || a2.length < this.maxFaces ? [4, this.detector.detectFaces(o2, false)] : [3, 2]);
            case 1:
              return 0 === (s2 = m2.sent()).length ? (this.reset(), o2.dispose(), [2, []]) : (u2 = s2.map(function(t5) {
                return v2.faceDetectionFrontDetectionToRoi(t5, i2);
              }), [3, 3]);
            case 2:
              u2 = [], m2.label = 3;
            case 3:
              return y2 = 0.5, w2 = [], [u2, a2 || []].forEach(function(t5) {
                return t5.forEach(function(t6) {
                  (w2 = w2.filter(function(e2) {
                    return vt2(t6, e2) <= y2;
                  })).push(t6);
                });
              }), c2 = w2, [4, Promise.all(c2.map(function(t5) {
                return v2.faceLandmark(t5, o2);
              }))];
            case 4:
              for (h = m2.sent(), l3 = [], this.prevFaceRectsFromLandmarks = [], f2 = 0; f2 < h.length; ++f2)
                null != (d2 = h[f2]) && (this.prevFaceRectsFromLandmarks.push(this.faceLandmarksToRoi(d2, i2)), null != (p2 = _t2(d2, i2)) && p2.forEach(function(t5, e2) {
                  var n3 = k3.get(e2);
                  null != n3 && (t5.name = n3);
                }), g2 = R2(p2), l3.push({ keypoints: p2, box: g2.locationData.relativeBoundingBox }));
              return o2.dispose(), [2, l3];
          }
          var y2, w2;
        });
      });
    }, t3.prototype.dispose = function() {
      this.detector.dispose(), this.landmarkModel.dispose();
    }, t3.prototype.reset = function() {
      this.detector.reset(), this.prevFaceRectsFromLandmarks = null;
    }, t3.prototype.faceDetectionFrontDetectionToRoi = function(t4, e2) {
      return Rt2(St2(t4, "boundingbox", "normRect", e2, { rotationVectorStartKeypointIndex: 0, rotationVectorEndKeypointIndex: 1, rotationVectorTargetAngleDegree: 0 }), e2, Bt2);
    }, t3.prototype.faceLandmark = function(t4, n2) {
      return S2(this, void 0, void 0, function() {
        var r2, i2, o2, a2, u2, s2, c2;
        return F2(this, function(h) {
          switch (h.label) {
            case 0:
              return r2 = At2(n2, Dt2, t4).imageTensor, i2 = ["output_faceflag"].concat(this.withAttention ? ["output_mesh_identity", "output_lips", "Identity_6:0", "Identity_1:0", "Identity_2:0", "Identity_5:0"] : ["output_mesh"]), o2 = this.landmarkModel.execute(r2, i2), a2 = o2[0], u2 = o2.slice(1), [4, a2.data()];
            case 1:
              return h.sent()[0] < 0.5 ? (dispose(o2), dispose(r2), [2, null]) : this.withAttention ? [4, this.tensorsToFaceLandmarksWithAttention(u2)] : [3, 3];
            case 2:
              return s2 = h.sent(), [3, 5];
            case 3:
              return [4, this.tensorsToFaceLandmarks(u2)];
            case 4:
              s2 = h.sent(), h.label = 5;
            case 5:
              return c2 = function(t5, e2, n3) {
                void 0 === n3 && (n3 = { ignoreRotation: false });
                for (var r3 = [], i3 = 0, o3 = t5; i3 < o3.length; i3++) {
                  var a3 = o3[i3], u3 = a3.x - 0.5, s3 = a3.y - 0.5, c3 = n3.ignoreRotation ? 0 : e2.rotation, h2 = Math.cos(c3) * u3 - Math.sin(c3) * s3, l3 = Math.sin(c3) * u3 + Math.cos(c3) * s3;
                  h2 = h2 * e2.width + e2.xCenter, l3 = l3 * e2.height + e2.yCenter;
                  var f2 = a3.z * e2.width, d2 = E2({}, a3);
                  d2.x = h2, d2.y = l3, d2.z = f2, r3.push(d2);
                }
                return r3;
              }(s2, t4), dispose(o2), dispose(r2), [2, c2];
          }
        });
      });
    }, t3.prototype.tensorsToFaceLandmarks = function(t4) {
      return S2(this, void 0, void 0, function() {
        return F2(this, function(e2) {
          return [2, kt2(t4[0], Pt2)];
        });
      });
    }, t3.prototype.tensorsToFaceLandmarksWithAttention = function(t4) {
      return S2(this, void 0, void 0, function() {
        var e2, n2, r2, i2, o2, a2;
        return F2(this, function(u2) {
          switch (u2.label) {
            case 0:
              return [4, kt2(t4[0], Pt2)];
            case 1:
              return e2 = u2.sent(), [4, kt2(t4[1], zt2)];
            case 2:
              return n2 = u2.sent(), [4, kt2(t4[3], Ut2)];
            case 3:
              return r2 = u2.sent(), [4, kt2(t4[5], Ut2)];
            case 4:
              return i2 = u2.sent(), [4, kt2(t4[4], Nt2)];
            case 5:
              return o2 = u2.sent(), [4, kt2(t4[2], Nt2)];
            case 6:
              return a2 = u2.sent(), [2, Ot2([e2, n2, r2, i2, o2, a2], [Vt2, Ht2, Kt2, Wt2, Gt2, Xt2])];
          }
        });
      });
    }, t3.prototype.faceLandmarksToRoi = function(t4, e2) {
      return Rt2(St2(R2(t4), "boundingbox", "normRect", e2, { rotationVectorStartKeypointIndex: 33, rotationVectorEndKeypointIndex: 263, rotationVectorTargetAngleDegree: 0 }), e2, Bt2);
    }, t3;
  }();
  function qt2(t3) {
    return S2(this, void 0, void 0, function() {
      var e2, n2, r2, i2;
      return F2(this, function(o2) {
        switch (o2.label) {
          case 0:
            return e2 = function(t4) {
              if (null == t4)
                return E2({}, It2);
              var e3 = E2({}, t4);
              return e3.runtime = "tfjs", null == e3.maxFaces && (e3.maxFaces = It2.maxFaces), null == e3.refineLandmarks && (e3.refineLandmarks = It2.refineLandmarks), null == e3.landmarkModelUrl && (e3.landmarkModelUrl = e3.refineLandmarks ? "https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/attention_mesh/1" : "https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/face_mesh/1"), e3;
            }(t3), n2 = "string" == typeof e2.landmarkModelUrl && e2.landmarkModelUrl.indexOf("https://tfhub.dev") > -1, [4, loadGraphModel(e2.landmarkModelUrl, { fromTFHub: n2 })];
          case 1:
            return r2 = o2.sent(), [4, dt2(rt2.MediaPipeFaceDetector, { modelType: "short", maxFaces: e2.maxFaces, detectorModelUrl: e2.detectorModelUrl, runtime: e2.runtime })];
          case 2:
            return i2 = o2.sent(), [2, new Jt2(i2, r2, e2.maxFaces, e2.refineLandmarks)];
        }
      });
    });
  }
  function $t2(t3, e2) {
    return S2(this, void 0, void 0, function() {
      var n2, r2;
      return F2(this, function(i2) {
        if (t3 === Yt2.MediaPipeFaceMesh) {
          if (r2 = void 0, null != (n2 = e2)) {
            if ("tfjs" === n2.runtime)
              return [2, qt2(n2)];
            if ("mediapipe" === n2.runtime)
              return [2, B2(n2)];
            r2 = n2.runtime;
          }
          throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got " + r2);
        }
        throw new Error(t3 + " is not a supported model name.");
      });
    });
  }
  !function(t3) {
    t3.MediaPipeFaceMesh = "MediaPipeFaceMesh";
  }(Yt2 || (Yt2 = {}));
  var Zt2 = Object.freeze({ __proto__: null, getKeypointIndexByContour: function(t3) {
    if (t3 === Yt2.MediaPipeFaceMesh)
      return O2;
    throw new Error("Model " + t3 + " is not supported.");
  }, getAdjacentPairs: function(t3) {
    if (t3 === Yt2.MediaPipeFaceMesh)
      return _2;
    throw new Error("Model " + t3 + " is not supported.");
  } });

  // dist/components/shared/params.js
  var NUM_KEYPOINTS = 468;
  var NUM_IRIS_KEYPOINTS = 5;
  var GREEN = "#32EEDB";
  var WHITE = "#FFFFFF";
  var BLUE_WATCH_SURE = "#1871F8";
  var VIDEO_SIZE = {
    "640 X 480": { width: 640, height: 480 },
    "640 X 360": { width: 640, height: 360 },
    "360 X 270": { width: 360, height: 270 }
  };
  var STATE = {
    camera: { targetFPS: 60, sizeOption: "640 X 480" },
    backend: "",
    flags: {},
    modelConfig: {}
  };
  async function createDetector() {
    return $t2(Yt2.MediaPipeFaceMesh, {
      runtime: "mediapipe",
      refineLandmarks: true,
      maxFaces: 1,
      solutionPath: `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh`
    });
  }
  var MODEL_BACKEND_MAP = {
    [Yt2.MediaPipeFaceMesh]: [
      "mediapipe-gpu",
      "tfjs-webgl"
    ]
  };

  // dist/components/shared/triangulation.js
  var TRIANGULATION = [
    127,
    34,
    139,
    11,
    0,
    37,
    232,
    231,
    120,
    72,
    37,
    39,
    128,
    121,
    47,
    232,
    121,
    128,
    104,
    69,
    67,
    175,
    171,
    148,
    157,
    154,
    155,
    118,
    50,
    101,
    73,
    39,
    40,
    9,
    151,
    108,
    48,
    115,
    131,
    194,
    204,
    211,
    74,
    40,
    185,
    80,
    42,
    183,
    40,
    92,
    186,
    230,
    229,
    118,
    202,
    212,
    214,
    83,
    18,
    17,
    76,
    61,
    146,
    160,
    29,
    30,
    56,
    157,
    173,
    106,
    204,
    194,
    135,
    214,
    192,
    203,
    165,
    98,
    21,
    71,
    68,
    51,
    45,
    4,
    144,
    24,
    23,
    77,
    146,
    91,
    205,
    50,
    187,
    201,
    200,
    18,
    91,
    106,
    182,
    90,
    91,
    181,
    85,
    84,
    17,
    206,
    203,
    36,
    148,
    171,
    140,
    92,
    40,
    39,
    193,
    189,
    244,
    159,
    158,
    28,
    247,
    246,
    161,
    236,
    3,
    196,
    54,
    68,
    104,
    193,
    168,
    8,
    117,
    228,
    31,
    189,
    193,
    55,
    98,
    97,
    99,
    126,
    47,
    100,
    166,
    79,
    218,
    155,
    154,
    26,
    209,
    49,
    131,
    135,
    136,
    150,
    47,
    126,
    217,
    223,
    52,
    53,
    45,
    51,
    134,
    211,
    170,
    140,
    67,
    69,
    108,
    43,
    106,
    91,
    230,
    119,
    120,
    226,
    130,
    247,
    63,
    53,
    52,
    238,
    20,
    242,
    46,
    70,
    156,
    78,
    62,
    96,
    46,
    53,
    63,
    143,
    34,
    227,
    173,
    155,
    133,
    123,
    117,
    111,
    44,
    125,
    19,
    236,
    134,
    51,
    216,
    206,
    205,
    154,
    153,
    22,
    39,
    37,
    167,
    200,
    201,
    208,
    36,
    142,
    100,
    57,
    212,
    202,
    20,
    60,
    99,
    28,
    158,
    157,
    35,
    226,
    113,
    160,
    159,
    27,
    204,
    202,
    210,
    113,
    225,
    46,
    43,
    202,
    204,
    62,
    76,
    77,
    137,
    123,
    116,
    41,
    38,
    72,
    203,
    129,
    142,
    64,
    98,
    240,
    49,
    102,
    64,
    41,
    73,
    74,
    212,
    216,
    207,
    42,
    74,
    184,
    169,
    170,
    211,
    170,
    149,
    176,
    105,
    66,
    69,
    122,
    6,
    168,
    123,
    147,
    187,
    96,
    77,
    90,
    65,
    55,
    107,
    89,
    90,
    180,
    101,
    100,
    120,
    63,
    105,
    104,
    93,
    137,
    227,
    15,
    86,
    85,
    129,
    102,
    49,
    14,
    87,
    86,
    55,
    8,
    9,
    100,
    47,
    121,
    145,
    23,
    22,
    88,
    89,
    179,
    6,
    122,
    196,
    88,
    95,
    96,
    138,
    172,
    136,
    215,
    58,
    172,
    115,
    48,
    219,
    42,
    80,
    81,
    195,
    3,
    51,
    43,
    146,
    61,
    171,
    175,
    199,
    81,
    82,
    38,
    53,
    46,
    225,
    144,
    163,
    110,
    246,
    33,
    7,
    52,
    65,
    66,
    229,
    228,
    117,
    34,
    127,
    234,
    107,
    108,
    69,
    109,
    108,
    151,
    48,
    64,
    235,
    62,
    78,
    191,
    129,
    209,
    126,
    111,
    35,
    143,
    163,
    161,
    246,
    117,
    123,
    50,
    222,
    65,
    52,
    19,
    125,
    141,
    221,
    55,
    65,
    3,
    195,
    197,
    25,
    7,
    33,
    220,
    237,
    44,
    70,
    71,
    139,
    122,
    193,
    245,
    247,
    130,
    33,
    71,
    21,
    162,
    153,
    158,
    159,
    170,
    169,
    150,
    188,
    174,
    196,
    216,
    186,
    92,
    144,
    160,
    161,
    2,
    97,
    167,
    141,
    125,
    241,
    164,
    167,
    37,
    72,
    38,
    12,
    145,
    159,
    160,
    38,
    82,
    13,
    63,
    68,
    71,
    226,
    35,
    111,
    158,
    153,
    154,
    101,
    50,
    205,
    206,
    92,
    165,
    209,
    198,
    217,
    165,
    167,
    97,
    220,
    115,
    218,
    133,
    112,
    243,
    239,
    238,
    241,
    214,
    135,
    169,
    190,
    173,
    133,
    171,
    208,
    32,
    125,
    44,
    237,
    86,
    87,
    178,
    85,
    86,
    179,
    84,
    85,
    180,
    83,
    84,
    181,
    201,
    83,
    182,
    137,
    93,
    132,
    76,
    62,
    183,
    61,
    76,
    184,
    57,
    61,
    185,
    212,
    57,
    186,
    214,
    207,
    187,
    34,
    143,
    156,
    79,
    239,
    237,
    123,
    137,
    177,
    44,
    1,
    4,
    201,
    194,
    32,
    64,
    102,
    129,
    213,
    215,
    138,
    59,
    166,
    219,
    242,
    99,
    97,
    2,
    94,
    141,
    75,
    59,
    235,
    24,
    110,
    228,
    25,
    130,
    226,
    23,
    24,
    229,
    22,
    23,
    230,
    26,
    22,
    231,
    112,
    26,
    232,
    189,
    190,
    243,
    221,
    56,
    190,
    28,
    56,
    221,
    27,
    28,
    222,
    29,
    27,
    223,
    30,
    29,
    224,
    247,
    30,
    225,
    238,
    79,
    20,
    166,
    59,
    75,
    60,
    75,
    240,
    147,
    177,
    215,
    20,
    79,
    166,
    187,
    147,
    213,
    112,
    233,
    244,
    233,
    128,
    245,
    128,
    114,
    188,
    114,
    217,
    174,
    131,
    115,
    220,
    217,
    198,
    236,
    198,
    131,
    134,
    177,
    132,
    58,
    143,
    35,
    124,
    110,
    163,
    7,
    228,
    110,
    25,
    356,
    389,
    368,
    11,
    302,
    267,
    452,
    350,
    349,
    302,
    303,
    269,
    357,
    343,
    277,
    452,
    453,
    357,
    333,
    332,
    297,
    175,
    152,
    377,
    384,
    398,
    382,
    347,
    348,
    330,
    303,
    304,
    270,
    9,
    336,
    337,
    278,
    279,
    360,
    418,
    262,
    431,
    304,
    408,
    409,
    310,
    415,
    407,
    270,
    409,
    410,
    450,
    348,
    347,
    422,
    430,
    434,
    313,
    314,
    17,
    306,
    307,
    375,
    387,
    388,
    260,
    286,
    414,
    398,
    335,
    406,
    418,
    364,
    367,
    416,
    423,
    358,
    327,
    251,
    284,
    298,
    281,
    5,
    4,
    373,
    374,
    253,
    307,
    320,
    321,
    425,
    427,
    411,
    421,
    313,
    18,
    321,
    405,
    406,
    320,
    404,
    405,
    315,
    16,
    17,
    426,
    425,
    266,
    377,
    400,
    369,
    322,
    391,
    269,
    417,
    465,
    464,
    386,
    257,
    258,
    466,
    260,
    388,
    456,
    399,
    419,
    284,
    332,
    333,
    417,
    285,
    8,
    346,
    340,
    261,
    413,
    441,
    285,
    327,
    460,
    328,
    355,
    371,
    329,
    392,
    439,
    438,
    382,
    341,
    256,
    429,
    420,
    360,
    364,
    394,
    379,
    277,
    343,
    437,
    443,
    444,
    283,
    275,
    440,
    363,
    431,
    262,
    369,
    297,
    338,
    337,
    273,
    375,
    321,
    450,
    451,
    349,
    446,
    342,
    467,
    293,
    334,
    282,
    458,
    461,
    462,
    276,
    353,
    383,
    308,
    324,
    325,
    276,
    300,
    293,
    372,
    345,
    447,
    382,
    398,
    362,
    352,
    345,
    340,
    274,
    1,
    19,
    456,
    248,
    281,
    436,
    427,
    425,
    381,
    256,
    252,
    269,
    391,
    393,
    200,
    199,
    428,
    266,
    330,
    329,
    287,
    273,
    422,
    250,
    462,
    328,
    258,
    286,
    384,
    265,
    353,
    342,
    387,
    259,
    257,
    424,
    431,
    430,
    342,
    353,
    276,
    273,
    335,
    424,
    292,
    325,
    307,
    366,
    447,
    345,
    271,
    303,
    302,
    423,
    266,
    371,
    294,
    455,
    460,
    279,
    278,
    294,
    271,
    272,
    304,
    432,
    434,
    427,
    272,
    407,
    408,
    394,
    430,
    431,
    395,
    369,
    400,
    334,
    333,
    299,
    351,
    417,
    168,
    352,
    280,
    411,
    325,
    319,
    320,
    295,
    296,
    336,
    319,
    403,
    404,
    330,
    348,
    349,
    293,
    298,
    333,
    323,
    454,
    447,
    15,
    16,
    315,
    358,
    429,
    279,
    14,
    15,
    316,
    285,
    336,
    9,
    329,
    349,
    350,
    374,
    380,
    252,
    318,
    402,
    403,
    6,
    197,
    419,
    318,
    319,
    325,
    367,
    364,
    365,
    435,
    367,
    397,
    344,
    438,
    439,
    272,
    271,
    311,
    195,
    5,
    281,
    273,
    287,
    291,
    396,
    428,
    199,
    311,
    271,
    268,
    283,
    444,
    445,
    373,
    254,
    339,
    263,
    466,
    249,
    282,
    334,
    296,
    449,
    347,
    346,
    264,
    447,
    454,
    336,
    296,
    299,
    338,
    10,
    151,
    278,
    439,
    455,
    292,
    407,
    415,
    358,
    371,
    355,
    340,
    345,
    372,
    390,
    249,
    466,
    346,
    347,
    280,
    442,
    443,
    282,
    19,
    94,
    370,
    441,
    442,
    295,
    248,
    419,
    197,
    263,
    255,
    359,
    440,
    275,
    274,
    300,
    383,
    368,
    351,
    412,
    465,
    263,
    467,
    466,
    301,
    368,
    389,
    380,
    374,
    386,
    395,
    378,
    379,
    412,
    351,
    419,
    436,
    426,
    322,
    373,
    390,
    388,
    2,
    164,
    393,
    370,
    462,
    461,
    164,
    0,
    267,
    302,
    11,
    12,
    374,
    373,
    387,
    268,
    12,
    13,
    293,
    300,
    301,
    446,
    261,
    340,
    385,
    384,
    381,
    330,
    266,
    425,
    426,
    423,
    391,
    429,
    355,
    437,
    391,
    327,
    326,
    440,
    457,
    438,
    341,
    382,
    362,
    459,
    457,
    461,
    434,
    430,
    394,
    414,
    463,
    362,
    396,
    369,
    262,
    354,
    461,
    457,
    316,
    403,
    402,
    315,
    404,
    403,
    314,
    405,
    404,
    313,
    406,
    405,
    421,
    418,
    406,
    366,
    401,
    361,
    306,
    408,
    407,
    291,
    409,
    408,
    287,
    410,
    409,
    432,
    436,
    410,
    434,
    416,
    411,
    264,
    368,
    383,
    309,
    438,
    457,
    352,
    376,
    401,
    274,
    275,
    4,
    421,
    428,
    262,
    294,
    327,
    358,
    433,
    416,
    367,
    289,
    455,
    439,
    462,
    370,
    326,
    2,
    326,
    370,
    305,
    460,
    455,
    254,
    449,
    448,
    255,
    261,
    446,
    253,
    450,
    449,
    252,
    451,
    450,
    256,
    452,
    451,
    341,
    453,
    452,
    413,
    464,
    463,
    441,
    413,
    414,
    258,
    442,
    441,
    257,
    443,
    442,
    259,
    444,
    443,
    260,
    445,
    444,
    467,
    342,
    445,
    459,
    458,
    250,
    289,
    392,
    290,
    290,
    328,
    460,
    376,
    433,
    435,
    250,
    290,
    392,
    411,
    416,
    433,
    341,
    463,
    464,
    453,
    464,
    465,
    357,
    465,
    412,
    343,
    412,
    399,
    360,
    363,
    440,
    437,
    399,
    456,
    420,
    456,
    363,
    401,
    435,
    288,
    372,
    383,
    353,
    339,
    255,
    249,
    448,
    261,
    255,
    133,
    243,
    190,
    133,
    155,
    112,
    33,
    246,
    247,
    33,
    130,
    25,
    398,
    384,
    286,
    362,
    398,
    414,
    362,
    463,
    341,
    263,
    359,
    467,
    263,
    249,
    255,
    466,
    467,
    260,
    75,
    60,
    166,
    238,
    239,
    79,
    162,
    127,
    139,
    72,
    11,
    37,
    121,
    232,
    120,
    73,
    72,
    39,
    114,
    128,
    47,
    233,
    232,
    128,
    103,
    104,
    67,
    152,
    175,
    148,
    173,
    157,
    155,
    119,
    118,
    101,
    74,
    73,
    40,
    107,
    9,
    108,
    49,
    48,
    131,
    32,
    194,
    211,
    184,
    74,
    185,
    191,
    80,
    183,
    185,
    40,
    186,
    119,
    230,
    118,
    210,
    202,
    214,
    84,
    83,
    17,
    77,
    76,
    146,
    161,
    160,
    30,
    190,
    56,
    173,
    182,
    106,
    194,
    138,
    135,
    192,
    129,
    203,
    98,
    54,
    21,
    68,
    5,
    51,
    4,
    145,
    144,
    23,
    90,
    77,
    91,
    207,
    205,
    187,
    83,
    201,
    18,
    181,
    91,
    182,
    180,
    90,
    181,
    16,
    85,
    17,
    205,
    206,
    36,
    176,
    148,
    140,
    165,
    92,
    39,
    245,
    193,
    244,
    27,
    159,
    28,
    30,
    247,
    161,
    174,
    236,
    196,
    103,
    54,
    104,
    55,
    193,
    8,
    111,
    117,
    31,
    221,
    189,
    55,
    240,
    98,
    99,
    142,
    126,
    100,
    219,
    166,
    218,
    112,
    155,
    26,
    198,
    209,
    131,
    169,
    135,
    150,
    114,
    47,
    217,
    224,
    223,
    53,
    220,
    45,
    134,
    32,
    211,
    140,
    109,
    67,
    108,
    146,
    43,
    91,
    231,
    230,
    120,
    113,
    226,
    247,
    105,
    63,
    52,
    241,
    238,
    242,
    124,
    46,
    156,
    95,
    78,
    96,
    70,
    46,
    63,
    116,
    143,
    227,
    116,
    123,
    111,
    1,
    44,
    19,
    3,
    236,
    51,
    207,
    216,
    205,
    26,
    154,
    22,
    165,
    39,
    167,
    199,
    200,
    208,
    101,
    36,
    100,
    43,
    57,
    202,
    242,
    20,
    99,
    56,
    28,
    157,
    124,
    35,
    113,
    29,
    160,
    27,
    211,
    204,
    210,
    124,
    113,
    46,
    106,
    43,
    204,
    96,
    62,
    77,
    227,
    137,
    116,
    73,
    41,
    72,
    36,
    203,
    142,
    235,
    64,
    240,
    48,
    49,
    64,
    42,
    41,
    74,
    214,
    212,
    207,
    183,
    42,
    184,
    210,
    169,
    211,
    140,
    170,
    176,
    104,
    105,
    69,
    193,
    122,
    168,
    50,
    123,
    187,
    89,
    96,
    90,
    66,
    65,
    107,
    179,
    89,
    180,
    119,
    101,
    120,
    68,
    63,
    104,
    234,
    93,
    227,
    16,
    15,
    85,
    209,
    129,
    49,
    15,
    14,
    86,
    107,
    55,
    9,
    120,
    100,
    121,
    153,
    145,
    22,
    178,
    88,
    179,
    197,
    6,
    196,
    89,
    88,
    96,
    135,
    138,
    136,
    138,
    215,
    172,
    218,
    115,
    219,
    41,
    42,
    81,
    5,
    195,
    51,
    57,
    43,
    61,
    208,
    171,
    199,
    41,
    81,
    38,
    224,
    53,
    225,
    24,
    144,
    110,
    105,
    52,
    66,
    118,
    229,
    117,
    227,
    34,
    234,
    66,
    107,
    69,
    10,
    109,
    151,
    219,
    48,
    235,
    183,
    62,
    191,
    142,
    129,
    126,
    116,
    111,
    143,
    7,
    163,
    246,
    118,
    117,
    50,
    223,
    222,
    52,
    94,
    19,
    141,
    222,
    221,
    65,
    196,
    3,
    197,
    45,
    220,
    44,
    156,
    70,
    139,
    188,
    122,
    245,
    139,
    71,
    162,
    145,
    153,
    159,
    149,
    170,
    150,
    122,
    188,
    196,
    206,
    216,
    92,
    163,
    144,
    161,
    164,
    2,
    167,
    242,
    141,
    241,
    0,
    164,
    37,
    11,
    72,
    12,
    144,
    145,
    160,
    12,
    38,
    13,
    70,
    63,
    71,
    31,
    226,
    111,
    157,
    158,
    154,
    36,
    101,
    205,
    203,
    206,
    165,
    126,
    209,
    217,
    98,
    165,
    97,
    237,
    220,
    218,
    237,
    239,
    241,
    210,
    214,
    169,
    140,
    171,
    32,
    241,
    125,
    237,
    179,
    86,
    178,
    180,
    85,
    179,
    181,
    84,
    180,
    182,
    83,
    181,
    194,
    201,
    182,
    177,
    137,
    132,
    184,
    76,
    183,
    185,
    61,
    184,
    186,
    57,
    185,
    216,
    212,
    186,
    192,
    214,
    187,
    139,
    34,
    156,
    218,
    79,
    237,
    147,
    123,
    177,
    45,
    44,
    4,
    208,
    201,
    32,
    98,
    64,
    129,
    192,
    213,
    138,
    235,
    59,
    219,
    141,
    242,
    97,
    97,
    2,
    141,
    240,
    75,
    235,
    229,
    24,
    228,
    31,
    25,
    226,
    230,
    23,
    229,
    231,
    22,
    230,
    232,
    26,
    231,
    233,
    112,
    232,
    244,
    189,
    243,
    189,
    221,
    190,
    222,
    28,
    221,
    223,
    27,
    222,
    224,
    29,
    223,
    225,
    30,
    224,
    113,
    247,
    225,
    99,
    60,
    240,
    213,
    147,
    215,
    60,
    20,
    166,
    192,
    187,
    213,
    243,
    112,
    244,
    244,
    233,
    245,
    245,
    128,
    188,
    188,
    114,
    174,
    134,
    131,
    220,
    174,
    217,
    236,
    236,
    198,
    134,
    215,
    177,
    58,
    156,
    143,
    124,
    25,
    110,
    7,
    31,
    228,
    25,
    264,
    356,
    368,
    0,
    11,
    267,
    451,
    452,
    349,
    267,
    302,
    269,
    350,
    357,
    277,
    350,
    452,
    357,
    299,
    333,
    297,
    396,
    175,
    377,
    381,
    384,
    382,
    280,
    347,
    330,
    269,
    303,
    270,
    151,
    9,
    337,
    344,
    278,
    360,
    424,
    418,
    431,
    270,
    304,
    409,
    272,
    310,
    407,
    322,
    270,
    410,
    449,
    450,
    347,
    432,
    422,
    434,
    18,
    313,
    17,
    291,
    306,
    375,
    259,
    387,
    260,
    424,
    335,
    418,
    434,
    364,
    416,
    391,
    423,
    327,
    301,
    251,
    298,
    275,
    281,
    4,
    254,
    373,
    253,
    375,
    307,
    321,
    280,
    425,
    411,
    200,
    421,
    18,
    335,
    321,
    406,
    321,
    320,
    405,
    314,
    315,
    17,
    423,
    426,
    266,
    396,
    377,
    369,
    270,
    322,
    269,
    413,
    417,
    464,
    385,
    386,
    258,
    248,
    456,
    419,
    298,
    284,
    333,
    168,
    417,
    8,
    448,
    346,
    261,
    417,
    413,
    285,
    326,
    327,
    328,
    277,
    355,
    329,
    309,
    392,
    438,
    381,
    382,
    256,
    279,
    429,
    360,
    365,
    364,
    379,
    355,
    277,
    437,
    282,
    443,
    283,
    281,
    275,
    363,
    395,
    431,
    369,
    299,
    297,
    337,
    335,
    273,
    321,
    348,
    450,
    349,
    359,
    446,
    467,
    283,
    293,
    282,
    250,
    458,
    462,
    300,
    276,
    383,
    292,
    308,
    325,
    283,
    276,
    293,
    264,
    372,
    447,
    346,
    352,
    340,
    354,
    274,
    19,
    363,
    456,
    281,
    426,
    436,
    425,
    380,
    381,
    252,
    267,
    269,
    393,
    421,
    200,
    428,
    371,
    266,
    329,
    432,
    287,
    422,
    290,
    250,
    328,
    385,
    258,
    384,
    446,
    265,
    342,
    386,
    387,
    257,
    422,
    424,
    430,
    445,
    342,
    276,
    422,
    273,
    424,
    306,
    292,
    307,
    352,
    366,
    345,
    268,
    271,
    302,
    358,
    423,
    371,
    327,
    294,
    460,
    331,
    279,
    294,
    303,
    271,
    304,
    436,
    432,
    427,
    304,
    272,
    408,
    395,
    394,
    431,
    378,
    395,
    400,
    296,
    334,
    299,
    6,
    351,
    168,
    376,
    352,
    411,
    307,
    325,
    320,
    285,
    295,
    336,
    320,
    319,
    404,
    329,
    330,
    349,
    334,
    293,
    333,
    366,
    323,
    447,
    316,
    15,
    315,
    331,
    358,
    279,
    317,
    14,
    316,
    8,
    285,
    9,
    277,
    329,
    350,
    253,
    374,
    252,
    319,
    318,
    403,
    351,
    6,
    419,
    324,
    318,
    325,
    397,
    367,
    365,
    288,
    435,
    397,
    278,
    344,
    439,
    310,
    272,
    311,
    248,
    195,
    281,
    375,
    273,
    291,
    175,
    396,
    199,
    312,
    311,
    268,
    276,
    283,
    445,
    390,
    373,
    339,
    295,
    282,
    296,
    448,
    449,
    346,
    356,
    264,
    454,
    337,
    336,
    299,
    337,
    338,
    151,
    294,
    278,
    455,
    308,
    292,
    415,
    429,
    358,
    355,
    265,
    340,
    372,
    388,
    390,
    466,
    352,
    346,
    280,
    295,
    442,
    282,
    354,
    19,
    370,
    285,
    441,
    295,
    195,
    248,
    197,
    457,
    440,
    274,
    301,
    300,
    368,
    417,
    351,
    465,
    251,
    301,
    389,
    385,
    380,
    386,
    394,
    395,
    379,
    399,
    412,
    419,
    410,
    436,
    322,
    387,
    373,
    388,
    326,
    2,
    393,
    354,
    370,
    461,
    393,
    164,
    267,
    268,
    302,
    12,
    386,
    374,
    387,
    312,
    268,
    13,
    298,
    293,
    301,
    265,
    446,
    340,
    380,
    385,
    381,
    280,
    330,
    425,
    322,
    426,
    391,
    420,
    429,
    437,
    393,
    391,
    326,
    344,
    440,
    438,
    458,
    459,
    461,
    364,
    434,
    394,
    428,
    396,
    262,
    274,
    354,
    457,
    317,
    316,
    402,
    316,
    315,
    403,
    315,
    314,
    404,
    314,
    313,
    405,
    313,
    421,
    406,
    323,
    366,
    361,
    292,
    306,
    407,
    306,
    291,
    408,
    291,
    287,
    409,
    287,
    432,
    410,
    427,
    434,
    411,
    372,
    264,
    383,
    459,
    309,
    457,
    366,
    352,
    401,
    1,
    274,
    4,
    418,
    421,
    262,
    331,
    294,
    358,
    435,
    433,
    367,
    392,
    289,
    439,
    328,
    462,
    326,
    94,
    2,
    370,
    289,
    305,
    455,
    339,
    254,
    448,
    359,
    255,
    446,
    254,
    253,
    449,
    253,
    252,
    450,
    252,
    256,
    451,
    256,
    341,
    452,
    414,
    413,
    463,
    286,
    441,
    414,
    286,
    258,
    441,
    258,
    257,
    442,
    257,
    259,
    443,
    259,
    260,
    444,
    260,
    467,
    445,
    309,
    459,
    250,
    305,
    289,
    290,
    305,
    290,
    460,
    401,
    376,
    435,
    309,
    250,
    392,
    376,
    411,
    433,
    453,
    341,
    464,
    357,
    453,
    465,
    343,
    357,
    412,
    437,
    343,
    399,
    344,
    360,
    440,
    420,
    437,
    456,
    360,
    420,
    363,
    361,
    401,
    288,
    265,
    372,
    353,
    390,
    339,
    249,
    339,
    448,
    255
  ];

  // dist/components/shared/util.js
  function isiOS() {
    return /iPhone|iPad|iPod/i.test(navigator.userAgent);
  }
  function isAndroid() {
    return /Android/i.test(navigator.userAgent);
  }
  function isMobile2() {
    return isAndroid() || isiOS();
  }
  function distance(a2, b2) {
    return Math.sqrt(Math.pow(a2[0] - b2[0], 2) + Math.pow(a2[1] - b2[1], 2));
  }
  function drawPath(ctx, points, closePath) {
    const region = new Path2D();
    region.moveTo(points[0][0], points[0][1]);
    for (let i2 = 1; i2 < points.length; i2++) {
      const point = points[i2];
      region.lineTo(point[0], point[1]);
    }
    if (closePath) {
      region.closePath();
    }
    ctx.stroke(region);
  }
  async function drawResults(ctx, faces, triangulateMesh, boundingBox) {
    faces.forEach((face) => {
      const keypoints = face.keypoints.map((keypoint) => [
        keypoint.x,
        keypoint.y
      ]);
      if (boundingBox) {
        ctx.strokeStyle = BLUE_WATCH_SURE;
        ctx.lineWidth = 1;
        const box = face.box;
        drawPath(ctx, [
          [box.xMin, box.yMin],
          [box.xMax, box.yMin],
          [box.xMax, box.yMax],
          [box.xMin, box.yMax]
        ], true);
      }
      if (triangulateMesh) {
        ctx.strokeStyle = WHITE;
        ctx.lineWidth = 0.5;
        for (let i2 = 0; i2 < TRIANGULATION.length / 3; i2++) {
          const points = [
            TRIANGULATION[i2 * 3],
            TRIANGULATION[i2 * 3 + 1],
            TRIANGULATION[i2 * 3 + 2]
          ].map((index) => keypoints[index]);
          drawPath(ctx, points, true);
        }
      } else {
        ctx.fillStyle = GREEN;
        for (let i2 = 0; i2 < NUM_KEYPOINTS; i2++) {
          const x2 = keypoints[i2][0];
          const y2 = keypoints[i2][1];
          ctx.beginPath();
          ctx.arc(x2, y2, 1, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
      if (keypoints.length > NUM_KEYPOINTS) {
        ctx.strokeStyle = BLUE_WATCH_SURE;
        ctx.lineWidth = 1;
        const leftCenter = keypoints[NUM_KEYPOINTS];
        const leftDiameterY = distance(keypoints[NUM_KEYPOINTS + 4], keypoints[NUM_KEYPOINTS + 2]);
        const leftDiameterX = distance(keypoints[NUM_KEYPOINTS + 3], keypoints[NUM_KEYPOINTS + 1]);
        ctx.beginPath();
        ctx.ellipse(leftCenter[0], leftCenter[1], leftDiameterX / 2, leftDiameterY / 2, 0, 0, 2 * Math.PI);
        ctx.stroke();
        if (keypoints.length > NUM_KEYPOINTS + NUM_IRIS_KEYPOINTS) {
          const rightCenter = keypoints[NUM_KEYPOINTS + NUM_IRIS_KEYPOINTS];
          const rightDiameterY = distance(keypoints[NUM_KEYPOINTS + NUM_IRIS_KEYPOINTS + 2], keypoints[NUM_KEYPOINTS + NUM_IRIS_KEYPOINTS + 4]);
          const rightDiameterX = distance(keypoints[NUM_KEYPOINTS + NUM_IRIS_KEYPOINTS + 3], keypoints[NUM_KEYPOINTS + NUM_IRIS_KEYPOINTS + 1]);
          ctx.beginPath();
          ctx.ellipse(rightCenter[0], rightCenter[1], rightDiameterX / 2, rightDiameterY / 2, 0, 0, 2 * Math.PI);
          ctx.stroke();
        }
      }
      const contours = Zt2.getKeypointIndexByContour(Yt2.MediaPipeFaceMesh);
      for (const [label, contour] of Object.entries(contours)) {
        ctx.strokeStyle = WHITE;
        ctx.lineWidth = 1;
        const path = contour.map((index) => keypoints[index]);
        if (path.every((value) => value != void 0)) {
          drawPath(ctx, path, false);
        }
      }
    });
  }

  // dist/components/camera.js
  var Camera = class {
    constructor(video, canvas) {
      __publicField(this, "video");
      __publicField(this, "canvas");
      __publicField(this, "ctx");
      var _a2;
      this.video = video;
      this.canvas = canvas;
      this.ctx = (_a2 = this.canvas) == null ? void 0 : _a2.getContext("2d");
    }
    /**
     * Initiate a Camera instance and wait for the camera stream to be ready.
     * @param cameraParam From app `STATE.camera`.
     */
    static async setupCamera(cameraParam, video, canvas) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.log("notSupport");
        throw new Error("Browser API navigator.mediaDevices.getUserMedia not available");
      }
      const { targetFPS, sizeOption } = cameraParam;
      const $size = VIDEO_SIZE["640 X 480"];
      const videoConfig = {
        audio: false,
        video: {
          facingMode: "user",
          // Only setting the video to a specified size for large screen, on
          // mobile devices accept the default size.
          width: isMobile2() ? VIDEO_SIZE["360 X 270"].width : $size.width,
          height: isMobile2() ? VIDEO_SIZE["360 X 270"].height : $size.height,
          frameRate: {
            ideal: targetFPS
          }
        }
      };
      const camera2 = new Camera(video, canvas);
      const videoWidth = camera2.video.videoWidth;
      const videoHeight = camera2.video.videoHeight;
      camera2.video.width = videoWidth;
      camera2.video.height = videoHeight;
      if (camera2.canvas && camera2.ctx) {
        camera2.canvas.width = videoWidth;
        camera2.canvas.height = videoHeight;
        const canvasContainer = document.querySelector(".canvas-wrapper");
        camera2.ctx.translate(camera2.video.videoWidth, 0);
        camera2.ctx.scale(-1, 1);
      }
      return camera2;
    }
    drawCtx() {
      if (!this.ctx) {
        return;
      }
      this.ctx.drawImage(this.video, 0, 0, this.video.videoWidth, this.video.videoHeight);
    }
    drawResults(faces, triangulateMesh, boundingBox) {
      if (!this.ctx) {
        return;
      }
      drawResults(this.ctx, faces, triangulateMesh, boundingBox);
    }
  };

  // dist/components/indices/MediaPipeIndexes.js
  var HEAD_OX_AXIS = [123, 352];
  var HEAD_OY_AXIS = [199, 151];
  var RIGHT_EYE_VERTICAL = [159, 145];
  var LEFT_EYE_VERTICAL = [386, 374];
  var EYEBROWS = [107, 336];
  var NOSE_BRIDGE = [168];
  var MOUTH_HEIGHT = [11, 16];
  var MOUTH_WIDTH = [61, 291];

  // dist/components/indices/CutomMath.js
  var Vector = class {
    constructor(x2, y2, z3) {
      __publicField(this, "x");
      __publicField(this, "y");
      __publicField(this, "z");
      this.x = x2;
      this.y = y2;
      this.z = z3;
    }
    static fromKeyPoint(keypoint) {
      if (keypoint.z === void 0)
        throw new Error("Only 3D vectors allowed");
      return new Vector(keypoint.x, keypoint.y, keypoint.z);
    }
    minus(other) {
      return new Vector(this.x - other.x, this.y - other.y, this.z - other.z);
    }
    plus(other) {
      return new Vector(this.x + other.x, this.y + other.y, this.z + other.z);
    }
    dot(other) {
      return this.x * other.x + this.y * other.y + this.z * other.z;
    }
    getLength() {
      return Math.sqrt(this.dot(this));
    }
  };
  function getAngle(lhs, rhs) {
    const cos3 = lhs.dot(rhs) / (lhs.getLength() * rhs.getLength());
    return Math.acos(cos3) * 180 / Math.PI;
  }
  function clamp2(num, min3, max3) {
    return Math.min(Math.max(num, min3), max3);
  }

  // dist/components/indices/IndexesController.js
  var IndexesController = class {
    constructor() {
      __publicField(this, "previousLeftEyeX", 0);
      __publicField(this, "previousLeftEyeY", 0);
      __publicField(this, "previousRightEyeX", 0);
      __publicField(this, "previousRightEyeY", 0);
      __publicField(this, "distanceInitial", false);
      __publicField(this, "initialZ", 0);
      __publicField(this, "initialX", 0);
      __publicField(this, "initialY", 0);
      __publicField(this, "initialAngleZ", 0);
      __publicField(this, "initialAngleX", 0);
      __publicField(this, "initialAngleY", 0);
      __publicField(this, "previousEyeAngle", 0);
      __publicField(this, "initialAngle", false);
      __publicField(this, "lastCoordsDistance", false);
      __publicField(this, "currentCoordsDistance", false);
      __publicField(this, "distanceCurrent", 0);
      __publicField(this, "distanceProcent", 0);
      __publicField(this, "everySecondAttention", true);
      __publicField(this, "tiredness", 0);
      __publicField(this, "happiness", 0);
      __publicField(this, "amazement", 0);
      __publicField(this, "eyesClosed", false);
      __publicField(this, "eyesClosedFrames", 0);
      __publicField(this, "eyesClosedTime", /* @__PURE__ */ new Date());
      __publicField(this, "noseCoordsInitial", 0);
      __publicField(this, "blinkTime", 0);
      __publicField(this, "blinks", 0);
      __publicField(this, "blinked", false);
      __publicField(this, "isMouthOpened", false);
      __publicField(this, "yawns", 0);
      __publicField(this, "headHeight", 0);
      __publicField(this, "initialHeadHeight", null);
      __publicField(this, "zeroAttnetionCounter", 0);
      __publicField(this, "zeroAttentionTime", 0);
      __publicField(this, "lastAttentioLostTime", /* @__PURE__ */ new Date());
      __publicField(this, "isCountingLostAttentionPeriod", false);
      __publicField(this, "lastMinuteIndexes", []);
      __publicField(this, "lastSecondIndexes", []);
      __publicField(this, "lastMinuteBlinks", 0);
      __publicField(this, "CONSTANTS", {
        DEFAULT: {
          BLINKS_IN_MINUTE: 10,
          BLINKS_TIME: 200,
          SMILE_SIZE: 60,
          EYEBROWS_HEIGHT: 25
        },
        MAX: {
          SMILE_SIZE: 70,
          EYEBROWS_HEIGHT: 30
        }
      });
    }
    calculateIndexes(face, values) {
      if (face === void 0) {
        this.handleNotAtScreen();
        const indexPackage2 = {
          attention: 0,
          happiness: 0,
          tiredness: 0,
          amazement: 0,
          involvement: 0,
          presence: false,
          statistic: {
            headAngleOX: -1,
            headAngleOY: -1,
            eyesClosedFrames: this.eyesClosedFrames,
            blinks: this.blinks,
            blinkTime: this.blinkTime,
            eyebrowsHeight: {
              left: -1,
              right: -1
            },
            yawns: this.yawns,
            smile: -1,
            attentionLostTimes: this.zeroAttnetionCounter,
            attentionLostMillieseconds: this.zeroAttentionTime,
            everySecondAttention: this.everySecondAttention
          }
        };
        this.updateCache(indexPackage2);
        return indexPackage2;
      }
      const headAngleOX = this.calculateHeadOXAngle(face);
      const headAngleOY = this.calculateHeadOYAngle(face);
      let eyebrowsHeight = this.calculateEyebrowsHeight(face);
      let smile = this.calculateSmile(face);
      let eyesHeight = this.calculateEyesHeight(face);
      let attentionClasses;
      if (values[0] > values[1]) {
        attentionClasses = true;
      }
      if (values[0] < values[1]) {
        attentionClasses = false;
      }
      let attention = (this.eyesClosedFrames < 30 || !this.eyesClosed) && (this.eyesClosedFrames < 30 && attentionClasses) ? 1 : 0;
      this.handleAttention(attention);
      if (this.initialHeadHeight !== null) {
        const scaleCoefficient = this.headHeight / this.initialHeadHeight;
        this.CONSTANTS.DEFAULT.SMILE_SIZE = this.initialHeadHeight * 0.4;
        this.CONSTANTS.MAX.SMILE_SIZE = this.initialHeadHeight * 0.45;
        this.CONSTANTS.DEFAULT.EYEBROWS_HEIGHT = this.initialHeadHeight * 0.18;
        this.CONSTANTS.MAX.EYEBROWS_HEIGHT = this.initialHeadHeight * 0.22;
        smile = smile / scaleCoefficient;
        eyebrowsHeight = {
          left: eyebrowsHeight.left / scaleCoefficient,
          right: eyebrowsHeight.right / scaleCoefficient
        };
        eyesHeight = {
          left: eyesHeight.left / scaleCoefficient,
          right: eyesHeight.right / scaleCoefficient
        };
      }
      this.calculateAmazement(eyebrowsHeight);
      this.calculateHappiness(smile);
      this.handleEyes(eyesHeight);
      this.handleYawn(face);
      if (attention === 0) {
        this.happiness = 0;
        this.amazement = 0;
      }
      const indexPackage = {
        attention,
        happiness: this.happiness,
        tiredness: this.tiredness,
        amazement: this.amazement,
        involvement: 0,
        presence: attention === 1 ? true : false,
        statistic: {
          headAngleOX,
          headAngleOY,
          eyesClosedFrames: this.eyesClosedFrames,
          blinks: this.blinks,
          blinkTime: this.blinkTime,
          eyebrowsHeight,
          yawns: this.yawns,
          smile,
          attentionLostTimes: this.zeroAttnetionCounter,
          attentionLostMillieseconds: this.zeroAttentionTime,
          everySecondAttention: this.everySecondAttention
        }
      };
      this.updateCache(indexPackage);
      return indexPackage;
    }
    calculateHeadOXAngle(face) {
      const rightCheekPosition = Vector.fromKeyPoint(face.keypoints[HEAD_OX_AXIS[0]]);
      const leftCheekPosition = Vector.fromKeyPoint(face.keypoints[HEAD_OX_AXIS[1]]);
      const headVectorOX = leftCheekPosition.minus(rightCheekPosition);
      headVectorOX.y = 0;
      const normalVectorOX = new Vector(1, 0, 0);
      return getAngle(headVectorOX, normalVectorOX);
    }
    calculateEyesHeight(face) {
      const leftEyeUpPosition = Vector.fromKeyPoint(face.keypoints[LEFT_EYE_VERTICAL[0]]);
      const leftEyeDownPosition = Vector.fromKeyPoint(face.keypoints[LEFT_EYE_VERTICAL[1]]);
      const rightEyeUpPosition = Vector.fromKeyPoint(face.keypoints[RIGHT_EYE_VERTICAL[0]]);
      const rightEyeDownPosition = Vector.fromKeyPoint(face.keypoints[RIGHT_EYE_VERTICAL[1]]);
      const leftEyeVerticalVector = leftEyeUpPosition.minus(leftEyeDownPosition);
      const rightEyeVerticalVector = rightEyeUpPosition.minus(rightEyeDownPosition);
      const leftEyeHeight = leftEyeVerticalVector.getLength();
      const rightEyeHeight = rightEyeVerticalVector.getLength();
      return {
        left: leftEyeHeight,
        right: rightEyeHeight
      };
    }
    handleEyes(eyesHeight) {
      const { left, right } = eyesHeight;
      if ((left < 5 || right < 5) && !this.eyesClosed) {
        this.eyesClosed = true;
        this.eyesClosedFrames = 0;
        this.eyesClosedTime = /* @__PURE__ */ new Date();
      } else if ((left < 5 || right < 5) && this.eyesClosed) {
        this.eyesClosedFrames++;
      } else if (this.eyesClosed) {
        this.eyesClosed = false;
        if (this.eyesClosedFrames < 15) {
          this.blinks++;
          this.blinkTime = (/* @__PURE__ */ new Date()).getTime() - this.eyesClosedTime.getTime();
          this.blinked = true;
        }
      }
    }
    calculateEyebrowsHeight(face) {
      const rightEyebrow = Vector.fromKeyPoint(face.keypoints[EYEBROWS[0]]);
      const leftEyebrow = Vector.fromKeyPoint(face.keypoints[EYEBROWS[1]]);
      const noseBridge = Vector.fromKeyPoint(face.keypoints[NOSE_BRIDGE[0]]);
      const leftToNoseBridge = leftEyebrow.minus(noseBridge);
      const rightToNoseBridge = rightEyebrow.minus(noseBridge);
      return {
        left: leftToNoseBridge.getLength(),
        right: rightToNoseBridge.getLength()
      };
    }
    handleYawn(face) {
      const mouthUp = Vector.fromKeyPoint(face.keypoints[MOUTH_HEIGHT[0]]);
      const mouthDown = Vector.fromKeyPoint(face.keypoints[MOUTH_HEIGHT[1]]);
      const mouthHeight = mouthUp.minus(mouthDown).getLength();
      if (mouthHeight > 30 && !this.isMouthOpened) {
        this.isMouthOpened = true;
      }
      if (mouthHeight <= 30 && this.isMouthOpened) {
        this.yawns++;
        this.isMouthOpened = false;
      }
    }
    calculateSmile(face) {
      const right = Vector.fromKeyPoint(face.keypoints[MOUTH_WIDTH[0]]);
      const left = Vector.fromKeyPoint(face.keypoints[MOUTH_WIDTH[1]]);
      return right.minus(left).getLength();
    }
    handleAttention(attention) {
      if (this.blinked) {
        this.isCountingLostAttentionPeriod = false;
        this.blinked = false;
        return;
      }
      if (attention === 0 && !this.isCountingLostAttentionPeriod) {
        this.lastAttentioLostTime = /* @__PURE__ */ new Date();
        this.isCountingLostAttentionPeriod = true;
      }
      if (attention === 1 && this.isCountingLostAttentionPeriod) {
        this.isCountingLostAttentionPeriod = false;
        this.zeroAttentionTime += (/* @__PURE__ */ new Date()).getTime() - this.lastAttentioLostTime.getTime();
        this.zeroAttnetionCounter++;
      }
    }
    handleNotAtScreen() {
      const attention = 0;
      this.blinked = false;
      this.handleAttention(attention);
    }
    calculateTiredness() {
      const blinks = this.lastMinuteIndexes[this.lastMinuteIndexes.length - 1].statistic.blinks - this.lastMinuteBlinks;
      this.lastMinuteBlinks += blinks;
      const blinksTime = this.lastMinuteIndexes.reduce((accum, current) => accum + current.statistic.blinkTime, 0) / this.lastMinuteIndexes.length;
      let normalizedTiredness = 0.2 * ((blinks - this.CONSTANTS.DEFAULT.BLINKS_IN_MINUTE) / this.CONSTANTS.DEFAULT.BLINKS_IN_MINUTE) + 0.8 * ((blinksTime - this.CONSTANTS.DEFAULT.BLINKS_TIME) / this.CONSTANTS.DEFAULT.BLINKS_TIME);
      normalizedTiredness *= 100;
      normalizedTiredness = clamp2(normalizedTiredness, 0, 100);
      this.tiredness = Math.round(normalizedTiredness / 20);
    }
    calculateHappiness(smileSize) {
      const offsetSmile = smileSize - this.CONSTANTS.DEFAULT.SMILE_SIZE;
      const offsetMaxSmile = this.CONSTANTS.MAX.SMILE_SIZE - this.CONSTANTS.DEFAULT.SMILE_SIZE;
      this.happiness = Math.round(offsetSmile / offsetMaxSmile * 100);
      this.happiness = clamp2(this.happiness, 0, 100);
    }
    calculateAmazement(eyebrowsHeight) {
      const { left, right } = eyebrowsHeight;
      const chosen = Math.max(left, right);
      const offsetEyebrowsHeight = chosen - this.CONSTANTS.DEFAULT.EYEBROWS_HEIGHT;
      const offsetMaxEyebrowsHeight = this.CONSTANTS.MAX.EYEBROWS_HEIGHT - this.CONSTANTS.DEFAULT.EYEBROWS_HEIGHT;
      this.amazement = Math.round(offsetEyebrowsHeight / offsetMaxEyebrowsHeight * 100);
      this.amazement = clamp2(this.amazement, 0, 100);
    }
    updateCache(index) {
      this.lastSecondIndexes.push(index);
      this.lastMinuteIndexes.push(index);
    }
    calculateHeadOYAngle(face) {
      const top = Vector.fromKeyPoint(face.keypoints[HEAD_OY_AXIS[1]]);
      const bottom = Vector.fromKeyPoint(face.keypoints[HEAD_OY_AXIS[0]]);
      const headVectorOY = top.minus(bottom);
      const normalOY = new Vector(0, 1, 0);
      this.headHeight = headVectorOY.getLength();
      if (this.initialHeadHeight === null)
        this.initialHeadHeight = this.headHeight;
      headVectorOY.x = 0;
      return 180 - getAngle(headVectorOY, normalOY);
    }
    calculateAttention() {
      const attentionSum = this.lastSecondIndexes.reduce((accum, current) => accum + current.attention, 0);
      if (attentionSum / this.lastSecondIndexes.length > 0.5) {
        this.everySecondAttention = true;
      } else {
        this.everySecondAttention = false;
      }
    }
    //TODO: убрать лишние данные
    exportingIndex() {
      return {
        video_sec: 1,
        video_id: 1,
        attention: this.everySecondAttention,
        happiness: this.happiness,
        tiredness: this.tiredness,
        amazement: this.amazement,
        involvement: 0,
        uuid: "123e4567-e89b-12d3-a456-426655440000",
        time: /* @__PURE__ */ new Date()
      };
    }
    handleSecond() {
      this.calculateAttention();
      this.lastSecondIndexes = [];
      return this.exportingIndex();
    }
    handleMinute() {
      this.calculateTiredness();
      this.lastMinuteIndexes = [];
    }
    calculateFaceCameraDistance(face) {
      this.currentCoordsDistance = face.keypoints[4];
      let distance2 = Math.sqrt(Math.pow(this.currentCoordsDistance.x - 0, 2) + Math.pow(this.currentCoordsDistance.y - 0, 2) + Math.pow(this.currentCoordsDistance.z - 0, 2));
      if (this.currentCoordsDistance.x < 0) {
        distance2 = -distance2;
      }
      console.log(this.currentCoordsDistance);
      console.log(distance2);
    }
    calculateAngles(face, dot3) {
      if (!this.initialX && !this.initialZ && !this.initialY) {
        this.initialX = face.keypoints[Number(dot3)].x;
        this.initialY = face.keypoints[Number(dot3)].y;
        this.initialZ = face.keypoints[Number(dot3)].z;
        return;
      }
      const endX = face.keypoints[Number(dot3)].x;
      const endY = face.keypoints[Number(dot3)].y;
      const endZ = face.keypoints[Number(dot3)].z;
      const dx = endX - this.initialX;
      const dy = endY - this.initialY;
      const dz = endZ - this.initialZ;
      const angle = Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);
      const axis = [dy / angle, -dx / angle, 0];
      const rad = angle * Math.PI / 180;
      const cos3 = Math.cos(rad);
      const sin3 = Math.sin(rad);
      const t3 = 1 - cos3;
      const R3 = [
        [cos3 + axis[0] ** 2 * t3, axis[0] * axis[1] * t3 - axis[2] * sin3, axis[0] * axis[2] * t3 + axis[1] * sin3],
        [axis[0] * axis[1] * t3 + axis[2] * sin3, cos3 + axis[1] ** 2 * t3, axis[1] * axis[2] * t3 - axis[0] * sin3],
        [axis[0] * axis[2] * t3 - axis[1] * sin3, axis[1] * axis[2] * t3 + axis[0] * sin3, cos3 + axis[2] ** 2 * t3]
      ];
      const angleX = Math.atan2(R3[1][2], R3[2][2]) * 180 / Math.PI;
      const angleY = Math.atan2(-R3[0][2], Math.sqrt(R3[1][2] ** 2 + R3[2][2] ** 2)) * 180 / Math.PI;
      const angleZ = Math.atan2(R3[0][1], R3[0][0]) * 180 / Math.PI;
      const dxy = Math.sqrt(dx ** 2 + dy ** 2);
      if (!this.initialAngleX && !this.initialAngleY && !this.initialAngleZ) {
        this.initialAngleX = angleX;
        this.initialAngleY = angleY;
        this.initialAngleZ = angleZ;
      }
      return { angleX, angleY, angleZ, dxy: angleX / dxy };
    }
    eyeNa(face) {
      const leftEye = face.keypoints[159];
      const rightEye = face.keypoints[386];
      const gazeDirection = [rightEye.x - leftEye.x, rightEye.y - leftEye.y, rightEye.z - leftEye.z];
    }
    centerPrediction(face) {
      const nose = face.keypoints[4];
      const leftEye = face.keypoints[159];
      const rightEye = face.keypoints[386];
      const centerX = (leftEye.x + rightEye.x) / 2;
      const centerY = (leftEye.y + rightEye.y) / 2;
      const angle = Math.atan2(centerY - nose.y, centerX - nose.x);
      if (!this.initialAngle) {
        this.initialAngle = angle;
      }
      return angle;
    }
    // testSize(face) {
    //     // Определение угла между линиями, проведенными через центры глаз
    //     const eyeCenterX = ((face.keypoints[33].x + face.keypoints[263].x) / 2);
    //     const eyeCenterY = ((face.keypoints[33].y + face.keypoints[263].y) / 2);
    //     const eyevecX = eyeCenterX - ((face.keypoints[159].x + face.keypoints[386].x) / 2);
    //     const eyevecY = eyeCenterY - ((face.keypoints[159].y + face.keypoints[386].y) / 2);
    //     let eyeAngle = Math.atan2(-eyevecY, eyevecX) * (180 / Math.PI);
    //     // Расчет угла поворота головы
    //     const leftEarX = leftEar.x;
    //     const leftEarY = leftEar.y;
    //     const rightEarX = rightEar.x;
    //     const rightEarY = rightEar.y;
    //     const earToEarLength = Math.sqrt(Math.pow(rightEarX - leftEarX, 2) + Math.pow(rightEarY - leftEarY, 2));
    //     const headAngle = Math.atan2(nose.y - ((rightEarY + leftEarY) / 2), nose.x - ((rightEarX + leftEarX) / 2)) * (180 / Math.PI);
    //     // Расчет угла поворота глаз
    //     let eyeTurnAngle = eyeAngle - (headAngle - 90);
    //     // Вывод угла поворота глаз на консоль
    //     console.log(`Угол поворота глаз: ${eyeTurnAngle}`);
    // }
    testSize(face) {
      const [leftInner, leftOuter] = face.keypoints[159].x < face.keypoints[386].x ? [face.keypoints[159], face.keypoints[386]] : [face.keypoints[386], face.keypoints[159]];
      const [rightInner, rightOuter] = face.keypoints[145].x < face.keypoints[362].x ? [face.keypoints[145], face.keypoints[362]] : [face.keypoints[362], face.keypoints[145]];
      const leftEyeWidth = Math.sqrt(Math.pow(leftOuter.x - leftInner.x, 2) + Math.pow(leftOuter.y - leftInner.y, 2));
      const rightEyeWidth = Math.sqrt(Math.pow(rightOuter.x - rightInner.x, 2) + Math.pow(rightOuter.y - rightInner.y, 2));
      const eyeCenterX = (face.keypoints[33].x + face.keypoints[263].x) / 2;
      const eyeCenterY = (face.keypoints[33].y + face.keypoints[263].y) / 2;
      const eyevecX = eyeCenterX - (face.keypoints[159].x + face.keypoints[386].x) / 2;
      const eyevecY = eyeCenterY - (face.keypoints[159].y + face.keypoints[386].y) / 2;
      let eyeAngle = Math.atan2(-eyevecY, eyevecX) * (180 / Math.PI);
      const angleThreshold = 5;
      if (Math.abs(eyeAngle - this.previousEyeAngle) > angleThreshold) {
        const eyeScale = (leftEyeWidth + rightEyeWidth) / 2;
        const correctedAngle = eyeAngle * (90 / eyeScale);
        this.previousEyeAngle = eyeAngle;
        if (Math.abs(correctedAngle) > angleThreshold) {
          return false;
        }
      }
      return true;
    }
    async calculateAngles(face) {
      const horizontalThreshold = 100;
      const verticalThreshold = 100;
      const leftEyeDeltaX = face.keypoints[33].x - this.previousLeftEyeX;
      const leftEyeDeltaY = face.keypoints[33].y - this.previousLeftEyeY;
      const rightEyeDeltaX = face.keypoints[263].x - this.previousRightEyeX;
      const rightEyeDeltaY = face.keypoints[263].y - this.previousRightEyeY;
      if (leftEyeDeltaX > horizontalThreshold && rightEyeDeltaX > horizontalThreshold) {
        console.log("\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u043E\u0442\u0432\u043E\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0432\u043F\u0440\u0430\u0432\u043E");
      } else if (leftEyeDeltaX < -horizontalThreshold && rightEyeDeltaX < -horizontalThreshold) {
        console.log("\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u043E\u0442\u0432\u043E\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0432\u043B\u0435\u0432\u043E");
      }
      if (leftEyeDeltaY > verticalThreshold && rightEyeDeltaY > verticalThreshold) {
        console.log("\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u043E\u043F\u0443\u0441\u043A\u0430\u0435\u0442 \u0432\u0437\u0433\u043B\u044F\u0434 \u0432\u043D\u0438\u0437");
      } else if (leftEyeDeltaY < -verticalThreshold && rightEyeDeltaY < -verticalThreshold) {
        console.log("\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u043F\u043E\u0434\u043D\u0438\u043C\u0430\u0435\u0442");
      }
      this.previousLeftEyeX = face.keypoints[33].x;
      this.previousLeftEyeY = face.keypoints[33].y;
      this.previousRightEyeX = face.keypoints[263].x;
      this.previousRightEyeY = face.keypoints[263].y;
    }
    calculateStartAngle(face) {
      const vecX = 0 - face.keypoints[159].x;
      const vecY = 0 - face.keypoints[159].y;
      const vecZ = 0 - face.keypoints[159].z;
      const angle = Math.atan2(Math.sqrt(vecX * vecX + vecY * vecY), vecZ) * (180 / Math.PI);
      return angle;
    }
  };

  // dist/interfaces/indexes.js
  var INDEXES_KEYS = [
    "attention",
    "amazement",
    "happiness",
    "tiredness",
    "involvement"
  ];
  var INDEXES_TITLES = {
    attention: "\u0412\u043D\u0438\u043C\u0430\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    amazement: "\u0423\u0434\u0438\u0432\u043B\u0435\u043D\u0438\u0435",
    happiness: "\u042D\u043C\u043E\u0446\u0438\u043E\u043D\u0430\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    tiredness: "\u0423\u0442\u043E\u043C\u043B\u044F\u0435\u043C\u043E\u0441\u0442\u044C",
    involvement: "\u0412\u043E\u0432\u043B\u0435\u0447\u0435\u043D\u043D\u043E\u0441\u0442\u044C"
  };
  var INDEXES_COLORS = {
    attention: "rgb(24, 113, 248)",
    amazement: "rgb(125, 128, 135)",
    happiness: "rgb(255, 157, 10)",
    tiredness: "rgb(250, 85, 85)",
    involvement: "rgb(180, 106, 238)"
  };
  var INDEXES_INFO = Object.fromEntries(INDEXES_KEYS.map((indexKey) => [
    indexKey,
    {
      title: INDEXES_TITLES[indexKey],
      color: INDEXES_COLORS[indexKey]
    }
  ]));
  var defaultIndex = {
    attention: 0,
    happiness: 0,
    tiredness: 0,
    amazement: 0,
    involvement: 0,
    presence: false,
    faces: 0,
    activeFaces: 0,
    attentions: [],
    statistic: {
      headAngleOX: -1,
      headAngleOY: -1,
      eyesClosedFrames: 0,
      blinks: 0,
      blinkTime: 0,
      eyebrowsHeight: {
        left: -1,
        right: -1
      },
      yawns: 0,
      smile: -1,
      attentionLostTimes: 0,
      attentionLostMillieseconds: 0,
      everySecondAttention: false
    }
  };

  // dist/components/index.js
  var detector;
  var camera;
  var indexesController;
  var indexCallback;
  var loadedModel;
  async function renderResult(callback) {
    if (camera.video.readyState < 2) {
      await new Promise((resolve) => {
        camera.video.onloadeddata = () => {
          resolve(true);
        };
      });
    }
    let faces = null;
    if (detector != null) {
      try {
        faces = await detector.estimateFaces(camera.video, {
          flipHorizontal: false
        });
        if (faces.length !== 0) {
          const virtualVideoCanvas = document.createElement("canvas");
          virtualVideoCanvas.width = camera.video.videoHeight;
          virtualVideoCanvas.height = camera.video.videoHeight;
          const virtualVideoCTX = virtualVideoCanvas.getContext("2d");
          virtualVideoCTX.drawImage(camera.video, (camera.video.videoWidth - camera.video.videoHeight) / 2, 0, camera.video.videoHeight, camera.video.videoHeight, 0, 0, camera.video.videoHeight, camera.video.videoHeight);
          const virtualCanvas = document.createElement("canvas");
          virtualCanvas.width = 224;
          virtualCanvas.height = 224;
          const virtualCTX = virtualCanvas.getContext("2d");
          virtualCTX.drawImage(virtualVideoCanvas, 0, 0, 224, 224);
          const tensor2 = Nf.fromPixels(virtualCanvas).toFloat().sub(224).div(224).reshape([1, 224, 224, 3]);
          const prediction = await loadedModel.predict(tensor2);
          const values = await prediction.dataSync();
          let activeFaces = 0;
          const attentions = [];
          for (const face of faces) {
            const index = indexesController.calculateIndexes(face, values);
            if (index.attention === 1) {
              activeFaces += 1;
            }
            attentions.push(index.attention);
          }
          const firstIndex = indexesController.calculateIndexes(faces[0], values);
          const exportIndex = __spreadValues({
            faces: faces.length,
            activeFaces,
            attentions
          }, firstIndex);
          callback(exportIndex);
        } else {
          callback(defaultIndex);
        }
      } catch (error) {
        detector.dispose();
        detector = null;
        alert(error);
      }
    }
    camera.drawCtx();
    if (faces && faces.length > 0) {
      camera.drawResults(faces, true, true);
    }
  }
  async function renderPrediction() {
    await renderResult(indexCallback);
    requestAnimationFrame(renderPrediction);
  }
  async function app(video, canvas, _indexCallback = (index) => {
    console.table(index);
  }) {
    loadedModel = await loadLayersModel("./model/model.json");
    indexCallback = _indexCallback;
    camera = await Camera.setupCamera(STATE.camera, video, canvas);
    detector = await createDetector();
    indexesController = new IndexesController();
    renderPrediction();
    return true;
  }
  function handleSecond() {
    if (!indexesController) {
      return;
    }
    return indexesController.handleSecond();
  }
  function handleMinute() {
    if (!indexesController) {
      return;
    }
    indexesController.handleMinute();
  }

  // dist/index.js
  (async () => {
    let seconds = 0;
    let interval = null;
    window.createFaceDetector = async function createFaceDetector(video, callbacks, canvas) {
      await Je();
      await app(video, canvas, callbacks.onIndex);
      interval = setInterval(async () => {
        seconds += 1;
        callbacks.onSecondIndex(handleSecond());
        if (seconds % 60 === 0) {
          handleMinute();
        }
      }, 1e3);
      return true;
    };
    window.destroyFaceDetector = function destroyFaceDetector() {
      console.log("FaceDetector:destroyFaceDetector | Destroying");
      if (interval) {
        clearInterval(interval);
      }
    };
  })();
})();
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/*! Bundled license information:

@tensorflow/tfjs-core/dist/tf-core.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-layers/dist/tf-layers.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/tf-converter.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-data/dist/tf-data.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/backend.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/util_base.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/environment.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/global_util.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/log.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/kernel_registry.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/hash_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/profiler.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/tape.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/tensor_format.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/tensor.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/types.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/tensor_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/engine.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/device_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/flags.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/tensor_util_env.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/operation.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/complex.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor_ops_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/types.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/io_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/router_registry.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/indexed_db.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/local_storage.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/model_management.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/platforms/platform_browser.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/platforms/platform_node.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/buffer.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/cast.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/clone.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/print.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/base_side_effects.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/globals.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/add.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/floorDiv.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/div.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/mul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/abs.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/acos.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/acosh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/add_n.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/all.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/any.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/arg_max.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/arg_min.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/asin.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/asinh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/atan.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/atan2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/atanh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv_util.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reshape.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/avg_pool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/avg_pool_3d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/concat.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/mat_mul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sigmoid.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tanh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/basic_lstm_cell.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/batch_to_space_nd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/batchnorm.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/bincount.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/broadcast_args.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/broadcast_to.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ceil.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fill.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/clip_by_value.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv2d_backprop_input.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv3d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv3d_backprop_input.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/cos.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/cosh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/cumprod.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the 'License');
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an 'AS IS' BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/cumsum.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/dense_bincount.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/depth_to_space.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/depthwise_conv2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/diag.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/dilation2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/broadcast_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/where.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/zeros_like.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/div_no_nan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/dot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/einsum.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/elu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/erf.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/axis_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/max.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/min.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/pow.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/scalar.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sqrt.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/square.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sum.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/norm.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/euclidean_norm.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/exp.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/expand_dims.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/expm1.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tile.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/eye.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/floor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/gather.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/greater.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/greater_equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/imag.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/is_finite.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/is_inf.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/is_nan.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/leaky_relu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/less.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/less_equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/linspace.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/local_response_normalization.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/log.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/log1p.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/gradients.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/neg.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/softplus.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/log_sigmoid.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sub.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/log_softmax.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/log_sum_exp.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/logical_and.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/logical_not.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/logical_or.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/logical_xor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/search_sorted.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/lower_bound.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/max_pool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/max_pool_3d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/max_pool_with_argmax.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/maximum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/mean.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/zeros.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ones.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/meshgrid.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/minimum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/mirror_pad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/mod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/moments.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/multinomial.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/not_equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/one_hot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ones_like.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/pad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/space_to_batch_nd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/pool.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/prelu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/prod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ragged_gather.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ragged_range.js:
  (**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ragged_tensor_to_tensor.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/rand.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/rand_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/random_gamma.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/random_normal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/random_standard_normal.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/random_uniform.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/range.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/real.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reciprocal.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/relu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/relu6.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reverse.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reverse_1d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reverse_2d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reverse_3d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reverse_4d.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/round.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/rsqrt.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/selu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/setdiff1d_async.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sign.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sin.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sinh.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice1d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice2d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice3d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice4d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/softmax.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/spectral/fft.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/spectral/ifft.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/spectral/irfft.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/split.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/spectral/rfft.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/squared_difference.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/squeeze.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/stack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/step.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/strided_slice.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tan.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor1d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor2d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor3d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor4d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor5d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/tensor6d.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/topk.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/truncated_normal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/unique.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/unsorted_segment_sum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/unstack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/upper_bound.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/variable.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/where_impl.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/where_async.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/boolean_mask.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/transpose.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/moving_average.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/scatter_nd.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse_to_dense.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/gather_nd.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/dropout_util.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/dropout.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/signal_ops_util.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/in_top_k.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/conv2d_backprop_filter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fused_util.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fused/conv2d.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/depthwise_conv2d_native_backprop_filter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/depthwise_conv2d_native_backprop_input.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fused/depthwise_conv2d.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fused/mat_mul.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/fused_ops.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/signal/hamming_window.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/signal/hann_window.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/signal/frame.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/signal/stft.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/crop_and_resize.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/flip_left_right.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/grayscale_to_rgb.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/rotate_with_offset.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/nonmax_util.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/non_max_suppression_util.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/non_max_suppression_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_async.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score_async.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded_async.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/resize_bilinear.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/resize_nearest_neighbor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/threshold.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/image/transform.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/linalg/band_part.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/linalg/gram_schmidt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/linalg/qr.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/loss_ops_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/losses/absolute_difference.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/losses/huber_loss.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/losses/log_loss.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/losses/mean_squared_error.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/losses/sigmoid_cross_entropy.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/losses/softmax_cross_entropy.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse/sparse_fill_empty_rows.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_mean.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_sum.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/string/string_n_grams.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/string/string_split.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/string/string_to_hash_bucket_fast.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ops.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/serialization.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/adadelta_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/adagrad_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/adam_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/adamax_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/sgd_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/momentum_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/rmsprop_optimizer.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/optimizers/register_optimizers.js:
  (**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/browser_files.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/progress.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/weights_loader.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/http.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/passthrough.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/io/io.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/browser.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/slice_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/browser_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/concat_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ragged_to_dense_util.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/reduce_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/rotate_util.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/array_ops_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/selu_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/erf_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/complex_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/einsum_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse/sparse_fill_empty_rows_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_reduction_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/segment_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/backend_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/backends/kernel_impls.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/base.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/index.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/canvas_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/tex_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/webgl_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/flags_webgl.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/glsl_version.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/decode_matrix_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/encode_float_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/encode_float_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/cpu_util.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/zeros_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Identity.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Real.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Cast.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/GatherNd_Impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Greater.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/GreaterEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Less.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LessEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Maximum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Minimum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Neg.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/NotEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Prod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedGather_impl.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedRange_impl.js:
  (**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedTensorToTensor_impl.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Scatter_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Sigmoid.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseReshape_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentReduction_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Sqrt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/SquaredDifference.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StringNGrams_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StringSplit_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/StringToHashBucketFast_impl.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Tile_impl.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/TopK_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-cpu/dist/shared.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/packing_util.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/texture_manager.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/unpack_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/base.js:
  (**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LeakyRelu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Prelu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/binaryop_complex_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reshape.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/mean_gpu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/transpose_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/transpose_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sum_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/_FusedMatMul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Abs.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Acos.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Acosh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Add.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/addn_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/addn_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/AddN.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/All.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Any.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/argminmax_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Asin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Asinh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Atan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Atan2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Atanh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3DGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPoolGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/batchnorm_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BatchNorm.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/slice_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BatchToSpaceND.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Bincount.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/BroadcastArgs.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/NotEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernel_utils/int.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cast.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Ceil.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/clip_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/clip_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ClipByValue.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/complex_abs_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ComplexAbs.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Concat_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Concat.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/im2col_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropFilter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropInput.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropFilterV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropInputV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cos.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cosh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/CropAndResize.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cum_impl.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cumprod.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Cumsum.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/DenseBincount.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/depth_to_space_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/DepthToSpace.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNative.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropInput.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/diag_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Diag.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/dilation_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Dilation2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Einsum.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Elu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/EluGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Equal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Erf.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Exp.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ExpandDims.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Expm1.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/fft_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FFT_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FFT.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/fill_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/flip_left_right_gpu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FlipLeftRight.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Floor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FloorDiv.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_packed_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FusedConv2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/FusedDepthwiseConv2D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/GatherNd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/gather_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/GatherV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Greater.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/GreaterEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/IFFT.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/IsFinite.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/IsInf.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/IsNaN.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Less.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LessEqual.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LinSpace.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Log.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Log1p.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalAnd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalNot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalOr.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/lrn_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/lrn_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LRN.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/lrn_grad_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/LRNGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Max_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Max.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Maximum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3D.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3DGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Mean_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Mean.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Min.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Minimum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/mirror_pad_gpu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/MirrorPad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Mod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/multinomial_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/RealDiv.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sub.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Softmax.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Multinomial.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Neg.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV3.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV4.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV5.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/onehot_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/OneHot.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ZerosLike.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/OnesLike.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Pack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/PadV2.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Pow.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Prod.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedGather.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedRange.js:
  (**
   * @license
   * Copyright 2022 Google LLC.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedTensorToTensor.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Range.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Reciprocal.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Relu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Relu6.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinear.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinearGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighbor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighborGrad.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/reverse_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/reverse_packed_gpu.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Reverse.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/rotate_gpu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/RotateWithOffset.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Round.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Rsqrt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/ScatterNd.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/search_sorted_gpu.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SearchSorted.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/select_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Select.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Selu.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sigmoid.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sign.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sin.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sinh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Softplus.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SpaceToBatchND.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SparseFillEmptyRows.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SparseReshape.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SparseSegmentMean.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SparseSegmentSum.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SparseToDense.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SplitV.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Sqrt.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Square.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/SquaredDifference.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Step.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/strided_slice_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/StridedSlice.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/StringNGrams.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/StringSplit.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/StringToHashBucketFast.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Tan.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Tanh.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/tile_gpu.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Tile.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/TopK.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/transform_gpu.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Transform.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Unique.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/Unpack.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/segment_gpu.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/register_all_kernels.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-backend-webgl/dist/index.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/flags.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/data/compiled_api.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/custom_op/register.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/arithmetic.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/basic_math.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/control.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/convolution.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/creation.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/dynamic.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/evaluation.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/graph.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/hash_table.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/image.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/logical.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/matrices.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/normalization.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/reduction.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/slice_join.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/sparse.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/spectral.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/string.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/op_list/transformation.js:
  (**
   * @license
   * Copyright 2023 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/operation_mapper.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/custom_op/node_value_impl.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-core/dist/ops/ops_for_converter.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/arithmetic_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/basic_math_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/tensor_utils.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/tensor_array.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/tensor_list.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/control_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/convolution_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/creation_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/dynamic_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/evaluation_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/graph_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/hash_table.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/hash_table_executor.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/image_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/logical_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/matrices_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/normalization_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/ragged_executor.js:
  (**
   * @license
   * Copyright 2022 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/reduction_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/slice_join_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/sparse_executor.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/spectral_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/string_executor.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/executors/transformation_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/operations/operation_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/model_analysis.js:
  (**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/graph_executor.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/executor/graph_model.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow/tfjs-converter/dist/version.js:
  (** @license See the LICENSE file. *)

@tensorflow/tfjs-converter/dist/index.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

@tensorflow-models/face-landmarks-detection/dist/face-landmarks-detection.esm.js:
  (**
      * @license
      * Copyright 2022 Google LLC. All Rights Reserved.
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing, software
      * distributed under the License is distributed on an "AS IS" BASIS,
      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      * See the License for the specific language governing permissions and
      * limitations under the License.
      * =============================================================================
      *)
*/
